<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vim Mode: Theory of Operation &mdash; Leo Doc</title>
    
    <link rel="stylesheet" href="_static/leo.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '5.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Leo Doc" href="index.html" />
    <link rel="up" title="Advanced Topics" href="intermediatetopics.html" />
    <link rel="next" title="The Leonine World" href="leonine-world.html" />
    <link rel="prev" title="Exploring Leo’s Code Base" href="theory.html" />
    <script type="text/javascript">
        (function() {
            var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
            s.type = 'text/javascript';
            s.async = true;
            s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
            t.parentNode.insertBefore(s, t);
        })();
    </script>
     

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="leonine-world.html" title="The Leonine World"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="theory.html" title="Exploring Leo’s Code Base"
             accesskey="P">previous</a> |</li>
        <li><a href="contents.html">Leo Doc</a> &raquo;</li>
          <li><a href="intermediatetopics.html" accesskey="U">Advanced Topics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="vim-mode-theory-of-operation">
<h1><a class="toc-backref" href="#id1">Vim Mode: Theory of Operation</a><a class="headerlink" href="#vim-mode-theory-of-operation" title="Permalink to this headline">¶</a></h1>
<p>This is the theory of operation of Leo&#8217;s vim mode, contained in
leo/core/leoVim.py. It discusses everything you need to understand the code
and to add new vim commands.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#vim-mode-theory-of-operation" id="id1">Vim Mode: Theory of Operation</a><ul>
<li><a class="reference internal" href="#the-big-picture" id="id2">The big picture</a></li>
<li><a class="reference internal" href="#a-simple-key-handler" id="id3">A simple key handler</a></li>
<li><a class="reference internal" href="#a-more-complex-key-handler" id="id4">A more complex key handler</a><ul>
<li><a class="reference internal" href="#vim-d" id="id5">vim_d</a></li>
<li><a class="reference internal" href="#vim-d2" id="id6">vim_d2</a></li>
<li><a class="reference internal" href="#vim-d3" id="id7">vim_d3</a></li>
<li><a class="reference internal" href="#vis-d" id="id8">vis_d</a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-level-details" id="id9">Code level details</a><ul>
<li><a class="reference internal" href="#initialization" id="id10">Initialization</a></li>
<li><a class="reference internal" href="#dispatchers" id="id11">Dispatchers</a></li>
<li><a class="reference internal" href="#about-key-handlers" id="id12">About key handlers</a></li>
<li><a class="reference internal" href="#ivars-for-key-handlers" id="id13">Ivars for key handlers</a></li>
<li><a class="reference internal" href="#api-s-for-key-handlers" id="id14">API&#8217;s for key handlers</a></li>
<li><a class="reference internal" href="#vc-return-value-and-internal-error-checking" id="id15">vc.return_value and internal error checking</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="the-big-picture">
<h2><a class="toc-backref" href="#id2">The big picture</a><a class="headerlink" href="#the-big-picture" title="Permalink to this headline">¶</a></h2>
<p>Leo&#8217;s vim mode dispatches keystrokes sent to it from k.masterKeyHandler to
<strong>key handlers</strong>.</p>
<p>Each key handler handles the incoming key and then calls either
vc.accept(), vc.done(), vc.ignore() or vc.quit(). These methods tell
k.masterKeyHandler whether vim-mode has completely handled the key. If so,
k.masterKeyHandler simply returns. Otherwise, k.masterKeyHandler handles
the key as usual.</p>
</div>
<div class="section" id="a-simple-key-handler">
<h2><a class="toc-backref" href="#id3">A simple key handler</a><a class="headerlink" href="#a-simple-key-handler" title="Permalink to this headline">¶</a></h2>
<p>The handler for the G command moves or extends the cursor depending on
vc.state.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">vim_G</span><span class="p">(</span><span class="n">vc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Put the cursor on the last character of the body pane.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">is_text_widget</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">w</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s">&#39;visual&#39;</span><span class="p">:</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="s">&#39;end-of-buffer-extend-selection&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="s">&#39;end-of-buffer&#39;</span><span class="p">)</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>On entry, the dispatcher has set vc.w to the widget with focus. First, the
code ensures that this widget is a text widget. If so, the code uses the
vc.do method, a thin wrapper for c.k.simulateCommand, to execute Leo
commands by name.</p>
</div>
<div class="section" id="a-more-complex-key-handler">
<h2><a class="toc-backref" href="#id4">A more complex key handler</a><a class="headerlink" href="#a-more-complex-key-handler" title="Permalink to this headline">¶</a></h2>
<p>The vc.vim_d method and its follow-on methods handle vim&#8217;s d commands.</p>
<p>The vc.vis_d method handles the d keystroke that ends visual mode.</p>
<p>The following sections examine each piece of the code in detail. If you
understand how it works you should know everything you need to write any
other key handler.</p>
<div class="section" id="vim-d">
<h3><a class="toc-backref" href="#id5">vim_d</a><a class="headerlink" href="#vim-d" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">vim_d</span><span class="p">(</span><span class="n">vc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    N dd      delete N lines</span>
<span class="sd">    d{motion} delete the text that is moved over with {motion}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">is_text_widget</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">w</span><span class="p">):</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="n">handler</span><span class="o">=</span><span class="n">vc</span><span class="o">.</span><span class="n">vim_d2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>This is the key handler for the &#8216;d&#8217; key in normal mode.</p>
<p>The entry in vc.normal_dispatch_d for &#8216;d&#8217; is: &#8216;d&#8217;:vc.vim_d.</p>
<p>Because this command changes text, vc.is_text_widget(vc.w) must be True. If
so, this handler simply calls vc.accept(handler=vc.vim_d2) to queue up the
follow-on handler. Otherwise, the handler calls vc.quit() to end the
command.</p>
</div>
<div class="section" id="vim-d2">
<h3><a class="toc-backref" href="#id6">vim_d2</a><a class="headerlink" href="#vim-d2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">vim_d2</span><span class="p">(</span><span class="n">vc</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">is_text_widget</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">w</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">stroke</span> <span class="o">==</span> <span class="s">&#39;d&#39;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">w</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">getInsertPoint</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">n1</span><span class="o">*</span><span class="n">vc</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="c"># It&#39;s simplest just to get the text again.</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">getAllText</span><span class="p">()</span>
                <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getLine</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="c"># Special case for end of buffer only for n == 1.</span>
                <span class="c"># This is exactly how vim works.</span>
                <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">n1</span><span class="o">*</span><span class="n">vc</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">w</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">d_stroke</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">stroke</span> <span class="c"># A scratch var.</span>
            <span class="n">vc</span><span class="o">.</span><span class="n">begin_motion</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">vim_d3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>This is the follow-on handler for the &#8216;d&#8217; command. It will be called when
the user types a <em>second</em> character following the &#8216;d&#8217; command in normal
mode.</p>
<p>All forms of the &#8216;d&#8217; command alter text, so this handler calls vc.quit if
vc.w is not a text widget.</p>
<p>If the second character is another &#8216;d&#8217;, we have the &#8216;dd&#8217; command. The code
uses the high-level interface to delete a line, then calls vc.done() to end
the command.</p>
<p>If the second character is <em>not</em> a &#8216;d&#8217;, it should be a following motion,
such as &#8220;2j&#8221; in &#8220;d2j&#8221;.</p>
<p>vc.vim_d2 remembers the character that started the motion in a <strong>scratch
ivar</strong>, vc.d_stroke. Such ivars are not inited or touched outside of vim_d
and its follow-on key handlers. This code must remember this character so
that the vim_d3 handler will know whether to expand the deleted text to a
line.</p>
<p>Finally, vc.vim_d2 calls vc.begin_motion, which does the following:</p>
<ul class="simple">
<li>Calls vc.ignore if the second character doesn&#8217;t really start a motion.</li>
<li>Sets vc.handler to vc.do_inner_motion.  This handles the motion.</li>
<li>Sets the vc.after_motion to the next follow-on handler: vc.vim_d3.
vc.vim_d3 will be called when the motion is complete. The details are
complicated, but happily the key handlers don&#8217;t have to know about them!</li>
</ul>
</div>
<div class="section" id="vim-d3">
<h3><a class="toc-backref" href="#id7">vim_d3</a><a class="headerlink" href="#vim-d3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">vim_d3</span><span class="p">(</span><span class="n">vc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Complete the d command after the cursor has moved.&#39;&#39;&#39;</span>
    <span class="c"># d2w doesn&#39;t extend to line.  d2j does.</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="bp">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span>
    <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">is_text_widget</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">w</span><span class="p">):</span>
        <span class="n">extend_to_line</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">d_stroke</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;jk&#39;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">w</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">getAllText</span><span class="p">()</span>
        <span class="n">i1</span><span class="p">,</span><span class="n">i2</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">motion_i</span><span class="p">,</span><span class="n">w</span><span class="o">.</span><span class="n">getInsertPoint</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i1</span> <span class="o">==</span> <span class="n">i2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&#39;no change&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="n">i2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">n1</span><span class="o">*</span><span class="n">vc</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">extend_to_line</span><span class="p">:</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">to_eol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                        <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&#39;extend i2 to eol&#39;</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># i1 &gt; i2</span>
            <span class="n">i1</span><span class="p">,</span><span class="n">i2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">,</span><span class="n">i1</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vc</span><span class="o">.</span><span class="n">n1</span><span class="o">*</span><span class="n">vc</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">extend_to_line</span><span class="p">:</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">to_bol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&#39;extend i1 to bol&#39;</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>This is the second and last follow-on handler for the d command. The
dispatcher that handles vim motions will call this handler after the
motions <strong>have actually happened</strong>.</p>
<p>First, the code double-checks that we are still in a text widget, calling
vc.quit() if not.</p>
<p>Next, the code compares the present insertion point, w,getInsertPoint(),
with the insertion point before the motion happened, vc.motion_i. It
extends the selection range if the scratch ivar, vc.d_stroke, is in (&#8216;jk&#8217;).
The code then deletes the selected text.</p>
<p>Finally, this method calls vc.done().</p>
</div>
<div class="section" id="vis-d">
<h3><a class="toc-backref" href="#id8">vis_d</a><a class="headerlink" href="#vis-d" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">vis_d</span><span class="p">(</span><span class="n">vc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Delete the highlighted text and terminate visual mode.&#39;&#39;&#39;</span>
    <span class="n">w</span>  <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">vis_mode_w</span>
    <span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">is_text_widget</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">vis_mode_i</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">getInsertPoint</span><span class="p">()</span>
        <span class="n">w</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s">&#39;normal&#39;</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">done</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vc</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<p>This is the key handler for the &#8216;d&#8217; key in normal mode.</p>
<p>It is <em>not</em> a follow-on method of vim_d. The dispatcher calls this method
after visual mode has highlighted text. Here is the entry for &#8216;d&#8217; in
vc.visual_dispatch_d: &#8216;d&#8217;:vc.vis_d.</p>
<p>Visual mode has already highlighted the text to be deleted, so this code
simply deletes the highlighted text and calls vc.done().</p>
</div>
</div>
<div class="section" id="code-level-details">
<h2><a class="toc-backref" href="#id9">Code level details</a><a class="headerlink" href="#code-level-details" title="Permalink to this headline">¶</a></h2>
<p>The VimCommands class in leoVim.py implements Leo&#8217;s vim mode. Vim mode is
active only if &#64;bool vim-mode = True.</p>
<p>The following sections will be of interest only to those seeking a deep
knowledge of how vim mode&#8217;s dispatchers work. Such knowledge should rarely
be required because dispatchers and key handlers are completely unaware of
each other. Dispatch dicts and acceptance methods shield dispatchers and
key handlers of all knowledge of each other. In particular, acceptance
methods handle the sometimes tricky details of ending a key handler.</p>
<p>Leo&#8217;s vim code is spectacularly different from the real vim&#8217;s code.
Wherever possible, Leo uses methods to hide implementation details.</p>
<p>Ironically, now that everything is hard coded in tables, it would be easy
for plugins to customize the workings of vim-mode.</p>
<div class="section" id="initialization">
<h3><a class="toc-backref" href="#id10">Initialization</a><a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h3>
<p>The init code for each Leo commander c assigns an instance of VimCommands
to c.vimCommands. This is done regardless of the &#64;bool vim-mode setting.</p>
<p>Each ivar of the VimCommands class is inited by exactly one of the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vc</span><span class="o">.</span><span class="n">init_constant_ivars</span><span class="p">()</span>
<span class="n">vc</span><span class="o">.</span><span class="n">init_dot_ivars</span><span class="p">()</span>
<span class="n">vc</span><span class="o">.</span><span class="n">init_persistent_ivars</span><span class="p">()</span>
<span class="n">vc</span><span class="o">.</span><span class="n">init_state_ivars</span><span class="p">()</span>
<span class="n">vc</span><span class="o">.</span><span class="n">create_dispatch_dicts</span><span class="p">()</span>
</pre></div>
</div>
<p>In effect, this code partitions each ivar into disjoint sets. This
partitioning simplifies code that must re-init some ivars but not others.</p>
<p>The init code creates <strong>dispatch dicts</strong> used by dispatchers.</p>
</div>
<div class="section" id="dispatchers">
<h3><a class="toc-backref" href="#id11">Dispatchers</a><a class="headerlink" href="#dispatchers" title="Permalink to this headline">¶</a></h3>
<p>Depending on various state date, dispatchers route incoming keys to the
proper <strong>key handler</strong>. Dispatchers use <strong>dispatch dicts</strong> to assign
handlers to incoming keys. These dicts eliminate almost all special case
code.</p>
<p>vc.do_key is the top-level dispatcher. k.masterKeyHandler calls it for all
keys <em>except</em> Ctrl-G. <strong>Note</strong>: k.masterKeyHandler calls vc.do_key only
when there no key state in effect, that is, when the minibuffer is not
active.</p>
<p>As discussed below, the value returned by vc.do_key tells k.masterKeyHandler
whether vim mode has completely handled the key.</p>
<p>Depending on the vc.handler ivar, vc.do_key can route the incoming key
either to an <strong>inner dispatcher</strong> or directly to a key handler.</p>
<p>Inner dispatchers handle keys for a particular vim mode using dispatch
dicts. Inner dispatchers the following ivars behind the scenes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vc</span><span class="o">.</span><span class="n">handler</span><span class="p">,</span> <span class="n">vc</span><span class="o">.</span><span class="n">next_func</span><span class="p">,</span> <span class="n">vc</span><span class="o">.</span><span class="n">return_value</span>
<span class="n">vc</span><span class="o">.</span><span class="n">in_motion</span> <span class="ow">and</span> <span class="n">vc</span><span class="o">.</span><span class="n">motion_func</span>
</pre></div>
</div>
<p>Handling these ivars can be tricky; hiding the details greatly simplifies all
key handlers.</p>
</div>
<div class="section" id="about-key-handlers">
<h3><a class="toc-backref" href="#id12">About key handlers</a><a class="headerlink" href="#about-key-handlers" title="Permalink to this headline">¶</a></h3>
<p>Key handlers handle a single key during the parsing of a vim command. Key
handlers can either complete a command, thereby actually doing something,
or change state so as to be able to parse (and possibly complete) the next
incoming keystroke.</p>
<p>For example, the key handler for the G command handles the command
completely. In contrast, two key handlers are needed to handle the gg
command. The first handler, vc.vim_g, simply calls
vc.accept(handler=vc.vim_g2). This call changes the vc.handler ivar to
point to the <strong>follow-on handler</strong>, vim_g2. vim_g2 handles all commands
after the user has typed &#8216;g&#8217; in normal mode.</p>
<p>Each key handler must end with a call to an <strong>acceptance method</strong>.
vc.accept is one such method. Acceptance methods prepare for the next
keystroke by setting internal state ivars used by the various dispatchers.</p>
<p>Many key handlers simply call vc.done(). This method handles all the
details of completing a key handler: it hides the details of parsing vim
command.</p>
<p><strong>Important</strong>: Any key handler that wants to change vc.state should
set vc.state <em>before</em> calling vc.done()</p>
<p>Key handlers can call either <strong>direct acceptance methods</strong>, vc.accept,
vc.delegate, vc.done, vc.ignore, vc.not_ready, vc.quit, and vc.reset, or
<strong>indirect acceptance methods</strong>: vc.begin_insert_mode, vc.begin_motion,
vc.end_insert_mode, and vc.vim_digits. Indirect acceptance methods must
eventually call direct acceptance methods.</p>
</div>
<div class="section" id="ivars-for-key-handlers">
<h3><a class="toc-backref" href="#id13">Ivars for key handlers</a><a class="headerlink" href="#ivars-for-key-handlers" title="Permalink to this headline">¶</a></h3>
<p>Dispatchers set the following ivars for each key handler:</p>
<p><strong>vc.w</strong> is the widget that has focus. Key handlers may use convenience
methods to determine the location and type of vc.w. The most important are:</p>
<ul class="simple">
<li>vc.is_text_widget(w): True if w is any text widget, including headlines,
body text and log pane.</li>
<li>vc.in_headline(w): True if w is a headline widget in edit mode.</li>
</ul>
<p><strong>vc.stroke</strong> is a standard Leo stroke representing the incoming key. Note
that the spelling of the stoke using the Tk spellings. Take a look at
entries in the dispatch dicts to see such spellings. When in doubt, enable
the trace in vc.do_key to see the incoming strokes.</p>
<p><strong>vc.n1</strong> and <strong>vc.n</strong> are the repeat counts in effect for each key
handler. Dispatchers and their allies handle most details of setting these
repeat counts, so most key handlers can simply use vc.n1*vc.n as the
ultimate repeat count.</p>
<p><strong>vc.motion_i</strong> is the insertion point <em>before</em> the motion has taken place.</p>
</div>
<div class="section" id="api-s-for-key-handlers">
<h3><a class="toc-backref" href="#id14">API&#8217;s for key handlers</a><a class="headerlink" href="#api-s-for-key-handlers" title="Permalink to this headline">¶</a></h3>
<p>The simplest way of moving the cursor or changing text is to use the vc.do
method, a thin wrapper for c.k.simulateCommand.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">vc</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s">&#39;visual&#39;</span><span class="p">:</span>
    <span class="n">vc</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="s">&#39;end-of-buffer-extend-selection&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">vc</span><span class="o">.</span><span class="n">do</span><span class="p">(</span><span class="s">&#39;end-of-buffer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Key handlers may also use the <strong>high-level interface</strong>. This is the API
used throughout Leo&#8217;s core. For details, see the HighLevelInterface class
in leoFrame.py and various subclasses in qtGui.py.</p>
</div>
<div class="section" id="vc-return-value-and-internal-error-checking">
<h3><a class="toc-backref" href="#id15">vc.return_value and internal error checking</a><a class="headerlink" href="#vc-return-value-and-internal-error-checking" title="Permalink to this headline">¶</a></h3>
<p>vc.do_key returns the value of vc.return_value. Most the acceptance
functions set vc.return_value to True, indicating that vim mode has
completely handled the key and that k.masterKeyHandler should simply
return. k.masterKeyHandler handles the key as usual if vc.do_key returns
False.</p>
<p>Each key handler sets vc.return_value indirectly by calling an acceptance
method. A simple check in vc.do_key ensures that every key handler, has, in
fact, called an acceptance method. In practice, this check has been very
effective.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="contents.html">
              <img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/>
            </a></p>
<h3><a href="contents.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Leo’s Home Page</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preliminaries.html">Preliminaries</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Downloading, Installing &amp; Running Leo</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Cheat Sheet</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="screencasts.html">Videos about Leo</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="usersguide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="leoandotherprograms.html">Leo and Other Programs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="intermediatetopics.html">Advanced Topics</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="coloring.html">Controlling Syntax Coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="writingPlugins.html">Writing Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="unitTesting.html">Unit testing with Leo</a></li>
<li class="toctree-l2"><a class="reference internal" href="debuggers.html">Debugging with Leo</a></li>
<li class="toctree-l2"><a class="reference internal" href="atShadow.html">Using &#64;shadow</a></li>
<li class="toctree-l2"><a class="reference internal" href="scripting-miscellany.html">A Miscellany of Leo Scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="theory.html">Exploring Leo&#8217;s Code Base</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Vim Mode: Theory of Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="leonine-world.html">The Leonine World</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">Appendices</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="apidoc/index.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="what-is-new.html">What&#8217;s New</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><p>Leo: Leonine Editor with Outlines</p>
<p>Written by <a HREF="ekr.html">Edward K. Ream</a>
<a class="FlattrButton" style="display:none;" rev="flattr;button:compact;" href="http://leoeditor.com"></a>
<noscript>
<a href="http://flattr.com/thing/410073/Leo" target="_blank">
<img src="http://api.flattr.com/button/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0" />
</a>
</noscript>
</p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="leonine-world.html" title="The Leonine World"
             >next</a> |</li>
        <li class="right" >
          <a href="theory.html" title="Exploring Leo’s Code Base"
             >previous</a> |</li>
        <li><a href="contents.html">Leo Doc</a> &raquo;</li>
          <li><a href="intermediatetopics.html" >Advanced Topics</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Edward K. Ream.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>