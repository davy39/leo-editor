<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050407144417"><vh>@settings</vh>
<v t="ekr.20130816100419.17299"><vh>@string target_language = rest</vh></v>
<v t="davy.20141208152655.3"><vh>@enabled-plugins</vh></v>
<v t="davy.20141208130053.53"><vh>Sphinx options</vh>
<v t="davy.20141208121156.278"><vh>@data conf.py</vh>
<v t="davy.20141208130053.52"><vh>Metadata</vh>
<v t="davy.20141208130053.4"><vh>Project name</vh></v>
<v t="davy.20141208130053.6"><vh>Major version</vh></v>
<v t="davy.20141208130053.7"><vh>Release version</vh></v>
<v t="davy.20141208130053.5"><vh>Copyright statement</vh></v>
</v>
<v t="davy.20141208130053.9"><vh>HTML output</vh>
<v t="davy.20141208130053.30"><vh>Logo</vh></v>
<v t="davy.20141208130053.28"><vh>Theme options</vh></v>
<v t="davy.20141208130053.29"><vh>Style sheet (CSS)</vh></v>
<v t="davy.20141208130053.39"><vh>Custom sidebars</vh></v>
<v t="davy.20141208130053.14"><vh>Static pathes</vh></v>
<v t="davy.20141208130053.8"><vh>Templates pathes</vh></v>
<v t="davy.20141208151446.5"><vh>Copy sources to HTLM path</vh></v>
<v t="davy.20141208151446.4"><vh>Show sourcelink</vh></v>
</v>
<v t="davy.20141209091210.39"><vh>Exclude paterns</vh></v>
<v t="davy.20141208130053.3"><vh>Enabled sphinx extensions</vh></v>
</v>
<v t="davy.20141208134720.5"><vh>@int jobs = 4</vh></v>
<v t="davy.20141208134720.8"><vh>@int verbosity = 0</vh></v>
<v t="davy.20141208134720.9"><vh>@bool traceback = True</vh></v>
<v t="davy.20141208134720.10"><vh>@bool quiet = False</vh></v>
<v t="davy.20141208134720.11"><vh>@bool veryQuiet = False</vh></v>
<v t="davy.20141208134720.12"><vh>@string warningToFile =</vh></v>
<v t="davy.20141208134720.13"><vh>@bool warningiserror = False</vh></v>
<v t="davy.20141208134720.14"><vh>@bool pdb = True</vh></v>
<v t="davy.20141208134720.4"><vh>@data builders</vh></v>
</v>
<v t="ekr.20050812123002"><vh>rst3 options</vh>
<v t="ekr.20131027064821.18685"><vh>@string rst3_write_intermediate_extension = .rst</vh></v>
<v t="davy.20141205111505.3"><vh>@string rst3_default_encoding = utf8</vh></v>
<v t="ekr.20131009050634.17658"><vh>@bool rst3_call_docutils = False</vh></v>
<v t="ekr.20131009050634.17625"><vh>@bool rst3_code_mode = False</vh></v>
<v t="ekr.20050812123002.7"><vh>@bool rst3_format_headlines = True</vh></v>
<v t="ekr.20131009050634.17627"><vh>@bool rst3_generate_rst = True</vh></v>
<v t="ekr.20131009050634.17610"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.6"><vh>@bool rst3_massage_body = False</vh></v>
<v t="ekr.20131009050634.17630"><vh>@bool rst3_show_headlines = True</vh></v>
<v t="ekr.20131009052848.6456"><vh>@bool rst3_show_leo_directives = True</vh></v>
<v t="ekr.20131009050634.17631"><vh>@bool rst3_show_organizer_nodes = True</vh></v>
<v t="ekr.20131009050634.17622"><vh>@bool rst3_verbose = True</vh></v>
<v t="ekr.20131009050634.17623"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="ekr.20051202072010"><vh>@string rst3_default_path = sources</vh></v>
<v t="ekr.20131009050634.17616"><vh>@string rst3_stylesheet_path = ..\doc</vh></v>
<v t="ekr.20050812123002.1"><vh>Http options...</vh>
<v t="ekr.20050812123002.2"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050812123002.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050812123002.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.5"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
</v>
<v t="ekr.20101009114830.4724"><vh>File options</vh>
<v t="ekr.20080923182326.1"><vh>@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412124815.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20101009114830.4723"><vh>@bool put_expansion_bits_in_leo_files = False</vh></v>
</v>
</v>
<v t="davy.20141209134323.2"><vh>About this file</vh>
<v t="davy.20141208162909.3"><vh>Requirements</vh></v>
<v t="davy.20141209134323.5"><vh>important</vh></v>
<v t="davy.20141208162909.2"><vh>Publish on github pages</vh>
<v t="davy.20141208162909.8"><vh>Github web hosting</vh></v>
<v t="davy.20141208162909.9"><vh>Set up project pages</vh>
<v t="davy.20141208162909.4"><vh>Create an orphan gh-pages branch</vh></v>
<v t="davy.20141208162909.10"><vh>Integrate the gh-pages branch as a master's submodule</vh></v>
<v t="davy.20141208162909.11"><vh>Extra : Clone gh-page into any folder </vh></v>
</v>
</v>
</v>
<v t="davy.20141209134323.4"><vh>Quick update</vh>
<v t="davy.20141208130053.6"></v>
<v t="davy.20141208130053.7"></v>
<v t="davy.20141209091210.36"><vh>&lt;&lt; commit &gt;&gt;</vh></v>
<v t="ekr.20101025080245.5791"><vh>@rst what-is-new</vh>
<v t="ekr.20071116062917.2"><vh>@rst-no-head links</vh></v>
<v t="davy.20141209154025.16"><vh>What's new in Leo 5.0</vh>
<v t="davy.20141209154025.17"><vh>Code</vh></v>
<v t="davy.20141209154025.18"><vh>New commands</vh></v>
<v t="davy.20141209154025.19"><vh>New &amp; improved features</vh></v>
<v t="davy.20141209154025.20"><vh>Plugins &amp; leo/external </vh></v>
<v t="davy.20141209154025.21"><vh>Settings &amp; options</vh></v>
</v>
<v t="ekr.20120320153011.8551"><vh>Previous versions</vh>
<v t="davy.20141209154025.10"><vh>Leo 4.11</vh>
<v t="davy.20141209154025.11"><vh>Commands</vh></v>
<v t="davy.20141209154025.12"><vh>Features</vh></v>
<v t="davy.20141209154025.13"><vh>Plugins &amp; Contributions</vh></v>
<v t="davy.20141209154025.14"><vh>Scripts</vh></v>
<v t="davy.20141209154025.15"><vh>Settings &amp; options</vh></v>
</v>
<v t="davy.20141209154025.3"><vh>Leo 4.10</vh>
<v t="davy.20141209154025.4"><vh>New features &amp; commands</vh>
<v t="davy.20141209154025.5"><vh>Weightless unit testing</vh></v>
</v>
<v t="davy.20141209154025.6"><vh>Plugins</vh></v>
<v t="davy.20141209154025.7"><vh>Scripts</vh></v>
<v t="davy.20141209154025.8"><vh>Settings</vh></v>
<v t="davy.20141209154025.9"><vh>Bugs fixed</vh></v>
</v>
<v t="ekr.20110601105631.19349"><vh>Leo 4.9</vh>
<v t="ekr.20110601105631.19360"><vh>Bugs fixed</vh></v>
<v t="ekr.20110601105631.19484"><vh>Deprecated/removed features</vh></v>
<v t="ekr.20110601105631.19481"><vh>Major improvements</vh>
<v t="ekr.20110602091552.16899"><vh>Completed Leo's autocompleter</vh></v>
<v t="ekr.20110602091552.16898"><vh>Greatly improved the viewrendered plugin</vh></v>
</v>
<v t="ekr.20110601105631.19434"><vh>New and improved features</vh>
<v t="ekr.20110601105631.19435"><vh>Colorizing</vh></v>
<v t="ekr.20110601105631.19480"><vh>Command-line arguments &amp; settings</vh></v>
<v t="ekr.20110601105631.19464"><vh>File handling</vh></v>
<v t="ekr.20110601105631.19441"><vh>Gui</vh></v>
<v t="ekr.20110601105631.19482"><vh>Improved commands</vh></v>
<v t="ekr.20110601105631.19463"><vh>New commands</vh></v>
<v t="ekr.20110601105631.19473"><vh>Scripting</vh></v>
</v>
<v t="ekr.20110604105805.16766"><vh>New in 4.9 b2</vh></v>
<v t="ekr.20110611085637.5009"><vh>New in 4.9 b3</vh>
<v t="ekr.20110611085637.5010"><vh>4.9 b3: Bugs fixed</vh></v>
<v t="ekr.20110611085637.5012"><vh>4.9 b3: New features</vh></v>
</v>
<v t="ekr.20110613172008.15106"><vh>New in 4.9 b4</vh></v>
<v t="ekr.20110616100929.14851"><vh>New in 4.9 rc1</vh></v>
</v>
<v t="ekr.20101025080245.5805"><vh>Leo 4.8</vh>
<v t="ekr.20101025080245.6077"><vh>New sentinels</vh></v>
<v t="ekr.20101025080245.6078"><vh>Drag and drop files into Leo</vh></v>
<v t="ekr.20101025080245.5980"><vh>Scripting improvements</vh></v>
<v t="ekr.20101025080245.6080"><vh>Improved @url nodes</vh></v>
<v t="ekr.20101104173324.5141"><vh>New &amp; improved commands</vh>
<v t="ekr.20101025080245.6079"><vh>Improved abbreviations commands</vh></v>
</v>
<v t="ekr.20101025080245.6081"><vh>New plugins</vh></v>
<v t="ekr.20101025080245.6006"><vh>New settings &amp; command-line args</vh></v>
<v t="ekr.20101025080245.5985"><vh>Other improvements</vh></v>
</v>
<v t="ekr.20100129054823.11924"><vh>Leo 4.7</vh>
<v t="ekr.20101025080245.6088"><vh>The one-node world</vh></v>
<v t="ekr.20100129054823.17680"><vh>Leo supports Python 3.x</vh></v>
<v t="ekr.20100129054823.11928"><vh>Improved file handling</vh></v>
<v t="ekr.20100129054823.11931"><vh>New command-line options</vh></v>
<v t="ekr.20100211221936.7098"><vh>New commands</vh></v>
<v t="ekr.20100129054823.11934"><vh>New settings</vh></v>
<v t="ekr.20100129054823.11935"><vh>Improved plugins</vh></v>
</v>
<v t="ekr.20090324145450.20"><vh>Leo 4.6</vh>
<v t="ekr.20090620073906.12095"><vh>Improved unit testing</vh></v>
<v t="ekr.20090324145450.23"><vh>Improved file handling</vh></v>
<v t="ekr.20090620082840.5608"><vh>Improved handling of rST files</vh></v>
<v t="ekr.20090324145450.27"><vh>New code features</vh></v>
<v t="ekr.20090324145450.36"><vh>New command-line options</vh></v>
<v t="ekr.20090324145450.40"><vh>New commands</vh></v>
<v t="ekr.20090324145450.46"><vh>New and improved directives</vh></v>
<v t="ekr.20090324145450.49"><vh>New settings</vh></v>
<v t="ekr.20090324145450.54"><vh>Plugins</vh></v>
</v>
<v t="ekr.20080806211440.185"><vh>Leo 4.5</vh>
<v t="ekr.20080806211440.188"><vh>Major new features</vh></v>
<v t="ekr.20080806211440.253"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080806211440.256"><vh>Minor new features</vh></v>
<v t="ekr.20080806211440.189"><vh>New settings</vh></v>
</v>
<v t="ekr.20080314081157.127"><vh>Leo 4.4.8</vh>
<v t="ekr.20080314081157.124"><vh>New features</vh></v>
<v t="ekr.20080314081157.128"><vh>New and improved plugins</vh></v>
<v t="ekr.20080314081157.125"><vh>New settings</vh></v>
</v>
<v t="ekr.20071217093444"><vh>Leo 4.4.6</vh>
<v t="ekr.20071217093444.5"><vh>New commands</vh></v>
<v t="ekr.20080116071239"><vh>New features</vh></v>
<v t="ekr.20071217093444.6"><vh>New settings</vh></v>
</v>
<v t="ekr.20071116062917"><vh>Leo 4.4.5</vh>
<v t="ekr.20071116063202"><vh>Bug fixed</vh></v>
<v t="ekr.20071116062917.3"><vh>New features</vh></v>
<v t="ekr.20071116062917.18"><vh>New commands</vh></v>
<v t="ekr.20071116063649"><vh>New settings</vh></v>
</v>
<v t="ekr.20070809145744"><vh>Leo 4.4.4</vh>
<v t="ekr.20071004103659"><vh>The Great Graph Aha</vh></v>
<v t="ekr.20070806090226.15"><vh>Added support for @auto files</vh>
<v t="ekr.20070806095535.1"><vh>What @auto does</vh></v>
<v t="ekr.20070809141529"><vh>Perfect import checks</vh></v>
<v t="ekr.20070806101412"><vh>Commands related to @auto</vh></v>
<v t="ekr.20070806100055"><vh>Extending the code: adding new parsers</vh></v>
</v>
<v t="ekr.20070920092716"><vh>New commands for resolving cvs conflicts</vh></v>
<v t="ekr.20070809145744.5"><vh>New kinds of settings trees</vh>
<v t="ekr.20071001122703"><vh>@buttons trees</vh></v>
<v t="ekr.20071004110818"><vh>@menus trees</vh></v>
</v>
<v t="ekr.20070809145744.6"><vh>New plugins</vh></v>
<v t="ekr.20071005100213"><vh>Leo's core is now compatible with jython</vh></v>
<v t="ekr.20071026180804"><vh>Improved prototype for icons in headlines</vh></v>
<v t="ekr.20070809145744.7"><vh>Minor improvements</vh></v>
<v t="ekr.20070809145744.4"><vh>Summary of new commands</vh></v>
</v>
<v t="ekr.20070513113903"><vh>Leo 4.4.3</vh></v>
<v t="ekr.20060928172457"><vh>Leo 4.4.2</vh>
<v t="ekr.20060929043325"><vh>A major code reorg</vh></v>
<v t="ekr.20061009111417.18"><vh>New commands</vh></v>
<v t="ekr.20060928172457.4"><vh>New features</vh></v>
<v t="ekr.20060928172457.5"><vh>New and improved plugins</vh></v>
<v t="ekr.20061009111417.11"><vh>Settings</vh></v>
<v t="ekr.20060929043325.1"><vh>ZODB scripting</vh></v>
</v>
<v t="ekr.20060620094033.1"><vh>Leo 4.4.1</vh>
<v t="ekr.20060620130636"><vh>New commands</vh></v>
<v t="ekr.20060620095949.15"><vh>New features</vh></v>
<v t="ekr.20060620130943"><vh>New and improved plugins</vh></v>
<v t="ekr.20060620095949.25"><vh>New settings</vh></v>
<v t="ekr.20070622212732"><vh>Improved settings</vh></v>
<v t="ekr.20060620095655"><vh>Minor improvements</vh></v>
</v>
<v t="ekr.20060620094033.2"><vh>Leo 4.4</vh>
<v t="ekr.20070622212132"><vh>New commands</vh></v>
<v t="ekr.20060620133820.16"><vh>New features</vh></v>
<v t="ekr.20060620140130"><vh>New and improved plugins</vh></v>
<v t="ekr.20060620140228"><vh>New and improved settings</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040414161647"><vh>sources</vh>
<v t="davy.20141202225703.2"><vh>Home page</vh>
<v t="davy.20141202225703.527"><vh>@rst index</vh></v>
</v>
<v t="davy.20141207133842.7"><vh>Autodoc</vh>
<v t="davy.20141207133842.8"><vh>@rst apidoc/index</vh></v>
</v>
<v t="ekr.20131005214621.16089"><vh>TOC</vh>
<v t="ekr.20090428102353.1" a="O"><vh>@rst contents</vh></v>
</v>
<v t="ekr.20131023151757.17122"><vh>Preliminaries</vh>
<v t="ekr.20131008041326.16079"><vh>@rst preliminaries</vh></v>
<v t="ekr.20131017174814.17479"><vh>@rst preface</vh></v>
<v t="ekr.20050831184021.4"><vh>@rst testimonials</vh>
<v t="ekr.20050830074815.1"><vh>Leo is revolutionary</vh></v>
<v t="ekr.20050830074815.2"><vh>Leo is a showcase Python application</vh></v>
<v t="ekr.20050830074815.3"><vh>Leo is fun, even addicting</vh></v>
<v t="ekr.20050830074815.4"><vh>Leo is a flexible, powerful IDE</vh></v>
<v t="ekr.20050830074815.5"><vh>Leo is a superb outliner</vh></v>
<v t="ekr.20050830074815.6"><vh>Leo is an excellent PIM</vh></v>
<v t="ekr.20050830074815.8"><vh>Leo is a superb documentation tool</vh></v>
<v t="ekr.20050830074815.9"><vh>Leo simplifies the understanding of complex systems</vh></v>
<v t="ekr.20050830074815.10"><vh>Leo is stable, well designed and well supported</vh></v>
<v t="ekr.20131023151757.17124"><vh>Quotes from Leo's developers</vh></v>
<v t="ekr.20050830074815.11"><vh>Longer quotes...</vh>
<v t="ekr.20050830074815.12"><vh> Speed Ream's slashdot article</vh></v>
<v t="ekr.20050830074815.13"><vh>Joe Orr</vh></v>
<v t="ekr.20050830074815.14"><vh>Dan Winkler</vh></v>
<v t="ekr.20050830074815.15"><vh>Dan Winkler 2</vh></v>
<v t="ekr.20050830074815.16"><vh>Dan Winkler 3</vh></v>
<v t="ekr.20131025044901.17144"><vh>Steve Litt</vh></v>
</v>
</v>
<v t="ekr.20040414172218.4"><vh>@rst acknowledgements</vh>
<v t="ekr.20040416080538"><vh>@rst-no-head special mentions</vh></v>
</v>
<v t="ekr.20090221070927.1"><vh>@rst license</vh></v>
</v>
<v t="ekr.20131008041326.16092"><vh>Installing &amp; running Leo</vh>
<v t="ekr.20131015104133.16766"><vh>@rst getting-started</vh></v>
<v t="ekr.20111127144911.5544"><vh>@rst download</vh>
<v t="tbrown.20140412113009.50227"><vh>Snapshots</vh></v>
</v>
<v t="ekr.20131008041326.16094"><vh>@rst installing</vh>
<v t="ekr.20141105052052.4"><vh>Dependencies</vh></v>
<v t="ekr.20101125062332.5090"><vh>Installing packages</vh></v>
<v t="ekr.20100817101952.4303"><vh>Installing Leo itself</vh>
<v t="ekr.20100731112744.7276"><vh>Installing Leo on Windows</vh>
<v t="ekr.20130807203905.16602"><vh>Using the single-click installer</vh></v>
<v t="ekr.20130807203905.16603"><vh>Installing from sources (Windows)</vh></v>
<v t="ekr.20130807203905.16597"><vh>Creating Windows file associations</vh></v>
</v>
<v t="ekr.20100731112744.7274"><vh>Installing Leo on Linux</vh>
<v t="ekr.20131030184445.17285"><vh>Installing from a debian package</vh></v>
<v t="ekr.20131030184445.17286"><vh>Installing from sources (Linux)</vh></v>
</v>
<v t="ekr.20120229094652.15098"><vh>Installing Leo on MacOs 10.7 (Lion) and later</vh></v>
<v t="ekr.20100817101952.4306"><vh>Contributing to Leo with git</vh></v>
</v>
</v>
<v t="ekr.20131008041326.16140"><vh>@rst running</vh>
<v t="ekr.20131008041326.16151"><vh>Running Leo</vh>
<v t="ekr.20131008041326.16152"><vh>Running Leo the first time</vh></v>
<v t="ekr.20131008041326.16153"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20131008041326.16154"><vh>Running Leo from a console window</vh></v>
<v t="ekr.20131008041326.16155"><vh>The .leo directory</vh></v>
</v>
<v t="ekr.20131008041326.16156"><vh>Leo's command-line options</vh></v>
</v>
</v>
<v t="ekr.20050831195331.1"><vh>FAQ</vh>
<v t="ekr.20050830115714"><vh>@rst FAQ</vh>
<v t="ekr.20050830120007"><vh>@rst-no-head Links (FAQ)</vh></v>
<v t="ekr.20050830115714.26"><vh>Customizing Leo</vh>
<v t="ekr.20050830115714.29"><vh>How can I add support for a new language?</vh></v>
<v t="ekr.20141108064630.18"><vh>How can I create a pane for matplotlib charts?</vh></v>
<v t="ekr.20060915112109"><vh>How can I enable and disable support for psyco?</vh></v>
<v t="ekr.20141108064630.16"><vh>How can I put background images in the body pane?</vh></v>
<v t="ekr.20060805094325"><vh>How can I use Leo's legacy key bindings?</vh></v>
<v t="ekr.20050830120844"><vh>How do I add a new menu item from a plugin?</vh></v>
<v t="ekr.20110531155858.20564"><vh>How do I set selection colors?</vh></v>
<v t="ekr.20091105080104.9031"><vh>How do I specify qt fonts?</vh></v>
<v t="ekr.20050830115714.30"><vh>How do I submit a plugin?</vh></v>
</v>
<v t="ekr.20090212054250.5"><vh>Getting Leo</vh>
<v t="ekr.20090212054250.6"><vh>Where can I get official releases of Leo?</vh></v>
<v t="ekr.20080603124653.1"><vh>How do I use git to get the latest sources from Leo's GitHub site?</vh></v>
<v t="ekr.20090212054250.7"><vh>How can I get recent snapshots of Leo?</vh></v>
</v>
<v t="ekr.20070623145346"><vh>Installing Leo</vh>
<v t="ekr.20090202191501.7"><vh>Leo's installer failed, what do I do?</vh></v>
<v t="ekr.20060329101442"><vh>Nothing (or almost nothing) happens when I start Leo.  What should I do?</vh></v>
<v t="ekr.20070623145346.1"><vh>Running Python setup.py install from the leo directory doesn't work.  Why not?</vh></v>
</v>
<v t="ekr.20050830115714.1"><vh>Learning to use Leo</vh>
<v t="ekr.20050830115714.2"><vh>What's the best way to learn to use Leo?</vh></v>
<v t="ekr.20050830115714.4"><vh>Why should I use clones?</vh></v>
<v t="ekr.20141108064630.8"><vh>How does EKR use clones?</vh></v>
<v t="ekr.20050830115714.7"><vh>When is using a section better than using a method?</vh></v>
<v t="ekr.20060111192108"><vh>When is deleting a node dangerous?</vh></v>
<v t="ekr.20110521135104.18151"><vh>Why doesn't Leo support cross-file clones?</vh></v>
<v t="ekr.20110531155858.20559"><vh>How does EKR (Leo's developer) use Leo?</vh></v>
<v t="ekr.20120229094652.15152"><vh>How does Leo handle clone conflicts?</vh></v>
</v>
<v t="ekr.20101025080245.6084"><vh>Leo in Shared environments</vh>
<v t="ekr.20050830115714.12"><vh>How should I use Leo with bzr/git/hg/svn/cvs?</vh></v>
<v t="ekr.20090706042206.14718"><vh>How can I use Leo cooperatively without sentinels?</vh></v>
<v t="ekr.20120229094652.15137"><vh>What's the recommended way to upgrade Leo?</vh></v>
</v>
<v t="ekr.20141109053526.4"><vh>Scipting &amp; Testing</vh>
<v t="ekr.20141108064630.15"><vh>How can I create buttons with dropdown menus?</vh></v>
<v t="ekr.20120229094652.15099"><vh>How can I make commonly-used scripts widely accessible?</vh></v>
<v t="ekr.20131115075142.16636"><vh>How can I test settings easily?</vh></v>
<v t="ekr.20141108064630.12"><vh>How can I use setuptools instead of .bat files?</vh></v>
<v t="ekr.20141108064630.13"><vh>How can scripts call functions from Leo's core?</vh></v>
<v t="ekr.20141108064630.10"><vh>How do I run unit tests from Leo?</vh></v>
<v t="ekr.20141108064630.14"><vh>How to use leo to make mathematical notes?</vh></v>
<v t="ekr.20080527063511.1"><vh>What is an easy way to profile code?</vh></v>
</v>
<v t="ekr.20050830115714.118"><vh>Tips and techniques</vh>
<v t="ekr.20050830115714.113"><vh>How can I create a template .leo file?</vh></v>
<v t="ekr.20050830115714.120"><vh>How can I display graphics in Leo?</vh></v>
<v t="ekr.20050830115714.74"><vh>How can I import many files at once?</vh></v>
<v t="ekr.20120229094652.15124"><vh>How can I restore focus without using the mouse</vh></v>
<v t="ekr.20050830115714.116"><vh>How can I show Leo files with Excel?</vh></v>
<v t="ekr.20141030042423.9"><vh>How can I specify the root directory of a thumb drive?</vh></v>
<v t="ekr.20120229094652.15148"><vh>How can I use BibTeX citations from Leo?</vh></v>
<v t="ekr.20130807203905.16526"><vh>How can I use bzr/git to check Leo's importers?</vh></v>
<v t="ekr.20050830120857"><vh>How can I use Leo to develop Leo itself?</vh></v>
<v t="ekr.20141109053526.8"><vh>How can I use the GTD workflow in Leo?</vh></v>
<v t="ekr.20050830115714.119"><vh>How can I use two copies of Leo to advantage?</vh></v>
<v t="ekr.20131122055946.16401"><vh>How to make a screencast</vh>
<v t="ekr.20131122055946.16402"><vh>Use a script to open your app</vh></v>
<v t="ekr.20131122055946.16403"><vh>Debug your workflow with short videos</vh></v>
<v t="ekr.20131122055946.16404"><vh>Emulate the screencast.com tutorials</vh></v>
<v t="ekr.20131122055946.16405"><vh>Record your first real take</vh></v>
<v t="ekr.20131122055946.16406"><vh>Edit your raw take</vh></v>
<v t="ekr.20131122055946.16407"><vh>Summary</vh></v>
<v t="ekr.20131129061821.16884"><vh>Additional tips</vh></v>
<v t="ekr.20131211054925.16388"><vh>Tips for improving audio</vh></v>
</v>
</v>
<v t="ekr.20050830115714.76"><vh>Trouble shooting</vh>
<v t="ekr.20090130144433.1"><vh>How do I get help?</vh></v>
<v t="ekr.20090130144433.2"><vh>How do I report bugs?</vh></v>
<v t="ekr.20080813064908.2"><vh>My old .leo files won't load using Leo 4.5 or later. What should I do?</vh></v>
<v t="ekr.20050830115714.115"><vh>Error messages from the rst3 plugin aren't helpful. What can I do?</vh></v>
<v t="ekr.20050906090012"><vh>How can I run Leo from a console window?</vh></v>
<v t="ekr.20050830115714.77"><vh>How can I use Python's pdb debugger with Leo?</vh></v>
<v t="ekr.20050830115714.17"><vh>I can't write Imported files.  What's going on?</vh></v>
<v t="ekr.20060329101442"></v>
<v t="ekr.20050830115714.117"><vh>The new Python decorator syntax causes problems.  What can I do?</vh></v>
<v t="ekr.20070623145346.1"></v>
<v t="ekr.20070816092449"><vh>I can't run the LeoBridge module outside of leo/core.  What should I do?</vh></v>
<v t="ekr.20101026082911.5538"><vh>Why didn't Leo update my @shadow outline as expected?</vh></v>
<v t="ekr.20120229094652.15130"><vh>Why do Qt windows disappear in my scripts?</vh></v>
</v>
<v t="ekr.20071026055929"><vh>Unicode issues</vh>
<v t="ekr.20061021164213"><vh>I can not enter non-ascii characters.  What can I do?</vh></v>
<v t="ekr.20050830115714.9"><vh>Some characters in external files look funny. What can I do?</vh></v>
<v t="ekr.20060917130130"><vh>I get weird results when defining unicode strings in scripts.  What is going on?</vh></v>
<v t="ekr.20050830115714.10"><vh>Some characters are garbled when importing files. What can I do?</vh></v>
<v t="ekr.20071026055929.1"><vh>Python's print statement shows 'byte hash' for unicode characters.  What can I do?</vh></v>
</v>
<v t="ekr.20050830115714.13"><vh>Using external files</vh>
<v t="ekr.20050830115714.14"><vh>How do I inhibit sentinels in external files?</vh></v>
<v t="ekr.20050830115714.16"><vh>How do I prevent Leo from expanding sections?</vh></v>
<v t="ekr.20050830115714.18"><vh>How can I create Javascript comments?</vh></v>
<v t="ekr.20050830115714.19"><vh>How can I disable PHP comments?</vh></v>
<v t="ekr.20050830115714.20"><vh>How can I use Leo with unsupported languages?</vh></v>
<v t="ekr.20050830115714.21"><vh>How do I make external files start with a shebang line?</vh></v>
<v t="ekr.20050830115714.24"><vh>Can @file trees contain material not in the external file?</vh></v>
<v t="ekr.20050830115714.25"><vh>How can I use Leo with older C compilers</vh></v>
<v t="ekr.20060529053407"><vh>Why can't I use @ignore directives in @file trees?</vh></v>
<v t="shadow.20080825171547.9"><vh>How can I avoid getting long lines in external files?</vh></v>
</v>
</v>
</v>
<v t="ekr.20091130111843.6787"><vh>Tutorials</vh>
<v t="ekr.20091130111843.6788"><vh>@rst tutorial</vh></v>
<v t="ekr.20131008041326.16203"><vh>@rst tutorial-basics</vh>
<v t="ekr.20131008041326.16204"><vh>@rst-no-head links &amp; markup</vh></v>
<v t="ekr.20131002211347.6456"><vh>Command names</vh></v>
<v t="ekr.20131002055813.15973"><vh>Leo's main window</vh></v>
<v t="ekr.20131004191204.16079"><vh>Operations on windows, panes &amp; files</vh></v>
<v t="ekr.20131002055813.19835"><vh>Operations on nodes</vh></v>
<v t="ekr.20131002055813.19036"><vh>Selecting and moving outline nodes</vh></v>
<v t="ekr.20131002055813.19037"><vh>Moving the cursor in text panes</vh></v>
<v t="ekr.20131001100335.15946"><vh>The minibuffer &amp; completions</vh></v>
<v t="ekr.20131001100335.15938"><vh>Finding &amp; replacing text</vh></v>
<v t="ekr.20131002055813.19837"><vh>Undoing and redoing changes</vh></v>
<v t="ekr.20131001100335.15947"><vh>Getting help</vh></v>
<v t="ekr.20131004064408.16020"><vh>Leo directives</vh></v>
<v t="ekr.20131001100335.15940"><vh>Configuring Leo</vh></v>
<v t="ekr.20131009100732.19038"><vh>Plugins</vh></v>
<v t="ekr.20131003040744.18221"><vh>Creating external files with @file and @all</vh></v>
<v t="ekr.20131005214621.16090"><vh>Summary</vh></v>
</v>
<v t="ekr.20131008041326.16222"><vh>@rst tutorial-pim</vh>
<v t="ekr.20131008041326.16248"><vh>@rst-no-head links &amp; markup</vh></v>
<v t="ekr.20131004073415.16044"><vh>Clones</vh></v>
<v t="ekr.20131018100353.16706"><vh>Clones accelerate work flow by creating views</vh></v>
<v t="ekr.20131009100732.16760"><vh>Using abbreviations and templates</vh></v>
<v t="ekr.20131009100732.16737"><vh>Using URLs</vh></v>
<v t="ekr.20131008041326.16066"><vh>Summary</vh></v>
</v>
<v t="ekr.20131008041326.16241"><vh>@rst tutorial-rst3</vh>
<v t="ekr.20131030071311.17087"><vh>@rst-ignore notes</vh></v>
<v t="ekr.20131102044158.16488"><vh>Install docutils and (optional) sphinx</vh></v>
<v t="ekr.20131009100732.16748"><vh>Create the @rst node</vh></v>
<v t="ekr.20131027064821.17144"><vh>The output and intermediate files</vh></v>
<v t="ekr.20131009100732.16754"><vh>Choose docutils or sphinx</vh>
<v t="ekr.20131027064821.18689"><vh>Setting up conf.py for sphinx</vh></v>
</v>
<v t="ekr.20131009100732.16750"><vh>Put a title in the @rst node </vh></v>
<v t="ekr.20131024051649.17136"><vh>Start the chapter</vh></v>
<v t="ekr.20131024051649.17137"><vh>Create sections and subsections</vh></v>
<v t="ekr.20131009100732.16751"><vh>Write your document</vh></v>
<v t="ekr.20131009100732.16752"><vh>Run the rst3 command</vh></v>
<v t="ekr.20131028213522.17150"><vh>Other topics</vh>
<v t="ekr.20131009100732.16755"><vh>\@rst-no-head suppresses sections</vh></v>
<v t="ekr.20131025044901.17147"><vh>\@rst-ignore &amp; @rst-ignore-tree ignore text</vh></v>
<v t="ekr.20131025044901.17148"><vh>Inserting line breaks and special characters</vh></v>
</v>
<v t="ekr.20131005214621.16128"><vh>Summary</vh></v>
<v t="ekr.20131009100732.16753"><vh>Further study</vh></v>
</v>
<v t="ekr.20131008041326.16245"><vh>@rst tutorial-programming</vh>
<v t="ekr.20131008041326.16252"><vh>@rst-no-head links &amp; markup</vh></v>
<v t="ekr.20131215083347.16903"><vh>Overview</vh></v>
<v t="ekr.20131003040744.18222" a="O"><vh>Basic markup</vh></v>
<v t="ekr.20131008041326.16054"><vh>Using @first and @last</vh></v>
<v t="ekr.20131008041326.16055"><vh>Using @path</vh></v>
<v t="ekr.20131016021541.16894"><vh>Using @edit nodes</vh></v>
<v t="ekr.20131008041326.16056"><vh>Using @auto nodes</vh></v>
<v t="ekr.20131008041326.16246"><vh>Summary</vh></v>
</v>
<v t="ekr.20040403171740"><vh>@rst tutorial-scripting</vh>
<v t="ekr.20050812134441.1"><vh>@rst-no-head markup &amp; links</vh></v>
<v t="ekr.20131215083347.16902"><vh>Overview</vh></v>
<v t="ekr.20131013060803.16852"><vh>Hello world</vh></v>
<v t="ekr.20070120075236"><vh>Predefined symbols: c, g and p</vh></v>
<v t="ekr.20131014053720.16810"><vh>Vnodes</vh></v>
<v t="ekr.20131014050027.16801"><vh>Positions</vh></v>
<v t="ekr.20131012060912.16775"><vh>Generators</vh></v>
<v t="ekr.20131014053720.16809"><vh>Capturing positions</vh></v>
<v t="ekr.20131016084446.16726"><vh>Further study</vh></v>
<v t="ekr.20101124083644.5052"><vh>Autocompletion</vh></v>
<v t="ekr.20131017051340.16815"><vh>Calltips</vh></v>
<v t="ekr.20050903161843"><vh>Using @button nodes</vh></v>
<v t="ekr.20131008041326.16058"><vh>Using @test nodes</vh></v>
<v t="ekr.20131016021541.16893"><vh>Summary</vh></v>
<v t="ekr.20131017051340.16732"><vh>@rst-ignore-tree scripting examples</vh>
<v t="ekr.20131017051340.16733"><vh>An example outline</vh></v>
<v t="ekr.20131017051340.16735"><vh>Example position scripts</vh></v>
</v>
</v>
</v>
<v t="ekr.20131008041326.16080"><vh>Users Guide</vh>
<v t="ekr.20131008041326.16082"><vh>@rst usersguide</vh></v>
<v t="EKR.20040524104904.211"><vh>Customizing Leo</vh>
<v t="ekr.20050901101608.4"><vh>@rst customizing</vh>
<v t="ekr.20050901102055"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.140"><vh>Specifying settings</vh>
<v t="ekr.20090116130002.1"><vh>Configuration directories</vh></v>
<v t="ekr.20090116094356.2"><vh>Search order for settings files</vh></v>
<v t="ekr.20090116094356.3"><vh>Safe rules for local settings</vh></v>
<v t="ekr.20070317043727"><vh>Organizer nodes</vh></v>
<v t="ekr.20080411111008.1"><vh>\@ignore and \@if nodes</vh></v>
<v t="ekr.20070317043727.2"><vh>Simple settings nodes</vh></v>
<v t="ekr.20070317043727.3"><vh>Complex settings nodes</vh>
<v t="ekr.20090116094356.5"><vh>\@button</vh></v>
<v t="ekr.20090116094356.6"><vh>\@commands</vh></v>
<v t="ekr.20090116094356.7"><vh>\@data</vh></v>
<v t="ekr.20090116094356.8"><vh>\@enabled-plugins</vh></v>
<v t="ekr.20090116094356.11"><vh>\@font</vh></v>
<v t="ekr.20090116094356.10"><vh>\@menuat</vh></v>
<v t="ekr.20090116094356.9"><vh>\@menus</vh></v>
<v t="ekr.20090116094356.14"><vh>\@mode</vh></v>
<v t="ekr.20090116094356.13"><vh>\@recentfiles</vh></v>
<v t="ekr.20090116094356.12"><vh>\@shortcuts</vh></v>
</v>
</v>
<v t="ekr.20060105214753"><vh>Input modes</vh></v>
<v t="ekr.20050306090601"><vh>Adding extensible attributes to nodes and .leo files</vh></v>
<v t="ekr.20080310093038.4"><vh>Translating Leo's menus and messages</vh></v>
<v t="ekr.20100122073254.11655"><vh>Writing new importers</vh></v>
</v>
</v>
<v t="ekr.20050831184021.1"><vh>Creating documents with the rst3 Command</vh>
<v t="ekr.20050818163826"><vh>@rst rstplugin3</vh>
<v t="ekr.20100810203016.4296"><vh>@rst-ignore</vh>
<v t="ekr.20131027064821.18709"><vh>unused links</vh></v>
<v t="ekr.20050818163826.6"><vh>Options that set command names</vh></v>
<v t="ekr.20050818163826.4"><vh>Advanced topics</vh>
<v t="ekr.20100810203016.4298"><vh>Modes</vh></v>
<v t="ekr.20100810091118.4301"><vh>Code mode options</vh></v>
<v t="ekr.20100810091118.4306"><vh>Rst mode options</vh></v>
<v t="ekr.20050818163826.10"><vh>The code-block directive</vh></v>
</v>
</v>
<v t="ekr.20100813075851.4296"><vh>Options</vh>
<v t="ekr.20100809122216.4286"><vh>General options</vh></v>
<v t="ekr.20050818163826.7"><vh>Headline commands</vh></v>
<v t="ekr.20050818163826.8"><vh>Option doc parts</vh></v>
<v t="ekr.20050818163826.9"><vh>Defaults for options</vh></v>
<v t="ekr.20050818163826.5"><vh>Http plugin options</vh></v>
<v t="ekr.20110612104631.16414"><vh>Section expansion options</vh></v>
</v>
<v t="ekr.20100813075851.4297"><vh>Other topics</vh>
<v t="ekr.20100810091118.4298"><vh>Markup doc parts</vh></v>
<v t="ekr.20050818163826.11"><vh>Required cascading style sheets</vh></v>
<v t="ekr.20060527103630"><vh>Controlling the rst3 command from scripts</vh></v>
</v>
<v t="ekr.20050818163826.13"><vh>Further study</vh></v>
<v t="ekr.20050818163826.16"><vh>Acknowledgements</vh></v>
<v t="ekr.20050818163826.14"><vh>Theory of operation</vh></v>
</v>
</v>
<v t="ekr.20050912125144"><vh>Plugins</vh>
<v t="ekr.20050912125144.1"><vh>@rst plugins</vh>
<v t="ekr.20050912125735"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070814104719"><vh>Enabling plugins</vh></v>
<v t="ekr.20101113063552.9398"><vh>Summary</vh></v>
<v t="ekr.20101113063552.9528"><vh>Gui-independent plugins</vh>
<v t="ekr.20101113063552.9412"><vh>Commands &amp; directives</vh>
<v t="ekr.20101113063552.9413"><vh>add_directives.py</vh></v>
<v t="ekr.20101113063552.9414"><vh>bzr_qcommands.py</vh></v>
<v t="ekr.20101113063552.9415"><vh>empty_leo_file.py</vh></v>
<v t="ekr.20101113063552.9416"><vh>import_cisco_config.py</vh></v>
<v t="ekr.20101113063552.9417"><vh>initinclass.py</vh></v>
<v t="ekr.20101113063552.9418"><vh>leo_interface.py</vh></v>
<v t="ekr.20101113063552.9419"><vh>lineNumbers.py</vh></v>
<v t="ekr.20101113063552.9420"><vh>macros.py</vh></v>
<v t="ekr.20101113063552.9421"><vh>mod_autosave.py</vh></v>
<v t="ekr.20101113063552.9422"><vh>mod_read_dir_outline.py</vh></v>
<v t="ekr.20101113063552.9423"><vh>mod_timestamp.py</vh></v>
<v t="ekr.20101113063552.9798"><vh>nodeActions.py</vh></v>
<v t="ekr.20101113063552.9425"><vh>outline_export.py</vh></v>
<v t="ekr.20101113063552.9426"><vh>paste_as_headlines.py</vh></v>
<v t="ekr.20101113063552.9427"><vh>pretty_print.py</vh></v>
<v t="ekr.20101113063552.9428"><vh>quickMove.py</vh></v>
<v t="ekr.20101113063552.9429"><vh>setHomeDirectory.py</vh></v>
<v t="ekr.20101113063552.9430"><vh>word_count.py</vh></v>
</v>
<v t="ekr.20101113063552.9431"><vh>Debugging</vh>
<v t="ekr.20101113063552.9432"><vh>debugger_pudb.py</vh></v>
<v t="ekr.20101113063552.9433"><vh>dump_globals.py</vh></v>
<v t="ekr.20101113063552.9434"><vh>enable_gc.py</vh></v>
<v t="ekr.20101113063552.9435"><vh>quit_leo.py</vh></v>
<v t="ekr.20101113063552.9436"><vh>trace_gc_plugin.py</vh></v>
<v t="ekr.20101113063552.9437"><vh>trace_keys.py</vh></v>
<v t="ekr.20101113063552.9438"><vh>trace_tags.py</vh></v>
</v>
<v t="ekr.20101113063552.9439"><vh>External programs</vh>
<v t="ekr.20101113063552.9440"><vh>ipython.py</vh></v>
<v t="ekr.20101113063552.9441"><vh>mod_tempfname.py</vh></v>
<v t="ekr.20101113063552.9442"><vh>open_shell.py</vh></v>
<v t="ekr.20101113063552.9443"><vh>tomboy_import.py</vh></v>
<v t="ekr.20101113063552.9444"><vh>vim.py</vh></v>
<v t="ekr.20101113063552.9445"><vh>xemacs.py</vh></v>
<v t="ekr.20101113063552.9446"><vh>word_export.py</vh></v>
</v>
<v t="ekr.20101113063552.9447"><vh>Files and nodes</vh>
<v t="ekr.20101113063552.9448"><vh>active_path.py</vh></v>
<v t="ekr.20101113063552.9449"><vh>at_folder.py</vh></v>
<v t="ekr.20101113063552.9450"><vh>at_produce.py</vh></v>
<v t="ekr.20101113063552.9451"><vh>at_view.py</vh></v>
<v t="ekr.20101113063552.9452"><vh>backlink.py</vh></v>
<v t="ekr.20101113063552.9453"><vh>datenodes.py</vh></v>
<v t="ekr.20101113063552.9454"><vh>expfolder.py</vh></v>
<v t="ekr.20101113063552.9455"><vh>FileActions.py</vh></v>
<v t="ekr.20101113063552.9456"><vh>geotag.py</vh></v>
<v t="ekr.20101113063552.9457"><vh>leocursor.py</vh></v>
<v t="ekr.20101113063552.9458"><vh>mime.py</vh></v>
<v t="ekr.20101113063552.9459"><vh>multifile.py</vh></v>
<v t="ekr.20101113063552.9460"><vh>niceNosent.py</vh></v>
<v t="ekr.20101113063552.9461"><vh>read_only_nodes.py</vh></v>
<v t="ekr.20101113063552.9462"><vh>run_nodes.py</vh></v>
<v t="ekr.20101113063552.9464"><vh>startfile.py</vh></v>
<v t="ekr.20130815102041.15632"><vh>timestamp.py</vh></v>
<v t="ekr.20101113063552.9466"><vh>xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20101113063552.9467"><vh>Scripting</vh>
<v t="ekr.20050912125735.363"><vh>dyna_menu</vh></v>
<v t="ekr.20101113063552.9468"><vh>leoscreen.py</vh></v>
<v t="ekr.20101113063552.9469"><vh>mod_scripting.py</vh></v>
<v t="ekr.20101113063552.9470"><vh>script_io_to_body.py</vh></v>
</v>
<v t="ekr.20101113063552.9471"><vh>Servers</vh>
<v t="ekr.20101113063552.9472"><vh>leoremote.py</vh></v>
<v t="ekr.20101113063552.9473"><vh>mod_http.py</vh></v>
</v>
<v t="ekr.20101113063552.9474"><vh>Slideshows and screenshots</vh>
<v t="ekr.20101113063552.9475"><vh>screenshots.py</vh></v>
<v t="ekr.20101113063552.9463"><vh>slideshow.py</vh></v>
</v>
<v t="ekr.20101113063552.9476"><vh>Text formatting</vh>
<v t="ekr.20101113063552.9477"><vh>bibtex.py</vh></v>
<v t="ekr.20101113063552.9478"><vh>dtest.py</vh></v>
<v t="ekr.20101113063552.9800"><vh>leo_to_html.py</vh></v>
<v t="ekr.20101113063552.9480"><vh>leo_to_rtf.py</vh></v>
</v>
<v t="ekr.20101113063552.9482"><vh>User interface</vh>
<v t="ekr.20101113063552.9483"><vh>UNL.py</vh></v>
<v t="ekr.20101113063552.9484"><vh>chapter_hoist.py</vh></v>
<v t="ekr.20101113063552.9485"><vh>detect_urls.py</vh></v>
<v t="ekr.20101113063552.9486"><vh>EditAttributes.py</vh></v>
<v t="ekr.20101113063552.9487"><vh>interact.py</vh></v>
<v t="ekr.20101113063552.9488"><vh>maximizeNewWindows.py</vh></v>
<v t="ekr.20101113063552.9489"><vh>mod_framesize.py</vh></v>
<v t="ekr.20101113063552.9794"><vh>plugins_menu.py</vh></v>
<v t="ekr.20101113063552.9491"><vh>redirect_to_log.py</vh></v>
<v t="ekr.20101113063552.9492"><vh>scripts_menu.py</vh></v>
<v t="ekr.20101113063552.9493"><vh>zenity_file_dialogs.py</vh></v>
</v>
</v>
<v t="ekr.20101113063552.9399"><vh>Qt only plugins</vh>
<v t="ekr.20101113063552.9400"><vh>attrib_edit.py</vh></v>
<v t="ekr.20141105055521.8"><vh>bigdash.py</vh></v>
<v t="ekr.20131009100732.19039"><vh>bookmarks.py</vh></v>
<v t="ekr.20101113063552.9401"><vh>colorize_headlines.py</vh></v>
<v t="ekr.20101113063552.9402"><vh>contextmenu.py</vh></v>
<v t="ekr.20101113063552.9411"><vh>graphcanvas.py</vh></v>
<v t="ekr.20130815102041.15628"><vh>leomylyn.py</vh></v>
<v t="ekr.20141105055521.5"><vh>livecode.py</vh></v>
<v t="ekr.20101113063552.9403"><vh>nav_qt.py</vh></v>
<v t="ekr.20141105055521.6"><vh>nodetags.py</vh>
<v t="ekr.20141105085003.7"><vh>API</vh></v>
<v t="ekr.20141105085003.8"><vh>UI</vh></v>
<v t="ekr.20141105085003.10"><vh>Tag Limitation</vh></v>
</v>
<v t="ekr.20130815102041.15618"><vh>printing.py</vh></v>
<v t="ekr.20101113063552.9404"><vh>projectwizard.py</vh></v>
<v t="ekr.20101113063552.9405"><vh>quicksearch.py</vh></v>
<v t="ekr.20130815102041.15630"><vh>screen_capture.py</vh></v>
<v t="ekr.20130815102041.15631"><vh>screencast.py</vh></v>
<v t="ekr.20101113063552.9406"><vh>scrolledmessage.py</vh></v>
<v t="ekr.20101113063552.9407"><vh>spydershell.py</vh></v>
<v t="ekr.20101113063552.9408"><vh>stickynotes.py</vh></v>
<v t="ekr.20101113063552.9409"><vh>todo.py</vh></v>
<v t="ekr.20131009100732.19040"><vh>valuespace.py</vh></v>
<v t="ekr.20101113063552.9410"><vh>viewrendered.py</vh></v>
<v t="ekr.20141105055521.7"><vh>viewrendered2.py</vh>
<v t="ekr.20141105085003.12"><vh>Why a better viewrendered plugin?</vh></v>
<v t="ekr.20141105085003.13"><vh>Objectives</vh></v>
<v t="ekr.20141105085003.14"><vh>Implementation</vh></v>
<v t="ekr.20141105085003.15"><vh>Issues / Limitations</vh></v>
<v t="ekr.20141105085003.16"><vh>Future</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040524104904.99"><vh>Commands Reference</vh>
<v t="ekr.20050901101608.2"><vh>@rst commands</vh>
<v t="ekr.20050901101852"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.100"><vh>File commands</vh>
<v t="EKR.20040524104904.101"><vh>Loading, Saving and Reverting Files</vh></v>
<v t="EKR.20040524104904.102"><vh>Communicating with external editors</vh></v>
<v t="EKR.20040524104904.108"><vh>Importing Files into Leo Outlines</vh></v>
<v t="EKR.20040524104904.109"><vh>Exporting Files from Leo Outlines</vh></v>
<v t="EKR.20040524104904.110"><vh>Quitting Leo</vh></v>
</v>
<v t="EKR.20040524104904.111"><vh>Edit commands</vh>
<v t="EKR.20040524104904.112"><vh>Undoing changes</vh></v>
<v t="EKR.20040524104904.113"><vh>Cutting, pasting and selecting text</vh></v>
<v t="EKR.20040524104904.114"><vh>Indenting body text</vh></v>
<v t="ekr.20050313102319"><vh>Adding and deleting comments in body text</vh></v>
<v t="EKR.20040524104904.115"><vh>Creating nodes from body text</vh></v>
<v t="EKR.20040524104904.116"><vh>Converting leading blanks and tabs in body text</vh></v>
<v t="EKR.20040524104904.117"><vh>Executing Python scripts in body text</vh></v>
<v t="EKR.20040524104904.134"><vh>Go To Line Number</vh></v>
<v t="EKR.20040524104904.136"><vh>Inserting the date and time</vh></v>
<v t="EKR.20040524104904.137"><vh>Reformatting paragraphs in body text</vh></v>
<v t="EKR.20040524104904.139"><vh>Matching brackets and parenthesis</vh></v>
<v t="ekr.20120319170934.6104"><vh>Indenting body text automatically</vh></v>
<v t="ekr.20120319170934.6105"><vh>Creating and destroying multiple body editors</vh></v>
<v t="ekr.20120319170934.6110"><vh>Using chapters</vh></v>
</v>
<v t="EKR.20040524104904.118"><vh>Search commands</vh>
<v t="ekr.20120319065417.8790"><vh>Basic searches</vh></v>
<v t="ekr.20120319065417.8798"><vh>Incremental find commands</vh></v>
<v t="ekr.20120319065417.8795"><vh>Word search and regex search commands</vh></v>
<v t="ekr.20120319065417.8788"><vh>Check boxes and their commands</vh></v>
<v t="ekr.20131122055946.16388"><vh>Radio buttons and their commands</vh></v>
</v>
<v t="EKR.20040524104904.143"><vh>Outline commands</vh>
<v t="ekr.20120319170934.6096"><vh>Creating and destroying nodes</vh></v>
<v t="ekr.20120319170934.6095"><vh>Expanding &amp; contracting nodes</vh></v>
<v t="ekr.20120319170934.6097"><vh>Cutting, pasting and deleting nodes</vh></v>
<v t="ekr.20120319170934.6094"><vh>Navigating through the outline</vh></v>
<v t="ekr.20120319170934.6098"><vh>Moving &amp; Reorganizing nodes</vh></v>
<v t="ekr.20120319170934.6099"><vh>Cloning nodes</vh></v>
<v t="ekr.20120319170934.6100"><vh>Marking nodes</vh></v>
<v t="ekr.20120319170934.6101"><vh>Dragging nodes</vh></v>
<v t="EKR.20040524104904.148"><vh>Hoisting &amp; De-hoisting nodes</vh></v>
<v t="EKR.20040524104904.144"><vh>Checking outlines</vh></v>
</v>
<v t="EKR.20040524104904.151"><vh>Window commands</vh></v>
<v t="EKR.20040524104904.157"><vh>Help commands</vh></v>
</v>
</v>
<v t="ekr.20131005214621.16130"><vh>Directives Reference</vh>
<v t="ekr.20131009065148.31758"><vh>@rst directives</vh>
<v t="ekr.20050828160132"><vh>@rst-no-head links</vh></v>
<v t="ekr.20100806170836.4392"><vh>Part 1: \@&lt;file&gt; directives</vh>
<v t="ekr.20100806170836.4393"><vh>\@asis &lt;path&gt;</vh></v>
<v t="ekr.20100806170836.4396"><vh>\@auto &lt;path&gt;</vh></v>
<v t="ekr.20100806170836.4395"><vh>\@edit &lt;path&gt;</vh></v>
<v t="ekr.20100806170836.4403"><vh>\@file &lt;path&gt; (aka @thin)</vh></v>
<v t="ekr.20100806170836.4399"><vh>\@nosent &lt;path&gt;</vh></v>
<v t="ekr.20100806170836.4402"><vh>\@shadow &lt;path&gt;</vh></v>
</v>
<v t="ekr.20100806170836.4411"><vh>Part 2: \@all and \@others</vh></v>
<v t="ekr.20100806170836.4398"><vh>Part 3: Syntax coloring directives</vh></v>
<v t="ekr.20100806170836.4408"><vh>Part 4: Dangerous directives</vh></v>
<v t="ekr.20100804133903.7262"><vh>Part 5: All other directives</vh></v>
</v>
</v>
</v>
<v t="ekr.20101025080245.5798"><vh>Leo and Other Programs</vh>
<v t="ekr.20131008041326.16100"><vh>@rst leoandotherprograms</vh></v>
<v t="ekr.20061025065357"><vh>Leo and Emacs</vh>
<v t="ekr.20061025065357.1"><vh>@rst emacs</vh>
<v t="ekr.20061025065357.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20140720203932.17747"><vh>Using org-mode (.org) files in Leo</vh></v>
<v t="ekr.20061025081359"><vh>Controlling Leo from Emacs using Pymacs</vh></v>
<v t="ekr.20061025070825.1"><vh>Functions in leoPymacs.py</vh></v>
<v t="ekr.20061025142434"><vh>The minibuffer</vh></v>
</v>
</v>
<v t="TL.20080804095315.1"><vh>Leo and Vim</vh>
<v t="TL.20080804095315.2"><vh>@rst vimBindings</vh>
<v t="ekr.20140810085801.18230"><vh>Using Leo's native vim mode</vh>
<v t="ekr.20140810153947.6747"><vh>Supported commands</vh></v>
<v t="ekr.20140810153947.6752"><vh>Differences from the real vim</vh></v>
<v t="ekr.20140810153947.6749"><vh>Abbreviations</vh></v>
<v t="ekr.20140810153947.6750"><vh>Colon commands</vh></v>
<v t="ekr.20140810153947.6751"><vh>Settings</vh></v>
</v>
<v t="ekr.20140720203932.17748"><vh>Using vimoutline (.otl) files in Leo</vh></v>
<v t="ekr.20140810085801.18231"><vh>Using stand-alone vim bindings</vh>
<v t="TL.20080804095315.4"><vh>Installing vim bindings</vh></v>
<v t="TL.20080804095315.5"><vh>General commands</vh></v>
<v t="TL.20080804095315.6"><vh>Body pane commands</vh></v>
<v t="TL.20080804095315.7"><vh>Outline commands</vh></v>
<v t="TL.20080804095315.8"><vh>Commands not supported</vh></v>
<v t="TL.20080804095315.9"><vh>Avoiding changes to 'tag' files</vh></v>
</v>
</v>
</v>
<v t="ekr.20080203101507"><vh>ILeo - the IPython bridge</vh>
<v t="ekr.20080203101507.1"><vh>@rst IPythonBridge</vh>
<v t="ekr.20080203101507.2"><vh>@rst-no-head links</vh></v>
<v t="vivainio.20080302174639.1"><vh>Overview</vh></v>
<v t="vivainio.20080302174639.2"><vh>Starting ILeo</vh></v>
<v t="ekr.20131001045038.18981"><vh>Running Leo scripts from IPython</vh></v>
<v t="ekr.20131001045038.18980"><vh>Running IPython scripts from Leo</vh></v>
<v t="ekr.20131001045038.18979"><vh>ILeo as an IPython notebook</vh></v>
<v t="ekr.20131001100236.15927"><vh>ILeo and the valuespace plugin</vh></v>
<v t="ekr.20131001045038.17448"><vh>Acknowledgements and history</vh></v>
</v>
</v>
<v t="ekr.20070317033759"><vh>Embedding Leo with the leoBridge module</vh>
<v t="ekr.20070317033759.1"><vh>@rst leoBridge</vh>
<v t="ekr.20070317033759.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070317033759.3"><vh>The basics</vh></v>
<v t="ekr.20071210094621"><vh>Running leoBridge from within Leo</vh></v>
</v>
</v>
<v t="ekr.20060913164304"><vh>Leo and ZODB</vh>
<v t="ekr.20060913164304.1"><vh>@rst zodb</vh>
<v t="ekr.20060913164311"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060913170145"><vh>Configuring Leo to use zodb</vh></v>
<v t="ekr.20060913170403"><vh>Initing zodb</vh></v>
<v t="ekr.20060913170403.1"><vh>Writing data to zodb</vh></v>
<v t="ekr.20060913175437"><vh>Defining zodb keys</vh></v>
<v t="ekr.20060913170403.2"><vh>Reading data from zodb</vh></v>
<v t="ekr.20060913175437.1"><vh>About connections</vh></v>
<v t="ekr.20060913165542.1"><vh>Convenience routines</vh>
<v t="ekr.20060913165542.2"><vh>g.init_zodb (pathToZodbStorage,verbose=True)</vh></v>
<v t="ekr.20060913165542.3"><vh>v.detach()</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20101025080245.5799"><vh>Advanced Topics</vh>
<v t="ekr.20131008041326.16099"><vh>@rst intermediatetopics</vh></v>
<v t="ekr.20060430221745"><vh>Controlling syntax coloring</vh>
<v t="ekr.20060430221745.1"><vh>@rst coloring</vh>
<v t="ekr.20060430222753"><vh>@rst-no-head links</vh></v>
<v t="ekr.20060830142929"><vh>Syntax coloring settings</vh></v>
<v t="ekr.20060430220749"><vh>Files</vh></v>
<v t="ekr.20060502084233"><vh>The colorizer's inner loop</vh></v>
<v t="ekr.20060502084233.1"><vh>Format of colorizer control files</vh>
<v t="ekr.20060502100550"><vh>Ruleset names</vh></v>
<v t="ekr.20060502090516"><vh>x.properties</vh></v>
<v t="ekr.20060510085547"><vh>Attribute dictionaries and x.attributesDictDict</vh></v>
<v t="ekr.20060502090516.1"><vh>Keyword dictionaries and x.keywordsDictDict</vh></v>
<v t="ekr.20060502090516.2"><vh>Rules, rules dictionaries and x.rulesDictDict</vh></v>
<v t="ekr.20060503072213"><vh>x.importDict and imported versus delegated rulesets</vh></v>
</v>
<v t="ekr.20060502122950"><vh>Rule methods</vh>
<v t="ekr.20060503064515"><vh>Arguments to rule methods</vh></v>
<v t="ekr.20060502122950.7"><vh>match_eol_span</vh></v>
<v t="ekr.20060502122950.10"><vh>match_eol_span_regexp</vh></v>
<v t="ekr.20060502122950.13"><vh>match_keywords</vh></v>
<v t="ekr.20060502122950.14"><vh>match_mark_following</vh></v>
<v t="ekr.20060502125223"><vh>match_mark_previous</vh></v>
<v t="ekr.20060502122950.40"><vh>match_seq</vh></v>
<v t="ekr.20060502122950.41"><vh>match_seq_regexp</vh></v>
<v t="ekr.20060502122950.42"><vh>match_span</vh></v>
<v t="ekr.20060502122950.47"><vh>match_span_regexp</vh></v>
<v t="ekr.20060502122950.48"><vh>match_terminate</vh></v>
</v>
</v>
</v>
<v t="ekr.20060612102055"><vh>Writing Plugins</vh>
<v t="ekr.20060612103240"><vh>@rst writingPlugins</vh>
<v t="ekr.20060612103824"><vh>@rst-no-head links</vh></v>
<v t="ekr.20131008041326.16053"><vh>Writing Plugins</vh></v>
<v t="EKR.20040524104904.224"><vh>Important security warnings</vh></v>
<v t="peckj.20130813123907.6841"><vh>Documenting plugins</vh></v>
<v t="ekr.20131012191145.16789"><vh>c ivars &amp; properties</vh></v>
<v t="ekr.20050903074833"><vh>Handling events</vh>
<v t="ekr.20050903074833.1"><vh>Summary of event handlers</vh></v>
</v>
<v t="EKR.20040524104904.240"><vh>Support for unit testing</vh></v>
</v>
</v>
<v t="ekr.20070628083442"><vh>Unit testing with Leo</vh>
<v t="ekr.20070628083442.1"><vh>@rst unitTesting</vh>
<v t="ekr.20070628083442.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070628084351"><vh>Using @test nodes</vh></v>
<v t="ekr.20070628094515.1"><vh>Using @suite nodes</vh></v>
<v t="ekr.20120229094652.15125"><vh>Using @mark-for-unit-tests</vh></v>
<v t="ekr.20070628094515.2"><vh>How the unit test commands work</vh></v>
<v t="ekr.20080729064227.6"><vh>\@button timer</vh></v>
<v t="ekr.20080729064227.7"><vh>\@button profile</vh></v>
</v>
</v>
<v t="ekr.20060527105211"><vh>Debugging with Leo</vh>
<v t="ekr.20060527105617"><vh>@rst debuggers</vh>
<v t="ekr.20060527105804"><vh>@rst-no-head links</vh></v>
<v t="ekr.20070116062405"><vh>Using g.trace and g.pdb</vh></v>
<v t="ekr.20060527112801"><vh>Settings for winpdb</vh></v>
<v t="ekr.20070115172724"><vh>Debugging scripts with winpdb</vh>
<v t="ekr.20070115172724.1"><vh>The debug command</vh></v>
<v t="ekr.20070115172724.3"><vh>The execute-script command with explicit debugger breaks</vh></v>
</v>
</v>
</v>
<v t="ekr.20080730212711.14"><vh>Using @shadow</vh>
<v t="ekr.20080730212711.15"><vh>@rst atShadow</vh>
<v t="ekr.20080730212711.16"><vh>@rst-no-head links</vh></v>
<v t="ekr.20080730212711.39"><vh>Overview</vh></v>
<v t="ekr.20080730212711.42"><vh>Creating @shadow trees</vh></v>
<v t="ekr.20080730212711.40"><vh>What the update algorithm does</vh></v>
<v t="ekr.20080730212711.52"><vh>Aha: boundary cases don't matter</vh></v>
</v>
</v>
<v t="ekr.20131015104133.16763"><vh>A scripting miscellany</vh>
<v t="ekr.20131015091948.16784"><vh>@rst scripting-miscellany</vh>
<v t="ekr.20110531155858.20563"><vh>Creating minimal outlines</vh></v>
<v t="ekr.20111115063523.13619"><vh>Creating Qt Windows from Leo scripts</vh></v>
<v t="ekr.20071026183116"><vh>g.app.gui.run* methods run dialogs</vh></v>
<v t="ekr.20040403173920.19"><vh>Getting commander preferences</vh></v>
<v t="ekr.20050907094633"><vh>Getting configuration settings</vh></v>
<v t="ekr.20080922124033.1"><vh>Getting interactive input from scripts</vh></v>
<v t="ekr.20080109074102"><vh>Inserting and deleting icons</vh></v>
<v t="ekr.20040403173920.18"><vh>Invoking commands from scripts</vh></v>
<v t="ekr.20050417072710.1"><vh>Making operations undoable</vh></v>
<v t="ekr.20100506062734.11593"><vh>Modifying plugins with @script scripts</vh></v>
<v t="ekr.20090223065025.3"><vh>Modifying the body pane directly</vh></v>
<v t="ekr.20070122093626"><vh>Recovering vnodes</vh></v>
<v t="ekr.20120317130339.8282"><vh>Retaining pointers to Qt windows</vh></v>
<v t="ekr.20040403173920.24"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20081205084002.2"><vh>Working with directives and paths</vh></v>
<v t="ekr.20131012060912.16788"><vh>Writing g.es output to other tabs</vh></v>
<v t="ekr.20131014053720.16816"><vh>\@button example</vh></v>
</v>
</v>
<v t="ekr.20131008041326.16178"><vh>Exploring Leo's Code Base</vh>
<v t="ekr.20131009065148.31760"><vh>@rst theory</vh>
<v t="ekr.20131011050613.16868"><vh>How to explore Leo's sources</vh>
<v t="ekr.20131012060912.16768"><vh>Finding commands</vh></v>
<v t="ekr.20131011050613.16870"><vh>Finding key-handling code</vh></v>
<v t="ekr.20131011050613.16871"><vh>Finding redraw and refocus code</vh></v>
<v t="ekr.20131011050613.16862"><vh>Debugging with g.trace, g.callers &amp; g.pdb</vh></v>
</v>
<v t="ekr.20131012060912.16769"><vh>Special topics</vh>
<v t="ekr.20131011050613.16860"><vh>The design of Leo's classes</vh></v>
<v t="ekr.20131011050613.16876"><vh>Fragile methods</vh></v>
<v t="ekr.20131011050613.16866"><vh>Read long comments with caution</vh></v>
<v t="ekr.20131011050613.16815"><vh>Startup</vh></v>
<v t="EKR.20040524104904.268"><vh>Unicode</vh></v>
<v t="ekr.20131012060912.16770"><vh>Why key handling is complex</vh></v>
</v>
</v>
</v>
<v t="ekr.20140810085801.18216"><vh>Vim Mode Theory of Operation</vh>
<v t="ekr.20140810085801.18232"><vh>@rst vim-theory</vh>
<v t="ekr.20140810085801.18217"><vh>The big picture</vh></v>
<v t="ekr.20140811083910.18246"><vh>A simple key handler</vh></v>
<v t="ekr.20140810085801.18221"><vh>A more complex key handler</vh>
<v t="ekr.20140810085801.18222"><vh>vim_d</vh></v>
<v t="ekr.20140810085801.18223"><vh>vim_d2</vh></v>
<v t="ekr.20140810085801.18224"><vh>vim_d3</vh></v>
<v t="ekr.20140810085801.18225"><vh>vis_d</vh></v>
</v>
<v t="ekr.20140810085801.18226"><vh>Code level details</vh>
<v t="ekr.20140810085801.18227"><vh>Initialization</vh></v>
<v t="ekr.20140810085801.18228"><vh>Dispatchers</vh></v>
<v t="ekr.20140810085801.18218"><vh>About key handlers</vh></v>
<v t="ekr.20140810085801.18219"><vh>Ivars for key handlers</vh></v>
<v t="ekr.20140810085801.18220"><vh>API's for key handlers</vh></v>
<v t="ekr.20140810085801.18229"><vh>vc.return_value and internal error checking</vh></v>
</v>
</v>
</v>
<v t="ekr.20131019035402.17557"><vh>The Leonine world</vh>
<v t="ekr.20131019035402.17573"><vh>@rst leonine-world</vh></v>
</v>
</v>
<v t="ekr.20131008041326.16091"><vh>Cheat Sheet</vh>
<v t="ekr.20131007143750.16070"><vh>@rst cheatsheet</vh>
<v t="ekr.20131019061259.16693"><vh>Key bindings</vh>
<v t="ekr.20131015035606.16778"><vh>Selecting outline nodes</vh></v>
<v t="ekr.20131015035606.16800"><vh>Moving outline nodes</vh></v>
<v t="ekr.20131015035606.16780"><vh>Moving the cursor</vh></v>
</v>
<v t="ekr.20131015035606.16801"><vh>Frequently used commands</vh></v>
<v t="ekr.20131015035606.16786"><vh>Leo directives</vh></v>
<v t="ekr.20131015035606.16788"><vh>Settings</vh></v>
<v t="ekr.20131031101712.16486"><vh>Node types</vh></v>
<v t="ekr.20131016103844.16730"><vh>Notable Plugins</vh></v>
<v t="ekr.20131015035606.16799"><vh>External files (@&lt;file&gt; nodes)</vh></v>
<v t="ekr.20131007143750.16074"><vh>Scripting</vh>
<v t="ekr.20131019061259.16686"><vh>Pre-defined symbols</vh></v>
<v t="ekr.20131019061259.16687"><vh>Generators</vh></v>
<v t="ekr.20131019061259.16688"><vh>Commands class</vh></v>
<v t="ekr.20131019061259.16690"><vh>vnode class</vh></v>
<v t="ekr.20131019061259.16691"><vh>position class</vh></v>
<v t="ekr.20131019061259.16692"><vh>leo.core.leoGlobals module</vh></v>
</v>
<v t="ekr.20131028213522.17138"><vh>Command-line options</vh></v>
</v>
</v>
<v t="ekr.20140216125129.16666"><vh>Additonal web pages</vh>
<v t="ekr.20101025080245.5791"></v>
<v t="ekr.20131030184445.16582"><vh>@rst leoLinks</vh></v>
<v t="ekr.20090711120622.10447"><vh>@rst screen-shots</vh>
<v t="ekr.20090811090022.14452"><vh>Windows screen shots</vh></v>
<v t="ekr.20090811090022.14453"><vh>Linux screen shots</vh></v>
</v>
<v t="ekr.20131120115900.16329"><vh>@rst screencasts</vh></v>
<v t="ekr.20100821182153.4343"><vh>@rst slides</vh></v>
</v>
<v t="ekr.20050831184021.5"><vh>Appendices &amp; glossary</vh>
<v t="ekr.20131008041326.16341"><vh>@rst appendices</vh>
<v t="ekr.20050831232205"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.357"><vh>Format of .leo files</vh></v>
<v t="ekr.20060921064744.1"><vh>Format of external files</vh></v>
<v t="EKR.20040524104904.354"><vh>Unicode reference</vh></v>
<v t="ekr.20120319170934.6109"><vh>Valid URL's</vh></v>
<v t="ekr.20131008041326.16177"><vh>History of Leo</vh>
<v t="ekr.20050901102147"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050902105852"><vh>Beginnings</vh></v>
<v t="ekr.20050902105852.1"><vh>Breakthrough</vh></v>
<v t="ekr.20050902105852.2"><vh>Apple and YellowBox</vh></v>
<v t="ekr.20050902105852.3"><vh>Borland C++</vh></v>
<v t="ekr.20050902105852.4"><vh>Discovering Python</vh></v>
<v t="ekr.20050902105852.5"><vh>SourceForge</vh></v>
<v t="ekr.20050902105852.6"><vh>Allowing sentinel lines in external files</vh></v>
<v t="ekr.20050902105852.7"><vh>Untangling @file is easy!</vh></v>
<v t="ekr.20050902105852.8"><vh>Leo 3.x: Continuous improvement</vh></v>
<v t="ekr.20050902105852.9"><vh>Leo 4.0: Eliminating error 'recovery'</vh></v>
<v t="ekr.20050902105852.10"><vh>Leo 4.1: The debut of gnx's</vh></v>
<v t="ekr.20050902105852.11"><vh>Leo 4.2: Complete at last</vh></v>
<v t="ekr.20050902105852.12"><vh>Leo 4.3 Settings</vh></v>
<v t="ekr.20060629083935"><vh>Leo 4.4 The minibuffer and key bindings</vh></v>
<v t="ekr.20080315115427.568"><vh>Leo 4.4.x Improvements</vh></v>
<v t="ekr.20101025080245.6085"><vh>Leo 4.5 @shadow files</vh></v>
<v t="ekr.20101025080245.6086"><vh>Leo 4.6 Caching, Qt and more</vh></v>
<v t="ekr.20101025080245.6087"><vh>Leo 4.7 The one node world and Python 3k</vh></v>
<v t="ekr.20101025080245.6089"><vh>Leo 4.8 Simple sentinels &amp; better data recovery</vh></v>
<v t="ekr.20131008041326.16253"><vh>Leo 4.9 Qt, autocompleter, vr pane</vh></v>
<v t="ekr.20131031101712.16685"><vh>Leo 4.10 Many improvements</vh></v>
<v t="ekr.20131031101712.17211"><vh>Leo 4.11 Many more improvements</vh></v>
<v t="ekr.20050902100834"><vh>@rst-ignore-tree More history</vh>
<v t="EKR.20040524104904.247"><vh>Versions</vh></v>
<v t="EKR.20040524104904.248"><vh>Designing @file trees</vh>
<v t="EKR.20040524104904.249"><vh>Deciding to do Leo2</vh></v>
<v t="EKR.20040524104904.250"><vh>A prototype</vh></v>
<v t="EKR.20040524104904.251"><vh>User interaction</vh></v>
<v t="EKR.20040524104904.252"><vh>The write code</vh></v>
<v t="EKR.20040524104904.253"><vh>The read code</vh></v>
<v t="EKR.20040524104904.254"><vh>The load/save code</vh></v>
<v t="EKR.20040524104904.255"><vh>Attributes, mirroring and dummy nodes</vh></v>
<v t="EKR.20040524104904.256"><vh>Clones</vh></v>
<v t="EKR.20040524104904.257"><vh>Error recovery, at last</vh></v>
</v>
</v>
</v>
<v t="ekr.20050901084134"><vh>Why I like Python</vh>
<v t="ekr.20050901092232.2"><vh>Clarity</vh></v>
<v t="ekr.20050901092232.3"><vh>Power</vh></v>
<v t="ekr.20050901092232.4"><vh>Safety</vh></v>
<v t="ekr.20050901092232.5"><vh>Speed</vh></v>
<v t="ekr.20050901092232.6"><vh>Conclusions</vh></v>
</v>
</v>
<v t="ekr.20091111112709.6672"><vh>@rst glossary</vh>
<v t="ekr.20100804133903.7250"><vh>\@</vh></v>
<v t="ekr.20100804133903.7251"><vh>A - C</vh></v>
<v t="ekr.20100804133903.7252"><vh>D - G</vh></v>
<v t="ekr.20100804133903.7253"><vh>H - L</vh></v>
<v t="ekr.20100804133903.7254"><vh>M - O</vh></v>
<v t="ekr.20100804133903.7255"><vh>P - R</vh></v>
<v t="ekr.20100804133903.7256"><vh>S - Z</vh></v>
</v>
</v>
</v>
<v t="davy.20141207133842.11"><vh>templates</vh>
<v t="davy.20141208214654.4"><vh>Sidebar</vh>
<v t="davy.20141209091210.2"><vh>@file sources/templates/flattrSidebar.html</vh></v>
<v t="davy.20141209091210.10"><vh>@file sources/templates/leoHomeSidebar.html</vh></v>
</v>
<v t="davy.20141208214654.5"><vh>Theme layout</vh>
<v t="davy.20141209091210.28"><vh>@file sources/templates/layout.html</vh></v>
</v>
<v t="davy.20141208214654.3"><vh>Autosummary</vh>
<v t="davy.20141209091210.32"><vh>@file sources/templates/autosummary/base.rst</vh></v>
<v t="davy.20141209091210.33"><vh>@file sources/templates/autosummary/module.rst</vh></v>
<v t="davy.20141209091210.34"><vh>@file sources/templates/autosummary/class.rst</vh></v>
</v>
</v>
<v t="davy.20141208214654.9"><vh>CSS</vh>
<v t="davy.20141208214654.8"><vh>@file sources/static/leo.css</vh></v>
</v>
<v t="davy.20141208214654.11"><vh>commands</vh>
<v t="davy.20141209024434.2"><vh>\@button make single rst</vh></v>
<v t="davy.20141208152655.2"><vh>@button make single</vh>
<v t="davy.20141208151446.2"><vh>&lt;&lt; import &gt;&gt;</vh></v>
<v t="davy.20141208134720.2"><vh>&lt;&lt; paths &gt;&gt;</vh></v>
<v t="davy.20141208134720.3"><vh>&lt;&lt; config &gt;&gt;</vh></v>
<v t="davy.20141208134720.15"><vh>make function</vh></v>
</v>
<v t="davy.20141208214654.10"><vh>\@button make all rst</vh></v>
<v t="davy.20141208113259.3"><vh>@button make all</vh>
<v t="davy.20141208151446.2"></v>
<v t="davy.20141208134720.2"></v>
<v t="davy.20141208134720.3"></v>
<v t="davy.20141208134720.15"></v>
</v>
<v t="davy.20141209091210.35"><vh>@button upload doc</vh>
<v t="davy.20141208134720.2"></v>
<v t="davy.20141209091210.36"></v>
</v>
</v>
<v t="davy.20141209134323.3"><vh>Orphans</vh>
<v t="davy.20141209134323.291"><vh>Release notes</vh>
<v t="edream.110203163054.117"><vh>Previous versions...</vh>
<v t="ekr.20050210102358"><vh>4.0... New read logic eliminates read errors, eliminated child indices</vh>
<v t="edream.110203163054.66"><vh>4.0.1 through 4.0.4</vh></v>
<v t="edream.110203163054.67"><vh>4.0 final</vh>
<v t="edream.110203163054.68"><vh>4.0 beta 4</vh></v>
<v t="edream.110203163054.69"><vh>4.0 beta 3</vh>
<v t="edream.110203163054.70"><vh>Fixed bugs</vh>
<v t="edream.110203163054.71"><vh>Fixed bug that caused some clones not to be marked as clones</vh></v>
<v t="edream.110203163054.72"><vh>Corrected problems with setting icons on Linux</vh></v>
<v t="edream.110203163054.73"><vh>Fixed crasher in sentinelName</vh></v>
<v t="edream.110203163054.74"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
</v>
<v t="edream.110203163054.75"><vh>New features</vh>
<v t="edream.110203163054.76"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="edream.110203163054.77"><vh>Added build number to signon</vh></v>
<v t="edream.110203163054.78"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
</v>
<v t="edream.110203163054.79"><vh>4.0 beta 2</vh>
<v t="edream.110203163054.80"><vh>To-do for 4.0 final</vh></v>
<v t="edream.110203163054.81"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.82"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="edream.110203163054.83"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="edream.110203163054.84"><vh>Fixed bugs involving find params</vh></v>
<v t="edream.110203163054.85"><vh>Fixed Python Import bug</vh></v>
<v t="edream.110203163054.86"><vh>Fixed several more unicode bugs</vh></v>
<v t="edream.110203163054.87"><vh>Fixed crasher in Go To Outline command.</vh></v>
<v t="edream.110203163054.88"><vh>Fixed @rawfile write problem</vh></v>
</v>
<v t="edream.110203163054.89"><vh>Improved commands</vh>
<v t="edream.110203163054.90"><vh>Finished Import External File command and made it undoable</vh></v>
<v t="edream.110203163054.91"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="edream.110203163054.92"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="edream.110203163054.93"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="edream.110203163054.94"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
<v t="edream.110203163054.95"><vh>Created leoGui base class for tkinterGui class</vh></v>
</v>
<v t="edream.110203163054.96"><vh>New and improved settings</vh>
<v t="edream.110203163054.97"><vh>Added support for two new settings affecting drags</vh></v>
<v t="edream.110203163054.98"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
</v>
<v t="edream.110203163054.99"><vh>4.0 beta 1</vh>
<v t="edream.110203163054.100"><vh>4.0 Theory of operation</vh></v>
<v t="edream.110203163054.101"><vh>New commands &amp; options</vh>
<v t="edream.110203163054.102"><vh>New write_old_format_derived_files option</vh></v>
<v t="edream.110203163054.103"><vh>New Clear Recent Files command</vh></v>
<v t="edream.110203163054.104"><vh>New Import External File command</vh></v>
<v t="edream.110203163054.105"><vh>New Write 3.x/4.x External Files &amp; autosave</vh></v>
</v>
<v t="edream.110203163054.106"><vh>New plugins</vh></v>
<v t="edream.110203163054.107"><vh>New read logic and greatly inproved error recovery</vh>
<v t="edream.110203163054.108"><vh>Added test for unvisited nodes in read logic</vh></v>
<v t="edream.110203163054.109"><vh>Error recovery is _much_ better than before</vh></v>
</v>
<v t="edream.110203163054.110"><vh>Improvements &amp; bug fixes</vh>
<v t="edream.110203163054.111"><vh>Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="edream.110203163054.112"><vh>Added support for Python 2.3</vh></v>
<v t="edream.110203163054.113"><vh>Leo recycles window objects only if more than one window open</vh></v>
<v t="edream.110203163054.114"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="edream.110203163054.115"><vh>Removed Open Python Window command</vh></v>
<v t="edream.110203163054.116"><vh>Simplified read and write code</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050210102150.1"><vh>4.1... gnx's</vh>
<v t="ekr.20040216151748"><vh>4.1 final</vh>
<v t="ekr.20040217085036"><vh>Added several new plugins</vh></v>
<v t="ekr.20040216152948"><vh>Added Toggle Angle Brackets command</vh></v>
<v t="ekr.20040216153725"><vh>Changed Undo/Redo messages</vh></v>
<v t="ekr.20040217075627"><vh>Fixed clone bug when pasting nodes</vh></v>
<v t="ekr.20040217085036.1"><vh>Investigated encoding problem: it's a Python 2.3 bug</vh></v>
</v>
<v t="ekr.20040131040356"><vh>4.1 rc4</vh>
<v t="ekr.20040201114855"><vh>New plugins in 4.1 rc4</vh>
<v t="ekr.20040201114855.42"><vh>mod_http.py plugin: Bernhard Mulder</vh></v>
<v t="ekr.20040201114855.91"><vh>newButtons.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.29"><vh>nodenavigator.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.36"><vh>rowcol.py: EKR</vh></v>
<v t="ekr.20040201114855.3"><vh>rst2.py plugin: Steve Zatz</vh></v>
<v t="ekr.20040201114855.13"><vh>searchbox.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201120903"><vh>status_line.py plugin: EKR</vh></v>
</v>
<v t="ekr.20040131041015"><vh>New features in 4.1 rc4</vh>
<v t="ekr.20040131040544.10"><vh>Leo no longer automatically draws the status area</vh></v>
<v t="ekr.20040131040544.21"><vh>Esc and enter key now work in the find panel</vh></v>
<v t="ekr.20040131040544.55"><vh>Improved message for orphan nodes</vh></v>
<v t="ekr.20040131040544.178"><vh>Eliminated marking nodes dirty unnecessarily</vh></v>
<v t="ekr.20040131040544.222"><vh>Execute Script command now ends all nodes with a newline</vh></v>
<v t="ekr.20040131040544.2"><vh>Added message when plugins are disabled</vh></v>
<v t="ekr.20040201061329"><vh>Created status_line.py plugin</vh></v>
<v t="ekr.20040201114855.105"><vh>Simplified operation of script-find/change &amp; improved documentation</vh>
<v t="edream.110603190322.6"><vh> Script Find and Script Change</vh>
<v t="edream.111803060152.1"><vh>How it works</vh></v>
<v t="ekr.20040201113232"><vh>Using the initScriptFind script</vh></v>
<v t="edream.111803060152.2"><vh>Ideas for using scripts</vh></v>
</v>
</v>
<v t="ekr.20040201114855.106"><vh>Added done message to Mark Changed commands</vh></v>
</v>
<v t="ekr.20040131040356.1"><vh>Bugs fixed in 4.1 rc4</vh>
<v t="ekr.20040131044727"><vh>Fixed several bugs when writing external files</vh></v>
<v t="ekr.20040131040754"><vh>Fixed several crashers</vh></v>
<v t="ekr.20040131040544.5"><vh>Fixed "bad leo file" when reading some 3.x .leo files</vh></v>
<v t="ekr.20040131040544.18"><vh>Fixed huge performance bug in cut/copy node commands</vh></v>
<v t="ekr.20040131040544.32"><vh>Leo now properly re-enables drawing after exceptions</vh></v>
<v t="ekr.20040201114855.107"><vh>Fixed major bug in tkFind.init</vh></v>
<v t="ekr.20040131040544.73"><vh>Fixed bug in Move Up command</vh></v>
<v t="ekr.20040131040544.81"><vh>Fixed bug in Import External File</vh></v>
<v t="ekr.20040131040544.146"><vh>Fixed bugs related to saving read-only files</vh></v>
<v t="ekr.20040131040544.169"><vh>Fixed bug in Import Python Window command when using Python 2.2</vh></v>
<v t="ekr.20040131040544.228"><vh>Fixed bugs in Convert All BlanksTabs commands</vh></v>
<v t="ekr.20040131040544.258"><vh>Fixed crashes in open_shell.py plugin</vh></v>
<v t="ekr.20040131044136"><vh>Fixed several bugs involving cut &amp; paste</vh></v>
<v t="ekr.20040131040544.227"><vh>Fixed whitespace problem in leoTkinterGui.py</vh></v>
<v t="ekr.20040131100557"><vh>Fixed glitches when inserting node in hoisted outline</vh></v>
<v t="ekr.20040203084228"><vh>Fixed bugs in search command</vh></v>
</v>
<v t="ekr.20040131040356.2"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="ekr.20040131040356.3"><vh>New code-level features</vh></v>
<v t="ekr.20040131040356.4"><vh>New configuration settings</vh></v>
<v t="ekr.20040131040356.5"><vh>New features</vh></v>
</v>
<v t="edream.121403160546"><vh>4.1 rc3</vh>
<v t="edream.121403165221"><vh>Bugs fixed in this release</vh></v>
<v t="edream.121403161017"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="edream.121403161017.1"><vh>New code-level features</vh></v>
<v t="edream.121403161017.2"><vh>New configuration settings</vh></v>
<v t="edream.121403161340"><vh>New features</vh></v>
</v>
<v t="edream.110603185805"><vh>4.1 beta 5</vh>
<v t="edream.120403174147"><vh>Changes made in 4.1 beta 5</vh>
<v t="edream.120403180443"><vh>New and improved features</vh>
<v t="edream.120403174147.105"><vh>Honor outline/body pane ratio when opening files</vh></v>
<v t="edream.120403174147.112"><vh>Leo now adjusts newly opened windows so they fit on the screen</vh></v>
<v t="edream.120403174147.119"><vh>Tested support for Unicode file &amp; directory names</vh></v>
<v t="edream.120403174147.128"><vh>Added code so @url nodes may open .leo files</vh></v>
<v t="edream.120403174147.56"><vh>Fixed problems with @lineending platform</vh></v>
</v>
<v t="edream.120403174241"><vh>Bugs fixed</vh>
<v t="edream.120403174147.30"><vh>Fixed crasher in Apply Settings command</vh></v>
<v t="edream.120403174147.102"><vh>Fixed crasher in Toggle Angle Brackets command</vh></v>
<v t="edream.120403174147.109"><vh>Fixed crasher when setting Icon in Linux)</vh></v>
<v t="edream.120403174147.33"><vh>Fixed Find panel bug on the Mac</vh></v>
<v t="edream.120403174147.36"><vh>Fixed Import backslash-newline bug</vh></v>
<v t="edream.120403174147.61"><vh>Fixed Linux import problem</vh></v>
<v t="edream.120403174147.63"><vh>Fixed Recent files crasher</vh></v>
<v t="edream.120403174147.65"><vh>Fixed Replace Blanks command</vh></v>
<v t="edream.110603190322.8"><vh>Fixed Serious Undo Change All bugs</vh></v>
<v t="edream.120403174147.94"><vh>Fixed several long-standing bugs related to Extract commands</vh></v>
</v>
</v>
<v t="edream.120403180443.1"><vh>Changes made in earlier 4.1 betas</vh>
<v t="edream.110603190234.1"><vh>Code-level features</vh>
<v t="edream.110603190125.3"><vh>Regression tests started</vh></v>
<v t="edream.110603190125.4"><vh>Code reorganized to support other guis</vh></v>
<v t="edream.110303182253.39"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
</v>
<v t="edream.110603190404"><vh>Fixed bugs</vh>
<v t="edream.110603190322.13"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="edream.110603190322.11"><vh>Fixed first node-only find bug</vh></v>
<v t="edream.110603190322.3"><vh>Fixed bug in idle_body_key</vh></v>
<v t="edream.111803060643"><vh>Fixed LaTeX syntax coloring bug</vh></v>
</v>
<v t="edream.110603192009"><vh>Improved format of .leo files</vh>
<v t="edream.110603190322.9"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="edream.110603190322.10"><vh>Leo now writes node_only find prefs</vh></v>
<v t="edream.110603190125.1"><vh>.leo files are now cvs-friendly</vh></v>
</v>
<v t="edream.110603192009.1"><vh>New &amp; improved commands</vh>
<v t="edream.112303173638"><vh>Running Leo in batch mode</vh></v>
<v t="edream.110203163054.833"><vh>Executing Python scripts in body text</vh></v>
<v t="edream.110603190322.14"><vh>Added Check Outline command</vh></v>
<v t="edream.110603190322.15"><vh>Added Hoist/De-Hoist commands</vh></v>
<v t="edream.111803060152"><vh>Added script-based find/change commands</vh>
<v t="edream.110603190322.6"></v>
</v>
<v t="edream.110303182253.3"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
<v t="edream.111803062437"><vh>Shift commands now shift single line if no selection</vh></v>
</v>
<v t="edream.110303182719"><vh>New config settings</vh></v>
</v>
</v>
<v t="edream.110203163054.64"><vh>4.1 alpha 1</vh></v>
</v>
<v t="ekr.20050210102150"><vh>4.2... @file-thin, shared tnodes</vh>
<v t="ekr.20040922074200"><vh>4.2 final</vh></v>
<v t="ekr.20040914103359"><vh>4.2 rc1</vh>
<v t="ekr.20040914103743.1"><vh>Added new features</vh>
<v t="ekr.20040914103359.137"><vh>Added c.frame.openDirectory to sys.path when executing scripts</vh></v>
<v t="ekr.20040914103359.37"><vh>Added expanded_click_area option to disable left click logic in outline pane</vh></v>
<v t="ekr.20040914103359.2"><vh>Restored the "iconclick1/2" hooks</vh></v>
<v t="ekr.20040914103359.19"><vh>(Allow longer headlines for to support long url's)</vh>
<v t="ekr.20040914103359.20"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20040914103743"><vh>Fixed bugs</vh>
<v t="ekr.20040914103359.47"><vh>Disabled perfect import</vh></v>
<v t="ekr.20040914103359.12"><vh>Fixed Import External Files command</vh></v>
<v t="ekr.20040914103359.15"><vh>Fixed parsing of minimal &lt;preferences&gt; tag</vh></v>
<v t="ekr.20040914103359.7"><vh>Fixed problem with tabs on MacOs</vh></v>
<v t="ekr.20040914103359.28"><vh>Fixed read errors with @language html</vh></v>
<v t="ekr.20040914103359.4"><vh>Made sure a proper message is given with invalid versions of Python</vh></v>
<v t="ekr.20040914103359.110"><vh>Removed failed assert from colorizer</vh></v>
<v t="ekr.20040914103359.31"><vh>Removed spurious "Warning: updating changed text" messages</vh></v>
<v t="ekr.20040914103359.129"><vh>Shifted all Alt-shortcuts to Ctrl shortcuts on the Mac</vh></v>
</v>
</v>
<v t="ekr.20040713110718"><vh>4.2 beta 3</vh>
<v t="ekr.20040804165258.1"><vh>Bug fixes</vh>
<v t="ekr.20040804164600.16"><vh>Leo gives the user a chance to save read-only files</vh></v>
<v t="ekr.20040804164600.36"><vh>Fixed some unit-test bugs</vh></v>
<v t="ekr.20040804164600.56"><vh>Added 3 .cascading style sheets to the distribution list</vh></v>
<v t="ekr.20040804164600.98"><vh>Fixed some bugs in g.importFromPath</vh></v>
<v t="ekr.20040804164600.102"><vh>Fixed major bug in write logic</vh></v>
<v t="ekr.20040804164600.265"><vh>Fixed bug in p.isAncestorOf</vh></v>
<v t="ekr.20040804164600.275"><vh>Leo now writes only the currently selected tree when pasting to the clipboard</vh></v>
<v t="ekr.20040804164600.377"><vh>Fixed performance bug when reading .leo files</vh></v>
<v t="ekr.20040804170846"><vh>Leo now reports problems with bad directories more clearly</vh></v>
<v t="ekr.20040804164600.394"><vh>Leo reads collapsed xml tags properly in .leo files</vh></v>
<v t="ekr.20040804164600.406"><vh>Leo makes brings the confirm save box to the front</vh></v>
<v t="ekr.20040804164600.419"><vh>Improved how es_exception gets line number of errors</vh></v>
<v t="ekr.20040804164600.421"><vh>Fixed major bug: changing headline now marks subnodes dirty</vh></v>
<v t="ekr.20040804164600.470"><vh>Leo now gives update warning only once per external file</vh></v>
<v t="ekr.20040804164600.471"><vh>Leo updates tnodeLists properly in all situations</vh></v>
<v t="ekr.20040804164600.515"><vh>Fixed several leaks of positions</vh></v>
<v t="ekr.20040804171818"><vh>Fixed all unit tests so they work with both Python 2.2 and Python 2.3</vh></v>
</v>
<v t="ekr.20040804165258.2"><vh>Features</vh>
<v t="ekr.20040804172113"><vh>@test and @suite greatly aid unit testing</vh></v>
<v t="ekr.20040804172113.1"><vh>New scripts in test.leo make it very easy to use the gc, profile and timeit modules</vh></v>
<v t="ekr.20040804165258.3"><vh>Import dialogs allow multiple selections</vh></v>
<v t="ekr.20040804165258.4"><vh>New Check menu and commands</vh></v>
<v t="ekr.20040804170531"><vh>Perfect Import feature automatically corrects imported files</vh></v>
<v t="ekr.20040804170657"><vh>Improved performance of outline pane</vh></v>
<v t="ekr.20040804164600.424"><vh>The Go To Line Number command ignores all @all nodes</vh></v>
</v>
</v>
<v t="EKR.20040628095213"><vh>4.2 beta 1 &amp; beta 2</vh>
<v t="EKR.20040628095213.311"><vh>New coding conventions</vh></v>
<v t="EKR.20040524104904.242"><vh>Extending the format of .leo files</vh></v>
<v t="ekr.20040705111716"><vh>in 4.2 b2</vh>
<v t="ekr.20040705111716.1"><vh>Savedmarks and expantion state in &lt;v&gt; elements for @thin nodes</vh></v>
<v t="ekr.20040705111716.45"><vh>Marked all related @thin nodes dirty when a node changesd</vh></v>
<v t="ekr.20040705111716.126"><vh>Fixed bug when reading  4.1 files with topology errors</vh></v>
<v t="ekr.20040705150130"><vh>Leo passes all important pychecker tests</vh></v>
</v>
<v t="ekr.20040705112148"><vh>in 4.2 b1</vh>
<v t="EKR.20040628095213.513"><vh>Changed *nix install script</vh></v>
<v t="EKR.20040628100535"><vh>Fixed bugs</vh>
<v t="EKR.20040628095213.3"><vh>Made "end1" and "ilde"events work again</vh></v>
<v t="EKR.20040628095213.23"><vh>Put drawing hooks back in</vh></v>
<v t="EKR.20040628095213.56"><vh>Fixed syntax colouring Bug in html mode</vh></v>
<v t="EKR.20040628095213.60"><vh>Colorizing fixes</vh></v>
<v t="EKR.20040628095213.113"><vh>Fixed Select All bug</vh></v>
<v t="EKR.20040628095213.121"><vh>Fixed bugs in @tab_width: support backspace with negative tab width</vh></v>
<v t="EKR.20040628095213.143"><vh>Fixed bugs in Remove Sentinel command</vh></v>
<v t="EKR.20040628095213.160"><vh>Eliminated spurious error messages in Import External File command</vh></v>
<v t="EKR.20040628095213.192"><vh>Removed gnx in headlines when importing thin external files</vh></v>
<v t="EKR.20040628095213.202"><vh>Fixed bugs reading 4.1 files</vh></v>
<v t="EKR.20040628095213.213"><vh>Fixed Open With bug</vh></v>
<v t="EKR.20040628095213.225"><vh>Fixed Go To Line Number command</vh></v>
<v t="EKR.20040628095213.246"><vh>Fixed crash when importing Borland wstring.cpp</vh></v>
<v t="EKR.20040628095213.279"><vh>Fixed bug in insertBodyTime</vh></v>
<v t="EKR.20040628095213.297"><vh>Fixed bug when pasting large text into headlines</vh></v>
<v t="EKR.20040628095213.308"><vh>Fixed bug in delete command</vh></v>
<v t="EKR.20040628095213.312"><vh>Fixed oops: nullGui setIdleTimeHook</vh></v>
<v t="EKR.20040628095213.324"><vh>Fixed problems with trailing newlines and spurious changed bit</vh></v>
<v t="EKR.20040628095213.346"><vh>Fixed headline key handling</vh></v>
<v t="EKR.20040628095213.348"><vh>Fixed Problems executing script</vh></v>
<v t="EKR.20040628095213.354"><vh>Fixed problem with PHP and @last</vh></v>
<v t="EKR.20040628095213.366"><vh>Fixed bug when writing unknownAttributes</vh></v>
<v t="EKR.20040628095213.368"><vh>Fixed bugs opening a second file</vh></v>
<v t="EKR.20040628095213.404"><vh>Fixed bug: @last silently failed when extra lines exist</vh></v>
<v t="EKR.20040628095213.407"><vh>Fixed hang when dragging from one clone copy to another</vh></v>
<v t="EKR.20040628095213.412"><vh>Fixed crash in Write Missing</vh></v>
<v t="EKR.20040628095213.442"><vh>Fixed bug in getScript</vh></v>
<v t="EKR.20040628095213.444"><vh>Fixed problems with @all</vh></v>
<v t="EKR.20040628095213.499"><vh>Fixed double print in Execute Script command</vh></v>
<v t="EKR.20040628095213.512"><vh>Fixed bug reading leo.nsi</vh></v>
</v>
<v t="EKR.20040628100535.1"><vh>Added new features</vh>
<v t="EKR.20040628095213.52"><vh>Allowed &lt;/leo_header&gt; tag</vh></v>
<v t="EKR.20040628095213.109"><vh>Replaced the word "Leo" with Leo icon in Find/Compare/Prefs windows</vh></v>
<v t="EKR.20040628095213.110"><vh>Improved Import command slightly</vh></v>
<v t="EKR.20040628095213.197"><vh>Added 3 files to distribution lists</vh></v>
<v t="EKR.20040628095213.198"><vh>Supported @tabwidth in indent/dedent</vh></v>
<v t="EKR.20040628095213.264"><vh>Import now creates absolute path</vh></v>
<v t="EKR.20040628095213.269"><vh>Created @killcolor directive</vh></v>
<v t="EKR.20040628095213.282"><vh>Added Paste Retaining Clones command</vh></v>
<v t="EKR.20040628095213.314"><vh>Added readLineGenerator &amp; readLineClass to leoGlobals</vh></v>
<v t="EKR.20040628095213.334"><vh>Much better error handling in executeScript</vh></v>
<v t="EKR.20040628095213.377"><vh>Recovered nodes when reading .leo files containing topology errors</vh></v>
<v t="EKR.20040628095213.391"><vh>Generalized write-to-string logic</vh></v>
<v t="EKR.20040628095213.408"><vh>Added case_sensitiveLanguage to colorizer</vh></v>
<v t="EKR.20040628095213.425"><vh>Write entire @thin tree on write errors</vh></v>
<v t="EKR.20040628095213.485"><vh>Handled inner @language and @comment properly</vh></v>
<v t="EKR.20040628095213.490"><vh>Better reporting of body text conflicts</vh></v>
<v t="EKR.20040628095213.493"><vh>Improved error handling for unknownAttributes</vh></v>
<v t="EKR.20040628095213.501"><vh>Read and write all t.unknownAttributes in top vnode of an @thin tree</vh></v>
</v>
</v>
</v>
<v t="EKR.20040601084317"><vh>4.2 a3</vh>
<v t="EKR.20040601084317.2"><vh>Bug fixes</vh>
<v t="EKR.20040601101118"><vh>Fixed copy/paste operations involving @thin trees</vh></v>
<v t="EKR.20040601101430"><vh>Fixed Change Headline command</vh></v>
<v t="EKR.20040601084317.99"><vh>Eliminated spurious "Not written x.tmp" message after write errors</vh></v>
<v t="EKR.20040601084317.142"><vh>Fixed problems saving unknownAttribute field</vh></v>
<v t="EKR.20040601102115"><vh>Fixed unicode problem in the Dump Outline command</vh></v>
</v>
<v t="EKR.20040601101227"><vh>New Features</vh>
<v t="EKR.20040601101227.1"><vh>Leo ignores all directives in @all trees</vh></v>
<v t="EKR.20040601101430.1"><vh>@+-middle sentinels allow sections to be defined in grandchildren</vh></v>
<v t="EKR.20040601101510"><vh>@clone sentinel allows siblings to be cloned</vh></v>
<v t="EKR.20040601101547"><vh>Created @thin, @nosent, @noref and @asis abbreviations</vh></v>
<v t="EKR.20040601084317.102"><vh>Made undo extensible</vh></v>
<v t="EKR.20040601102703"><vh>Started work on simple new undo scheme</vh></v>
<v t="EKR.20040601084317.161"><vh>Created new c, p, v iterators</vh></v>
</v>
<v t="EKR.20040601102808"><vh>Known bugs</vh></v>
</v>
<v t="EKR.20040518070558"><vh>4.2 a2</vh>
<v t="EKR.20040518070940.5"><vh>Implemented @file-thin</vh></v>
<v t="EKR.20040518070824"><vh>Fixed bugs</vh>
<v t="EKR.20040518071415"><vh>Fixed clone bug that caused parts of outlines to disappear</vh></v>
<v t="EKR.20040518070940.156"><vh>Fixed long-standing problem with the outline-only command</vh></v>
<v t="EKR.20040518070824.1"><vh>Made sure file indices are always assigned when writing files.</vh></v>
<v t="EKR.20040518070940"><vh>Fixed problems with missing tnodeList with @file-noref</vh></v>
<v t="EKR.20040518070940.164"><vh>Added t.writeBit</vh></v>
</v>
<v t="EKR.20040518075457"><vh>Dangers of @file-thin</vh></v>
</v>
</v>
<v t="ekr.20060206111600"><vh>4.3...@settings</vh>
<v t="ekr.20050917092557"><vh>4.3.3 final</vh>
<v t="ekr.20050917105646"><vh>Fixes made in 4.3.3</vh></v>
<v t="ekr.20050917092557.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050917092557.2"><vh>Bug fixes...</vh>
<v t="ekr.20050917092557.3"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050917092557.4"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050917092557.5"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050917092557.6"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050917092557.7"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050917092557.8"><vh>New and improved  plugins</vh>
<v t="ekr.20050917092557.9"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050917092557.11"><vh>Improved vim plugin</vh></v>
</v>
<v t="ekr.20050917092557.12"><vh>New &amp; improved features...</vh>
<v t="ekr.20050917092557.13"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050917092557.14"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050913131848"><vh>4.3.2 final</vh>
<v t="ekr.20050906104918.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050906104931.1"><vh>Bug fixes...</vh>
<v t="ekr.20050909082711"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050906104931.15"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050906104931.38"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050906104931.42"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050906104931.43"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050908164150"><vh>New and improved  plugins</vh>
<v t="ekr.20050908164150.1"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050910143326"><vh>Improved vim plugin</vh></v>
</v>
<v t="ekr.20050906104931.48"><vh>New &amp; improved features...</vh>
<v t="ekr.20050906104931.49"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050906104931.56"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050906104918"><vh>4.3.2 beta 1</vh></v>
<v t="ekr.20050620144052"><vh>4.3.1</vh>
<v t="ekr.20050620144052.2"><vh>Bug fixes...</vh>
<v t="ekr.20050620144052.3"><vh>Fixed bug in @ratio setting</vh></v>
<v t="ekr.20050620144052.6"><vh>Fixed crasher footprint plugin</vh></v>
<v t="ekr.20050620144052.8"><vh>Fixed invalid position bug)</vh></v>
<v t="ekr.20050620144052.48"><vh>Fixed undo problems in unit tests</vh></v>
<v t="ekr.20050620144052.112"><vh>Made sure same case is used in all recent files entries</vh></v>
<v t="ekr.20050620144052.114"><vh>Made sure all dialogs gets focus when they are run</vh></v>
<v t="ekr.20050620144052.116"><vh>Improved Resize To Screen command</vh></v>
<v t="ekr.20050620144052.119"><vh>Made sure comments are always visible in setting dialog even for non-@ nodes</vh></v>
<v t="ekr.20050620144052.154"><vh>Fixed problem with leading @ in body text</vh></v>
<v t="ekr.20050620144052.166"><vh>Fixed several  crashers while undoing a move involving clones</vh></v>
<v t="ekr.20050620144052.182"><vh>Fixed Unicode encoding problem</vh></v>
<v t="ekr.20050620144052.185"><vh>Fixed problem with coloring @language plain</vh></v>
<v t="ekr.20050620144602"><vh>Fixed bug: Mark Clones command did not work</vh></v>
</v>
<v t="ekr.20050620144052.207"><vh>New features...</vh>
<v t="ekr.20050620144052.208"><vh>Created separate helpers for idle_body_key</vh></v>
<v t="ekr.20050620144052.210"><vh>Made all Mark commands undoable</vh></v>
<v t="ekr.20050620144052.222"><vh>Removed dependence on profile and pstats modules from leoTest.py</vh></v>
<v t="ekr.20050620144052.231"><vh>Added support for tk resource files</vh></v>
<v t="ekr.20050620144425"><vh>Added support for coloring the PL/SQL language</vh></v>
</v>
</v>
<v t="ekr.20050523092026"><vh>4.3-final</vh>
<v t="ekr.20050523092056.1"><vh>Fixed crasher when pie-menu plugin enabled</vh></v>
<v t="ekr.20050523092056.4"><vh>Fixed crasher in Extract Section Command</vh></v>
</v>
<v t="ekr.20050513141852"><vh>4.3-beta 2</vh>
<v t="ekr.20050513141913.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050513141913.16"><vh>Fixed nodenavagator bug</vh></v>
<v t="ekr.20050513141913.17"><vh>Fixed LaTex Coloring bug</vh></v>
<v t="ekr.20050513141913.22"><vh>Error messages in scripts are now redirected properly.</vh></v>
<v t="ekr.20050513141913.30"><vh>Fixed 2 crashers in nav_buttons plugin</vh></v>
<v t="ekr.20050513141913.57"><vh>Fixed crasher in yoffsetTree</vh></v>
<v t="ekr.20050513141913.60"><vh>Fixed crasher in undo</vh></v>
<v t="ekr.20050513141913.82"><vh>Fixed  several problems with Extract and Extract Section</vh></v>
<v t="ekr.20050513141913.91"><vh>Fixed bug with Delete in headlines</vh></v>
<v t="ekr.20050513141913.127"><vh>Fixed bugs re initial_splitter_orientation &amp; @strings &amp; @ints generally</vh></v>
<v t="ekr.20050513141913.140"><vh>Fixed bug with hoist + insert</vh></v>
<v t="ekr.20050513141913.145"><vh>Fixed problem with settings dialog position when panes split horizontally</vh></v>
<v t="ekr.20050513141913.149"><vh>Fixed problem changing shortcut &amp; redid shortcuts widget</vh></v>
</v>
<v t="ekr.20050513141913.187"><vh>New Features...</vh>
<v t="ekr.20050513141913.97"><vh>Marking any node sets the outline changed</vh></v>
<v t="ekr.20050513141913.188"><vh>Allow quoted urls in  @urls nodes</vh></v>
<v t="ekr.20050513141913.194"><vh>Moved executeFile into core</vh></v>
<v t="ekr.20050513141913.197"><vh>Rewrote g.getScript using at.writeFromString</vh></v>
<v t="ekr.20050513141913.233"><vh>Added define_name arg to c.executeScript</vh></v>
</v>
</v>
<v t="ekr.20050429094215"><vh>4.3-beta 1</vh>
<v t="ekr.20050429094215.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050429094215.3"><vh>Made sure NameErrors are reported with tracebacks in scripts</vh></v>
<v t="ekr.20050429094215.22"><vh>Finally! fixed .leoID problem!</vh></v>
<v t="ekr.20050429094215.31"><vh>Investigated problem with LeoPluginsRef.leo</vh></v>
<v t="ekr.20050429094215.41"><vh>Fixed conflicts in menu shortcuts</vh></v>
<v t="ekr.20050429094215.113"><vh>Fixed bug in p.initStatus caught by pychecker</vh></v>
<v t="ekr.20050429094215.116"><vh>Fixed crasher in import logic (leoAtFile)</vh></v>
<v t="ekr.20050429094215.120"><vh>Put in protections against unbounded recursion in idle_scrollTo</vh></v>
</v>
<v t="ekr.20050429094215.130"><vh>New features...</vh>
<v t="ekr.20050429094215.131"><vh>Created stand-alone leoGlobals.py module</vh></v>
<v t="ekr.20050429094215.139"><vh>Leo now ignores problems opening settings file for chapters plugin</vh></v>
<v t="ekr.20050429094215.145"><vh>Improved write logic</vh></v>
<v t="ekr.20050429094215.173"><vh>Rewrote the undo code</vh></v>
<v t="ekr.20050429094215.286"><vh>Implemented undo/redo for Paste Retaining clones</vh></v>
<v t="ekr.20050429094215.316"><vh>Added support for 'str_' uA's</vh></v>
<v t="ekr.20050429094215.347"><vh>Removed unused params from leoAtFile.py</vh></v>
<v t="ekr.20050429094215.353"><vh>Leo  saves recent files info in .leoRecentFiles.txt files</vh>
<v t="ekr.20050429094215.354"><vh>What I did</vh></v>
<v t="ekr.20050429094215.355"><vh>New plan</vh></v>
</v>
<v t="ekr.20050429095849"><vh>Finished all @settings coding</vh></v>
</v>
</v>
<v t="ekr.20050313101229"><vh>4.3-a4</vh>
<v t="ekr.20050313101229.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050313101229.74"><vh>Fixed @wrap bug</vh></v>
<v t="ekr.20050313101229.77"><vh>Fixed change-all bug</vh></v>
</v>
<v t="ekr.20050313103448"><vh>New features...</vh>
<v t="ekr.20050313101229.95"><vh>Created Add Comments and Delete Comments commands</vh></v>
<v t="ekr.20050313101229.94"><vh>Deprecated new_c key in hooks, added c key</vh></v>
<v t="ekr.20050313103448.1"><vh>Added the 'before-create-leo-frame' hook</vh></v>
<v t="ekr.20050313101229.101"><vh>Added support for mod_labels plugin</vh></v>
</v>
<v t="ekr.20050313101229.100"><vh>Revised plugins for the 4.3 code base</vh></v>
</v>
<v t="ekr.20050221104844"><vh>4.3-a3</vh>
<v t="ekr.20050221104844.2"><vh>Bugs</vh>
<v t="ekr.20050221104844.12"><vh>Applied patch to rst2 plugin</vh></v>
<v t="ekr.20050221104844.14"><vh>Revised searchbox plugin so it works with Leo 4.3</vh></v>
<v t="ekr.20050221104844.27"><vh>Fixed bugs in nav_buttons and nodenavigator plugins</vh></v>
<v t="ekr.20050221104844.45"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050221104844.54"><vh>Fixed botch in g.pdb</vh></v>
<v t="ekr.20050222100936"><vh>Fixed crasher when executing a script if the script was selected text in a new window</vh></v>
</v>
<v t="ekr.20050221104844.57"><vh>New features</vh>
<v t="ekr.20050221104844.58"><vh>Added sets.py to distribution</vh></v>
<v t="ekr.20050221104844.59"><vh>Added color='suppress' hack to g.es</vh></v>
</v>
</v>
<v t="ekr.20050126100405"><vh>4.3-a2</vh>
<v t="ekr.20050130112336.1"><vh>To do: Improve how Leo handles recent files</vh></v>
<v t="ekr.20050209141626.3"><vh>Bugs fixed...</vh>
<v t="ekr.20050209141626.4"><vh>Fixed very old bug in Undo Insert Node</vh></v>
<v t="ekr.20050209141626.8"><vh>Made sure to remove duplicates from recent files</vh></v>
<v t="ekr.20050209141626.12"><vh>Fixed indentation problems in leoTkinterFind.py</vh></v>
<v t="ekr.20050209141626.13"><vh>Changed leoConfig.txt to leoSettings.leo in Help menu, etc.</vh></v>
<v t="ekr.20050209141626.16"><vh>Investigated recent files problems</vh></v>
<v t="ekr.20050209141626.23"><vh>Improved queuing of log messages</vh></v>
<v t="ekr.20050209141626.42"><vh>Fixed crasher in Change All command</vh></v>
<v t="ekr.20050209141626.43"><vh>Fixed crasher in script button</vh></v>
<v t="ekr.20050209141626.46"><vh>Fixed print problems on the Mac</vh></v>
<v t="ekr.20050209141626.53"><vh>leoTest.runTests now makes copies of all positions</vh></v>
<v t="ekr.20050209141626.54"><vh>Fixed problems with unit test file paths</vh></v>
<v t="ekr.20050209141626.55"><vh>Made local config settings work again</vh></v>
<v t="ekr.20050209141626.91"><vh>Fix problems searching for nothing but whitespace</vh></v>
<v t="ekr.20050210101318"><vh>Fixed problems with typing return in the Find panel</vh></v>
<v t="ekr.20050209141626.101"><vh>Buttons no longer work in toolbars when settings dialog is open</vh></v>
<v t="ekr.20050209141626.102"><vh>Fixed bug in delayed focus logic</vh></v>
<v t="ekr.20050209141626.105"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050209141626.113"><vh>Leo now prints unicode characters properly in the log pane</vh></v>
<v t="ekr.20050209141626.114"><vh>Fixed various problems with opening files with Unicode filenames</vh></v>
<v t="ekr.20050211095754"><vh>Fixed bug reading encoding field in external files</vh></v>
<v t="ekr.20050212054743"><vh>Allow indented code blocks to be run using Execute Script command</vh></v>
<v t="ekr.20050212144116"><vh>Fixed problems found by pychecker</vh></v>
</v>
<v t="ekr.20050209141626.150"><vh>New features...</vh>
<v t="ekr.20050126100405.1"><vh>Added undo granularity</vh>
<v t="EKR.20040524104904.48"><vh>Undoing operations</vh></v>
</v>
<v t="ekr.20050209141626.185"><vh>Added support for top-level init function in plugins</vh></v>
<v t="ekr.20050209141626.190"><vh>Changed name of Paste Retaining Clones to Paste Node As Clone</vh></v>
<v t="ekr.20050209141626.193"><vh>Added leoPlugins.leo to Help menu</vh></v>
<v t="ekr.20050209141626.194"><vh>Script buttons can request to be removed</vh></v>
<v t="ekr.20050209141626.195"><vh>Improved documentation in several nodes in leoSettings.leo</vh></v>
<v t="ekr.20050209141626.196"><vh>Predefined c,g &amp; p in scripts, unit tests &amp; test routines</vh></v>
<v t="ekr.20050209141626.198"><vh>Changed name of Preferences command to Settings</vh></v>
</v>
</v>
<v t="ekr.20050122090311"><vh>4.3-a1</vh>
<v t="ekr.20050123112834"><vh>Defining features of 4.3</vh>
<v t="ekr.20050123110009"><vh>Using @settings trees and leoSettings.leo</vh>
<v t="ekr.20050122084954"><vh>Using leoSettings.leo and @settings trees</vh></v>
<v t="ekr.20050122091036"><vh>Unfinished configuration features</vh></v>
</v>
<v t="ekr.20050123092834.520"><vh>Rewrote Leo's read/write logic</vh></v>
<v t="ekr.20050123115804"><vh>Added Plugins Manager plugin</vh></v>
<v t="ekr.20050123115804.1"><vh>You can install third-party extensions in Leo's extensions directory</vh></v>
</v>
<v t="ekr.20050123092834.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050123101208"><vh> Major bugs: these bugs corrupted external files!</vh>
<v t="ekr.20050123092834.432"><vh>Fixed double doc part bug</vh></v>
<v t="ekr.20050123092834.497"><vh>Fixed bug in how Leo writes thin external files</vh></v>
</v>
<v t="ekr.20050123092834.2"><vh>Commands</vh>
<v t="ekr.20050123092834.6"><vh>Fixed problems with spawnv option of openWith</vh></v>
<v t="ekr.20050123092834.19"><vh>Fixed bug in  Remove Sentinels command</vh></v>
<v t="ekr.20050123092834.27"><vh>Fixed bug re Paste Node As Clone</vh></v>
<v t="ekr.20050123092834.42"><vh>Fixed Pretty Print commands for Python 2.4</vh></v>
<v t="ekr.20050123092834.71"><vh>Fixed crasher in Import external files command</vh></v>
<v t="ekr.20050123092834.510"><vh>Search commands are now restricted to hoisted area</vh></v>
</v>
<v t="ekr.20050123100706.1"><vh>Distribution</vh>
<v t="ekr.20050123092834.491"><vh>Fixed file association in leoDist.leo</vh></v>
</v>
<v t="ekr.20050123092834.165"><vh>Files</vh>
<v t="ekr.20050123092834.492"><vh>g.import wrappers return module if it is in sys.modules</vh></v>
<v t="ekr.20050123092834.166"><vh>Disabled changes to comment delims in @@language and @@comment sentinels</vh></v>
<v t="ekr.20050123092834.176"><vh>Made sure files that differ only in line ending get written if @lineending is in effect</vh></v>
<v t="ekr.20050123092834.196"><vh>Fixed bug:  @nosent wrote sentinels!</vh></v>
<v t="ekr.20050123092834.422"><vh>Fixed bug in replaceTargetFileIfDifferent</vh></v>
<v t="ekr.20050123092834.424"><vh>Made sure that @ignore forces writing of inner @thin trees</vh></v>
<v t="ekr.20050123092834.431"><vh>Fixed crasher when attempting to write a external file to an invalid path</vh></v>
<v t="ekr.20050123092834.434"><vh>Fixed Python 2.4 deprecation warning when saving .leo files</vh></v>
<v t="ekr.20050123092834.499"><vh>Fixed crasher in getOutputNewline</vh></v>
<v t="ekr.20050123092834.544"><vh>Always use os.rename in utils_rename</vh></v>
<v t="ekr.20050123151338"><vh>Fixed bugs handling @language &amp; @comment in atFile.scanAllDirectives &amp; g.scanDirectives)</vh></v>
</v>
<v t="ekr.20050123103303"><vh>Gui</vh>
<v t="ekr.20050123092834.502"><vh>Put the scrollWheel workaround in createTkTreeCanvas</vh></v>
</v>
<v t="ekr.20050123100706.2"><vh>Menus</vh>
<v t="ekr.20050123092834.81"><vh>Fixed problems with Control-E</vh></v>
<v t="ekr.20050123092834.490"><vh>Better handling of duplicate menu shortcuts</vh></v>
</v>
<v t="ekr.20050123092834.159"><vh>Nodes</vh>
<v t="ekr.20050123092834.160"><vh>Fixed crash after cutting an imported node</vh></v>
<v t="ekr.20050123092834.163"><vh>Removed invalid assert in lastVisible</vh></v>
<v t="ekr.20050123093854.1"><vh>Fixed bugs in tnodes_iter and unique_tnodes_iter</vh></v>
</v>
<v t="ekr.20050123111723"><vh>Plugins</vh>
<v t="ekr.20050123092834.1047"><vh>Fixed two bugs in Plugins Manager plugin</vh></v>
<v t="ekr.20050123092834.1052"><vh>Fixed bug re referencing destroyed ivars</vh></v>
<v t="ekr.20050123092834.1057"><vh>Fixed bug in registerOneHandler</vh></v>
<v t="ekr.20050123092834.506"><vh>Fixed conflict between settings panel and chapters plugin</vh></v>
</v>
<v t="ekr.20050123092834.526"><vh>Pychecker</vh></v>
<v t="ekr.20050123092834.438"><vh>Scripting</vh>
<v t="ekr.20050123092834.439"><vh>Fixed unbounded recursion with --script and redirected output</vh></v>
<v t="ekr.20050123092834.474"><vh>Script buttons now execute the entire script</vh></v>
<v t="ekr.20050123092834.480"><vh>Fixed error reporting in executeScript when the error happens outside the script</vh></v>
</v>
<v t="ekr.20050123092834.486"><vh>Startup</vh>
<v t="ekr.20050123092834.487"><vh>Non-existent command-line file becomes name of new Leo wiindow</vh></v>
<v t="ekr.20050123092834.1011"><vh>computeHomeDir now handles references to other vars</vh></v>
</v>
</v>
<v t="ekr.20050123092834.896"><vh>New or improved features...</vh>
<v t="ekr.20050123110009"></v>
<v t="ekr.20050123103303.1"><vh>Code</vh>
<v t="ekr.20050123092834.520"></v>
<v t="ekr.20050123092834.173"><vh>Added g.cantImport</vh></v>
<v t="ekr.20050123092834.901"><vh>Added g.fileLikeObject.readline</vh></v>
<v t="ekr.20050123092834.928"><vh>Added support for g.app.debugSwitch in es_exception</vh></v>
<v t="ekr.20050123092834.984"><vh>Restored drawing/event hooks</vh></v>
<v t="ekr.20050123092834.1004"><vh>Added p=p param to all hooks containing v=v</vh></v>
<v t="ekr.20050123092834.565"><vh>Implemented delayed focus scheme</vh></v>
</v>
<v t="ekr.20050123103521"><vh>Commands</vh>
<v t="ekr.20050123092834.897"><vh>Added 'Expand Or Go Right' and 'Contract or Go Left' commands</vh></v>
<v t="ekr.20050123092834.908"><vh>Added keyboard shortcuts to find panel</vh></v>
<v t="ekr.20050123092834.1005"><vh>Find panels are now associated with individual Leo windows</vh></v>
<v t="ekr.20050123105026"><vh>Find panels are now inited from @settings nodes</vh></v>
<v t="ekr.20050123092834.961"><vh>Improved Go To Line Number and Execute Script commands</vh></v>
<v t="ekr.20050123092834.1018"><vh>Improved support for relative path names</vh></v>
<v t="ekr.20050123092834.1043"><vh>Implemented 'Undo Clear Recent Files'</vh></v>
<v t="ekr.20050123092834.517"><vh>Removed old-style write commands</vh></v>
</v>
<v t="ekr.20050123092834.1044"><vh>Plugins &amp; extensions</vh>
<v t="ekr.20050123115804"></v>
<v t="ekr.20050123115804.1"></v>
<v t="ekr.20050123112151"><vh>Improved doHandlersForTag</vh></v>
<v t="ekr.20050123092834.1013"><vh>Leo now associates modules with hook handlers</vh></v>
</v>
<v t="ekr.20050123103753"><vh>Syntax Coloring &amp; languages</vh>
<v t="ekr.20050123092834.903"><vh>Added support for Ada</vh></v>
<v t="ekr.20050123092834.929"><vh>Added support for Forth</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111717.1"><vh>4.4 minibuffer, keys, autocompletion, multiple log panes</vh>
<v t="ekr.20051219150602"><vh>4.4 alpha 5</vh>
<v t="ekr.20051219150602.2"><vh>Fixed bugs</vh>
<v t="ekr.20051219150602.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh></v>
<v t="ekr.20051219150602.7"><vh>Fixed problem with getScript in batch mode</vh></v>
<v t="ekr.20051219150602.10"><vh>Text box is now selected in goto-line-number command</vh></v>
<v t="ekr.20051219150602.13"><vh>Restored headkey  &amp; bodykey hooks</vh></v>
<v t="ekr.20051219150602.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh></v>
<v t="ekr.20051219150602.75"><vh>Fixed many headline problems</vh></v>
<v t="ekr.20051219150602.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20051219150602.85"><vh>Installed LeoUsers patch</vh></v>
<v t="ekr.20060105182648.376"><vh>Improved Import external files command.</vh></v>
<v t="ekr.20060105182648.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060105182648.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060105182648.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh></v>
<v t="ekr.20060105182648.382"><vh>Suppressed crash undoing a clone followed by a drag</vh></v>
</v>
<v t="ekr.20051219150602.100"><vh>New features</vh>
<v t="ekr.20051219150602.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20051219150602.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20051219150602.105"><vh>Revised cursor movement commands and added selection-extension commands</vh></v>
<v t="ekr.20051219151926"><vh>Added classic key bindings in leoSettings.leo</vh></v>
<v t="ekr.20060105182648.432"><vh>Allow multiple key bindings to the same command</vh></v>
<v t="ekr.20060105182648.469"><vh>Settings command now opens leoSettings.leo</vh></v>
</v>
</v>
<v t="ekr.20051028051444"><vh>4.4 alpha 4</vh>
<v t="ekr.20051028051444.1"><vh>Quick Start</vh></v>
<v t="ekr.20051028051444.2"><vh>The 'key' features of 4.4</vh>
<v t="ekr.20051101161405"><vh>Leo's minibuffer works like the Emacs mini-buffer</vh></v>
<v t="ekr.20051101161405.1"><vh>@shortcuts nodes in leoSettings.leo allow per-pane bindings</vh></v>
<v t="ekr.20051101161405.2"><vh>The scripting plugin allows key bindings</vh></v>
<v t="ekr.20051101161405.3"><vh>EKR shortcuts</vh></v>
<v t="ekr.20051101162123"><vh>Leo now ignores key bindings in menu tables</vh></v>
</v>
<v t="ekr.20051205091625"><vh>Status of minibuffer commands</vh></v>
<v t="ekr.20051028051616"><vh>New in alpha 1...</vh>
<v t="ekr.20051028051444.4"><vh>New options</vh>
<v t="ekr.20051028051444.5"><vh>The @bool useMinibuffer option</vh></v>
<v t="ekr.20051028051444.6"><vh>The @bool useCmdMenu option</vh></v>
<v t="ekr.20051028051444.7"><vh>Options for selected body text</vh></v>
</v>
<v t="ekr.20051028051444.8"><vh>New mini-buffer commands</vh></v>
<v t="ekr.20051028051444.9"><vh>New code-level features</vh>
<v t="ekr.20051028051444.10"><vh>Dictionaries of keys and commands</vh></v>
<v t="ekr.20051028051444.11"><vh>Functions that return the present key bindings</vh></v>
<v t="ekr.20051028051444.12"><vh>Added registerCommand helper</vh></v>
</v>
<v t="ekr.20051028051444.13"><vh>Bugs fixed (in 4.3 code base)</vh>
<v t="ekr.20051028051444.14"><vh>Leo protects c.endUpdate with a 'finally' clause</vh></v>
<v t="ekr.20051028051444.15"><vh>Added kludge to solve infamous control-v problems</vh></v>
<v t="ekr.20051028051444.16"><vh>Fixed bug in Leo's read logic</vh></v>
<v t="ekr.20051028051444.17"><vh>Fixed bug in goto-last-node.</vh></v>
<v t="ekr.20051028051444.18"><vh>Leo now reads @settings trees when opening a .leo file from another outline.</vh></v>
<v t="ekr.20051028051444.19"><vh>Improved g.removeExtraLws</vh></v>
</v>
</v>
<v t="ekr.20051028051616.1"><vh>New in alpha 2</vh>
<v t="ekr.20051101162123.1"><vh>The tabbed log</vh>
<v t="ekr.20051028051616.172"><vh>Programming the tabbed log</vh></v>
</v>
<v t="ekr.20051028061322"><vh>New minibuffer commands</vh></v>
<v t="ekr.20051028051616.299"><vh>Optional generation of closing brackets</vh></v>
<v t="ekr.20051101182739"><vh>New settings in leoSettings.leo</vh></v>
<v t="ekr.20051101161949"><vh>Improved and retired plugins</vh>
<v t="ekr.20051028051616.160"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20051101162947"><vh>Retired the TabbedLog plugin</vh></v>
</v>
<v t="ekr.20051101163145"><vh>Many code-level improvements</vh></v>
<v t="ekr.20051101163404"><vh>Fixed minor bugs</vh></v>
</v>
<v t="ekr.20051109112610"><vh>New in alpha 3</vh>
<v t="ekr.20051109112826"><vh>The New and Newer World Orders</vh></v>
<v t="ekr.20051109141223"><vh>Bugs fixed...</vh>
<v t="ekr.20051109112826.217"><vh>Fix crasher in Open logic</vh></v>
<v t="ekr.20051109112826.227"><vh>(Undo ends editing</vh></v>
<v t="ekr.20051109112826.257"><vh>Disabled minibuffer when not in use</vh></v>
<v t="ekr.20051109112826.315"><vh>Fixed bug in Find Backward</vh></v>
<v t="ekr.20051109112826.265"><vh>Improved Spell tab</vh></v>
</v>
<v t="ekr.20051109141524"><vh>New features</vh>
<v t="ekr.20051109112826.222"><vh>Created scripts.leo and unitTest.leo</vh></v>
<v t="ekr.20051109112826.254"><vh>c.executeMinibufferCommand executes a minibuffer command by name</vh></v>
<v t="ekr.20051109112826.310"><vh>Improved perl entries in language dicts</vh></v>
</v>
<v t="ekr.20051109141524.1"><vh>Code-level changes</vh>
<v t="ekr.20051109112826.223"><vh>Changed  edit_text to edit_widget everywhere</vh></v>
<v t="ekr.20051109112826.224"><vh>Removed tree ivars</vh></v>
<v t="ekr.20051109142920"><vh>Removed frame.begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20051128181229"><vh>New in alpha 4</vh>
<v t="ekr.20051128181351"><vh>Bugs fixed</vh>
<v t="ekr.20051128181302.148"><vh>Changed scripting plugin so files opened with buttons stay in front</vh></v>
<v t="ekr.20051128181302.183"><vh>Fixed undo/redo bugs</vh></v>
<v t="ekr.20051128181302.192"><vh>Fixed focus problem with tab completion</vh></v>
<v t="ekr.20051128181302.193"><vh>Fixed minor Save bug</vh></v>
<v t="ekr.20051128181302.231"><vh>Fixed long-standing problem with Plugins Manager plugin</vh></v>
<v t="ekr.20051128181302.244"><vh>Fixed 2 outline editing bugs</vh></v>
<v t="ekr.20051205090923.13"><vh>Fixed crasher in deleteNextChar</vh></v>
<v t="ekr.20051205090923.16"><vh>Fixed new headline bug</vh></v>
<v t="ekr.20051205090923.22"><vh>Fix problems applying settings</vh></v>
<v t="ekr.20051128181302.204"><vh>Fixed several bugs in rst3 plugin</vh></v>
</v>
<v t="ekr.20051128181651"><vh>Code changes</vh>
<v t="ekr.20051128181302.149"><vh>Removed later arg from c.frame.xWantsFocus</vh></v>
<v t="ekr.20051128181302.196"><vh>Created enableTclTraces</vh></v>
<v t="ekr.20051128181302.208"><vh>Eliminated w.update in g.app.gui.set_focus</vh></v>
</v>
<v t="ekr.20051128181651.1"><vh>New &amp; improved features and files</vh>
<v t="ekr.20051128181302.147"><vh>Moved all scripts into scripts.leo</vh></v>
<v t="ekr.20051128181302.150"><vh>Improved how the New Tab and Rename Tab commands work in the log pane</vh></v>
<v t="ekr.20051128181302.151"><vh>Improved the appearance of the Spell tab</vh></v>
<v t="ekr.20051128181302.156"><vh>Added Clone-find checkbox to the Find tab</vh></v>
<v t="ekr.20051128181302.171"><vh>Improved find tab</vh></v>
<v t="ekr.20051128181302.211"><vh>Improved formatting of shortcuts in print-commands and print-bindings</vh></v>
<v t="ekr.20051128181302.213"><vh>Added settings for vim plugin</vh></v>
<v t="ekr.20051128181302.214"><vh>Put up a dialog if can't import Pmw</vh></v>
<v t="ekr.20051128181302.229"><vh>Bound &lt;Return&gt; to end-edit-headline</vh></v>
</v>
</v>
</v>
<v t="ekr.20060116174906"><vh>4.4 beta 1</vh>
<v t="ekr.20060116174906.2"><vh>Bugs fixed</vh>
<v t="ekr.20060116174906.3"><vh>Fixed minor headline problems</vh></v>
<v t="ekr.20060116174906.63"><vh>Fixed undo problems</vh></v>
<v t="ekr.20060116174906.86"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060116174906.87"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060116174906.88"><vh>Fix crash: tab in minibuffer</vh></v>
<v t="ekr.20060116174906.90"><vh>Installed patch for headline width</vh></v>
<v t="ekr.20060116174906.97"><vh>Redraw screen properly after Move To Next Dirty</vh></v>
<v t="ekr.20060116174906.100"><vh>Fixed focus bug</vh></v>
<v t="ekr.20060116174906.103"><vh>Made sure to bring proper window on top in settings.leo button</vh></v>
<v t="ekr.20060116174906.104"><vh>Arrow keys now clear the text selection</vh></v>
<v t="ekr.20060116174906.113"><vh>Fixed several minor bugs</vh></v>
<v t="ekr.20060116174906.118"><vh>Fixed problems with plugins</vh></v>
<v t="ekr.20060116174906.122"><vh>Fixed old file handling bug</vh></v>
<v t="ekr.20060116174906.125"><vh>Use shutil.move in g.utils_rename</vh></v>
<v t="ekr.20060116174906.130"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh></v>
<v t="ekr.20060116174906.160"><vh>Made sure that focus stays in body during tab completion</vh></v>
<v t="ekr.20060116174906.163"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060116174906.164"><vh>Fixed many binding problems</vh></v>
<v t="ekr.20060116174906.185"><vh>Fixed extend-selection problems</vh></v>
<v t="ekr.20060116174906.187"><vh>Fixed per-pane bindings!</vh></v>
<v t="ekr.20060116174906.194"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060116174906.195"><vh>Code level changes</vh>
<v t="ekr.20060116174906.198"><vh>Removed g.top from Leo's core and all plugins</vh></v>
<v t="ekr.20060116174906.199"><vh>Created c.exists ivar and related logic</vh></v>
<v t="ekr.20060116174906.213"><vh>Call c.setLog in all entries into code</vh></v>
<v t="ekr.20060116174906.255"><vh>Generalized doCommand</vh></v>
</v>
<v t="ekr.20060116174906.258"><vh>New features</vh>
<v t="ekr.20060116174906.259"><vh>Installed many standard bindings to leoSettings.leo</vh></v>
<v t="ekr.20060116174906.262"><vh>Added Check Bindings script in leoSettings.leo</vh></v>
<v t="ekr.20060116174906.263"><vh>Scripts now maintain original focus</vh></v>
<v t="ekr.20060116174906.267"><vh>Added scroll-up/down-extend-selection commands</vh></v>
<v t="ekr.20060116174906.272"><vh>Improved cursor move/extend commands</vh></v>
<v t="ekr.20060116174906.296"><vh>Added support for @mode nodes</vh></v>
<v t="ekr.20060116174906.306"><vh>keyboard-quit restores default input mode</vh></v>
</v>
<v t="ekr.20060116174906.257"><vh>Added discusion to FAQ about when deleting a node is 'dangerous'</vh>
<v t="ekr.20060111192108"></v>
</v>
</v>
<v t="ekr.20060206111508"><vh>4.4 beta 2</vh>
<v t="ekr.20060206111508.2"><vh>Bugs fixed</vh>
<v t="ekr.20060206111508.3"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060206111508.4"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060206111508.5"><vh>Fixed two annoying headline glitches</vh></v>
<v t="ekr.20060206111508.14"><vh>Insert headline didn't redraw headline properly in vim mode</vh></v>
<v t="ekr.20060206111508.40"><vh>Improved printBindings, printCommands &amp; modeHelp</vh></v>
</v>
<v t="ekr.20060206111508.48"><vh>Fixed crasher re BackSpace in log window</vh></v>
<v t="ekr.20060206111508.49"><vh>Fixed crashers in cut/copy/paste commands</vh></v>
<v t="ekr.20060206111508.54"><vh>Fixed crasher when clicking the close box during a long command</vh></v>
<v t="ekr.20060206111508.58"><vh>cloneFindAll now honor present find settings</vh></v>
<v t="ekr.20060206111508.63"><vh>Double-click didn't work in the body pane.</vh></v>
<v t="ekr.20060206111508.74"><vh>Improved body.makeInsertPointVisible</vh></v>
<v t="ekr.20060206111508.75"><vh>Fixed cut/copy/paste from menu</vh></v>
<v t="ekr.20060206111508.553"><vh>Fixed major blunder: tree.onHeadChanged sets focus only if there was a real change</vh></v>
<v t="ekr.20060206111508.97"><vh>Disabled plain-key bindings in insert/overwrite modes</vh></v>
<v t="ekr.20060206111508.103"><vh>Disabled auto-scrolling in outline pane on clicks</vh></v>
<v t="ekr.20060206111508.136"><vh>move-outline and find commands force a screen scroll</vh></v>
<v t="ekr.20060211104746.2"><vh>Fixed undo problem in headlines</vh></v>
<v t="ekr.20060214085054"><vh>Found the cause of 'sticking focus' problem</vh></v>
<v t="ekr.20060211104746.162"><vh>Fixed tree icon bug</vh></v>
<v t="ekr.20060211104746.177"><vh>Set remembered column properly in prev-line and next-line</vh></v>
<v t="ekr.20060211104746.208"><vh>Fixed focus problems in spell tab</vh></v>
<v t="ekr.20060214074035.9"><vh>Fixed problem with body_gmt_time setting</vh></v>
<v t="ekr.20060214074035.20"><vh>Made sure save updates the open directory</vh></v>
<v t="ekr.20060214074035.41"><vh>Fixed sort-lines problems</vh></v>
<v t="ekr.20060214074035.101"><vh>Fixed bug: paste outline lost headline editing</vh></v>
</v>
<v t="ekr.20060206111508.547"><vh>Code improvements</vh>
<v t="ekr.20060206111508.550"><vh>Removed code in c.begin/EndUpdate and c.endEditLabel that tried to save/restore focus</vh></v>
<v t="ekr.20060206111508.596"><vh>Improved tree allocation</vh></v>
<v t="ekr.20060211104746.12"><vh>Created c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.168"><vh>Added unit tests for key dicts</vh></v>
<v t="ekr.20060211104746.346"><vh>Special-cased commands for minibuffer</vh></v>
<v t="ekr.20060214074035.6"><vh>Made sure yield works with Python 2.2</vh></v>
<v t="ekr.20060214074035.12"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh></v>
</v>
<v t="ekr.20060206112001"><vh>Improved commands</vh>
<v t="ekr.20060212102459.4"><vh>Minibuffer-oriented find commands</vh></v>
<v t="ekr.20060214074035.67"><vh>Leo remembers the previous open directory</vh></v>
</v>
<v t="ekr.20060214090742"><vh>Improved plugins</vh>
<v t="ekr.20060214074035.65"><vh>Fixed problem with view plugin</vh></v>
<v t="ekr.20060214074035.66"><vh>Installed cleo patch</vh></v>
</v>
<v t="ekr.20060214083808"><vh>New commands</vh>
<v t="ekr.20060212102459.4"></v>
</v>
<v t="ekr.20060214083647"><vh>New settings</vh></v>
<v t="ekr.20060214092741"><vh>User input modes</vh></v>
</v>
<v t="ekr.20060215112429"><vh>4.4 experimental 1</vh>
<v t="ekr.20060215112429.9"><vh>Fixed (maybe) problems with unicode characters &amp; caps lock</vh></v>
<v t="ekr.20060215112429.2"><vh>Restored some legacy bindings</vh></v>
<v t="ekr.20060215112429.3"><vh>Fixed crasher in Go To Line command</vh></v>
<v t="ekr.20060215112429.6"><vh>Fixed menu problem on Linux</vh></v>
</v>
<v t="ekr.20060217071505"><vh>4.4 a6</vh>
<v t="ekr.20060217071505.1"><vh>Fixed urgent compatibility problems</vh></v>
<v t="ekr.20060217072324"><vh>Minor bugs fixed</vh></v>
<v t="ekr.20060217072647"><vh>New debugging options in leoSettings.leo</vh></v>
</v>
<v t="ekr.20060227102028"><vh>4.4 a7</vh>
<v t="ekr.20060227102028.2"><vh>Bugs Fixed</vh>
<v t="ekr.20060227102028.3"><vh>Fixed binding bug</vh></v>
<v t="ekr.20060227102028.14"><vh>Fixed bug in open-find-dialog</vh></v>
<v t="ekr.20060227102028.15"><vh>Ensure dialogs properly get focus</vh></v>
<v t="ekr.20060227102028.16"><vh>Disabled autocompleter in headlines</vh></v>
<v t="ekr.20060227102028.17"><vh>Removed horrible g.app.dialogs hack</vh></v>
<v t="ekr.20060227102028.18"><vh>Fix crasher in plugin</vh></v>
</v>
</v>
<v t="ekr.20060328171518"><vh>4.4 b3</vh>
<v t="ekr.20060328171518.1"><vh>New features</vh>
<v t="ekr.20060328171518.10"><vh>Added scroll outline pane commands</vh></v>
<v t="ekr.20060328171518.11"><vh>Improved registerCommand</vh></v>
<v t="ekr.20060328171518.15"><vh>Suppressed autocompletion after numbers</vh></v>
<v t="ekr.20060328171518.16"><vh>Added colorizing support for Lua language</vh></v>
<v t="ekr.20060328171518.45"><vh>Added run-unit-test command</vh></v>
</v>
<v t="ekr.20060328171518.47"><vh>Bugs</vh>
<v t="ekr.20060328171518.48"><vh>Fixed problem with left &amp; right arrows in outline mode</vh></v>
<v t="ekr.20060328171518.57"><vh>Fixed undo problem with clones</vh></v>
<v t="ekr.20060328171518.83"><vh>Investigated setting descendant @file nodes dirty when changing body text</vh></v>
<v t="ekr.20060328171518.85"><vh>Work around newline problems on the Mac</vh></v>
<v t="ekr.20060328171518.101"><vh>Got rid of settings messages</vh></v>
<v t="ekr.20060328171518.108"><vh>Clicks outside minibuffer no longer rip focus</vh></v>
<v t="ekr.20060328171518.111"><vh>Handled missing leoSettings.leo files more gracefully</vh></v>
<v t="ekr.20060328171518.119"><vh>Converted all shortcuts to unicode</vh></v>
<v t="ekr.20060328171518.135"><vh>Made Open With shortcuts work again</vh></v>
<v t="ekr.20060328171518.151"><vh>Made sure autocompleter and calltip text stick</vh></v>
<v t="ekr.20060328171518.152"><vh>Fixed a bug in c.openWith</vh></v>
<v t="ekr.20060328171518.169"><vh>Import/export commands now set directory for next open</vh></v>
<v t="ekr.20060328171518.190"><vh>Investigated colorizer problems: can not reproduce</vh></v>
<v t="ekr.20060328171518.248"><vh>Removed support @ifgui: it doesn't and can't work</vh></v>
<v t="ekr.20060328171518.249"><vh>Removed autocompletion for self</vh></v>
<v t="ekr.20060414071350.1"><vh>Rewrote g.importExtension to simplify startup logic</vh></v>
<v t="ekr.20060414071350.8"><vh>Removed calls to lstrip and rstrip for compatibility with Python 2.2.1</vh></v>
<v t="ekr.20060414071350.47"><vh>Fixed Crash after undoing clearRecentFiles command</vh></v>
<v t="ekr.20060414071350.58"><vh>Fixed minor problems reported by Pychecker</vh></v>
</v>
<v t="ekr.20060328171518.191"><vh>Plugins</vh>
<v t="ekr.20060328171518.238"><vh>Changed path to stylesheet in the rst3 plugin</vh></v>
<v t="ekr.20060328171518.240"><vh>Fixed problems with chapters plugin</vh></v>
<v t="ekr.20060328171518.244"><vh>Improved groupoperations plugin</vh></v>
<v t="ekr.20060328171518.245"><vh>Fixed crasher in Word (and other) plugins</vh></v>
<v t="ekr.20060328171518.246"><vh>Fixed problem with labels plugin</vh></v>
</v>
</v>
<v t="ekr.20060417092536"><vh>4.4 b4</vh>
<v t="ekr.20060421070409.1"><vh>Bugs</vh>
<v t="ekr.20060421070602"><vh>Fixed rename-buffer command</vh></v>
<v t="ekr.20060421070409.2"><vh>Investigated problems with legacy bindings</vh></v>
<v t="ekr.20060421070409.3"><vh>Fixed bug when cutting text in headline</vh>
<v t="ekr.20060421070409.4"><vh>Report</vh></v>
</v>
<v t="ekr.20060421070409.9"><vh>Fixed crasher in open-find-dialog</vh>
<v t="ekr.20060421070409.10"><vh>Report</vh></v>
<v t="ekr.20060421070409.11"><vh>Traceback</vh></v>
</v>
<v t="ekr.20060421070409.33"><vh>Don't do typing completion for numbers</vh></v>
<v t="ekr.20060421070409.36"><vh>Fixed crash in undo</vh></v>
</v>
<v t="ekr.20060421070409.37"><vh>New features</vh>
<v t="ekr.20060417092825.1"><vh>Added script to update new copies of leoSettting.leo from previous copies</vh></v>
<v t="ekr.20060421070409.41"><vh>Added new commands</vh></v>
<v t="ekr.20060421070409.40"><vh>Made all edit command undoable</vh></v>
</v>
</v>
<v t="ekr.20060428084553"><vh>4.4 rc1</vh>
<v t="ekr.20060428084553.2"><vh>Bugs</vh>
<v t="ekr.20060428084957"><vh>Fixed rename-buffer command</vh></v>
<v t="ekr.20060428084553.4"><vh>Fixed bug when cutting text in headline</vh></v>
<v t="ekr.20060428084553.10"><vh>Fixed crasher in open-find-dialog</vh></v>
<v t="ekr.20060428084553.34"><vh>Suppressed typing completion for numbers</vh></v>
<v t="ekr.20060428084553.37"><vh>Fixed crash in undo</vh></v>
<v t="ekr.20060428084711"><vh>Fixed crash in datenodes plugin</vh></v>
</v>
<v t="ekr.20060428084553.38"><vh>New features</vh>
<v t="ekr.20060428084553.39"><vh>Added clear-selection command</vh></v>
<v t="ekr.20060428084553.41"><vh>Made all edit command undoable</vh></v>
<v t="ekr.20060428084553.42"><vh>Added new commands</vh></v>
<v t="ekr.20060428084553.273"><vh>Added filename completion</vh></v>
</v>
</v>
<v t="ekr.20060511074853"><vh>4.4 final</vh></v>
</v>
<v t="ekr.20080311060457.214"><vh>4.4.x</vh>
<v t="ekr.20060822140418"><vh>4.4.1...new colorizer, slideshow, multiple editors</vh>
<v t="ekr.20060830141224"><vh>4.4.1 final</vh>
<v t="ekr.20060830141224.2"><vh>Removed warning about changed nodes</vh></v>
<v t="ekr.20060830141224.13"><vh>Bugs fixed</vh>
<v t="ekr.20060830141224.14"><vh>Fixed serious bug in Paste Node as Clone</vh>
<v t="ekr.20060830141224.15"><vh>Report</vh></v>
<v t="ekr.20060830141224.16"><vh>What I did</vh></v>
</v>
<v t="ekr.20060830141224.37"><vh>Fixed minor .leoID.txt bug</vh>
<v t="ekr.20060830141224.38"><vh>Report</vh></v>
</v>
<v t="ekr.20060830141224.45"><vh>Improved speed of unmark-all and corresponding undo/redo</vh>
<v t="ekr.20060830141224.46"><vh>Report</vh></v>
</v>
</v>
</v>
<v t="ekr.20060822140418.1"><vh>4.4.1 b4</vh>
<v t="ekr.20060822140418.3"><vh>Bugs fixed</vh>
<v t="ekr.20060822140418.4"><vh>Added bindings to text panes for show-font command</vh></v>
<v t="ekr.20060822140418.26"><vh>Fixed kill-line, kill-word, kill-sentence, etc</vh></v>
<v t="ekr.20060822140418.29"><vh>Fixed minor scrolling problem</vh></v>
<v t="ekr.20060822140418.36"><vh>Fixed bug in backward-kill-word</vh></v>
<v t="ekr.20060822140418.39"><vh>Fixed unicode bug in forward-word and backward-word commands</vh></v>
<v t="ekr.20060822140418.41"><vh>Fixed problem setting body background color</vh></v>
<v t="ekr.20060822140418.49"><vh>Disabled incremental colorizing in new colorizer when there are multiple editors</vh></v>
<v t="ekr.20060822140418.97"><vh>Removed component classes</vh></v>
</v>
<v t="ekr.20060822140418.69"><vh>New features</vh>
<v t="ekr.20060822140418.76"><vh>Added scroll-outline-left/right commands</vh></v>
<v t="ekr.20060822140418.77"><vh>Generalized bracket flasher</vh></v>
<v t="ekr.20060822140418.88"><vh>Leo *already* supports Python decorators</vh></v>
<v t="ekr.20060822140418.92"><vh>Wrote script to convert g.es to g.et where appropriate</vh></v>
<v t="ekr.20060822140418.70"><vh>Created menu font settings</vh></v>
</v>
</v>
<v t="ekr.20060601101643"><vh>4.4.1 b1</vh>
<v t="ekr.20060601101958.1"><vh>Fixed bugs</vh>
<v t="ekr.20060601101958.56"><vh>The Open Python Window command runs Idle in a separate process</vh></v>
<v t="ekr.20060601101958.2"><vh>Fixed crasher in searchbox plugin</vh></v>
<v t="ekr.20060601101958.6"><vh>Fixed binding problems in leoSettings.leo reported by Check bindings script.</vh></v>
<v t="ekr.20060601101958.13"><vh>Fixed crasher in macros plugin</vh></v>
<v t="ekr.20060601101958.14"><vh>Fixed crasher in  UNL plugin</vh></v>
<v t="ekr.20060601101958.16"><vh>Suppressed traceback in g.callers when the call stack isn't deep enough</vh></v>
<v t="ekr.20060603082009"><vh>Fixed long-standing bug involving @comment and @language</vh></v>
</v>
<v t="ekr.20060601102802"><vh>New features, commands &amp; plugins</vh>
<v t="ekr.20060601101958.245"><vh>Support for multiple editors in the body pane</vh></v>
<v t="ekr.20060601101958.70"><vh>Improved searches</vh></v>
<v t="ekr.20060601101958.52"><vh>Added debug command</vh></v>
<v t="ekr.20060601101958.58"><vh>Added Debug button to scripting plugin</vh></v>
<v t="ekr.20060603072938"><vh>Added python-help command</vh></v>
<v t="ekr.20060601101958.277"><vh>Added toggle-invisibles and hide-invisibles commands</vh></v>
<v t="ekr.20060601101958.172"><vh>Added run-unit-test command</vh></v>
<v t="ekr.20060601101958.234"><vh>The help-for-command command now works for almost all commands</vh></v>
<v t="ekr.20060603081537"><vh>Added shortcut_button plugin</vh></v>
</v>
<v t="ekr.20060601102802.2"><vh>New and improved settings</vh>
<v t="ekr.20060601101958.174"><vh>Added @bool idle_redraw setting</vh></v>
<v t="ekr.20060601101958.264"><vh>Added autoindent_in_nocolor_mode setting</vh></v>
<v t="ekr.20060601101958.244"><vh>Added warnings about the expanded_click_area setting</vh></v>
<v t="ekr.20060601101958.276"><vh>Removed support for @shortcut (@shortcuts remains)</vh></v>
</v>
<v t="ekr.20060601101958.28"><vh>Minor improvements</vh>
<v t="ekr.20060601101958.218"><vh>Finished Cmds menu</vh></v>
<v t="ekr.20060601101958.235"><vh>Improved show-fonts command</vh></v>
<v t="ekr.20060601101958.238"><vh>Strip quotes from color, font settings.</vh></v>
<v t="ekr.20060601101958.239"><vh>Warn about invalid Enter and Leave key bindings</vh></v>
</v>
</v>
<v t="ekr.20060620094645"><vh>4.4.1 b2</vh>
<v t="ekr.20060620094645.34"><vh>Bugs fixed</vh>
<v t="ekr.20060620094645.35"><vh>Made sure calltip always adds '('</vh></v>
<v t="ekr.20060620094645.43"><vh>word matches now succeed if first character of the pattern is not in word-chars.</vh></v>
<v t="ekr.20060620094645.44"><vh>Dialogs now bring the Leo window back to the front</vh></v>
<v t="ekr.20060620094645.45"><vh>Fixed unit test: ensure that body gets focus after ending editing</vh></v>
<v t="ekr.20060620094645.46"><vh>Remember scrolling postion, insert point and selection range in multiple editors</vh></v>
<v t="ekr.20060620094645.50"><vh>Fix crasher in kill-region command</vh></v>
<v t="ekr.20060620094645.52"><vh>Fixed bug: cycle-editor hung Leo</vh></v>
<v t="ekr.20060620094645.64"><vh>Fixed crasher in init code</vh></v>
<v t="ekr.20060620094645.68"><vh>use g.stripBrackets instead of lstrip and rstrip</vh></v>
<v t="ekr.20060620094645.76"><vh>Restore cursor when changing focus in editors</vh></v>
<v t="ekr.20060620094645.77"><vh>Undo restores focus again</vh></v>
<v t="ekr.20060622130815"><vh>Updated row/col indicators when using arrow keys</vh></v>
<v t="ekr.20060622130815.3"><vh>Fixed show-invisibles crasher</vh></v>
</v>
<v t="ekr.20060620094645.78"><vh>Code level</vh>
<v t="ekr.20060620094645.79"><vh>Simplified gui bindings</vh></v>
<v t="ekr.20060622130815.9"><vh>Created g.app.gui.makeScriptButton</vh></v>
</v>
<v t="ekr.20060620094645.85"><vh>New &amp; improved features</vh>
<v t="ekr.20060620094645.86"><vh>Improved filename completion</vh></v>
<v t="ekr.20060620094645.96"><vh>Added support for --&gt; command-name in @mode nodes</vh></v>
<v t="ekr.20060620094645.97"><vh>Better listings for print-commands and print-bindings &amp; mode-help commands</vh></v>
<v t="ekr.20060620094645.103"><vh>Fixed find-character &amp; find-word commands</vh></v>
<v t="ekr.20060620094645.106"><vh>Better printing of bindings (period -&gt; .) etc</vh></v>
<v t="ekr.20060620094645.107"><vh>Added support for !command, !insert and !overwrite bindings</vh></v>
<v t="ekr.20060620094645.108"><vh>Improved check bindings script in leoSettings.leo</vh></v>
<v t="ekr.20060620094645.109"><vh>Improved isearch &amp; added isearch-with-present-options command</vh></v>
<v t="ekr.20060620094645.194"><vh>Use last shortcut defined</vh></v>
<v t="ekr.20060620094645.225"><vh>selfInsertCommand sets the column used by up/down arrows</vh></v>
<v t="ekr.20060620094645.231"><vh>Added toggle-autocompleter and toggle-calltips commands</vh></v>
<v t="ekr.20060620094645.232"><vh>Script buttons now create press-xxx-button commands</vh></v>
<v t="ekr.20060620094645.233"><vh>print-bindings command now properly sorts bindings</vh></v>
<v t="ekr.20060620094645.234"><vh>Allow @shortcuts bindings to apply to press-xxx-commands</vh></v>
<v t="ekr.20060620094645.242"><vh>Added support for @abbrev nodes in leoSettings.leo</vh></v>
<v t="ekr.20060620094645.243"><vh>Created open-users-guide command</vh></v>
<v t="ekr.20060620094645.252"><vh>scroll-up/down commands now scroll the outline if focus is in outline pane</vh></v>
<v t="ekr.20060620094645.258"><vh>Cycle-focus command cycles through tabs and editors</vh></v>
<v t="ekr.20060620094645.286"><vh>Allow @mode outside of leoSettings.leo</vh></v>
<v t="ekr.20060622130553"><vh>Added section about upgrading settings</vh></v>
<v t="ekr.20060622130553.2"><vh>Documented how to turn @buttons into plugins</vh></v>
</v>
<v t="ekr.20060620094645.302"><vh>Plugins</vh>
<v t="ekr.20060620094645.303"><vh>Added doc-only option to rst3</vh></v>
<v t="ekr.20060620094645.304"><vh>Fixed bug in rst doc_only_mode</vh></v>
<v t="ekr.20060620094645.305"><vh>Support show_headlines options in doc-only mode in rst3 plugin</vh></v>
<v t="ekr.20060620094645.306"><vh>Fixed bug in UNL plugin</vh></v>
<v t="ekr.20060620094645.307"><vh>Improved image plugin</vh></v>
<v t="ekr.20060620094645.308"><vh>Fixed path problem with rst3 plugin</vh></v>
<v t="ekr.20060620094645.309"><vh>Fixed crashers in scheduler plugin</vh></v>
</v>
<v t="ekr.20060622132524"><vh>Settings</vh>
<v t="ekr.20060620094645.299"><vh>Added editor_orientation setting</vh></v>
</v>
</v>
<v t="ekr.20060629083400.1"><vh>4.4.1 b3</vh>
<v t="ekr.20060629083935.2"><vh>Bugs fixed</vh>
<v t="ekr.20060629083935.3"><vh>Fixed recent bug: Ctrl-g does not work in @mode nodes</vh></v>
<v t="ekr.20060629083935.8"><vh>Update column display when typing</vh></v>
<v t="ekr.20060629083935.15"><vh>Fixed long-standing problem reporting indentation errors</vh></v>
<v t="ekr.20060629083935.25"><vh>Fixed long-standing bug in Remove Sentinels command</vh></v>
<v t="ekr.20060629083935.32"><vh>Fixed long-standing bugs in import code</vh></v>
<v t="ekr.20060629083935.61"><vh>Overwrite mode now works in headllines</vh></v>
<v t="ekr.20060629083935.70"><vh>Fixed crasher in masterCommand</vh></v>
<v t="ekr.20060629083935.71"><vh>Improved view-lossage command</vh></v>
</v>
<v t="ekr.20060629083935.74"><vh>New features</vh>
<v t="ekr.20060629083935.75"><vh>Finished repeat-complex-command</vh></v>
<v t="ekr.20060629083935.76"><vh>Read leoSettings.leo from the directory containing the .leo file</vh></v>
<v t="ekr.20060629083935.93"><vh>Flash matching parens &amp; corresponding settings</vh></v>
</v>
<v t="ekr.20060629083935.96"><vh>New settings</vh>
<v t="ekr.20060629083935.97"><vh>Added standard bindings for Ctrl-y (yank) and Ctrl-k (kill-line)</vh></v>
<v t="ekr.20060629083935.98"><vh>Added @bool warn_about_redefined_shortcuts setting</vh></v>
<v t="ekr.20060629083935.99"><vh>Added @bool trace_bind_key_exceptions setting</vh></v>
<v t="ekr.20060629083935.100"><vh>Added bracket flash settings</vh></v>
</v>
</v>
<v t="ekr.20060903102158"><vh>4.4.1.1 final</vh></v>
</v>
<v t="ekr.20061008190905"><vh>4.4.2... opml, zodb, sax, myLeoSettings, leoPymacs, autocontract, outline nav</vh>
<v t="ekr.20060928172040"><vh>4.4.2 beta 1</vh>
<v t="ekr.20060928172525.81"><vh>The 'big reorg':  vnode, tnode and position classes are independent of the rest of Leo</vh></v>
<v t="ekr.20060928195040"><vh>New features</vh>
<v t="ekr.20060928194633.1"><vh>myLeoSettings.leo</vh></v>
<v t="ekr.20060928172525.195"><vh>Created simple support for ZODB databases</vh>
<v t="ekr.20060928172525.197"><vh>Scripting using zodb</vh></v>
</v>
<v t="ekr.20060928172525.172"><vh>Improved help-for-command</vh></v>
<v t="ekr.20060928172525.180"><vh>Improved  quick-find commands</vh></v>
<v t="ekr.20060928172525.198"><vh>Improved how Leo works w/o the mousre</vh></v>
<v t="ekr.20060928172525.237"><vh>Increased speed of arrow keys</vh></v>
<v t="ekr.20060928172525.240"><vh>Find command now collapses nodes during searches</vh></v>
<v t="ekr.20060928172525.252"><vh>Added support  -- comments in @url nodes</vh></v>
<v t="ekr.20060928172525.167"><vh>Added many new commands to Cmds menu</vh></v>
</v>
<v t="ekr.20060928195040.1"><vh>New plugins</vh></v>
</v>
<v t="ekr.20061008190655"><vh>4.4.2 beta 2</vh>
<v t="ekr.20061008190633.248"><vh>Bugs</vh>
<v t="ekr.20061008190633.249"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20061008190633.250"><vh>Fixed apparent bug in pmw</vh></v>
<v t="ekr.20061008190633.257"><vh>Fixed various unicode word-select problems</vh></v>
<v t="ekr.20061008190633.261"><vh>Installed installer patch</vh></v>
<v t="ekr.20061008190633.262"><vh>Use letter accellerators for recent files after 9</vh></v>
<v t="ekr.20061008190633.264"><vh>Made yank work in minibuffer</vh></v>
<v t="ekr.20061008190633.265"><vh>Mass change to edit commands: made sure w is a text widget</vh></v>
<v t="ekr.20061008190633.283"><vh>Do full recolor after cut/paste/yank</vh></v>
<v t="ekr.20061008190633.294"><vh>Fixed crash when pasting a node</vh></v>
</v>
<v t="ekr.20061008192040"><vh>Settings</vh>
<v t="ekr.20061008190633.298"><vh>Completed support for myLeoSettings.leo</vh></v>
<v t="ekr.20061008190633.306"><vh>Added settings for all mod_scripting switches</vh></v>
<v t="ekr.20061008190633.307"><vh>Added @bool collapse_nodes_during_finds</vh></v>
<v t="ekr.20061008190633.325"><vh>Added @bool outline_pane_has_initial_focus</vh></v>
<v t="ekr.20061008190633.362"><vh>Added @bool sparse_move_outline_left</vh></v>
<v t="ekr.20061008190633.360"><vh>Added bindings for Alt-Shift-Arrow keys to force an outline move</vh></v>
<v t="ekr.20061009112808"><vh>Added @bool use_sax_based_read</vh></v>
</v>
<v t="ekr.20061008192040.1"><vh>New commands</vh>
<v t="ekr.20061008190633.354"><vh>Added extend-to-line command</vh></v>
<v t="ekr.20061008190633.356"><vh>Improved print-bindings command</vh></v>
<v t="ekr.20061008190633.364"><vh>Created extend-to-sentence and extend-to-paragraph commands</vh></v>
<v t="ekr.20061008190633.371"><vh>Created runEditCommandTest</vh></v>
</v>
<v t="ekr.20061008190633.295"><vh>Features</vh>
<v t="ekr.20070622180342"><vh>Added chapters</vh></v>
<v t="ekr.20061008190633.296"><vh>Improved the mod_scripting plugin</vh></v>
<v t="ekr.20061008190633.297"><vh>rst3 plugin now registers the rst3-process-tree command</vh></v>
<v t="ekr.20061008190633.311"><vh>Made writing .leo files faster</vh></v>
<v t="ekr.20061008190633.347"><vh>Generalized navigation in outline pane to ignore @file, @thin, etc prefixes</vh></v>
<v t="ekr.20061008190633.351"><vh>Made outline navigation cumulative</vh></v>
<v t="ekr.20061008190633.353"><vh>added p.archivedPosition</vh></v>
<v t="ekr.20061008190633.382"><vh>(Integrated sax with read logic)</vh></v>
</v>
<v t="ekr.20061009074305"><vh>Leap 204. "New" positions allow Leo outlines to represent arbitrary directed graphs</vh></v>
</v>
<v t="ekr.20061020155306"><vh>4.4.2 beta 3</vh>
<v t="ekr.20061020155235.1"><vh>Bugs</vh>
<v t="ekr.20061020155235.2"><vh>Fixed crash when searching for headllines containing unicode chars</vh></v>
<v t="ekr.20061020155235.27"><vh>Fixed bug with Alt-n keys</vh></v>
<v t="ekr.20061020155235.36"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20061020155235.37"><vh>The end-of-script message no longer yanks focus from tabs</vh></v>
<v t="ekr.20061020155235.41"><vh>Fixed  warning if minibuffer command does not exist when making menus</vh></v>
<v t="ekr.20061020155235.47"><vh>Fixed new unicode bug</vh></v>
<v t="ekr.20061020155235.123"><vh>Made 'About Plugin' dialog scrollable</vh></v>
<v t="ekr.20061020155235.124"><vh>Removed unwanted key-state message</vh></v>
<v t="ekr.20061020155235.126"><vh>Made sure all kill commands do a full recolor</vh></v>
<v t="ekr.20061020155235.149"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061020155235.180"><vh>Removed set-mark-command and all calls to removeRKeys</vh></v>
<v t="ekr.20061020155235.185"><vh>Fixed body editor problems</vh></v>
<v t="ekr.20061020155235.254"><vh>Moved @import to top of doc/default.css</vh></v>
<v t="ekr.20061020155235.255"><vh>Fixed focus problem when double-clicking @url nodes</vh></v>
</v>
<v t="ekr.20061020155235.263"><vh>Features</vh>
<v t="ekr.20061020155235.271"><vh>Added minibuffer and Settings menus</vh></v>
<v t="ekr.20061020155235.292"><vh>Toggling autocompleter and calltips now write to log (in red) instead of the statusLine</vh></v>
<v t="ekr.20061020155235.294"><vh>Finished collapse-on-move-left</vh></v>
<v t="ekr.20061020155235.304"><vh>Properly create Help menu on the Mac</vh></v>
<v t="ekr.20061020155235.307"><vh>'*command-name' in headline means convert '-' to blanks</vh></v>
<v t="ekr.20061020155235.308"><vh>Removed all references to commands from menu tables</vh></v>
<v t="ekr.20061020155235.335"><vh>Add Open scripts.leo to help menu</vh></v>
<v t="ekr.20061020155235.337"><vh>The spell tab now uses ctypes for Python 2.5</vh></v>
<v t="ekr.20061020155235.385"><vh>Simulated x-windows middle-button paste</vh></v>
</v>
<v t="ekr.20061020155235.393"><vh>Plugins</vh>
<v t="ekr.20061020155235.394"><vh>Fixed keyBindings plugin</vh></v>
<v t="ekr.20061020155235.395"><vh>The scripting plugin now creates a delete-x-script-button command for each script button</vh></v>
<v t="ekr.20061020155235.396"><vh>Fixed the nodenavigator plugin</vh></v>
<v t="ekr.20061020155235.397"><vh>Rewrote the multifile plugin for the 4.x code base.</vh></v>
<v t="ekr.20061020155235.398"><vh>Replaced __name__ with __plugin_name__ in four plugins</vh></v>
<v t="ekr.20061020155235.399"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20061020155235.400"><vh>Fixed bugs in multi-file plugin</vh></v>
<v t="ekr.20061020155235.402"><vh>Fix bug in shortcut_button plugin</vh></v>
<v t="ekr.20061020155235.125"><vh>Removed datenodes.ini from cvs</vh></v>
<v t="ekr.20061020155235.34"><vh>Fix bug in ops plugin</vh></v>
<v t="ekr.20061020155235.35"><vh>Fixed crasher on script button balloons</vh></v>
</v>
<v t="ekr.20061020155235.403"><vh>Settings</vh>
<v t="ekr.20061020155235.404"><vh>Made unlimited undo the default</vh></v>
<v t="ekr.20061020155235.405"><vh>Added @bool select_all_text_when_editing_headlines</vh></v>
<v t="ekr.20061020155235.410"><vh>Added bindings to toggle-autocompleter and toggle-calltips</vh></v>
<v t="ekr.20061020155235.411"><vh>Added 'Candidates for myLeoSettings.leo' to leoSettings.leo</vh></v>
<v t="ekr.20061020155235.412"><vh>Recent changes to settings</vh></v>
<v t="ekr.20061020155235.413"><vh>Added @bool insert_new_nodes_at_end</vh></v>
<v t="ekr.20061020155235.264"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh></v>
</v>
</v>
<v t="ekr.20061026095728"><vh>4.4.2 final and 4.4.2.1 final</vh>
<v t="ekr.20061026095922.1"><vh>Bugs</vh>
<v t="ekr.20061026095922.2"><vh>Changed leo_rst.css to pass the w3 validator</vh></v>
<v t="ekr.20061026095922.3"><vh>Fixed 'Run on string' message when typing</vh></v>
<v t="ekr.20061026095922.15"><vh>Fixed problem with c++ extensions</vh></v>
<v t="ekr.20061026095922.17"><vh>Move on if regexp matches an empty string</vh></v>
<v t="ekr.20061026095922.19"><vh>Fixed several bugs related to multiple body panes</vh></v>
<v t="ekr.20061026095922.25"><vh>Fixed multipath plugin so it works with new colorizier</vh></v>
<v t="ekr.20061026095922.32"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061026095922.33"><vh>Fixed config bug</vh></v>
</v>
<v t="ekr.20061026095922.35"><vh>New features</vh>
<v t="ekr.20061026095922.51"><vh>Added forward-end-word/-extend-selection commands</vh></v>
<v t="ekr.20061026095922.36"><vh>Created leoPymacs.py for interaction with pymacs</vh></v>
</v>
</v>
</v>
<v t="ekr.20070316182323"><vh>4.4.3... winpdb, leoBridge, gui reorg, chapters</vh>
<v t="ekr.20070122070619"><vh>4.4.3 alpha 1</vh>
<v t="ekr.20070122070634.1"><vh>Bugs</vh>
<v t="ekr.20070122070634.2"><vh>Fixed an escape bug in new colorizer</vh></v>
<v t="ekr.20070122070634.4"><vh>Treat escaped characters in find patterns as a single character</vh></v>
<v t="ekr.20070122070634.13"><vh>Fixed undo problems with yank/kill</vh></v>
<v t="ekr.20070122070634.40"><vh>Fixed clone-drag problem</vh></v>
<v t="ekr.20070122070634.51"><vh>Made sure all ancestors expanded when select a body editor with multiple body editors</vh></v>
<v t="ekr.20070122070634.54"><vh>Fixed bug in CheckVersion</vh></v>
</v>
<v t="ekr.20070122070634.305"><vh>Code reorg for wxGui plugin</vh></v>
<v t="ekr.20070122070634.58"><vh>Features</vh>
<v t="ekr.20070122070634.59"><vh>Added handleUrlInUrlNode helper for OnIconDoubleClick</vh></v>
<v t="ekr.20070122070634.66"><vh>Only do one message re writing recent files</vh></v>
<v t="ekr.20070122070634.69"><vh>Made escape in the minibuffer work like ctrl-g</vh></v>
<v t="ekr.20070122070634.81"><vh>Clear status line in repeat-complex-command</vh></v>
<v t="ekr.20070122070634.82"><vh>Added shortcuts for goto-first/last-sibling</vh></v>
<v t="ekr.20070122070634.83"><vh>Made copied nodes valid Leo files</vh></v>
<v t="ekr.20070122070634.89"><vh>Added support for chdir_to_relative_path setting</vh></v>
<v t="ekr.20070122070634.91"><vh>changeAll now works like findAll</vh></v>
<v t="ekr.20070122070634.209"><vh>Added Find &amp; Spell tabs to log pane on startup</vh></v>
<v t="ekr.20070122070634.220"><vh>Created standard pluginsManager.txt only if it does not exist</vh></v>
<v t="ekr.20070122070634.223"><vh>Improved support for the winpdb debugger</vh></v>
<v t="ekr.20070122104240"><vh>Added \runAskOkCancelStringDialog</vh></v>
</v>
<v t="ekr.20070122070634.298"><vh>Plugins</vh>
<v t="ekr.20070122072110"><vh>The wxGui plugin is now functional</vh></v>
<v t="ekr.20070122070634.299"><vh>Changed bindings in UniversalScrolling pluing</vh></v>
<v t="ekr.20070122070634.300"><vh>Registered write-restructured-text command in rst3 plugin</vh></v>
</v>
<v t="ekr.20070122070634.301"><vh>Settings</vh>
<v t="ekr.20070122070634.302"><vh>Added @bool center_selected_tree_node</vh></v>
<v t="ekr.20070122070634.303"><vh>Added @bool invisible_outline_navigation = False</vh></v>
<v t="ekr.20070122070634.304"><vh>Added @bool show_full_tracebacks_in_scripts</vh></v>
</v>
</v>
<v t="ekr.20070316182323.1"><vh>4.4.3 alpha 2</vh>
<v t="ekr.20070316182341.1"><vh>Fixed Bugs</vh>
<v t="ekr.20070316182341.2"><vh>Fixed bugs in undo/redoNodeContents</vh></v>
<v t="ekr.20070316182341.6"><vh>Fixed minor xml problem</vh></v>
<v t="ekr.20070316182341.10"><vh>Fixed C++ import bug</vh></v>
<v t="ekr.20070316182341.39"><vh>Fixed recent bug in next-line command</vh></v>
<v t="ekr.20070316182341.41"><vh>Made standalone plugins manager work again</vh></v>
<v t="ekr.20070316182341.42"><vh>Fixed wiki markup bug</vh></v>
<v t="ekr.20070316182341.43"><vh>Fixed bugs in regular expressions</vh></v>
<v t="ekr.20070316182341.54"><vh>Fixed memory error in leoBridge</vh></v>
<v t="ekr.20070316182341.56"><vh>Fixed backspace in headline bug</vh></v>
<v t="ekr.20070316182341.66"><vh>Made sure alt-arrow keys honor focus settings</vh></v>
<v t="ekr.20070316182341.112"><vh>Fixed bug in nav button plugin</vh></v>
<v t="ekr.20070316182341.113"><vh>Fixed yet another cursor down bug</vh></v>
<v t="ekr.20070316182341.137"><vh>Improved special case in moveOutlineUp</vh></v>
<v t="ekr.20070316182341.138"><vh>Fixed crasher in rclicker plugin</vh></v>
<v t="ekr.20070316182341.139"><vh>Fixed recent problem with settings report</vh></v>
</v>
<v t="ekr.20070316182341.437"><vh>New Features</vh>
<v t="ekr.20070316182341.440"><vh>Added leoBridge module</vh></v>
<v t="ekr.20070316182341.723"><vh>Added support for @enabled-plugins in settings files</vh></v>
<v t="ekr.20070316182341.718"><vh>Added new search path for pluginsManager.txt</vh></v>
<v t="ekr.20070316182341.155"><vh>Made Leo's core gui-indenpendent</vh></v>
<v t="ekr.20070316182341.438"><vh>Warn on dubious section brackets</vh></v>
</v>
<v t="ekr.20070317044545"><vh>Plugins</vh></v>
</v>
<v t="ekr.20070513111132"><vh>4.4.3 beta 1</vh>
<v t="ekr.20070513111526.1"><vh>New features</vh>
<v t="ekr.20070513112414"><vh>Added support for chapters to Leo's core</vh></v>
<v t="ekr.20070513111526.2"><vh>Added @bool force_newlines_in_at_nosent_bodies setting</vh></v>
<v t="ekr.20070513111526.7"><vh>Added apropos-debugging-commands command</vh></v>
<v t="ekr.20070513111526.8"><vh>Added print-plugins &amp; print-plugin-handlers commands</vh></v>
<v t="ekr.20070513111526.10"><vh>Added print-settings command</vh></v>
<v t="ekr.20070513111526.14"><vh>Added support for @openwith nodes in leoSettings.leo</vh></v>
<v t="ekr.20070513111526.39"><vh>Created clean-all-lines command</vh></v>
<v t="ekr.20070513111526.42"><vh>Support for compressed .leo files</vh></v>
</v>
<v t="ekr.20070513111526.77"><vh>Fixed bugs</vh>
<v t="ekr.20070513111526.78"><vh>Fixed bug: new-file doesn't allow edit of initial headline</vh></v>
<v t="ekr.20070513111526.80"><vh>Removed all returns from finally clauses</vh></v>
<v t="ekr.20070513111526.105"><vh>Fixed repeatComplexCommand weirdness</vh></v>
<v t="ekr.20070513111526.198"><vh>Fixed minor chapter hoist bug</vh></v>
<v t="ekr.20070513111526.200"><vh>Fixed crasher in plugins_menu.py</vh></v>
</v>
</v>
<v t="ekr.20070610063456"><vh>4.4.3 beta 2</vh>
<v t="ekr.20070610063538.1"><vh>Fixed bugs</vh>
<v t="ekr.20070610063538.2"><vh>Fixed noweb hangs</vh></v>
<v t="ekr.20070610063538.151"><vh>Alt-4 did not work in tree pane in unitTest.leo</vh></v>
<v t="ekr.20070610063538.163"><vh>Investigated problem with subprocess (works for me)</vh></v>
<v t="ekr.20070610063538.164"><vh>Fixed crashers in leoupate plugin</vh></v>
<v t="ekr.20070610063538.165"><vh>Fixed automatic directory creation</vh></v>
<v t="ekr.20070610063538.168"><vh>Fixed bug: shift-arrow keys not bound properly when node is clicked</vh></v>
<v t="ekr.20070610063538.171"><vh>Made sure the new outlines aren't marked dirty</vh></v>
<v t="ekr.20070610063538.175"><vh>Fix crasher in maximizeNewWindows</vh></v>
<v t="ekr.20070610063538.209"><vh>Don't change focus in the save command</vh></v>
<v t="ekr.20070610063538.212"><vh>downcase-region and upcase-region didn't color body text.</vh></v>
<v t="ekr.20070611161859"><vh>Fixed *major* demote bug</vh></v>
</v>
<v t="ekr.20070610063538.280"><vh>Features</vh>
<v t="ekr.20070610063538.281"><vh>Supported write_strips_blank_lines option</vh></v>
<v t="ekr.20070610063538.334"><vh>Completed chapters</vh></v>
<v t="ekr.20070610063538.366"><vh>Improved dynamic abbreviations</vh></v>
<v t="ekr.20070610063538.377"><vh>Created the hoist-changed hook</vh></v>
<v t="ekr.20070610173300"><vh>Enabled more plugins by default</vh></v>
</v>
</v>
<v t="ekr.20070622090350"><vh>4.4.3 beta 3</vh>
<v t="ekr.20070622090350.1"><vh>Fixed bugs</vh>
<v t="ekr.20070622090350.8"><vh>Fixed a bug that disabled icon button colors on Linux</vh></v>
<v t="ekr.20070622090350.22"><vh>Switch chapters if new position isn't in current chapter</vh></v>
<v t="ekr.20070622090350.42"><vh>Improved goto-next/prev-node commands</vh></v>
<v t="ekr.20070622090350.57"><vh>Fixed failing bridge unit test</vh></v>
</v>
<v t="ekr.20070622090350.59"><vh>New features &amp; settings</vh>
<v t="ekr.20070622090350.60"><vh>Added @bool contractVisitedNodes setting</vh></v>
<v t="ekr.20070622090350.61"><vh>Added goto-first-visible-node command</vh></v>
<v t="ekr.20070622090350.62"><vh>Changed binding of Alt-Home</vh></v>
<v t="ekr.20070622090350.65"><vh>Added @button dynamic-tests.</vh></v>
<v t="ekr.20070622090350.66"><vh>created g.unitTesting and g.getTestVars</vh></v>
<v t="ekr.20070622090350.9"><vh>Made alt menu keys work</vh></v>
</v>
</v>
<v t="ekr.20070626082732"><vh>4.4.3 final</vh></v>
<v t="ekr.20070702162421"><vh>4.4.3.1</vh>
<v t="ekr.20070703095207.1"><vh>Bugs</vh>
<v t="ekr.20070703095207.2"><vh>Fixed improper can not open myLeoSettings message</vh></v>
<v t="ekr.20070703095207.5"><vh>Fixed import problem in leoDynamicTest.py</vh></v>
<v t="ekr.20070703095207.34"><vh>Fixed cleo crasher</vh></v>
<v t="ekr.20070703095207.35"><vh>Fixed spell-check bug</vh></v>
<v t="ekr.20070703095207.40"><vh>Fixed several crashers in the group operations plugin</vh></v>
<v t="ekr.20070703095207.41"><vh>Fixed chapters bug</vh></v>
<v t="ekr.20070703095207.43"><vh>Fixed problems in groupOperations plugin</vh></v>
<v t="ekr.20070703095207.50"><vh>Fixed pychecker complaints</vh></v>
<v t="ekr.20070703095207.51"><vh>Fixed editor bug: deleting an editor did not always select the proper body pane</vh></v>
</v>
<v t="ekr.20070703095207.55"><vh>Features</vh>
<v t="ekr.20070703095207.56"><vh>g.es and g.es_print print only to console during unit tests</vh></v>
<v t="ekr.20070703095207.61"><vh>Run unit tests in a separate process</vh></v>
<v t="ekr.20070703095207.72"><vh>Move most unit tests into external files</vh></v>
</v>
</v>
</v>
<v t="ekr.20070806090235"><vh>4.4.4 @auto, @menus, threading syntax colorer, the Great Graph Aha</vh>
<v t="ekr.20070806090235.1"><vh>4.4.4 b1</vh>
<v t="ekr.20070806090226.1"><vh>Added support for @mark-for-unit-tests node</vh></v>
<v t="ekr.20070806090226.14"><vh>Created threading_colorizer</vh></v>
<v t="ekr.20070806090226.15"></v>
</v>
<v t="ekr.20070915101216"><vh>4.4.4 b2</vh>
<v t="ekr.20070915101157.1"><vh>Bug fixes</vh>
<v t="ekr.20070915101157.3"><vh>Fixed UNL bug1</vh></v>
<v t="ekr.20070915101157.5"><vh>Fixed how @auto handles paths</vh></v>
<v t="ekr.20070915101157.14"><vh>Fixed another path bug</vh></v>
<v t="ekr.20070915101157.16"><vh>fixed c parser so it handles non-ascii declaratsions</vh></v>
<v t="ekr.20070915101157.17"><vh>Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops</vh></v>
<v t="ekr.20070915101157.18"><vh>Fixed unicode bug in http plugin</vh></v>
<v t="ekr.20070915101157.19"><vh>Fixed new @path problem</vh></v>
<v t="ekr.20070915101157.40"><vh>Fixed @auto path bug</vh></v>
<v t="ekr.20070915101157.45"><vh>Improved messages on @import failure</vh></v>
<v t="ekr.20070915101157.48"><vh>Fixed problem with space in path names in runLeoDynamicTest</vh></v>
<v t="ekr.20070915101157.50"><vh>Fixed bad drag &amp; drop bug</vh></v>
<v t="ekr.20070915101157.70"><vh>Fixed bug 'node note selected' bug</vh></v>
<v t="ekr.20070915101157.81"><vh>Retain dirty bit after write @auto fails</vh></v>
</v>
<v t="ekr.20070915101157.82"><vh>Features</vh>
<v t="ekr.20070915101157.168"><vh>Read @auto nodes during saves if the node has not been read previously</vh></v>
<v t="ekr.20070920092716"></v>
</v>
</v>
<v t="ekr.20071004101349"><vh>4.4.4 b3</vh>
<v t="ekr.20071004101443.1"><vh>Bugs fixed</vh>
<v t="ekr.20071004101443.18"><vh>Greatly improved speed of unmark-all</vh></v>
<v t="ekr.20071004101443.26"><vh>Made sure dirty bits get updated in xemacs plugin</vh></v>
<v t="ekr.20071021111856.20"><vh>Fixed backward find bug</vh></v>
<v t="ekr.20071021111856.83"><vh>Fixed cursor up/down problem</vh></v>
<v t="ekr.20071021111856.124"><vh>Fixed unicode bug in trace</vh></v>
<v t="ekr.20071021111856.127"><vh>Fixed chapter crasher</vh></v>
<v t="ekr.20071021111856.252"><vh>Installed patch to fix Fedora Tk.Text bug</vh></v>
<v t="ekr.20071021111856.437"><vh>Fixed bug in rst3 plugin</vh></v>
<v t="ekr.20071021111856.461"><vh>Allow unicode characters in Leo file names</vh></v>
<v t="ekr.20071023080957"><vh>Fixed bugs when running unit tests externally</vh></v>
</v>
<v t="ekr.20071004101443.29"><vh>New Features</vh>
<v t="ekr.20071004103659"></v>
<v t="ekr.20071021111856.441"><vh>Rewrote threading colorizer</vh></v>
<v t="ekr.20070806090226.15"></v>
<v t="ekr.20071004101443.52"><vh>Added @buttons trees in @settings trees</vh></v>
<v t="ekr.20071004101443.105"><vh>Added @menus trees in @settings trees</vh></v>
<v t="ekr.20070920092716"></v>
<v t="ekr.20071004105000"><vh>Added the graphed plugin</vh></v>
<v t="ekr.20071004101443.178"><vh>New convenience methods</vh></v>
<v t="ekr.20071004101443.30"><vh>Added button font settings</vh></v>
<v t="ekr.20071005095907"><vh>Leo's core is now compatible with jython</vh></v>
<v t="ekr.20071006093614"><vh>Added the insert-child command</vh></v>
<v t="ekr.20071006155647"><vh>@bool add_ws_to_kill_ring setting</vh></v>
<v t="ekr.20071021111856.412"><vh>Improved yank and yank-pop commands</vh></v>
<v t="ekr.20071021111856.458"><vh>Improved debug command</vh></v>
<v t="ekr.20071021111856.459"><vh>Added the @bool rst3 strip_at_file_prefixes setting</vh></v>
<v t="ekr.20071021111856.476"><vh>Added g.app.inBridge ivar</vh></v>
<v t="ekr.20071021111856.477"><vh>Improved the scripting and plugins chapters of Leo's Users Guide</vh></v>
</v>
</v>
<v t="ekr.20071026053825"><vh>4.4.4 b4</vh>
<v t="ekr.20071026053931.1"><vh>Fixed bugs</vh>
<v t="ekr.20071026053931.13"><vh>Fixed bug: utf-8 files now get imported properly</vh></v>
<v t="ekr.20071026053931.156"><vh>Replaced c.frame.body with c.frame.body.bodyCtrl</vh></v>
<v t="ekr.20071026053931.157"><vh>Fixed (maybe) multi-editor bug</vh></v>
<v t="ekr.20071026053931.219"><vh>Made sure proper node is visible when deleting a body editor</vh></v>
<v t="ekr.20071026053931.220"><vh>Fixed colorizer end-of-text bug</vh></v>
<v t="ekr.20071026075016"><vh>Added support for fastGotoNode plugin to leoKeyEvent classes</vh></v>
<v t="ekr.20071026092552"><vh>Fixed bug that disabled multiple occurances of the same user icon</vh></v>
</v>
<v t="ekr.20071026182824"><vh>Added features</vh>
<v t="ekr.20071026053931.221"><vh>Added @bool big_outline_pane setting</vh></v>
<v t="ekr.20071026053931.234"><vh>Can print *can* handle unicode</vh></v>
<v t="ekr.20071026180804.1"><vh>Improved the prototype of icon handling</vh></v>
</v>
</v>
<v t="ekr.20071101162646"><vh>4.4.4 Final</vh>
<v t="ekr.20071101162751"><vh>Fixed bugs</vh>
<v t="ekr.20071101162751.2"><vh>Fixed bug that caused rClick plugin to crash</vh></v>
<v t="ekr.20071101162751.4"><vh>Fixed scrolling problem with chapters</vh></v>
<v t="ekr.20071101162751.19"><vh>Fixed bug: select a chapter containing the initially selected node</vh></v>
<v t="ekr.20071101162751.28"><vh>Fixed Apple help menu reversion</vh></v>
<v t="ekr.20071101162751.32"><vh>Disabled the plugins manage plugin</vh></v>
<v t="ekr.20071101162751.33"><vh>Made sure plugins work if frame.iconFrame is None</vh></v>
<v t="ekr.20071101162751.34"><vh>Fixed @auto java bug</vh></v>
<v t="ekr.20071101162751.97"><vh>Fixed spell-check problem on Linux</vh></v>
<v t="ekr.20071101162751.149"><vh>Use the default spell tab</vh></v>
<v t="ekr.20071101162751.150"><vh>Fixed long-standing and important body editor bug</vh></v>
<v t="ekr.20071101162751.178"><vh>Non-ignored @auto trees do not get saved to the .leo file</vh></v>
<v t="ekr.20071101162751.184"><vh>Fixed bug that cause the import of PyParse.py to fail</vh></v>
<v t="ekr.20071101163257"><vh>Improved error reporting in rst3 plugins for code_block directive</vh></v>
</v>
</v>
</v>
<v t="ekr.20071115102421"><vh>4.4.5 bug fixes</vh>
<v t="ekr.20071115102156"><vh>Leo 4.4.5 b1</vh>
<v t="ekr.20071115102156.5"><vh>Fixed bugs</vh>
<v t="ekr.20071115102156.2"><vh>Removed all references to pluginsManager.txt</vh></v>
<v t="ekr.20071115102156.6"><vh>Fixed hung windows</vh></v>
<v t="ekr.20071115102156.11"><vh>Warn on resurrected (vampire) nodes</vh></v>
<v t="ekr.20071115102156.21"><vh>Fixed new @auto bug (python)</vh></v>
<v t="ekr.20071115102156.78"><vh>Fixed new @auto bug: c++</vh></v>
<v t="ekr.20071115102156.79"><vh>Fixed various @auto comparison problems</vh></v>
<v t="ekr.20071115102156.81"><vh>Retain relative paths in recent files menu</vh></v>
<v t="ekr.20071115102156.123"><vh>Fixed windows registry problem</vh></v>
<v t="ekr.20071115102156.124"><vh>Fixed paste node as clone crasher</vh></v>
<v t="ekr.20071115102156.141"><vh>Fixed hoist crasher</vh></v>
<v t="ekr.20071115102156.146"><vh>Ignore unpickling problems in getUa</vh></v>
</v>
<v t="ekr.20071116081521"><vh>New commaneds</vh>
<v t="ekr.20071115102156.238"><vh>toggle-collapse_nodes_during_finds</vh></v>
<v t="ekr.20071115102156.256"><vh>3 new sort-lines commands</vh></v>
<v t="ekr.20071115102156.303"><vh>Added Cmd:Icons menu and commands</vh></v>
</v>
<v t="ekr.20071115102156.148"><vh>New features</vh>
<v t="ekr.20071115102156.149"><vh>Leo now recognizes directives in headlines</vh></v>
<v t="ekr.20071115102156.301"><vh>Moved all unit tests to unitTest.leo</vh></v>
<v t="ekr.20071115102156.320"><vh>Added @rst-preformat</vh></v>
<v t="ekr.20071115102156.321"><vh>Installed small icon set from Tango library</vh></v>
</v>
<v t="ekr.20071116081521.1"><vh>New settings</vh>
<v t="ekr.20071115102156.237"><vh>@bool at_auto_warns_about_leading_whitespace</vh></v>
<v t="ekr.20071115102156.302"><vh>@bool vim_plugin_opens_url_nodes</vh></v>
<v t="ekr.20071115102156.289"><vh>@bool warn_when_plugins_fail_to_load</vh></v>
</v>
</v>
<v t="ekr.20071206093346"><vh>Leo 4.4.5 b2</vh>
<v t="ekr.20071206093323.1"><vh>Fixed bugs</vh>
<v t="ekr.20071206093323.2"><vh>Fixed two crashers in the @noref logic</vh></v>
<v t="ekr.20071206093323.3"><vh>Fixed crasher in regularizeWhitespace</vh></v>
<v t="ekr.20071206093323.4"><vh>Fixed paste-node-as-clone</vh></v>
<v t="ekr.20071206093323.29"><vh>Fixed threading colorizer hang with perl</vh></v>
<v t="ekr.20071206093323.30"><vh>Fixed C++ importer crash</vh></v>
<v t="ekr.20071206093323.31"><vh>Reorganized leoImport.py</vh></v>
<v t="ekr.20071206093323.59"><vh>Fixed command lockout problem</vh></v>
<v t="ekr.20071206093323.72"><vh>Improved @auto code</vh></v>
<v t="ekr.20071206093323.76"><vh>Simplified perl colorizer and added progress checks</vh></v>
<v t="ekr.20071206093323.80"><vh>Fixed problem with decorators</vh></v>
<v t="ekr.20071206093323.87"><vh>Fixed @auto bug</vh></v>
<v t="ekr.20071206093323.96"><vh>Fixed  focus problem with goto-next clone command</vh></v>
</v>
</v>
<v t="ekr.20071211083251"><vh>Leo 4.4.5 final</vh></v>
</v>
<v t="ekr.20080106114331"><vh>4.4.6 bug fixes</vh>
<v t="ekr.20071217092250"><vh>leo 4.4.6 b1</vh>
<v t="ekr.20071217092203.1"><vh>Bugs fixed</vh>
<v t="ekr.20071217092203.2"><vh>Fixed undo (dirty bit) problem)</vh></v>
<v t="ekr.20071217092203.30"><vh>Fixed cursesGui  plugin</vh></v>
<v t="ekr.20071217092203.31"><vh>Fixed script_io_to_body plugin</vh></v>
<v t="ekr.20071217092203.45"><vh>Make Import to @file create @file nodes</vh></v>
<v t="ekr.20071217092203.51"><vh>Fixed bug: rst3 plugin now finds default.css file correctly</vh></v>
<v t="ekr.20071217092203.52"><vh>Fixed bug with clear-recent-files</vh></v>
<v t="ekr.20071217092203.64"><vh>Fixed bug: replace didn't always start in the correct place</vh></v>
<v t="ekr.20071217092203.127"><vh>fixed colorizer bug</vh></v>
<v t="ekr.20071217092203.128"><vh>Fixed clone focus bug</vh></v>
<v t="ekr.20071217092203.130"><vh>Removed call to printLine in change-all logic</vh></v>
<v t="ekr.20071217092203.131"><vh>Fixed crash when copying or cloning to non-exisitent chapter</vh></v>
<v t="ekr.20071217092203.161"><vh>Added text bindings to status area</vh></v>
<v t="ekr.20071217092203.136"><vh>Repaired damaged minusnode.gif icon</vh></v>
</v>
<v t="ekr.20071217092203.137"><vh>New features</vh>
<v t="ekr.20071217092203.138"><vh>Applied Terry Brown's config patch</vh></v>
<v t="ekr.20071217092203.145"><vh>Applied plumloco's patch to plugins_menu.py</vh></v>
<v t="ekr.20071217092203.146"><vh>Upgraded to Pmw 1.3</vh></v>
<v t="ekr.20071217092203.147"><vh>Added find-next-clone command</vh></v>
<v t="ekr.20071217092203.149"><vh>Added toggle-sparse-move command</vh></v>
<v t="ekr.20071217092203.152"><vh>Added support for @data nodes in @settings trees</vh></v>
<v t="ekr.20071217092203.154"><vh>Added @auto xml script</vh></v>
<v t="ekr.20071217092203.163"><vh>Added @import scanners for javascript and xml files</vh></v>
</v>
</v>
<v t="ekr.20080106114225"><vh>leo 4.4.6 b2</vh>
<v t="ekr.20080106114648"><vh>Fixed bugs</vh>
<v t="ekr.20080106114203.1"><vh>Fixed bug in nav_buttons plugin</vh></v>
<v t="ekr.20080106114203.2"><vh>Fixed problems with modes/rest.py</vh></v>
<v t="ekr.20080106114203.3"><vh>Replaced delete-all-icons command with a script in script.leo</vh></v>
<v t="ekr.20080106114203.4"><vh>Leo issues better messages if Image can not be imported</vh></v>
<v t="ekr.20080115093848.18"><vh>Added convenience methods for icons</vh></v>
<v t="ekr.20080115093848.19"><vh>Fixed undo bug</vh></v>
<v t="ekr.20080115093848.23"><vh>Don't mark nodes dirty if insert-icon is cancelled</vh></v>
</v>
</v>
<v t="ekr.20080126090039"><vh>leo 4.4.6 final</vh></v>
</v>
<v t="ekr.20080218154129"><vh>4.4.7 ipython plugin</vh>
<v t="ekr.20080212221734"><vh>leo 4.4.7 b1</vh>
<v t="ekr.20080212221711.1"><vh>Fixed bugs</vh>
<v t="ekr.20080212221711.2"><vh>Fixed perl syntax coloring bug</vh></v>
<v t="ekr.20080212221711.4"><vh>Removed warnings while typing @language directives</vh></v>
<v t="ekr.20080212221711.15"><vh>Fixed pascal import bug</vh></v>
<v t="ekr.20080212221711.35"><vh>write-outline-only command now prints a 'done' message</vh></v>
<v t="ekr.20080213094948.1"><vh>Worked around problems with winpdb</vh></v>
<v t="ekr.20080213094948.4"><vh>Fixed new problem with image.py</vh></v>
</v>
<v t="ekr.20080212221711.32"><vh>New features</vh>
<v t="ekr.20080212221711.33"><vh>All import commands now honor @path</vh></v>
<v t="ekr.20080212221711.34"><vh>Added ipython plugin</vh></v>
<v t="ekr.20080212221711.47"><vh>Added support for @bool open_with_save_on_update setting</vh></v>
<v t="ekr.20080212221711.26"><vh>Improved handling of unicode for @auto files</vh></v>
</v>
</v>
<v t="ekr.20080218153931"><vh>leo 4.4.7 final</vh>
<v t="ekr.20080218153931.1"><vh>Fixed bugs</vh>
<v t="ekr.20080218153931.2"><vh>Fixed perl syntax coloring bug</vh></v>
<v t="ekr.20080218153931.3"><vh>Removed warnings while typing @language directives</vh></v>
<v t="ekr.20080218153931.4"><vh>Fixed pascal import bug</vh></v>
<v t="ekr.20080218153931.5"><vh>write-outline-only command now prints a 'done' message</vh></v>
<v t="ekr.20080218153931.6"><vh>Worked around problems with winpdb</vh></v>
<v t="ekr.20080218153931.7"><vh>Fixed new problem with image.py</vh></v>
<v t="ekr.20080218154129.1"><vh>Leo's old colorizer now colorizes Leo directives properly</vh></v>
</v>
<v t="ekr.20080218153931.8"><vh>New features</vh>
<v t="ekr.20080218153931.9"><vh>All import commands now honor @path</vh></v>
<v t="ekr.20080218153931.10"><vh>Added ipython plugin</vh></v>
<v t="ekr.20080218153931.11"><vh>Added support for @bool open_with_save_on_update setting</vh></v>
<v t="ekr.20080218153931.12"><vh>Improved handling of unicode for @auto files</vh></v>
</v>
</v>
</v>
<v t="ekr.20080311060457.215"><vh>4.4.8 translating args to g.es and g.es_print</vh>
<v t="ekr.20080304112808"><vh>4.4.8 b1</vh>
<v t="ekr.20080304112802.1"><vh>Allow arguments to minibuffer commands</vh></v>
<v t="ekr.20080304112802.25"><vh>Added translation services</vh>
<v t="ekr.20080310093038.4"></v>
</v>
</v>
<v t="ekr.20080311060457.1"><vh>4.4.8 b2</vh>
<v t="ekr.20080311060457.210"><vh>b1</vh>
<v t="ekr.20080311060457.211"><vh>Allow arguments to minibuffer commands</vh></v>
<v t="ekr.20080311060457.212"><vh>Added translation services</vh>
<v t="ekr.20080311060457.213"><vh>Translating Leo's menus and messages</vh></v>
</v>
</v>
<v t="ekr.20080311060457.216"><vh>b2</vh>
<v t="ekr.20080311060457.2"><vh>Bug fixes</vh>
<v t="ekr.20080311060457.3"><vh>Assigned g.fileIndex on the fly</vh></v>
<v t="ekr.20080311060457.28"><vh>Allow tkFrame to complete before killing it</vh></v>
<v t="ekr.20080311060457.38"><vh>Renamed self.fileIndex to  readBufferIndex in file read logic</vh></v>
<v t="ekr.20080311060457.125"><vh>Made sure that all fileIndex fields get converted on read</vh></v>
</v>
<v t="ekr.20080311060457.128"><vh>Features</vh>
<v t="ekr.20080311060457.188"><vh>Compile regexp's once in findNextMatch</vh></v>
<v t="ekr.20080311060457.198"><vh>Created menus very late in the creation process</vh></v>
<v t="ekr.20080314081157.1"><vh>Improved marks/recent buttons plugin</vh></v>
<v t="ekr.20080314081157.2"><vh>Added support for @commands trees in settings files</vh></v>
</v>
</v>
</v>
<v t="ekr.20080328074117.340"><vh>4.4.8 b3</vh>
<v t="ekr.20080328074117.2"><vh>Fixed bugs</vh>
<v t="ekr.20080328074117.3"><vh>Corrected docs: unit tests are in test/unitTest.leo</vh></v>
<v t="ekr.20080328074117.4"><vh>Removed '.' from leoID</vh></v>
<v t="ekr.20080328074117.12"><vh>Fixed Open With menu</vh></v>
<v t="ekr.20080328074117.30"><vh>Fixed @lineending botch</vh></v>
<v t="ekr.20080328074117.76"><vh>Fixed undo problem with mutliple editors</vh></v>
<v t="ekr.20080328074117.77"><vh>Write dirty bit if write fails</vh></v>
<v t="ekr.20080328074117.135"><vh>Fixed bug involving default_target_language</vh></v>
<v t="ekr.20080328074117.215"><vh>Fixed plugins that create new menu items</vh></v>
</v>
<v t="ekr.20080328074117.216"><vh>Features</vh>
<v t="ekr.20080328074117.217"><vh>Added @bool collapse_nodes_while_spelling setting</vh></v>
<v t="ekr.20080328074117.220"><vh>Errors reading external files give line numbers</vh></v>
<v t="ekr.20080328074117.262"><vh>Added @bool allow_middle_button_paste</vh></v>
<v t="ekr.20080328074117.297"><vh>Added support for @popup settings</vh></v>
</v>
</v>
<v t="ekr.20080403065258.10"><vh>4.4.8 rc1</vh>
<v t="ekr.20080403065258.6"><vh>Fixed delete-editor problem</vh></v>
</v>
</v>
<v t="ekr.20080405074410.4"><vh>4.4.8 final</vh>
<v t="ekr.20080405074410.7"><vh>Open leoPluginsRef.leo in help menu if leoPlugins.leo does not exist</vh></v>
<v t="ekr.20080405074410.9"><vh>Fixed big performance bug in find/spell commands.</vh></v>
<v t="ekr.20080405074410.38"><vh>Fixed several unit testing bugs relating to doTests(all=True)</vh></v>
</v>
</v>
<v t="ekr.20080730095710.1"><vh>4.5 code reorgs, vim bindings, @shadow</vh>
<v t="ekr.20080624093059.1"><vh>4.5 b1</vh>
<v t="ekr.20080624093059.2"><vh>Bug fixes</vh>
<v t="ekr.20080624093059.3"><vh>Fixed bug in appendToRecentFiles</vh></v>
<v t="ekr.20080624093059.4"><vh>Fixed bug in install script</vh></v>
<v t="ekr.20080624093059.5"><vh>Fixed bug: no focus after save-as and save-to commands</vh></v>
<v t="ekr.20080624093059.6"><vh>Fixed find bug</vh></v>
<v t="ekr.20080624093059.7"><vh>Fixed find completion bug</vh></v>
<v t="ekr.20080624093059.8"><vh>Fixed how-many, find-word and goto-character commands</vh></v>
<v t="ekr.20080624093059.9"><vh>Fixed import PHP bug</vh></v>
<v t="ekr.20080624093059.10"><vh>Fixed keyword handling in g.es and g.es_print</vh></v>
<v t="ekr.20080624093059.11"><vh>Fixed new @auto bug</vh></v>
<v t="ekr.20080624093059.12"><vh>Fixed recent files bug</vh></v>
<v t="ekr.20080624093059.14"><vh>Greatly increased speed of undo clone-find-all</vh></v>
<v t="ekr.20080624093059.15"><vh>Temporary fix for php import bug</vh></v>
<v t="ekr.20080624093059.16"><vh>Fixed unbounded loop in autocompleter.findAnchor</vh></v>
<v t="ekr.20080624093059.17"><vh>Fixed insert-newline bug</vh></v>
<v t="ekr.20080624093059.18"><vh>Single click did not color body correctly</vh></v>
<v t="ekr.20080624093059.19"><vh>Body not colored correctly after find</vh></v>
<v t="ekr.20080624093059.20"><vh>Fixed big performance bug in contract-all command</vh></v>
<v t="ekr.20080624093059.21"><vh>Changed bindings so Home and end keys work as expected when editing a headline</vh></v>
<v t="ekr.20080624093059.22"><vh>Fixed bug: myLeoSettings.leo sometimes read twice</vh></v>
<v t="ekr.20080624093059.23"><vh>Compute menus list for each c</vh></v>
<v t="ekr.20080624093059.24"><vh>Fixed minor spelling bug</vh></v>
<v t="ekr.20080624093059.25"><vh>Fixed spell bug: words containing unicode characters aren't saved properly</vh></v>
<v t="ekr.20080624093059.26"><vh>Fixed coloring bugs in reformatParagraph and c.redraw</vh></v>
<v t="ekr.20080624093059.27"><vh>Fixed missing redraw problem</vh></v>
<v t="ekr.20080624093059.28"><vh>Fixed new-headline problem</vh></v>
<v t="ekr.20080624093059.29"><vh>Fixed recent crasher</vh></v>
<v t="ekr.20080624093059.30"><vh>Fixed encoding problems with paste from clipboard</vh></v>
<v t="ekr.20080624093059.31"><vh>Changed installer to support leo-as-a-package</vh></v>
<v t="ekr.20080628062747.69"><vh>Fixed undo problem</vh></v>
<v t="ekr.20080628062747.70"><vh>Fixed insert-file bug</vh></v>
<v t="ekr.20080628062747.71"><vh>Fixed script button bug</vh></v>
<v t="ekr.20080628062747.72"><vh>Fixed dragging bug</vh></v>
</v>
<v t="ekr.20080624093059.32"><vh>Features</vh>
<v t="ekr.20080624093059.33"><vh>Remove useTextWidget option from leoKeys.py</vh></v>
<v t="ekr.20080624093059.34"><vh>Set use_sax = True always</vh></v>
<v t="ekr.20080624093059.35"><vh>Added g.unified_nodes</vh></v>
<v t="ekr.20080624093059.36"><vh>Added install nodes re Leo's home directory</vh></v>
<v t="ekr.20080624093059.37"><vh>Added support for @bool fixedWindow option</vh></v>
<v t="ekr.20080624093059.38"><vh>Added new key-handling</vh></v>
<v t="ekr.20080624093059.39"><vh>New drawing/focus code</vh></v>
<v t="ekr.20080624093059.40"><vh>Improved end of calltips</vh></v>
<v t="ekr.20080624093059.41"><vh>Find character crosses lines</vh></v>
<v t="ekr.20080624093059.42"><vh>Added os.curdir to sys.path if possible</vh></v>
<v t="ekr.20080624093059.43"><vh>Added support for single-config option</vh></v>
<v t="ekr.20080624093059.44"><vh>Finished Tracer class</vh></v>
<v t="ekr.20080624093059.45"><vh>Rewrote option-parsing code using optparse</vh></v>
<v t="ekr.20080624093059.46"><vh>Added @bool cleo_color_ignore = True</vh></v>
<v t="ekr.20080624093059.47"><vh>Set cwd in read/write commands</vh></v>
<v t="ekr.20080624093059.48"><vh>Added  vim patches</vh>
<v t="ekr.20080624093059.49"><vh>Realization</vh></v>
<v t="ekr.20080624093059.50"><vh>Problems</vh></v>
<v t="ekr.20080624093059.51"><vh>Notes</vh></v>
</v>
<v t="ekr.20080624093059.52"><vh>Added 'kill' bindings</vh></v>
<v t="ekr.20080624093059.53"><vh>Added check for empty @nosent nodes</vh></v>
</v>
</v>
<v t="ekr.20080730095710.2"><vh>4.5 b2</vh>
<v t="ekr.20080806211440.188"></v>
<v t="ekr.20080806211440.253"></v>
<v t="ekr.20080806211440.256"></v>
<v t="ekr.20080806211440.189"></v>
</v>
<v t="ekr.20080815093141.89"><vh>4.5 b3</vh>
<v t="ekr.20080815093141.90"><vh>Major new features</vh></v>
<v t="ekr.20080815093141.91"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080815093141.92"><vh>Minor new features</vh></v>
<v t="ekr.20080815093141.93"><vh>New settings</vh></v>
</v>
<v t="ekr.20080827175609.55"><vh>4.5 rc1</vh>
<v t="ekr.20080827175609.56"><vh>Major new features</vh></v>
<v t="ekr.20080827175609.57"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080827175609.58"><vh>Minor new features</vh></v>
<v t="ekr.20080827175609.59"><vh>New settings</vh></v>
</v>
<v t="ekr.20080830082008.1"><vh>4.5 rc2</vh>
<v t="ekr.20080830082008.2"><vh>Major new features</vh></v>
<v t="ekr.20080830082008.3"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080830082008.4"><vh>Minor new features</vh></v>
<v t="ekr.20080830082008.5"><vh>New settings</vh></v>
</v>
<v t="ekr.20080902080930.2"><vh>4.5 final</vh>
<v t="ekr.20080902080930.3"><vh>Major new features</vh></v>
<v t="ekr.20080902080930.4"><vh>Major code reorganizations</vh></v>
<v t="ekr.20080902080930.5"><vh>Minor new features</vh></v>
<v t="ekr.20080902080930.6"><vh>New settings</vh></v>
</v>
<v t="ekr.20080912143702.137"><vh>4.5.1 final</vh>
<v t="ekr.20080912143702.138"><vh>Fixed line number problems</vh></v>
<v t="ekr.20080912143702.139"><vh>Fixed problems with @shadow files with unknown file extensions</vh></v>
<v t="ekr.20080912143702.140"><vh>Fixed bug in Leo's pre-install script</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10704"><vh>4.6 file caching, qt gui, @edit, @auto-rst</vh>
<v t="ekr.20090324085713.2"><vh>4.6 b1</vh>
<v t="ekr.20090324085713.285"><vh>Bugs fixed</vh>
<v t="ekr.20090324085713.292"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090324085713.326"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090324085713.350"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090324085713.358"><vh>Paste outline problem</vh></v>
<v t="ekr.20090324085713.395"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090324085713.404"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090324085713.513"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090324085713.605"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090324085713.327"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090324085713.289"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090324085713.318"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090324085713.320"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
<v t="ekr.20090324085713.690"><vh>Improved file handling</vh>
<v t="ekr.20090324085713.726"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090324085713.748"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090324085713.792"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090324085713.661"><vh>New code features</vh>
<v t="ekr.20090324085713.662"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090324085713.663"><vh>Added g.PosList</vh></v>
<v t="ekr.20090324085713.666"><vh>Better plugin info</vh></v>
<v t="ekr.20090324085713.672"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090324085713.688"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090324085713.689"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090324085713.272"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090324085713.745"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090324105223.15"><vh>New command-line options</vh>
<v t="ekr.20090324085713.849"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090324085713.835"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090324085713.867"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090324105223.9"><vh>New commands</vh>
<v t="ekr.20090324085713.747"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090324085713.817"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090324085713.836"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090324085713.837"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090324085713.847"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090324105223.10"><vh>New and improved directives</vh>
<v t="ekr.20090324085713.740"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090324085713.691"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090324085713.848"><vh>New settings</vh>
<v t="ekr.20090324085713.732"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090324085713.850"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090324085713.746"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090324085713.814"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090324085713.868"><vh>Plugins</vh>
<v t="ekr.20090324085713.869"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090324085713.881"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090324085713.890"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090620073906.11072"><vh>4.6 b2</vh>
<v t="ekr.20090620073906.11073"><vh>Bugs</vh>
<v t="ekr.20090620073906.11083"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090620073906.11087"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090620073906.11960"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090620073906.11590"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090620073906.11376"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090620073906.11981"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090620073906.12044"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090620073906.11865"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090620073906.11850"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090620073906.11564"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090620073906.11296"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090620073906.11081"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090620103431.5601"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090620073906.11833"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090620073906.11374"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090620073906.11521"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090620073906.11091"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090620073906.11380"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090620073906.11074"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090620073906.11137"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090620073906.11387"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090620073906.11776"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090620073906.11707"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090620073906.11377"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090620073906.11864"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090620073906.11352"><vh>Fixed new command</vh></v>
<v t="ekr.20090620073906.11740"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090620073906.11818"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090620073906.11390"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090620073906.11086"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090620073906.11760"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090620073906.11666"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090620073906.11866"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090620073906.11349"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090620073906.11107"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090620073906.11378"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090620073906.11759"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090620073906.11094"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090620073906.11612"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090620073906.11620"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090620073906.11824"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090620073906.11771"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090620073906.11973"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090620073906.11870"><vh>New features</vh>
<v t="ekr.20090620073906.11923"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090620073906.11873"><vh>Improved unit testing</vh></v>
<v t="ekr.20090620073906.11898"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090620073906.12061"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090620073906.11935"><vh>Support @auto-rst</vh></v>
</v>
</v>
<v t="ekr.20090709084001.5944"><vh>4.6 rc1</vh>
<v t="ekr.20090709084001.5945"><vh>Bugs</vh>
<v t="ekr.20090709084001.5968"><vh>Fixed unicode problem with spell checker</vh></v>
<v t="ekr.20090709084001.6086"><vh>Ensure newline at end of each @auto node</vh></v>
<v t="ekr.20090709084001.6096"><vh>Fixed bugs with goto-global-line and @auto</vh></v>
<v t="ekr.20090709084001.6119"><vh>Added key bindings in log pane</vh></v>
<v t="ekr.20090709084001.6138"><vh>Honor split ratios</vh></v>
<v t="ekr.20090709084001.6140"><vh>Click in body after editing activates body</vh></v>
<v t="ekr.20090709084001.6144"><vh>Rewrote string-rectangle command for speed</vh></v>
<v t="ekr.20090709084001.6149"><vh>Fixed read-at-auto-nodes bug</vh></v>
<v t="ekr.20090709084001.6153"><vh>Fixed major focus problems</vh></v>
<v t="ekr.20090709084001.6156"><vh>Fixed problem with read-at-file/shadow-nodes</vh></v>
<v t="ekr.20090709084001.6164"><vh>Fixed major icon/t.uA bug</vh></v>
<v t="ekr.20090709084001.6192"><vh>Fixed rst bug</vh></v>
<v t="ekr.20090709084001.6204"><vh>Made alt-6 run all unit tests</vh></v>
<v t="ekr.20090709084001.6238"><vh>Fixed crasher in dynamicExpanderHelper</vh></v>
<v t="ekr.20090709084001.6241"><vh>Don't collapse initial node automatically</vh></v>
<v t="ekr.20090709084001.6254"><vh>Fixed bug: don't duplicate standard buttons</vh></v>
<v t="ekr.20090709084001.6283"><vh>Fixed critical @file data-loss problem</vh></v>
<v t="ekr.20090709084001.6291"><vh>Added hasSelection to leoQtBody</vh></v>
</v>
<v t="ekr.20090709084001.6296"><vh>Features</vh>
<v t="ekr.20090709084001.6297"><vh>Added open-quickstart-leo command</vh></v>
<v t="ekr.20090709084001.6300"><vh>Added tree bindings for page-up/down commands</vh></v>
<v t="ekr.20090709084001.6301"><vh>Issue error message re non-existent plugins</vh></v>
<v t="ekr.20090709084001.6304"><vh>Expanded Alt-lt/rt arrows</vh></v>
<v t="ekr.20090709084001.6307"><vh>Added important @auto warning</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10808"><vh>4.6 final</vh>
<v t="ekr.20090717084250.10809"><vh>Bug fixes</vh>
<v t="ekr.20090717084250.10810"><vh>Bugs fixed in 4.6 b2</vh>
<v t="ekr.20090717084250.10811"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090717084250.10812"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090717084250.10813"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090717084250.10814"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090717084250.10815"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090717084250.10816"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090717084250.10817"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090717084250.10818"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090717084250.10819"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090717084250.10820"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090717084250.10821"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090717084250.10822"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090717084250.10823"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090717084250.10824"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090717084250.10825"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090717084250.10826"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090717084250.10827"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090717084250.10828"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090717084250.10829"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090717084250.10830"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090717084250.10831"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090717084250.10832"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090717084250.10833"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090717084250.10834"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090717084250.10835"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090717084250.10836"><vh>Fixed new command</vh></v>
<v t="ekr.20090717084250.10837"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090717084250.10838"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090717084250.10839"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090717084250.10840"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090717084250.10841"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090717084250.10842"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090717084250.10843"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090717084250.10844"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090717084250.10845"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090717084250.10846"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090717084250.10847"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090717084250.10848"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090717084250.10849"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090717084250.10850"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090717084250.10851"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090717084250.10852"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090717084250.10853"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090717084250.10854"><vh>Bugs fixed in 4.6 b1</vh>
<v t="ekr.20090717084250.10855"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090717084250.10856"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090717084250.10857"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090717084250.10858"><vh>Paste outline problem</vh></v>
<v t="ekr.20090717084250.10859"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090717084250.10860"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090717084250.10861"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090717084250.10862"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090717084250.10863"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090717084250.10864"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090717084250.10865"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090717084250.10866"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10867"><vh>New features</vh>
<v t="ekr.20090717084250.10868"><vh>New features in 4.6 b1</vh>
<v t="ekr.20090717084250.10869"><vh>Improved file handling</vh>
<v t="ekr.20090717084250.10870"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090717084250.10871"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090717084250.10872"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090717084250.10873"><vh>New code features</vh>
<v t="ekr.20090717084250.10874"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090717084250.10875"><vh>Added g.PosList</vh></v>
<v t="ekr.20090717084250.10876"><vh>Better plugin info</vh></v>
<v t="ekr.20090717084250.10877"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090717084250.10878"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090717084250.10879"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090717084250.10880"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090717084250.10881"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090717084250.10882"><vh>New command-line options</vh>
<v t="ekr.20090717084250.10883"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090717084250.10884"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090717084250.10885"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090717084250.10886"><vh>New commands</vh>
<v t="ekr.20090717084250.10887"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090717084250.10888"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090717084250.10889"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090717084250.10890"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090717084250.10891"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090717084250.10892"><vh>New and improved directives</vh>
<v t="ekr.20090717084250.10893"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090717084250.10894"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090717084250.10895"><vh>New settings</vh>
<v t="ekr.20090717084250.10896"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090717084250.10897"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090717084250.10898"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090717084250.10899"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090717084250.10900"><vh>Plugins</vh>
<v t="ekr.20090717084250.10901"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090717084250.10902"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090717084250.10903"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10904"><vh>New features in 4.6 b2</vh>
<v t="ekr.20090717084250.10905"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090717084250.10906"><vh>Improved unit testing</vh></v>
<v t="ekr.20090717084250.10907"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090717084250.10908"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090717084250.10909"><vh>Support @auto-rst</vh></v>
</v>
<v t="ekr.20090717084250.10910"><vh>New features in 4.6 final</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10405"><vh>4.6.1 final</vh>
<v t="ekr.20090718092032.10406"><vh>Bug fixes</vh>
<v t="ekr.20090718092032.10407"><vh>Bugs fixed in 4.6 b2</vh>
<v t="ekr.20090718092032.10408"><vh>Added patch for startup logic</vh></v>
<v t="ekr.20090718092032.10409"><vh>Allocate gnx's when nodes are created</vh></v>
<v t="ekr.20090718092032.10410"><vh>Allow block comments in private shadow files</vh></v>
<v t="ekr.20090718092032.10411"><vh>Compute delims from private shadow file as needed</vh></v>
<v t="ekr.20090718092032.10412"><vh>Don't copy @edit trees to outline</vh></v>
<v t="ekr.20090718092032.10413"><vh>Don't expand ancestors of @chapter node when selecting chapter</vh></v>
<v t="ekr.20090718092032.10414"><vh>Entries in recent files menu now have absolute paths</vh></v>
<v t="ekr.20090718092032.10415"><vh>Fixed (worked around) tk chapters bug</vh></v>
<v t="ekr.20090718092032.10416"><vh>Fixed @edit bug</vh></v>
<v t="ekr.20090718092032.10417"><vh>Fixed @shadow crasher</vh></v>
<v t="ekr.20090718092032.10418"><vh>Fixed @thin bug</vh></v>
<v t="ekr.20090718092032.10419"><vh>Fixed back-to-home so it works as expected</vh></v>
<v t="ekr.20090718092032.10420"><vh>Fixed bad @verbatim bug</vh></v>
<v t="ekr.20090718092032.10421"><vh>Fixed binding problem with notebook</vh></v>
<v t="ekr.20090718092032.10422"><vh>Fixed bug: sorting could revert headline changes</vh></v>
<v t="ekr.20090718092032.10423"><vh>Fixed crash when reading .zip files</vh></v>
<v t="ekr.20090718092032.10424"><vh>Fixed crasher when creating .leoID.txt</vh></v>
<v t="ekr.20090718092032.10425"><vh>Fixed dabbrev-expands bug</vh></v>
<v t="ekr.20090718092032.10426"><vh>Fixed elisp importer problem</vh></v>
<v t="ekr.20090718092032.10427"><vh>Fixed F10/11/12 key bug</vh></v>
<v t="ekr.20090718092032.10428"><vh>Fixed file bug re unicode characters</vh></v>
<v t="ekr.20090718092032.10429"><vh>Fixed hoist problems</vh></v>
<v t="ekr.20090718092032.10430"><vh>Fixed lost anchor bug page up/down</vh></v>
<v t="ekr.20090718092032.10431"><vh>Fixed minor @auto bug</vh></v>
<v t="ekr.20090718092032.10432"><vh>Fixed multiple-editor focus problems</vh></v>
<v t="ekr.20090718092032.10433"><vh>Fixed new command</vh></v>
<v t="ekr.20090718092032.10434"><vh>Fixed problems with change-all command</vh></v>
<v t="ekr.20090718092032.10435"><vh>Fixed read clone bug</vh></v>
<v t="ekr.20090718092032.10436"><vh>Fixed rst import bug</vh></v>
<v t="ekr.20090718092032.10437"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20090718092032.10438"><vh>Fixed seg-fault bug</vh></v>
<v t="ekr.20090718092032.10439"><vh>Fixed Shift-Arrow in headlines</vh></v>
<v t="ekr.20090718092032.10440"><vh>Fixed startup problem</vh></v>
<v t="ekr.20090718092032.10441"><vh>Fixed stubConfig problems</vh></v>
<v t="ekr.20090718092032.10442"><vh>Fixed undo bug</vh></v>
<v t="ekr.20090718092032.10443"><vh>Fixed vim bindings (dd) bug</vh></v>
<v t="ekr.20090718092032.10444"><vh>Investigated bug: File-&gt;Export-&gt;write failed due to incorrect path</vh></v>
<v t="ekr.20090718092032.10445"><vh>Investigated speed of external unit tests</vh></v>
<v t="ekr.20090718092032.10446"><vh>Made @url nodes work with qt gui</vh></v>
<v t="ekr.20090718092032.10447"><vh>Mark @&lt;file&gt; nodes dirty when @path nodes change</vh></v>
<v t="ekr.20090718092032.10448"><vh>Removed duplicate messages when opening non-existent .leo file</vh></v>
<v t="ekr.20090718092032.10449"><vh>Reversed messages about redefined keys</vh></v>
<v t="ekr.20090718092032.10450"><vh>Scroll commands now affect only scrollbars</vh></v>
</v>
<v t="ekr.20090718092032.10451"><vh>Bugs fixed in 4.6 b1</vh>
<v t="ekr.20090718092032.10452"><vh>Fixed goto-global-line crasher</vh></v>
<v t="ekr.20090718092032.10453"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh></v>
<v t="ekr.20090718092032.10454"><vh>Save/restore tnodeList in atFile.write</vh></v>
<v t="ekr.20090718092032.10455"><vh>Paste outline problem</vh></v>
<v t="ekr.20090718092032.10456"><vh>Made sure $Home works for @nosent</vh></v>
<v t="ekr.20090718092032.10457"><vh>Fixed atFile unicode bug</vh></v>
<v t="ekr.20090718092032.10458"><vh>Fixed Mark Edgington's @shadow bug</vh></v>
<v t="ekr.20090718092032.10459"><vh>Fixed whitespace problems with @auto/@shadow</vh></v>
<v t="ekr.20090718092032.10460"><vh>Fixed nested @path problem</vh></v>
<v t="ekr.20090718092032.10461"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090718092032.10462"><vh>Fixed new rst3 crash</vh></v>
<v t="ekr.20090718092032.10463"><vh>Fixed two c syntax-coloring bugs</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10464"><vh>New features</vh>
<v t="ekr.20090718092032.10465"><vh>New features in 4.6 b1</vh>
<v t="ekr.20090718092032.10466"><vh>Improved file handling</vh>
<v t="ekr.20090718092032.10467"><vh>Open a default .leo file if no other is specified</vh></v>
<v t="ekr.20090718092032.10468"><vh>Added escapes for underindented lines</vh></v>
<v t="ekr.20090718092032.10469"><vh>Warn when writing an externally changed file</vh></v>
</v>
<v t="ekr.20090718092032.10470"><vh>New code features</vh>
<v t="ekr.20090718092032.10471"><vh>Added autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20090718092032.10472"><vh>Added g.PosList</vh></v>
<v t="ekr.20090718092032.10473"><vh>Better plugin info</vh></v>
<v t="ekr.20090718092032.10474"><vh>Added properties to leoNodes.py</vh></v>
<v t="ekr.20090718092032.10475"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090718092032.10476"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090718092032.10477"><vh>Predefined 'self' in @test/@suite nodes</vh></v>
<v t="ekr.20090718092032.10478"><vh>Added c.getNodePath and c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090718092032.10479"><vh>New command-line options</vh>
<v t="ekr.20090718092032.10480"><vh>Added -c option to specify config files</vh></v>
<v t="ekr.20090718092032.10481"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090718092032.10482"><vh>Added support for --gui option</vh></v>
</v>
<v t="ekr.20090718092032.10483"><vh>New commands</vh>
<v t="ekr.20090718092032.10484"><vh>Added smart home (back-to-home) command</vh></v>
<v t="ekr.20090718092032.10485"><vh>The open command creates @edit nodes when opening non-.leo files</vh></v>
<v t="ekr.20090718092032.10486"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090718092032.10487"><vh>Added support for smart_tab setting</vh></v>
<v t="ekr.20090718092032.10488"><vh>Improved isearch commands</vh></v>
</v>
<v t="ekr.20090718092032.10489"><vh>New and improved directives</vh>
<v t="ekr.20090718092032.10490"><vh>Added @nocolor-node directive</vh></v>
<v t="ekr.20090718092032.10491"><vh>Improved @path handling</vh></v>
</v>
<v t="ekr.20090718092032.10492"><vh>New settings</vh>
<v t="ekr.20090718092032.10493"><vh>Added better default fonts for Leo on Linux</vh></v>
<v t="ekr.20090718092032.10494"><vh>Added support for @int icon_bar_widgets_per_row setting</vh></v>
<v t="ekr.20090718092032.10495"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090718092032.10496"><vh>Use myLeoSettings when opening leoSettings.leo</vh></v>
</v>
<v t="ekr.20090718092032.10497"><vh>Plugins</vh>
<v t="ekr.20090718092032.10498"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh></v>
<v t="ekr.20090718092032.10499"><vh>Created qtGui and tkGui plugins</vh></v>
<v t="ekr.20090718092032.10500"><vh>Created leoGuiPluginsRef.leo</vh></v>
</v>
</v>
<v t="ekr.20090718092032.10501"><vh>New features in 4.6 b2</vh>
<v t="ekr.20090718092032.10502"><vh>Allow Leo to open any file</vh></v>
<v t="ekr.20090718092032.10503"><vh>Improved unit testing</vh></v>
<v t="ekr.20090718092032.10504"><vh>Leo tests syntax of .py files when saving them</vh></v>
<v t="ekr.20090718092032.10505"><vh>Made qt gui the default</vh></v>
<v t="ekr.20090718092032.10506"><vh>Support @auto-rst</vh></v>
</v>
<v t="ekr.20090718092032.10507"><vh>New features in 4.6 final</vh></v>
</v>
</v>
<v t="ekr.20090802162204.5798"><vh>4.6.2 final</vh>
<v t="ekr.20090803084828.5800"><vh>Bugs fixed</vh></v>
</v>
<v t="ekr.20091006093902.6558"><vh>4.6.3 final</vh>
<v t="ekr.20091006093902.6559"><vh>Bugs fixed</vh></v>
<v t="ekr.20091006093902.6560"><vh>New features</vh></v>
</v>
</v>
<v t="ekr.20100118181428.8827"><vh>4.7 One-node world, Leo-3k, @auto-rst, convert @file</vh>
<v t="ekr.20090909083000.6547"><vh>4.7 beta 1</vh>
<v t="ekr.20090909083000.6556"><vh>Added new Windows installer</vh></v>
<v t="ekr.20090909083000.6555"><vh>Added new plugins</vh></v>
<v t="ekr.20090909083000.6552"><vh>Added options to vim plugin</vh></v>
<v t="ekr.20090909083000.6553"><vh>Leo no longer adds directories to sys.path</vh></v>
</v>
<v t="ekr.20100118181428.8813"><vh>4.7 beta 2</vh>
<v t="ekr.20100118181428.7557"><vh>Bugs</vh>
<v t="ekr.20100118181428.7559"><vh>Fixed calltips on leo3k</vh></v>
<v t="ekr.20100118181428.7570"><vh>Fixed headline scrolling</vh></v>
<v t="ekr.20100118181428.7571"><vh>Fixed bug 498692: Undo renames headline</vh></v>
<v t="ekr.20100118181428.7614"><vh>Fixed bug 498688: Undo back to last saved content...</vh></v>
<v t="ekr.20100118181428.7712"><vh>Fixed bug: no log when notebook does not exist</vh></v>
<v t="ekr.20100118181428.7715"><vh>Fixed bug 362950: during body text undo selection goes nuts...</vh></v>
<v t="ekr.20100118181428.7830"><vh>Removed unsettling @auto warning</vh></v>
<v t="ekr.20100118181428.7831"><vh>Fixed at-auto-rst problems</vh></v>
<v t="ekr.20100118181428.8070"><vh>Fixed bug: at-nosent nodes were not being dirty when headline changes</vh></v>
<v t="ekr.20100118181428.8077"><vh>Allow hyphens in xml tags</vh></v>
<v t="ekr.20100118181428.8090"><vh>Fixed Alt-u bug and refactored k.masterKeyHandler</vh></v>
<v t="ekr.20100118181428.8109"><vh>Fixed at-shadow error</vh></v>
<v t="ekr.20100118181428.8236"><vh>Fixed bug 408886: qttabs gui doesn't mark commanders dirty properly</vh></v>
<v t="ekr.20100118181428.8239"><vh>Fixed bug 476653: @nowrap isn't working for qt / @edit nodes</vh></v>
<v t="ekr.20100118181428.8240"><vh>Fixed bug 480422: string-rectangle kills syntax highlighting</vh></v>
<v t="ekr.20100118181428.8242"><vh>Fixed bug in g.adjustTripleString</vh></v>
<v t="ekr.20100118181428.8248"><vh>Fixed bug in writeNodeToString</vh></v>
<v t="ekr.20100118181428.8252"><vh>Fixed bug: @nosent should warn about orphan nodes</vh></v>
<v t="ekr.20100118181428.8257"><vh>Fixed bug: Sometimes 'redefining shortcut' message is backwards</vh></v>
<v t="ekr.20100118181428.8262"><vh>Fixed contract-or-go-right</vh></v>
<v t="ekr.20100118181428.8275"><vh>Fixed crasher when writing to a newly-deleted file</vh></v>
<v t="ekr.20100118181428.8278"><vh>Fixed double prompt in c.close()</vh></v>
<v t="ekr.20100118181428.8281"><vh>Fixed elisp parsing bug</vh></v>
<v t="ekr.20100118181428.8294"><vh>Fixed publish-argv-for-missing-stylesheets</vh></v>
<v t="ekr.20100118181428.8297"><vh>Fixed registerHandler bug</vh></v>
<v t="ekr.20100118181428.8298"><vh>Fixed scrolling problem with multiple editors</vh></v>
<v t="ekr.20100118181428.8299"><vh>Fixed startup reversion when .leoID.txt does not exist</vh></v>
<v t="ekr.20100118181428.8302"><vh>Handle Insert key properly</vh></v>
<v t="ekr.20100118181428.8306"><vh>Improved the install docs</vh></v>
<v t="ekr.20100118181428.8307"><vh>Made add-comments and delete-comments commands work with shortcuts</vh></v>
<v t="ekr.20100118181428.8334"><vh>Marked @&lt;file&gt; nodes dirty if nodes change during read.</vh></v>
<v t="ekr.20100118181428.8358"><vh>Recover from bad chars in .leo files</vh></v>
<v t="ekr.20100118181428.8362"><vh>Select main chapter initially</vh></v>
<v t="ekr.20100118181428.8363"><vh>Suppressed dangerous write prompt for clones</vh></v>
<v t="ekr.20100118181428.8365"><vh>Use w.leoMoveCursorHelper if it exists</vh></v>
<v t="ekr.20100118181428.8413"><vh>Fixed bug 452303 @auto-rst can be dangerous</vh></v>
<v t="ekr.20100118181428.8447"><vh>Fixed underlining problem in rst</vh></v>
<v t="ekr.20100118181428.8449"><vh>Fixed qt key problems</vh></v>
<v t="ekr.20100118181428.8473"><vh>Fixed bug: 381895 qtGui Split ratio is not saved in .leo file</vh></v>
<v t="ekr.20100118181428.8481"><vh>Applied patches to fix bug: 451377 Make Leo frienly to mac apps</vh></v>
<v t="ekr.20100118181428.8485"><vh>Fixed bug: 394445 Chapters selection button: in qt, missing, in Tk, only one option</vh></v>
<v t="ekr.20100118181428.8486"><vh>Fixed bug: overwrite modified file message</vh></v>
<v t="ekr.20100118181428.8497"><vh>Fixed auto-save problem</vh></v>
<v t="ekr.20100118181428.8502"><vh>Fixed old at-shadow problem</vh></v>
<v t="ekr.20100118181428.8514"><vh>Fixed ctrl-tab bug</vh></v>
<v t="ekr.20100118181428.8517"><vh>Fixed 349027: body doesn't get focus after headline edit</vh></v>
<v t="ekr.20100118181428.8518"><vh>Fixed bug 507559: Can't use End key while editing node headline</vh></v>
<v t="ekr.20100118181428.8522"><vh>Finished bug 486433: non-breaking space etc. are invisible</vh></v>
<v t="ekr.20100118181428.8523"><vh>Fixed bug: 420988 @tabwith 8 not honored</vh></v>
<v t="ekr.20100118181428.8524"><vh>Don't colorize @others and @all unless they start a line</vh></v>
<v t="ekr.20100119145003.7319"><vh>Gui bugs</vh>
<v t="ekr.20100119145003.7320"><vh>Fixed file-open focus problem</vh></v>
<v t="ekr.20100119145003.7322"><vh>Eliminate double close prompt</vh></v>
<v t="ekr.20100119145003.7324"><vh>Fixed scrolling problem with multiple editors</vh></v>
<v t="ekr.20100119145003.7325"><vh>Fixed crash in quicksearch plugin</vh></v>
<v t="ekr.20100119145003.7327"><vh>Fixed @nosent dirty bug</vh></v>
<v t="ekr.20100119145003.7358"><vh>Allow horizontal scrolling in QtTree</vh></v>
<v t="ekr.20100119145003.7531"><vh>Correct binding of insert key</vh></v>
<v t="ekr.20100119145003.7546"><vh>Update tab names when the commander is dirty</vh></v>
<v t="ekr.20100119145003.7612"><vh>Made @nowrap work</vh></v>
<v t="ekr.20100119145003.7618"><vh>Added leoMoveCursorHelper</vh></v>
<v t="ekr.20100119145003.7625"><vh>Remember the ratios when the user moves splitters by hand.</vh></v>
<v t="ekr.20100119145003.7629"><vh>Chapter tabs require both_chapters and use_chapters_tabs</vh></v>
<v t="ekr.20100119145003.7632"><vh>Don't colorize directives unless they start a line</vh></v>
<v t="ekr.20100119145003.7643"><vh>Config coloring tags whenever the language changes</vh></v>
<v t="ekr.20100119145003.7718"><vh>Update qttabs when saving a new file</vh></v>
</v>
<v t="ekr.20100124164700.11919"><vh>Fixed colorizer bug affecting per-language @font settings</vh></v>
<v t="ekr.20100124164700.11920"><vh>support extend-mode for several commands</vh></v>
<v t="ekr.20100124164700.11921"><vh>Fixed qttab problem</vh></v>
<v t="ekr.20100124164700.11922"><vh>&lt;alt-x&gt; select-all crashes python when focus is in headline</vh></v>
<v t="ekr.20100124164700.11923"><vh>Allow saving .leo files with undefined-sections</vh></v>
<v t="ekr.20100124164700.11924"><vh>Refactored write_Leo_file</vh></v>
<v t="ekr.20100124164700.11925"><vh>Fixed print-bindings crasher w/ leo3k</vh></v>
<v t="ekr.20100124164700.11926"><vh>Fixed problem with already-existing .leo.bak files</vh></v>
<v t="ekr.20100124164700.11927"><vh>Fixed sort children bug</vh></v>
<v t="ekr.20100124164700.11928"><vh>Fixed unicode problems</vh></v>
<v t="ekr.20100124164700.11938"><vh>Fixed crash in writeToFileHelper</vh></v>
<v t="ekr.20100124164700.11944"><vh>Add warnings when @file logic happens</vh></v>
<v t="ekr.20100124164700.11946"><vh>Fixed mkstemp bug</vh></v>
<v t="ekr.20100124164700.11951"><vh>Removed most usage of _bodyString &amp; _headString</vh></v>
<v t="ekr.20100124164700.11965"><vh>Don't use tnodeList to separate old/new @file nodes</vh></v>
<v t="ekr.20100124164700.12027"><vh>Eliminated warning re orphan nodes</vh></v>
<v t="ekr.20100128094926.12524"><vh>Eliminated node-changed marks</vh></v>
<v t="ekr.20100128094926.12739"><vh>Suppress path changed message in save-as and save-to</vh></v>
<v t="ekr.20100128094926.12756"><vh>Fixed Terry's unicode problem</vh></v>
</v>
<v t="ekr.20100118181428.8525"><vh>Features</vh>
<v t="ekr.20100118181428.8815"><vh>Leo supports Python 3.x</vh></v>
<v t="ekr.20100129054823.11928"></v>
<v t="ekr.20100129054823.17683"><vh>New command-line options</vh></v>
<v t="ekr.20100129054823.11935"></v>
<v t="ekr.20100129054823.17685"><vh>New settings</vh></v>
</v>
</v>
<v t="ekr.20100201192329.7018"><vh>4.7 beta 3</vh>
<v t="ekr.20100201192329.7095"><vh>Bugs fixed in Leo 4.7 b3</vh>
<v t="ekr.20100201192329.7141"><vh>Fixed unicode problems</vh></v>
<v t="ekr.20100201192329.7101"><vh>paste-node-as-clone now sets dirty bits properly</vh></v>
<v t="ekr.20100201192329.7106"><vh>Fixed crasher in sort-siblings</vh></v>
<v t="ekr.20100201192329.7108"><vh>Fixed bug 515164: a crasher in p.positionExists</vh></v>
<v t="ekr.20100201192329.7113"><vh>Fixed problem with colon following @path</vh></v>
<v t="ekr.20100201192329.7116"><vh>Code cleanup</vh></v>
</v>
</v>
<v t="ekr.20100205152016.14053"><vh>4.7 rc 1</vh>
<v t="ekr.20100205152016.14054"><vh>Recovering from clone conflicts</vh></v>
<v t="ekr.20100209160132.11690"><vh>Bugs fixed</vh>
<v t="ekr.20100209160132.11691"><vh>Fixed unicode bug in setSelectionRangeHelper</vh></v>
<v t="ekr.20100209160132.11692"><vh>Home key no longer clears the minibuffer</vh></v>
<v t="ekr.20100209160132.11694"><vh>Fixed bug in c.pasteOutline when run from unit tests</vh></v>
<v t="ekr.20100209160132.11700"><vh>Removed all references to isAtNorefFileNode</vh></v>
<v t="ekr.20100209160132.11701"><vh>Fixed inconsistency in how @path works</vh></v>
<v t="ekr.20100209160132.11711"><vh>Fixed crasher in path.py</vh></v>
<v t="ekr.20100209160132.11712"><vh>Fixed at-auto write bug</vh></v>
<v t="ekr.20100209160132.11718"><vh>Fixed the critical 'file used by another process' bug</vh></v>
<v t="ekr.20100209160132.11736"><vh>Alt-right should *not* go down</vh></v>
<v t="ekr.20100209160132.11742"><vh>Big change: simplified g.utils_rename</vh></v>
<v t="ekr.20100209160132.11751"><vh>Fixed cursor hangnail</vh></v>
<v t="ekr.20100209160132.11755"><vh>Do a full redraw when contracting a cloned node</vh></v>
<v t="ekr.20100209160132.11756"><vh>Bug 399720: (fixed) goto-global-line doesn't work with @edit nodes</vh></v>
<v t="ekr.20100209160132.11765"><vh>Fixed unit test for leo_interface.py</vh></v>
<v t="ekr.20100209160132.11767"><vh>Fixed g.getLastTracebackFileAndLineNubmer</vh></v>
<v t="ekr.20100209160132.11770"><vh>Fixed open-with crash</vh>
<v t="ekr.20100209160132.11771"><vh>Report</vh></v>
</v>
<v t="ekr.20100209160132.11773"><vh>Fixed bug 518823: clone headline updates</vh></v>
<v t="ekr.20100211125418.11596"><vh>Removed duplicate can not open message for @auto file</vh></v>
<v t="ekr.20100211125418.11599"><vh>Fixed minor bug involving insertion point</vh></v>
<v t="ekr.20100211125418.11602"><vh>Fixed unicode crasher in write-recent-files logic</vh></v>
</v>
<v t="ekr.20100211125418.11611"><vh>New commands</vh>
<v t="ekr.20100209160132.11888"><vh>Created clear-cache and clear-all-caches commands</vh></v>
</v>
</v>
<v t="ekr.20100223063657.7262"><vh>4.7 final</vh>
<v t="ekr.20100223063657.7264"><vh>Bug fixed</vh>
<v t="ekr.20100223063657.7182"><vh>Fixed calls to sort in 6 places</vh></v>
<v t="ekr.20100223063657.7192"><vh>Fix bug 363406: goto-global-line works with @auto files</vh></v>
<v t="ekr.20100223063657.7212"><vh>Put focus in a standard place after save commands</vh></v>
<v t="ekr.20100223063657.7232"><vh>Fixed internal Leo error in atFile.read method</vh></v>
<v t="ekr.20100223063657.7238"><vh>Fixed wish-list bug 508108: No methods sub-nodes in PHP class import</vh></v>
<v t="ekr.20100223063657.7245"><vh>Fixed qt colorizer bug</vh></v>
<v t="ekr.20100223063657.7246"><vh>Fixed ancient minibuffer bug</vh></v>
<v t="ekr.20100223063657.7249"><vh>Improved support for wrapping in the log pane</vh></v>
<v t="ekr.20100223063657.7263"><vh>Reformatted the output of the apropos commands</vh></v>
</v>
</v>
<v t="ekr.20100225102026.7139"><vh>4.7.1 final</vh>
<v t="ekr.20100225102026.7140"><vh>Changes made to Leo 4.7.1</vh></v>
</v>
</v>
<v t="ekr.20101104091058.5045"><vh>4.8 Simpler sentinels, better installer, recovery nodes</vh>
<v t="ekr.20101024234254.5433"><vh>4.8 a1</vh></v>
<v t="ekr.20101114081049.5004"><vh>4.8 b1</vh></v>
<v t="ekr.20101104091058.4975"><vh>4.8 rc1</vh>
<v t="ekr.20101104091058.4976"><vh>Known problems</vh></v>
<v t="ekr.20101104173324.5140"><vh>New in 4.8 a1</vh>
<v t="ekr.20101104091058.4977"><vh>Bugs</vh>
<v t="ekr.20101104091058.4978"><vh>Significant bugs</vh>
<v t="ekr.20101104091058.4979"><vh>Fixed vampire nodes and created p.deletePositionsInList</vh>
<v t="ekr.20101104091058.4980"><vh>Post re vampire nodes</vh></v>
</v>
<v t="ekr.20101104091058.4981"><vh>Fixed bug 577047: Invalid @path directory does not warn user</vh></v>
<v t="ekr.20101104091058.4986"><vh>Fixed @shadow problem</vh></v>
<v t="ekr.20101104173324.4924"><vh>Don't write tnodes of @file nodes!</vh></v>
</v>
<v t="ekr.20101104091058.4988"><vh>Minor bugs</vh>
<v t="ekr.20101104091058.4989"><vh>Fixed the @test logic for external files</vh></v>
<v t="ekr.20101104091058.4990"><vh>Fixed save scrolling bug</vh></v>
<v t="ekr.20101104091058.4991"><vh>Fixed at-auto-rst crash</vh></v>
<v t="ekr.20101104091058.4992"><vh>Don't put &amp;nbsp; in redirected log</vh></v>
<v t="ekr.20101104091058.4993"><vh>Fixed crash in log pane</vh></v>
<v t="ekr.20101104091058.4994"><vh>Fixed at-auto-rst bug</vh></v>
<v t="ekr.20101104091058.4995"><vh>Fixed erroneous error message in at-auto-rst read logic</vh></v>
<v t="ekr.20101104091058.4996"><vh>Fixed crasher in openFileForReading</vh></v>
<v t="ekr.20101104091058.4997"><vh>Fixed Java import problem</vh></v>
<v t="ekr.20101104091058.4999"><vh>Fixed gloto-global-line</vh></v>
<v t="ekr.20101104091058.5000"><vh>Fixed rst3 bug with docutils on py3k</vh></v>
<v t="ekr.20101104091058.5001"><vh>fixed bug 618474: show_leo_directives</vh></v>
<v t="ekr.20101104091058.5002"><vh>fixed bug 618482: code-mode line feeds</vh></v>
<v t="ekr.20101104091058.5003"><vh>Fixed weave (and many similar) commands</vh></v>
<v t="ekr.20101104091058.5004"><vh>Shorter warnings about incompatible gui type</vh></v>
<v t="ekr.20101104091058.5005"><vh>Improved @enabled-plugins: ignore lines starting with '@'</vh></v>
<v t="ekr.20101104091058.5006"><vh>Fixed bug in runUnitTestLeoFile</vh></v>
<v t="ekr.20101104091058.5007"><vh>Fixed crasher with del in minibuffer</vh></v>
<v t="ekr.20101104091058.5008"><vh>Ignore F-Keys &amp; Ins in the minibuffer.</vh></v>
<v t="ekr.20101104091058.5009"><vh>Fixed bug 618570: leoRst: option strip_at_file_prefixes...</vh></v>
<v t="ekr.20101104091058.5010"><vh>Fixed bug 622802: Go to clone" switches to the first chapter</vh></v>
<v t="ekr.20101104091058.5011"><vh>Fixed unicode bug in files</vh></v>
<v t="ekr.20101104091058.5012"><vh>Eliminated check python syntax commands, but retained code</vh></v>
<v t="ekr.20101104091058.5013"><vh>Improved handling of history</vh></v>
<v t="ekr.20101104091058.5014"><vh>Remember whether @asis/@nosent existed at read time</vh></v>
<v t="ekr.20101104091058.5015"><vh>Added g.app.config.config_iter</vh></v>
</v>
</v>
<v t="ekr.20101104091058.5016"><vh>Code features</vh>
<v t="ekr.20101104091058.5017"><vh>Added g.findTestScript</vh></v>
<v t="ekr.20101104091058.5018"><vh>Added p.deletePositionsInList</vh></v>
<v t="ekr.20101104173324.4920"><vh>Leo is more clever in putting up the Leo id dialog</vh></v>
<v t="ekr.20101104173324.4921"><vh>Simplified leoPlugins code</vh></v>
<v t="ekr.20101104173324.4923"><vh>Patched @test logic</vh></v>
</v>
<v t="ekr.20101104091058.5019"><vh>Commands</vh>
<v t="ekr.20101104091058.5020"><vh>Added legend for print-settings command</vh></v>
<v t="ekr.20101104091058.5021"><vh>Added code-to-rst command</vh></v>
<v t="ekr.20101104091058.5022"><vh>Removed mark-clones command</vh></v>
<v t="ekr.20101104091058.5023"><vh>Improved abbreviation commands</vh></v>
<v t="ekr.20101104091058.5150"><vh>Completed cascade-windows and minimize-all-windows commands</vh></v>
<v t="ekr.20101104091058.5252"><vh>Created head-to-prev-node and tail-to-next-node commands</vh></v>
</v>
<v t="ekr.20101104091058.5024"><vh>Documentation</vh>
<v t="ekr.20101104091058.5025"><vh>Created introductory slide shows</vh></v>
<v t="ekr.20101104091058.5026"><vh>Reorganized Users Guide</vh></v>
</v>
<v t="ekr.20101104091058.5027"><vh>Features</vh>
<v t="ekr.20101104091058.5028"><vh>New sentinels</vh></v>
<v t="ekr.20101104091058.5029"><vh>Don't create @chapter node for new file</vh></v>
<v t="ekr.20101104091058.5030"><vh>Improved install instructions &amp; logic</vh></v>
<v t="ekr.20101104091058.5031"><vh>DnD outline nodes</vh></v>
<v t="ekr.20101104091058.5032"><vh>write @edit nodes like @nosent nodes</vh></v>
<v t="ekr.20101104091058.5033"><vh>Leo now uses PyEnchant to check spelling</vh></v>
<v t="ekr.20101104091058.5034"><vh>Improved @url nodes</vh></v>
<v t="ekr.20101104091058.5035"><vh>Made sure that all @auto nodes end with a newline</vh></v>
<v t="ekr.20101104091058.5036"><vh>Improved language support</vh></v>
</v>
<v t="ekr.20101104091058.5037"><vh>Settings</vh>
<v t="ekr.20101104091058.5038"><vh>Allow multiple files on the command line</vh></v>
<v t="ekr.20101104091058.5039"><vh>Allow proportional fonts in plain text</vh></v>
<v t="ekr.20101104091058.5040"><vh>Allow changing minibuffer colors</vh></v>
<v t="ekr.20101104091058.5041"><vh>Added support for @string qt-toolbar-location</vh></v>
<v t="ekr.20101104091058.5042"><vh>Support @bool write_expansion_bits_in_leo_files</vh></v>
<v t="ekr.20101104091058.5043"><vh>Added support for slideshow plugin</vh></v>
<v t="ekr.20101104091058.5044"><vh>New settings for abbreviations</vh></v>
</v>
</v>
<v t="ekr.20101104173324.5021"><vh>New in 4.8 b1</vh>
<v t="ekr.20101104173324.5142"><vh>Bugs</vh>
<v t="ekr.20101104173324.5023"><vh>Fixed bug 603720: @auto parsing error on dedented triple quote string</vh></v>
<v t="ekr.20101104173324.5028"><vh>Fixed bug 597757: c.frame.body.getSelectedText() doesn't work in added editors</vh></v>
<v t="ekr.20101104173324.5102"><vh>Fixed bug 604115: chapter-{clone,copy}-node-to broken</vh></v>
<v t="ekr.20101104173324.5138"><vh>Made sure proper install.txt appears</vh></v>
</v>
<v t="ekr.20101104173324.5031"><vh>Completed cascade-windows and minimize-all-windows commands</vh></v>
<v t="ekr.20101104173324.5032"><vh>Improved present autocompleter</vh></v>
<v t="ekr.20101104173324.5133"><vh>Created head-to-prev-node and tail-to-next-node commands</vh></v>
<v t="ekr.20101105082829.4917"><vh>Put non-def code in their own node</vh></v>
</v>
<v t="ekr.20101114081049.5090"><vh>New in 4.8 rc1</vh>
<v t="ekr.20101114081049.5101"><vh>Revised many plugins</vh></v>
<v t="ekr.20101114081049.5102"><vh>Fixed crasher in UNL.py: recursiveUNLSearch</vh></v>
<v t="ekr.20101114081049.5103"><vh>Big improvement to execute-script command</vh></v>
<v t="ekr.20101114081049.5108"><vh>Added extract-python-method command</vh></v>
<v t="ekr.20101115085632.4928"><vh>Open the default leo file if possible</vh></v>
<v t="ekr.20101115085632.4930"><vh>Fixed problems with installer</vh></v>
</v>
</v>
<v t="ekr.20101124102457.5135"><vh>4.8 final</vh>
<v t="ekr.20101124102457.5136"><vh>Known problems</vh></v>
<v t="ekr.20101124102457.5137"><vh>New in 4.8 a1</vh>
<v t="ekr.20101124102457.5138"><vh>Bugs</vh>
<v t="ekr.20101124102457.5139"><vh>Significant bugs</vh>
<v t="ekr.20101124102457.5140"><vh>Fixed vampire nodes and created p.deletePositionsInList</vh>
<v t="ekr.20101124102457.5141"><vh>Post re vampire nodes</vh></v>
</v>
<v t="ekr.20101124102457.5142"><vh>Fixed bug 577047: Invalid @path directory does not warn user</vh></v>
<v t="ekr.20101124102457.5143"><vh>Fixed @shadow problem</vh></v>
<v t="ekr.20101124102457.5144"><vh>Don't write tnodes of @file nodes!</vh></v>
</v>
<v t="ekr.20101124102457.5145"><vh>Minor bugs</vh>
<v t="ekr.20101124102457.5146"><vh>Fixed the @test logic for external files</vh></v>
<v t="ekr.20101124102457.5147"><vh>Fixed save scrolling bug</vh></v>
<v t="ekr.20101124102457.5148"><vh>Fixed at-auto-rst crash</vh></v>
<v t="ekr.20101124102457.5149"><vh>Don't put &amp;nbsp; in redirected log</vh></v>
<v t="ekr.20101124102457.5150"><vh>Fixed crash in log pane</vh></v>
<v t="ekr.20101124102457.5151"><vh>Fixed at-auto-rst bug</vh></v>
<v t="ekr.20101124102457.5152"><vh>Fixed erroneous error message in at-auto-rst read logic</vh></v>
<v t="ekr.20101124102457.5153"><vh>Fixed crasher in openFileForReading</vh></v>
<v t="ekr.20101124102457.5154"><vh>Fixed Java import problem</vh></v>
<v t="ekr.20101124102457.5155"><vh>Fixed gloto-global-line</vh></v>
<v t="ekr.20101124102457.5156"><vh>Fixed rst3 bug with docutils on py3k</vh></v>
<v t="ekr.20101124102457.5157"><vh>fixed bug 618474: show_leo_directives</vh></v>
<v t="ekr.20101124102457.5158"><vh>fixed bug 618482: code-mode line feeds</vh></v>
<v t="ekr.20101124102457.5159"><vh>Fixed weave (and many similar) commands</vh></v>
<v t="ekr.20101124102457.5160"><vh>Shorter warnings about incompatible gui type</vh></v>
<v t="ekr.20101124102457.5161"><vh>Improved @enabled-plugins: ignore lines starting with '@'</vh></v>
<v t="ekr.20101124102457.5162"><vh>Fixed bug in runUnitTestLeoFile</vh></v>
<v t="ekr.20101124102457.5163"><vh>Fixed crasher with del in minibuffer</vh></v>
<v t="ekr.20101124102457.5164"><vh>Ignore F-Keys &amp; Ins in the minibuffer.</vh></v>
<v t="ekr.20101124102457.5165"><vh>Fixed bug 618570: leoRst: option strip_at_file_prefixes...</vh></v>
<v t="ekr.20101124102457.5166"><vh>Fixed bug 622802: Go to clone" switches to the first chapter</vh></v>
<v t="ekr.20101124102457.5167"><vh>Fixed unicode bug in files</vh></v>
<v t="ekr.20101124102457.5168"><vh>Eliminated check python syntax commands, but retained code</vh></v>
<v t="ekr.20101124102457.5169"><vh>Improved handling of history</vh></v>
<v t="ekr.20101124102457.5170"><vh>Remember whether @asis/@nosent existed at read time</vh></v>
<v t="ekr.20101124102457.5171"><vh>Added g.app.config.config_iter</vh></v>
</v>
</v>
<v t="ekr.20101124102457.5172"><vh>Code features</vh>
<v t="ekr.20101124102457.5173"><vh>Added g.findTestScript</vh></v>
<v t="ekr.20101124102457.5174"><vh>Added p.deletePositionsInList</vh></v>
<v t="ekr.20101124102457.5175"><vh>Leo is more clever in putting up the Leo id dialog</vh></v>
<v t="ekr.20101124102457.5176"><vh>Simplified leoPlugins code</vh></v>
<v t="ekr.20101124102457.5177"><vh>Patched @test logic</vh></v>
</v>
<v t="ekr.20101124102457.5178"><vh>Commands</vh>
<v t="ekr.20101124102457.5179"><vh>Added legend for print-settings command</vh></v>
<v t="ekr.20101124102457.5180"><vh>Added code-to-rst command</vh></v>
<v t="ekr.20101124102457.5181"><vh>Removed mark-clones command</vh></v>
<v t="ekr.20101124102457.5182"><vh>Improved abbreviation commands</vh></v>
<v t="ekr.20101124102457.5183"><vh>Completed cascade-windows and minimize-all-windows commands</vh></v>
<v t="ekr.20101124102457.5184"><vh>Created head-to-prev-node and tail-to-next-node commands</vh></v>
</v>
<v t="ekr.20101124102457.5189"><vh>Documentation</vh>
<v t="ekr.20101124102457.5190"><vh>Created introductory slide shows</vh></v>
<v t="ekr.20101124102457.5191"><vh>Reorganized Users Guide</vh></v>
</v>
<v t="ekr.20101124102457.5192"><vh>Features</vh>
<v t="ekr.20101124102457.5193"><vh>New sentinels</vh></v>
<v t="ekr.20101124102457.5194"><vh>Don't create @chapter node for new file</vh></v>
<v t="ekr.20101124102457.5195"><vh>Improved install instructions &amp; logic</vh></v>
<v t="ekr.20101124102457.5196"><vh>DnD outline nodes</vh></v>
<v t="ekr.20101124102457.5197"><vh>write @edit nodes like @nosent nodes</vh></v>
<v t="ekr.20101124102457.5198"><vh>Leo now uses PyEnchant to check spelling</vh></v>
<v t="ekr.20101124102457.5199"><vh>Improved @url nodes</vh></v>
<v t="ekr.20101124102457.5200"><vh>Made sure that all @auto nodes end with a newline</vh></v>
<v t="ekr.20101124102457.5201"><vh>Improved language support</vh></v>
</v>
<v t="ekr.20101124102457.5202"><vh>Settings</vh>
<v t="ekr.20101124102457.5203"><vh>Allow multiple files on the command line</vh></v>
<v t="ekr.20101124102457.5204"><vh>Allow proportional fonts in plain text</vh></v>
<v t="ekr.20101124102457.5205"><vh>Allow changing minibuffer colors</vh></v>
<v t="ekr.20101124102457.5206"><vh>Added support for @string qt-toolbar-location</vh></v>
<v t="ekr.20101124102457.5207"><vh>Support @bool write_expansion_bits_in_leo_files</vh></v>
<v t="ekr.20101124102457.5208"><vh>Added support for slideshow plugin</vh></v>
<v t="ekr.20101124102457.5209"><vh>New settings for abbreviations</vh></v>
</v>
</v>
<v t="ekr.20101124102457.5210"><vh>New in 4.8 b1</vh>
<v t="ekr.20101124102457.5211"><vh>Bugs</vh>
<v t="ekr.20101124102457.5212"><vh>Fixed bug 603720: @auto parsing error on dedented triple quote string</vh></v>
<v t="ekr.20101124102457.5213"><vh>Fixed bug 597757: c.frame.body.getSelectedText() doesn't work in added editors</vh></v>
<v t="ekr.20101124102457.5214"><vh>Fixed bug 604115: chapter-{clone,copy}-node-to broken</vh></v>
<v t="ekr.20101124102457.5215"><vh>Made sure proper install.txt appears</vh></v>
</v>
<v t="ekr.20101124102457.5216"><vh>Completed cascade-windows and minimize-all-windows commands</vh></v>
<v t="ekr.20101124102457.5217"><vh>Improved present autocompleter</vh></v>
<v t="ekr.20101124102457.5218"><vh>Created head-to-prev-node and tail-to-next-node commands</vh></v>
<v t="ekr.20101124102457.5219"><vh>Put non-def code in their own node</vh></v>
</v>
<v t="ekr.20101124102457.5220"><vh>New in 4.8 rc1</vh>
<v t="ekr.20101124102457.5221"><vh>Revised many plugins</vh></v>
<v t="ekr.20101124102457.5222"><vh>Fixed crasher in UNL.py: recursiveUNLSearch</vh></v>
<v t="ekr.20101124102457.5223"><vh>Big improvement to execute-script command</vh></v>
<v t="ekr.20101124102457.5224"><vh>Added extract-python-method command</vh></v>
<v t="ekr.20101124102457.5225"><vh>Open the default leo file if possible</vh></v>
<v t="ekr.20101124102457.5226"><vh>Fixed problems with installer</vh></v>
</v>
<v t="ekr.20101124102457.5227"><vh>New in 4.8 final</vh></v>
</v>
</v>
<v t="ekr.20110531155858.19246"><vh>4.9 Qt only, autocompleter, vr pane</vh>
<v t="ekr.20110601105631.19359"><vh>Deprecated/removed features</vh></v>
<v t="ekr.20110531155858.19830"><vh>Bugs fixed in b1</vh>
<v t="ekr.20110604043410.17811"><vh>Numbered bugs</vh></v>
<v t="ekr.20110604043410.17812"><vh>Other bugs</vh></v>
</v>
<v t="ekr.20110602091552.16903"><vh>Major improvements</vh>
<v t="ekr.20110602091552.16904"><vh>Completed Leo's autocompleter</vh></v>
<v t="ekr.20110602091552.16905"><vh>Greatly improved the viewrendered plugin</vh></v>
</v>
<v t="ekr.20110531155858.20246"><vh>New and improved features</vh>
<v t="ekr.20110602091552.16907"><vh>Colorizing improvements</vh></v>
<v t="ekr.20110602091552.16909"><vh>New command-line arguments &amp; settings</vh></v>
<v t="ekr.20110602091552.16913"><vh>Gui improvements</vh></v>
<v t="ekr.20110602091552.16915"><vh>Improved commands</vh></v>
<v t="ekr.20110602091552.16911"><vh>File handling improvements</vh></v>
<v t="ekr.20110602091552.16917"><vh>Scripting improvements</vh></v>
</v>
<v t="ekr.20110604043410.17808"><vh>New in 4.9 b2</vh></v>
<v t="ekr.20110611055444.16617"><vh>New in 4.9 b3</vh>
<v t="ekr.20110611055444.16618"><vh>Bugs fixed</vh></v>
<v t="ekr.20110611055444.16654"><vh>Simplified Leo's key handling</vh></v>
<v t="ekr.20110611055444.16726"><vh>Features</vh></v>
<v t="ekr.20110611092035.16493"><vh>Removed settings</vh></v>
</v>
<v t="ekr.20110613172008.14775"><vh>New in 4.9 b4</vh></v>
<v t="ekr.20110616100929.14794"><vh>New in 4.9 rc1</vh></v>
<v t="ekr.20110620083705.14902"><vh>New in 4.9 final</vh></v>
</v>
<v t="ekr.20120229094652.14053"><vh>4.10 Incremental improvements</vh>
<v t="ekr.20120229094652.14757"><vh>Bugs</vh>
<v t="ekr.20120318075211.6163"><vh>Significant bugs</vh>
<v t="ekr.20120229094652.14758"><vh>Fixed ancient hanger in paste-retaining-clones</vh></v>
<v t="ekr.20120229094652.14780"><vh>Fixed serious atFile read bug</vh></v>
<v t="ekr.20120229094652.14934"><vh>Fixed bug: @button @key=x does not override x</vh></v>
<v t="ekr.20120229094652.14973"><vh>Fixed the wretched scrolling bug</vh></v>
<v t="ekr.20120318075211.6165"><vh>Fixed several node-selection bugs related to hoists &amp; chaptesr</vh>
<v t="ekr.20120313074006.14657"><vh>Fixed bug 823267: when a tab is closed focus may go to a tab other than the visible one</vh></v>
<v t="ekr.20120313074006.14771"><vh>Fixed bug 875327: Positioning outside of hoisted outline" usually causes problems</vh></v>
<v t="ekr.20120313074006.14663"><vh>Fixed bug 917814: Switching Log Pane tabs is done incompletely</vh></v>
<v t="ekr.20120313074006.14740"><vh>Fixed bug 875323: Hoist an @chapter node leaves a non-visible node selected</vh></v>
<v t="ekr.20120313074006.14765"><vh>Fixed bug 831658: @url doesn't leave Chapter</vh></v>
</v>
</v>
<v t="ekr.20120318075211.6164"><vh>Minor bugs</vh>
<v t="ekr.20120229094652.14759"><vh>Fixed bug in p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20120229094652.14761"><vh>Fixed double-click problem</vh></v>
<v t="ekr.20120229094652.14762"><vh>Fixed url focus issues</vh></v>
<v t="ekr.20120229094652.14763"><vh>Fixed p1 &gt; p2</vh></v>
<v t="ekr.20120229094652.14764"><vh>Fixed cacher problem</vh></v>
<v t="ekr.20120229094652.14765"><vh>Fixed encoding problem with @shadow</vh></v>
<v t="ekr.20120229094652.14767"><vh>Fixed a major DnD bug</vh></v>
<v t="ekr.20120229094652.14769"><vh>Regularized slashes in @edit/@file</vh></v>
<v t="ekr.20120229094652.14770"><vh>Made sure Leo's write code auto-detects file extension</vh></v>
<v t="ekr.20120229094652.14772"><vh>Fixed cycle-editor-focus bug</vh></v>
<v t="ekr.20120229094652.14775"><vh>Fixed Py3k crash in quicksearch.py</vh></v>
<v t="ekr.20120229094652.14779"><vh>Macro expansion now forces a full recolor</vh></v>
<v t="ekr.20120229094652.14781"><vh>Fixed unicode bugs with @shadow</vh></v>
<v t="ekr.20120229094652.14782"><vh>Recompute width of hard tabs depending on @tabwidth</vh></v>
<v t="ekr.20120229094652.14783"><vh>Applied patch for Bug 800311: Undo: Word granularity should recognize cursor movements</vh></v>
<v t="ekr.20120229094652.14784"><vh>Applied patch for Bug 800312: Collapsing node moves should be optional</vh></v>
<v t="ekr.20120229094652.14785"><vh>Fixed Bug 880975: Binding Meta and print-bindings</vh></v>
<v t="ekr.20120229094652.14786"><vh>Fixed bug 823601: cascade-windows fails</vh></v>
<v t="ekr.20120229094652.14817"><vh>Fixed html colorizing by fixing a bad bug in g.importFromPath</vh></v>
<v t="ekr.20120229094652.14818"><vh>Allow lower case keywords in colorizer</vh></v>
<v t="ekr.20120229094652.14820"><vh>Fixed rst3 pdf problem</vh></v>
<v t="ekr.20120229094652.14822"><vh>Removed traceback when cancelling a write</vh></v>
<v t="ekr.20120229094652.14823"><vh>Fixed removeBlankLinesTokens</vh></v>
<v t="ekr.20120229094652.14824"><vh>Fixed crasher in config.set</vh></v>
<v t="ekr.20120229094652.14825"><vh>Fixed resize-to-screen and minimize-all</vh></v>
<v t="ekr.20120229094652.14826"><vh>Fixed html import problems</vh></v>
<v t="ekr.20120229094652.14827"><vh>Removed extra newlines in g.trace</vh></v>
<v t="ekr.20120229094652.14828"><vh>Fixed crash in compareTokens</vh></v>
<v t="ekr.20120229094652.14829"><vh>Finished import work</vh></v>
<v t="ekr.20120229094652.14831"><vh>Fixed hard crash when deleting body editor 3 times</vh></v>
<v t="ekr.20120229094652.14832"><vh>Fixed add/delete html comments</vh></v>
<v t="ekr.20120229094652.14833"><vh>Fixed bug that prevented text bindings from working in log tabs</vh></v>
<v t="ekr.20120229094652.14835"><vh>Fixed crashers involving calls to w.setSelectionRange</vh></v>
<v t="ekr.20120229094652.14836"><vh>Fixed hang in cycleAllFocus</vh></v>
<v t="ekr.20120229094652.14837"><vh>Fixed crasher in k.handleDefaultChar</vh></v>
<v t="ekr.20120229094652.14838"><vh>Fixed bug: Focus lost after opening or closing tab</vh></v>
<v t="ekr.20120229094652.14839"><vh>Ignore unbound Alt/Ctrl keys, especially Alt/Ctrl-N</vh></v>
<v t="ekr.20120229094652.14840"><vh>Fixed bug: ensure global @buttons work</vh></v>
<v t="ekr.20120229094652.14841"><vh>Fixed bug in p.moveToFirstChild</vh></v>
<v t="ekr.20120229094652.14842"><vh>Fixed bug 804960: Refreshing unlinks clones, just reopening connects them again</vh></v>
<v t="ekr.20120229094652.14848"><vh>Fixed crasher in reportMismatch</vh></v>
<v t="ekr.20120229094652.14850"><vh>Fix bug: Allow @all only in top-level @&lt;file&gt; nodes (test2.leo)</vh></v>
<v t="ekr.20120229094652.14855"><vh>Fixed erroneous "file changed" message</vh></v>
<v t="ekr.20120229094652.14856"><vh>Fixed bug 889175: Changing @auto paths overwrites files without warning</vh></v>
<v t="ekr.20120229094652.14891"><vh>Fixed bug in DynamicWindow.setGeometry</vh></v>
<v t="ekr.20120229094652.14892"><vh>Fixed bug 87933: Redefining a key binding breaks menu items with same binding</vh>
<v t="ekr.20120229094652.14893"><vh> Report</vh></v>
<v t="ekr.20120229094652.14894"><vh>Bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display</vh></v>
<v t="ekr.20120229094652.14925"><vh>Updating dependent dicts</vh></v>
</v>
<v t="ekr.20120229094652.14941"><vh>Fixed Bug: @mark-for-unit-tests nodes</vh></v>
<v t="ekr.20120229094652.14942"><vh>The recent files commands now work</vh></v>
<v t="ekr.20120229094652.15012"><vh>Fixed bug: @int pagewidth now set c.page_width</vh></v>
<v t="ekr.20120229094652.15013"><vh>Fixed bug: goto end line handler is broken</vh></v>
<v t="ekr.20120229094652.14520"><vh>Removed unused color tags</vh></v>
<v t="ekr.20120229094652.15147"><vh>Fixed bug: End only goes to physical line</vh></v>
<v t="ekr.20120229094652.15146"><vh>Fixed bug 87933 with major key reorg</vh></v>
<v t="ekr.20120313074006.14648"><vh>Fixed Bug 930726 re expandNodeAndGoToFirstChild</vh></v>
<v t="ekr.20120313074006.14650"><vh>Fixed Bug 869429 (undo &amp; redo when deleting nodes from contextmenu)</vh></v>
<v t="ekr.20120313074006.14697"><vh>Fixed bug 924123: Some SyntaxError's thrown when compiling the whole source with Python 3</vh></v>
<v t="ekr.20120313074006.14702"><vh>Fixed bug 501636: Leo's import code should support non-ascii xml tags</vh></v>
<v t="ekr.20120313074006.14713"><vh>Fixed bug 799695: colorizer bug after move-lines-up into a docstring</vh></v>
<v t="ekr.20120313074006.14714"><vh>Fixed bug 824087: Alt+F4 is not the same as Alt+F, c</vh></v>
<v t="ekr.20120313074006.14715"><vh>Fixed bug 923301: Unicode error when executing 'rst3' command</vh></v>
<v t="ekr.20120313074006.14738"><vh>Fixed g.os_startfile on Linux</vh></v>
<v t="ekr.20120313074006.14800"><vh>Fixed Bug: multiple @language directive not colored correctly</vh></v>
<v t="ekr.20120313074006.14906"><vh>Fixed Bug: multiple @language directives mess up add-comments command</vh></v>
<v t="ekr.20120313074006.15120"><vh>Fixed bug 952365: Leo-Editor can't write a file created from the command line</vh></v>
<v t="ekr.20120313074006.15125"><vh>Fixed bug 951921: Opening myLeoSettings.leo can clutter the console unworthwhile messages</vh></v>
<v t="ekr.20120328102352.5897"><vh>Fixed crasher in flattenOutline</vh></v>
<v t="ekr.20120328102352.5899"><vh>Fix viewrendered crash</vh></v>
<v t="ekr.20120328102352.5900"><vh>Fixed most scrolling problem with multiple editors</vh></v>
<v t="ekr.20120328102352.5936"><vh>Ensure selected @test node is run</vh></v>
<v t="ekr.20120328102352.5938"><vh>fixed problem with file:/// url's on Windows</vh></v>
</v>
<v t="ekr.20120318075211.6166"><vh>Unfixed bugs</vh>
<v t="ekr.20120313074006.14698"><vh>Failed to fix bug 844953: copy-clone-pasted node appears in other tab</vh></v>
</v>
</v>
<v t="ekr.20120229094652.14518"><vh>Code improvements</vh>
<v t="ekr.20120229094652.15142"><vh>Leo's new classes</vh>
<v t="ekr.20120318075211.6168"><vh>LoadManager</vh></v>
<v t="ekr.20120318075211.6169"><vh>ModeController &amp; ModeInfo (not used yet)</vh></v>
<v t="ekr.20120318075211.6170"><vh>LogManager (not used yet)</vh></v>
<v t="ekr.20120318075211.6172"><vh>KeyStroke &amp; ShortcutInfo</vh></v>
<v t="ekr.20120318075211.6173"><vh>EditCommandsManager</vh></v>
</v>
<v t="ekr.20120318075211.6174"><vh>Most files now import just leo.core.leoGlobals</vh></v>
<v t="ekr.20120318075211.6175"><vh>Global switches are now all in leoGlobals.py</vh></v>
<v t="ekr.20120229094652.15138"><vh>version.py now uses bzr_version.py</vh></v>
<v t="ekr.20120229094652.15176"><vh>Minor</vh>
<v t="ekr.20120229094652.14522"><vh>Eliminated the low-level interface</vh></v>
<v t="ekr.20120229094652.14523"><vh>Removed unused cruft from high-level interface</vh></v>
<v t="ekr.20120229094652.14525"><vh>Unified the high-level interface</vh></v>
<v t="ekr.20120229094652.14526"><vh>Create properties for logCtrl &amp; bodyCtrl</vh></v>
<v t="ekr.20120229094652.14527"><vh>Added eventFilters to top-level frames</vh></v>
<v t="ekr.20120229094652.14528"><vh>Added log.orderedTabNames</vh></v>
<v t="ekr.20120229094652.14532"><vh>Created the TestManager class</vh></v>
<v t="ekr.20120229094652.14533"><vh>Created the LoadManager class (docs)</vh></v>
<v t="ekr.20120229094652.14534"><vh>Removed c argument from g.app.config getters</vh></v>
<v t="ekr.20120229094652.14535"><vh>Delay "reading settings" message until after signon</vh></v>
<v t="ekr.20120229094652.14538"><vh>Use at.readOneAtAutoNode instead of ic.readOneAtAutoNode</vh></v>
<v t="ekr.20120229094652.14578"><vh>Added p.positionAfterDeletedTree</vh></v>
<v t="ekr.20120229094652.14577"><vh>Removed Leo's old syntax coloring code</vh></v>
<v t="ekr.20120229094652.14583"><vh>Rewrote shell-command commands</vh></v>
<v t="ekr.20120229094652.14608"><vh>Added g.app.isExternalUnitTest</vh></v>
<v t="ekr.20120229094652.14611"><vh>Added c.config.set</vh></v>
<v t="ekr.20120229094652.14595"><vh>help-for-command now uses g.getDocStringFromFunction</vh></v>
</v>
<v t="ekr.20120229094652.15157"><vh>Investigations</vh>
<v t="ekr.20120229094652.15158"><vh>Investigated unicode problems with print</vh></v>
<v t="ekr.20120229094652.15159"><vh>Investigated autocomplete popup bug</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15162"><vh>Major new features</vh>
<v t="ekr.20120318075211.6167"><vh>Improved handling of URL's</vh></v>
<v t="ekr.20120229094652.14593"><vh>Tab completion shows all @command/@button commands</vh></v>
<v t="ekr.20120229094652.15093"><vh>Weightless unit testsing</vh></v>
<v t="ekr.20120313134250.14232"><vh>Leo's File:Open With command now works with Qt</vh></v>
<v t="ekr.20120229094652.14585"><vh>Added quick edit/save mode</vh></v>
<v t="ekr.20120229094652.15153"><vh>Detached windows</vh></v>
<v t="ekr.20120229094652.15135"><vh>The leoInspect module</vh></v>
<v t="ekr.20120313074006.14640"><vh>Instant abbreviations (~a)</vh></v>
</v>
<v t="ekr.20120229094652.15163"><vh>Minor new features</vh>
<v t="ekr.20120328102352.5946"><vh>Improved Leo's home page</vh></v>
<v t="ekr.20120229094652.14787"><vh>Generalized stylesheet handling</vh></v>
<v t="ekr.20120229094652.15151"><vh>Leo now raises a dialog on @ignore @&lt;file&gt; nodes</vh></v>
<v t="ekr.20120229094652.14596"><vh>@ignore now prevents local @button/@command node definitions</vh></v>
<v t="ekr.20120229094652.14592"><vh>Added support for tags in @button nodes</vh></v>
<v t="ekr.20120229094652.14610"><vh>bridgeController.initLeo now kills events if plugins not loaded</vh></v>
<v t="ekr.20120229094652.14607"><vh>Call unselect1 hook only once</vh></v>
<v t="ekr.20120229094652.14613"><vh>Improved scannerUnitTest</vh></v>
<v t="ekr.20120314095341.14216"><vh>Leo supports @ignore when scanning for @command and @button nodes.</vh></v>
<v t="ekr.20120229094652.14777"><vh>Support @ignore when installing @command/@button nodes</vh></v>
<v t="ekr.20120229094652.14541"><vh>set g.app.execute_script during script execution</vh></v>
<v t="ekr.20120229094652.14600"><vh>Support single-line nodes like &lt;node/&gt; xml import code</vh></v>
<v t="ekr.20120229094652.14576"><vh>The Find tab now scrolls</vh></v>
<v t="ekr.20120229094652.14621"><vh>Warn when importing/reading/writing @ignored nodes</vh></v>
<v t="ekr.20120229094652.14849"><vh>Disabled section-reference handling in @auto files</vh></v>
<v t="ekr.20120313074006.14772"><vh>Dragging a binary file to Leo creates an @url node</vh></v>
<v t="ekr.20120229094652.14612"><vh>Alt-left-arrow collapses all children when selecting the parent</vh></v>
<v t="ekr.20120313074006.14643"><vh>Reinstated warnings for conflicting definitions</vh></v>
<v t="ekr.20120229094652.14589"><vh>Searches from Leo's web pages now work</vh></v>
<v t="ekr.20120229094652.14601"><vh>Leo's home page now shows the latest postings from leo-editor.</vh></v>
<v t="ekr.20120328102352.5942"><vh>Alt-Home &amp; Alt-End collapse all possible nodes</vh></v>
</v>
<v t="ekr.20120229094652.15164"><vh>New &amp; improved commands</vh>
<v t="ekr.20120229094652.14590"><vh>Added @button split-defs</vh></v>
<v t="ekr.20120229094652.14544"><vh>Added beautify-c command</vh></v>
<v t="ekr.20120229094652.14545"><vh>Added c-to-python command</vh></v>
<v t="ekr.20120229094652.14625"><vh>Added clone-find-all-flattened command</vh></v>
<v t="ekr.20120229094652.15090"><vh>Added clone/move/delete-marked-nodes commands</vh></v>
<v t="ekr.20120229094652.14602"><vh>Added run-marked-unit-tests-locally/externally</vh></v>
<v t="ekr.20120229094652.14542"><vh>Added select-to-matching-bracket command</vh></v>
<v t="ekr.20120229094652.14616"><vh>Improved add/delete-comments</vh></v>
<v t="ekr.20120229094652.14581"><vh>Improved open command</vh></v>
<v t="ekr.20120229094652.15169"><vh>Improved page-up &amp; page-down commands</vh></v>
<v t="ekr.20120229094652.14622"><vh>Improved presentation of autocompletion list</vh></v>
<v t="ekr.20120229094652.14618"><vh>Improved print-bindings &amp; print-commands</vh></v>
<v t="ekr.20120313134250.14294"><vh>Improved rst3 command</vh></v>
<v t="ekr.20120229094652.14599"><vh>Improved word jumps/deletes</vh></v>
</v>
<v t="ekr.20120229094652.15165"><vh>Plugins</vh>
<v t="ekr.20120229094652.15091"><vh>Improved quicksearch plugin</vh></v>
<v t="ekr.20120313074006.16135"><vh>New bigdash plugin</vh></v>
<v t="ekr.20120229094652.14776"><vh>Removed scrolledmessage plugin</vh></v>
<v t="ekr.20120313074006.14655"><vh>vim and xemacs plugins now work smoothly with contextmenu plugin.</vh></v>
<v t="ekr.20120229094652.14540"><vh>Supported auto-hide in viewrendered plugin</vh></v>
</v>
<v t="ekr.20120229094652.15166"><vh>Scripts</vh>
<v t="ekr.20120229094652.14582"><vh>Improved create @auto nodes script</vh></v>
<v t="ekr.20120229094652.14567"><vh>Added import-org-mode script</vh></v>
<v t="ekr.20120229094652.15131"><vh>Code for displaying a function call hierarchy in Leo</vh>
<v t="ekr.20120229094652.15132"><vh>call tree</vh>
<v t="ekr.20120229094652.15133"><vh>displayCalltree</vh></v>
<v t="ekr.20120229094652.15134"><vh>trace session</vh></v>
</v>
</v>
<v t="ekr.20120229094652.14543"><vh>Improved recursive import script</vh></v>
<v t="ekr.20120229094652.15149"><vh>Replacing Qt stylesheets on the fly</vh></v>
<v t="ekr.20120229094652.15089"><vh>Terry added bookmark scripts</vh></v>
<v t="ekr.20120229173025.20633"><vh>Document Terry's magic refactor button</vh>
<v t="ekr.20120229173025.20635"><vh>@@button fac</vh></v>
</v>
<v t="ekr.20120229094652.15139"><vh>Changed calling signatures of g.openWithFileName and g.app.newCommander</vh></v>
<v t="ekr.20120229094652.19777"><vh>The open-with event now has a new format</vh></v>
</v>
<v t="ekr.20120229094652.15168"><vh>Settings</vh>
<v t="ekr.20120229094652.14615"><vh>Added @bool indent_added_comments setting</vh></v>
<v t="ekr.20120229094652.14606"><vh>Added @bool use_body_focus_border</vh></v>
<v t="ekr.20120229094652.14598"><vh>Added border around selected pane</vh></v>
<v t="ekr.20120229094652.14584"><vh>Added shell commands to Cmds menu</vh></v>
<v t="ekr.20120229094652.14619"><vh>Added show-decoration-selected: 1 to stylesheet</vh></v>
<v t="ekr.20120229094652.14620"><vh>Added stylesheets for Log &amp; Find tabs</vh></v>
<v t="ekr.20120229094652.15143"><vh>Eliminated the -c option</vh></v>
<v t="ekr.20120318075211.7524"><vh>New default settings for run unit tests commands</vh></v>
<v t="ekr.20120229094652.15140"><vh>New format for @openwith settings nodes</vh></v>
<v t="ekr.20120229094652.15144"><vh>New search order for leoSettings.leo &amp; myLeoSettings.leo</vh></v>
</v>
</v>
<v t="ekr.20130926053913.15855"><vh>4.11 Better abbreviations, many bug fixes</vh>
<v t="ekr.20131105110107.16836"><vh>Leo 4.11 final Release notes</vh>
<v t="ekr.20131105110107.16837"><vh>a1 and a2 releases</vh>
<v t="ekr.20131105110107.16838"><vh>Bugs</vh>
<v t="ekr.20131105110107.16839"><vh>Bugs: minor</vh>
<v t="ekr.20131105110107.16840"><vh>Clear previous focus-border after alt-tab</vh></v>
<v t="ekr.20131105110107.16841"><vh>Don't horizontally scroll body pane if word wrapping</vh></v>
<v t="ekr.20131105110107.16842"><vh>Execute selected script now works again</vh></v>
<v t="ekr.20131105110107.16843"><vh>Fixed activateMenu</vh></v>
<v t="ekr.20131105110107.16844"><vh>Fixed bug 1021849: typo in path for icon of desktop shortcut</vh></v>
<v t="ekr.20131105110107.16845"><vh>Fixed bug 1194209: Inconsistent Window Titles</vh></v>
<v t="ekr.20131105110107.16846"><vh>Fixed bug 879338: Global tables in leoApp.py should describe all languages known to the colorizer</vh></v>
<v t="ekr.20131105110107.16847"><vh>Fixed bug 971171: re .leoRecentFiles</vh></v>
<v t="ekr.20131105110107.16848"><vh>Fixed bug 981849: incorrect body content shown</vh></v>
<v t="ekr.20131105110107.16849"><vh>Fixed bug 998090: save file as doesn't remove entry from open file list</vh></v>
<v t="ekr.20131105110107.16850"><vh>Fixed bug: selected node was not always restored properly</vh></v>
<v t="ekr.20131105110107.16851"><vh>Fixed bugs 971166 &amp; 979142 re copy/paste</vh></v>
<v t="ekr.20131105110107.16852"><vh>Fixed crash after viewrendered-hide</vh></v>
<v t="ekr.20131105110107.16853"><vh>Fixed crasher in active_path.py</vh></v>
<v t="ekr.20131105110107.16854"><vh>Fixed crasher in flattenOutline</vh></v>
<v t="ekr.20131105110107.16855"><vh>Fixed crasher in leoBridge</vh></v>
<v t="ekr.20131105110107.16856"><vh>fixed crasher involving g.importFromPath</vh></v>
<v t="ekr.20131105110107.16857"><vh>Fixed failing unit tests in distro</vh></v>
<v t="ekr.20131105110107.16858"><vh>fixed get_fn in viewrendered plugin</vh></v>
<v t="ekr.20131105110107.16859"><vh>Fixed import problems discovered by importing 2to3</vh></v>
<v t="ekr.20131105110107.16860"><vh>Fixed missing search text bug</vh></v>
<v t="ekr.20131105110107.16861"><vh>fixed problem with file:/// url's on Windows</vh></v>
<v t="ekr.20131105110107.16862"><vh>Fixed problems with scrolling when saving</vh></v>
<v t="ekr.20131105110107.16863"><vh>Fixed scrolling problem with scrollwheel</vh></v>
<v t="ekr.20131105110107.16864"><vh>Fixed several problems with c-to-py command</vh></v>
<v t="ekr.20131105110107.16865"><vh>Fixed special cases of auto-completion of commands</vh></v>
<v t="ekr.20131105110107.16866"><vh>Fixed undo problems in headlines</vh></v>
<v t="ekr.20131105110107.16867"><vh>Increased the width of find/change text</vh></v>
<v t="ekr.20131105110107.16868"><vh>Made sure tab completion only happens on explicit tab</vh></v>
<v t="ekr.20131105110107.16869"><vh>Made sure the new load code loads plugins at most once</vh></v>
<v t="ekr.20131105110107.16870"><vh>Minimize scrolling during paste-text</vh></v>
<v t="ekr.20131105110107.16871"><vh>Restore focus on window activation</vh></v>
<v t="ekr.20131105110107.16872"><vh>Restored special case for run-selected-unit-tests</vh></v>
<v t="ekr.20131105110107.16873"><vh>Rewrote and tested at.deleteUnvisitedNodes</vh></v>
<v t="ekr.20131105110107.16874"><vh>Rewrote and tested p.deletePositionsInList</vh></v>
<v t="ekr.20131105110107.16875"><vh>Running unit tests no longer change the selected tab</vh></v>
<v t="ekr.20131105110107.16876"><vh>The @auto read code now catches failed asserts in import code.</vh></v>
<v t="ekr.20131105110107.16877"><vh>Wont Fix bug 903640: Import of Python files containing the strings "&lt;&lt;" and "&gt;&gt;" does not work</vh></v>
</v>
<v t="ekr.20131105110107.16878"><vh>Bugs: serious</vh>
<v t="ekr.20131105110107.16879"><vh>Added ubuntu only menu kludge</vh></v>
<v t="ekr.20131105110107.16880"><vh>Created a dummy tab when only one tab would otherwise be opened</vh></v>
<v t="ekr.20131105110107.16881"><vh>Fixed another scrolling bug</vh></v>
<v t="ekr.20131105110107.16882"><vh>Fixed bug 1184855: data loss with command line 'leo somefile.ext'</vh></v>
<v t="ekr.20131105110107.16883"><vh>Fixed scrolling problem with multiple editors</vh></v>
</v>
</v>
<v t="ekr.20131105110107.16884"><vh>Code</vh>
<v t="ekr.20131105110107.16885"><vh>Added c.deletePositionsInList</vh></v>
<v t="ekr.20131105110107.16886"><vh>Added c2 keyword arg to c.bringToFront</vh></v>
<v t="ekr.20131105110107.16887"><vh>Added default button to dialog methods</vh></v>
<v t="ekr.20131105110107.16888"><vh>Added external/leosax.py to leoPyRef.leo</vh></v>
<v t="ekr.20131105110107.16889"><vh>Added g.getActualColor</vh></v>
<v t="ekr.20131105110107.16890"><vh>Added g.restore_selection_range</vh></v>
<v t="ekr.20131105110107.16891"><vh>Added leo/extensions/sh.py</vh></v>
<v t="ekr.20131105110107.16892"><vh>Added local pylint suppressions</vh></v>
<v t="ekr.20131105110107.16893"><vh>baseNativeTree.onHeadChanged now truncates headlines</vh></v>
<v t="ekr.20131105110107.16894"><vh>Cached syntax coloring</vh></v>
<v t="ekr.20131105110107.16895"><vh>g.pdb now does qtGui stuff</vh></v>
<v t="ekr.20131105110107.16896"><vh>Improved g.trace</vh></v>
<v t="ekr.20131105110107.16897"><vh>Integrated free_layout into Leo's core</vh></v>
<v t="ekr.20131105110107.16898"><vh>Removed unused files from leo/modes directory</vh></v>
<v t="ekr.20131105110107.16899"><vh>SherlockTracer now shows returned values</vh></v>
</v>
<v t="ekr.20131105110107.16900"><vh>Contrib branch</vh>
<v t="ekr.20131105110107.16901"><vh>Dumping leo docs to excel</vh></v>
<v t="ekr.20131105110107.16902"><vh>Full text searches</vh></v>
<v t="ekr.20131105110107.16903"><vh>LeoReader: Leo as web app</vh></v>
<v t="ekr.20131105110107.16904"><vh>QML notebook</vh></v>
<v t="ekr.20131105110107.16905"><vh>Templates with macro expansions</vh></v>
</v>
<v t="ekr.20131105110107.16906"><vh>Commands: new and improved</vh>
<v t="ekr.20131105110107.16907"><vh>Added docstrings for all commands</vh></v>
<v t="ekr.20131105110107.16908"><vh>All viewrended commands now start with vr</vh></v>
<v t="ekr.20131105110107.16909"><vh>Allow periods before section names in headlines</vh></v>
<v t="ekr.20131105110107.16910"><vh>Alt-Home &amp; Alt-End collapse all possible nodes</vh></v>
<v t="ekr.20131105110107.16911"><vh>Ensure selected @test node is run</vh></v>
<v t="ekr.20131105110107.16912"><vh>Fixed dabbrev commands</vh></v>
<v t="ekr.20131105110107.16913"><vh>go-anywhere command (quicksearch plugin)</vh></v>
<v t="ekr.20131105110107.16914"><vh>Help commands now use &lt;pre&gt; formatting if docutils is not available</vh></v>
<v t="ekr.20131105110107.16915"><vh>help-for-command executes apropos commands</vh></v>
<v t="ekr.20131105110107.16916"><vh>help-for-python now uses vr window</vh></v>
<v t="ekr.20131105110107.16917"><vh>help-for-regular-expressions command</vh></v>
<v t="ekr.20131105110107.16918"><vh>Improved incremental search commands</vh></v>
<v t="ekr.20131105110107.16919"><vh>leoscreen-jump-to-error command</vh></v>
<v t="ekr.20131105110107.16920"><vh>normalize-whitespace</vh></v>
<v t="ekr.20131105110107.16921"><vh>parse-body command</vh></v>
<v t="ekr.20131105110107.16922"><vh>print-buttons command</vh></v>
<v t="ekr.20131105110107.16923"><vh>Refresh from disk menu command now refreshes all selected nodes</vh></v>
<v t="ekr.20131105110107.16924"><vh>Show all commands after &lt;alt-x&gt;&lt;tab&gt;</vh></v>
<v t="ekr.20131105110107.16925"><vh>vr-expand/contract commands</vh></v>
<v t="ekr.20131105110107.16926"><vh>zoom-in/out commands</vh></v>
</v>
<v t="ekr.20131105110107.16927"><vh>Gui improvements</vh>
<v t="ekr.20131105110107.16928"><vh>@wrap now suppresses horizontal scrolling</vh></v>
<v t="ekr.20131105110107.16929"><vh>All @button nodes now show call tips</vh></v>
<v t="ekr.20131105110107.16930"><vh>Change focus-border color depending on input state</vh></v>
<v t="ekr.20131105110107.16931"><vh>Dark colorizing theme</vh></v>
<v t="ekr.20131105110107.16932"><vh>Sublime Text 2 (A dark colorizing theme)</vh></v>
<v t="ekr.20131105110107.16933"><vh>Use ctrl-click to open url's</vh></v>
</v>
<v t="ekr.20131105110107.16934"><vh>New features</vh>
<v t="ekr.20131105110107.16935"><vh>About @testsetup</vh></v>
<v t="ekr.20131105110107.16936"><vh>Added support for @testclass</vh></v>
<v t="ekr.20131105110107.16937"><vh>Added support for sessions</vh></v>
<v t="ekr.20131105110107.16938"><vh>Allow cloned siblings</vh></v>
<v t="ekr.20131105110107.16939"><vh>Allow clones anywhere in @file nodes</vh></v>
<v t="ekr.20131105110107.16940"><vh>Major additions to abbreviations</vh></v>
<v t="ekr.20131105110107.16941"><vh>Major improvements made to abbreviations</vh></v>
<v t="ekr.20131105110107.16942"><vh>Warn if same .leo file open in another Leo instance</vh></v>
</v>
<v t="ekr.20131105110107.16943"><vh>New languages and importers</vh>
<v t="ekr.20131105110107.16944"><vh>Added importer for .otl files</vh></v>
<v t="ekr.20131105110107.16945"><vh>Added importer for .ipynb importer</vh></v>
<v t="ekr.20131105110107.16946"><vh>Added importer for TypeScript files</vh></v>
<v t="ekr.20131105110107.16947"><vh>Added importer for vimoutliner imports and @auto-otl</vh></v>
<v t="ekr.20131105110107.16948"><vh>Added support for clojure syntax coloring</vh></v>
</v>
<v t="ekr.20131105110107.16949"><vh>Plugins</vh>
<v t="ekr.20131105110107.16950"><vh>New plugins</vh>
<v t="ekr.20131105110107.16951"><vh>leomylyn.py</vh></v>
<v t="ekr.20131105110107.16952"><vh>printing.py</vh></v>
<v t="ekr.20131105110107.16953"><vh>screen_capture.py</vh></v>
<v t="ekr.20131105110107.16954"><vh>screencast.py</vh></v>
<v t="ekr.20131105110107.16955"><vh>timestamp.py</vh></v>
</v>
<v t="ekr.20131105110107.16956"><vh>Improved plugins</vh>
<v t="ekr.20131105110107.16957"><vh>bookmarks.py</vh></v>
<v t="ekr.20131105110107.16958"><vh>ipython.py</vh></v>
<v t="ekr.20131105110107.16959"><vh>valuespace.py</vh></v>
<v t="ekr.20131105110107.16960"><vh>viewrendered.py</vh></v>
</v>
</v>
<v t="ekr.20131105110107.16961"><vh>Revised IPython Bridge</vh></v>
<v t="ekr.20131105110107.16962"><vh>Scripts</vh>
<v t="ekr.20131105110107.16963"><vh>Full tree preview</vh></v>
</v>
<v t="ekr.20131105110107.16964"><vh>Settings &amp; options</vh></v>
<v t="ekr.20131105110107.16965"><vh>Web site improvements</vh></v>
</v>
<v t="ekr.20131105110107.16966"><vh>b1 release</vh>
<v t="ekr.20131105110107.16967"><vh>Greatly improved tutorials</vh></v>
<v t="ekr.20131105110107.16968"><vh>Code improvements</vh>
<v t="ekr.20131105110107.16969"><vh>Added c.recursiveImport and ic.recursiveImportController</vh></v>
<v t="ekr.20131105110107.16970"><vh>Added c.user_dict and g.user_dict</vh></v>
<v t="ekr.20131105110107.16971"><vh>Added strip_data argument to config.getData</vh></v>
<v t="ekr.20131105110107.16972"><vh>Improved abbreviations</vh></v>
<v t="ekr.20131105110107.16973"><vh>Removed unused binding &amp; gui code</vh></v>
<v t="ekr.20131105110107.16974"><vh>Simplified creation of event filters in qtGui.py</vh></v>
</v>
<v t="ekr.20131105110107.16975"><vh>Fixed bugs</vh>
<v t="ekr.20131105110107.16977"><vh>Fixed annoying reformat-paragraph bug</vh></v>
<v t="ekr.20131105110107.16978"><vh>Fixed autocompletion crasher</vh></v>
<v t="ekr.20131105110107.16979"><vh>Fixed bug  869385: Chapters make the nav_qt.py plugin useless</vh></v>
<v t="ekr.20131105110107.16980"><vh>Fixed bug  879338: Global tables in leoApp.py should describe all languages known</vh></v>
<v t="ekr.20131105110107.16981"><vh>Fixed bug 1019794: p.copyTreeFromSelfTo, chould deepcopy p.v.u</vh></v>
<v t="ekr.20131105110107.16982"><vh>Fixed bug 1028986: create relative urls when dragging binary files to Leo</vh></v>
<v t="ekr.20131105110107.16983"><vh>Fixed bug 1046195: character encoding changes when dragging outline between leo files</vh></v>
<v t="ekr.20131105110107.16984"><vh>Fixed bug 1046728: quickstart.leo 'auto nodes' example is not working</vh></v>
<v t="ekr.20131105110107.16985"><vh>Fixed bug 1074812: certain .leo file causes "IndexError: list index out of range"</vh></v>
<v t="ekr.20131105110107.16986"><vh>Fixed bug 1099035: Leo yank and kill behaviour not quite the same as emacs</vh></v>
<v t="ekr.20131105110107.16987"><vh>Fixed bug 1132821: Leo replaces a soft link with a real file</vh></v>
<v t="ekr.20131105110107.16988"><vh>Fixed bug 1160660: File-Compare-Leo-Files creates "other file" clones</vh></v>
<v t="ekr.20131105110107.16989"><vh>Fixed bug 1162307: Undoing a headline change does not change focus to the headline</vh></v>
<v t="ekr.20131105110107.16990"><vh>Fixed bug 1175013: leo/plugins/spellpyx.txt is both source controlled and customized</vh></v>
<v t="ekr.20131105110107.16991"><vh>Fixed bug 1182695: the tricky string that leo can not handle</vh></v>
<v t="ekr.20131105110107.16992"><vh>Fixed bug 1182864: goto-global-line cmd bug</vh></v>
<v t="ekr.20131105110107.16993"><vh>Fixed bug 1185409: importing binary files puts binary content in body editor</vh></v>
<v t="ekr.20131105110107.16994"><vh>Fixed bug 1193819: Script buttons cant "go to script" after outline changes</vh></v>
<v t="ekr.20131105110107.16995"><vh>Fixed bug 1193870 Delete Menu doesn't work in Qt</vh></v>
<v t="ekr.20131105110107.16996"><vh>Fixed bug 1208659 leo parsed the wrong line number of html file</vh></v>
<v t="ekr.20131105110107.16997"><vh>Fixed bug 1208942: Leo holding directory/file handles after file close?</vh></v>
<v t="ekr.20131105110107.16998"><vh>Fixed bug 1223383: Garbled text with BOM-marked files</vh>
<v t="ekr.20131105110107.16999"><vh> report</vh></v>
<v t="ekr.20131105110107.17000"><vh> what I did</vh></v>
</v>
<v t="ekr.20131105110107.17001"><vh>Fixed bug 1224586: Reorganizing @chapter nodes breaks chapter menu</vh></v>
<v t="ekr.20131105110107.17002"><vh>Fixed bug 1226358 File URL's are broken on MacOS</vh></v>
<v t="ekr.20131105110107.17003"><vh>Fixed bug 1226816: Command line "leo xxx.leo" creates file xxx.leo.leo</vh></v>
<v t="ekr.20131105110107.17004"><vh>Fixed bug 1229896: nav_qt traceback when node deleted</vh></v>
<v t="ekr.20131105110107.17005"><vh>Fixed bug in at.putCodeLine</vh></v>
<v t="ekr.20131105110107.17006"><vh>Fixed bugs 1183855 &amp; 1212332 involving missing select hooks</vh></v>
<v t="ekr.20131105110107.17007"><vh>Fixed docs re bug 1159302: Correcting and improving the "Open with" documentation</vh></v>
<v t="ekr.20131105110107.17008"><vh>Investigated bug  971171: re .leo/.leoRecentFiles.txt</vh></v>
<v t="ekr.20131105110107.17009"><vh>Investigated bug 1178249: url: file relative path does not work same way</vh></v>
<v t="ekr.20131105110107.17010"><vh>Investigated bug 1182694: not display unique in leo and other editor</vh></v>
<v t="ekr.20131105110107.17011"><vh>Investigated bug 1190778: ScriptFile.py not generating correctly (ignores text after @others)</vh></v>
<v t="ekr.20131105110107.17012"><vh>Investigated spell crash (already fixed)</vh></v>
<v t="ekr.20131105110107.17013"><vh>Fixed import problem in leoRst.py</vh></v>
<v t="ekr.20131105110107.17014"><vh>Fixed major bug in rst3 command</vh></v>
<v t="ekr.20131105110107.17015"><vh>Fixed Alt-Gr keys</vh></v>
<v t="ekr.20131105110107.17016"><vh>Alt-0 (vr-toggle) now puts focus in the body pane</vh></v>
<v t="ekr.20131105110107.17017"><vh>Fixed crasher in k.auto_completer_state_hander</vh></v>
<v t="ekr.20131105110107.17018"><vh>Fixed problems with c.save commands in the leoBridge</vh></v>
<v t="ekr.20131105110107.17019"><vh>Fixed bug 1168689 re ipython</vh></v>
<v t="ekr.20131105110107.17020"><vh>Fixed several window-sizing bugs</vh></v>
<v t="ekr.20131105110107.17021"><vh>Fixed bug 1243847: unicode error when saving @shadow nodes</vh></v>
<v t="ekr.20131105110107.17022"><vh>Fixed bug #1243855: @auto-rst doesn't save text</vh></v>
<v t="ekr.20131105110107.17023"><vh>--minimized now disables splash screen</vh></v>
<v t="ekr.20131105110107.17024"><vh>Fixed bug: 1168689 outdated documentation about ipython</vh></v>
<v t="ekr.20131105110107.17025"><vh>Fixed bug 1180186: debian install not documented well enough</vh></v>
</v>
<v t="ekr.20131105110107.17026"><vh>New commands, features &amp; settings</vh>
<v t="ekr.20131105110107.17027"><vh>Added @bool enable-tree-dragging to leoSettings.leo</vh></v>
<v t="ekr.20131105110107.17028"><vh>Added help text to the find panel</vh></v>
<v t="ekr.20131105110107.17029"><vh>Added yes-to-all button when prompting for dangerous writes</vh></v>
<v t="ekr.20131105110107.17030"><vh>Bound Alt-Ctrl-M for macro-call-last</vh></v>
<v t="ekr.20131105110107.17031"><vh>Copy cheatsheet.leo when creating workbook</vh></v>
<v t="ekr.20131105110107.17032"><vh>Created insert-node-before command &amp; p.insertBefore</vh></v>
<v t="ekr.20131105110107.17033"><vh>Revised help-for commands</vh></v>
</v>
<v t="ekr.20131105110107.17034"><vh>New plugins</vh></v>
</v>
<v t="ekr.20131105110107.17041"><vh>final release</vh>
<v t="ekr.20131105110107.17042"><vh>Improved reformat-paragraph</vh></v>
<v t="ekr.20131105110107.17043"><vh>Fixed bug: add/remove comments now handle ambiguous @language directives</vh></v>
<v t="ekr.20131105110107.17044"><vh>Fixed Haskell coloring problem</vh></v>
<v t="ekr.20131105110107.17045"><vh>Fixed text in Find Panel</vh></v>
<v t="ekr.20131105110107.17046"><vh>Investigated install problem</vh></v>
</v>
</v>
</v>
<v t="ekr.20131220065609.16614"><vh>4.11.1 Release notes</vh>
<v t="ekr.20131220065609.16634"><vh>Leo is now easier to use</vh>
<v t="ekr.20131221065129.16525"><vh>Added more intuitive key bindings</vh></v>
<v t="ekr.20131220065609.16619"><vh>Improved the Find tab</vh></v>
<v t="ekr.20131220065609.16638"><vh>Improved &amp; reorganized menus</vh></v>
<v t="ekr.20131220065609.16628"><vh>Simplified leoSettings.leo</vh></v>
<v t="ekr.20131220065609.16621"><vh>Added join-leo-irc command</vh></v>
<v t="ekr.20131220065609.17422"><vh>Added @data qt-gui-user-style-sheet</vh></v>
<v t="ekr.20131221065129.16526"><vh>Improved the print-bindigs command</vh></v>
<v t="ekr.20131222112420.16374"><vh>Added per-node expansions of cloned nodes</vh></v>
</v>
<v t="ekr.20131220065609.16635"><vh>Fixed bugs</vh>
<v t="ekr.20131220065609.16622"><vh>Allow comments after @data setting-name</vh></v>
<v t="ekr.20131220065609.16620"><vh>Got focus border working again</vh></v>
<v t="ekr.20131220065609.16623"><vh>Allow comment lines in @item nodes</vh></v>
<v t="ekr.20131220065609.16624"><vh>Improved debugging capabilities</vh></v>
<v t="ekr.20131220065609.16625"><vh>Improved tab pane</vh></v>
<v t="ekr.20131220065609.16626"><vh>Fixed greedy checkbox bug</vh></v>
<v t="ekr.20131220065609.16631"><vh>Fixed bug re Ctrl-A in minibuffer</vh></v>
<v t="ekr.20131220065609.16633"><vh>Changed frame.endEditLabelCommand</vh></v>
<v t="ekr.20131220065609.16616"><vh>fixed documentation of ctrl-tab</vh></v>
</v>
<v t="ekr.20131220065609.16636"><vh>Settings</vh>
<v t="ekr.20131220065609.16615"><vh>Added @bool force_execute_entire_body</vh></v>
<v t="ekr.20131220065609.16617"><vh>Added support for @outline-data</vh></v>
<v t="ekr.20131220065609.16618"><vh>Added support for @outline-data tree-abbreviations</vh></v>
</v>
<v t="ekr.20131220065609.16637"><vh>Plugins</vh>
<v t="ekr.20131220065609.16629"><vh>Added web-oriented bookmarks to mod_http plugin</vh></v>
</v>
</v>
<v t="davy.20141209154025.22"><vh>5.0 Plays well with others</vh>
<v t="davy.20141209154025.23"><vh>Leo 5.0-final release notes</vh>
<v t="davy.20141209154025.24"><vh>Highlights</vh>
<v t="davy.20141209154025.25"><vh>Better integration with Vim, Emacs &amp; pylint</vh>
<v t="davy.20141209154025.26"><vh>vim mode</vh></v>
<v t="davy.20141209154025.27"><vh>Better support for pylint</vh></v>
<v t="davy.20141209154025.28"><vh>Full support for org-mode (.org) and vimoutline (.otl) files</vh></v>
</v>
<v t="davy.20141209154025.29"><vh>Power features</vh>
<v t="davy.20141209154025.30"><vh>Added command history</vh></v>
<v t="davy.20141209154025.31"><vh>@data nodes can now be composed from a tree of nodes</vh></v>
<v t="davy.20141209154025.32"><vh>Clones expand and contract independently</vh></v>
<v t="davy.20141209154025.33"><vh>File name completion</vh></v>
<v t="davy.20141209154025.34"><vh>Better support for nodes containing large text</vh></v>
<v t="davy.20141209154025.35"><vh>Leo now colors text at idle time</vh></v>
<v t="davy.20141209154025.232"><vh>Fully parameterized style sheet</vh></v>
<v t="davy.20141209154025.37"><vh>The style-reload command changes Leo's appearance instantly</vh></v>
<v t="davy.20141209154025.38"><vh>A plugable architecture for @auto nodes</vh></v>
</v>
<v t="davy.20141209154025.39"><vh>Leo's default workbook contains Leo's quickstart guide</vh></v>
</v>
<v t="davy.20141209154025.40"><vh>Bugs fixed</vh>
<v t="davy.20141209154025.41"><vh>Bugs fixed in 5.0 final</vh>
<v t="davy.20141209154025.42"><vh>Removed *trailing* whitespace for import compares</vh></v>
<v t="davy.20141209154025.43"><vh>Don't horizontally scroll when pasting large text</vh></v>
<v t="davy.20141209154025.44"><vh>Fixed dart coloring</vh></v>
<v t="davy.20141209154025.45"><vh>Fixed bug 1158269: viewrendered pane goes blank when url clicked</vh></v>
<v t="davy.20141209154025.46"><vh>Status line fields are now read-only</vh></v>
<v t="davy.20141209154025.47"><vh>Fixed markdown unit test</vh></v>
<v t="davy.20141209154025.48"><vh>Fixed sessions crash</vh></v>
</v>
<v t="davy.20141209154025.49"><vh>Bugs fixed in 5.0rc1</vh>
<v t="davy.20141209154025.50"><vh>Fixed scrolling problem when expanding abbreviations</vh></v>
</v>
<v t="davy.20141209154025.51"><vh>Bugs fixed in 5.0b2</vh>
<v t="davy.20141209154025.52"><vh>Fixed bug  38: autocompleter gives a strange traceback</vh></v>
<v t="davy.20141209154025.53"><vh>Fixed bug  78?: find-next target not always scrolled into view</vh></v>
<v t="davy.20141209154025.54"><vh>Fixed bug  80: Find-previous fails at last node with mouse click</vh></v>
<v t="davy.20141209154025.55"><vh>Fixed bug 101: IPython issues</vh></v>
<v t="davy.20141209154025.56"><vh>Fixed bug 102: Loading @file node with embedded code broken</vh></v>
<v t="davy.20141209154025.57"><vh>Fixed bug 103: Installation Issues on Linux</vh></v>
<v t="davy.20141209154025.58"><vh>Installer window now shows version</vh></v>
<v t="davy.20141209154025.59"><vh>Investigated bug 66: support @path with md importer/writer/rclick</vh></v>
<v t="davy.20141209154025.60"><vh>Made sure the .json file is part of the .zip file.</vh></v>
</v>
<v t="davy.20141209154025.61"><vh>Bugs fixed in 5.0b1</vh>
<v t="davy.20141209154025.62"><vh>Fixed</vh>
<v t="davy.20141209154025.63"><vh>The spell checker handles apostrophes correctly</vh></v>
<v t="davy.20141209154025.64"><vh>fixed bug 1159490: "Open with" fails to copy changes by external editor back to Leo-Editor node</vh></v>
<v t="davy.20141209154025.65"><vh>Fixed bug 1338773: Autocompleter error</vh></v>
<v t="davy.20141209154025.66"><vh>Fixed bug 1338172: ReplaceAll will not replace newlines indicated as \n in target string</vh></v>
<v t="davy.20141209154025.67"><vh>Fixed bug 92: Tab loses focus when executing a button defined in an unopened settings file</vh></v>
<v t="davy.20141209154025.68"><vh>Fixed bug 66: errors inhibited read @auto foo.md</vh></v>
<v t="davy.20141209154025.69"><vh>Disable activate/deactivate logic</vh></v>
<v t="davy.20141209154025.70"><vh>fixed pythonw bug</vh></v>
</v>
</v>
<v t="davy.20141209154025.71"><vh>Bugs fixed in 5.0a2</vh></v>
<v t="davy.20141209154025.72"><vh>Bugs fixed in 5.0a1</vh>
<v t="davy.20141209154025.73"><vh>Fixed 14 github bugs</vh>
<v t="davy.20141209154025.74"><vh>Fixed bug 12: when hoisted, the (alt-)arrow keys can't navigate to the top node</vh></v>
<v t="davy.20141209154025.75"><vh>Fixed bug 28: Leo hangs when a node with too large body is selected</vh></v>
<v t="davy.20141209154025.76"><vh>Fixed bug 31: 'undo' on a freshly-loaded outline</vh></v>
<v t="davy.20141209154025.77"><vh>Fixed bug 35: leoBridge sometimes assigns the same GNX to two distinct vnodes</vh></v>
<v t="davy.20141209154025.78"><vh>Fixed bug 36: @auto file not found produces a script error</vh></v>
<v t="davy.20141209154025.79"><vh>Fixed bug 50: Important body text lost switching @file to @auto-rst</vh></v>
<v t="davy.20141209154025.80"><vh>Fixed bug 59: drag and drop: target too small</vh></v>
<v t="davy.20141209154025.81"><vh>Fixed bug 60: create relative paths &amp; urls when dragging files to Leo</vh></v>
<v t="davy.20141209154025.82"><vh>Fixed bug 63: refresh-from-disk does not clear big text load delay UI</vh></v>
<v t="davy.20141209154025.83"><vh>Fixed bug 64: https://github.com/leo-editor/leo-editor/issues/64</vh></v>
<v t="davy.20141209154025.84"><vh>Fixed bug 74: problems with @button if defined in myLeoSettings.leo</vh></v>
<v t="davy.20141209154025.85"><vh>Fixed bug 75: write-opml-file always produces an empty file</vh></v>
<v t="davy.20141209154025.86"><vh>Fixed bug 76: erroneous clone markers in @auto trees</vh></v>
<v t="davy.20141209154025.87"><vh>Fixed bug 78: F3 find-next target not always highlighted</vh></v>
</v>
<v t="davy.20141209154025.88"><vh>Fixed 20+ Launchpad bugs</vh>
<v t="davy.20141209154025.89"><vh>Fixed bug 1028986: create relative urls when dragging binary files to Leo</vh></v>
<v t="davy.20141209154025.90"><vh>Fixed bug 1041906: underlying C/C++ object has been deleted</vh></v>
<v t="davy.20141209154025.91"><vh>Fixed bug 1090950: refresh from disk - cut node resurrection</vh></v>
<v t="davy.20141209154025.92"><vh>Fixed bug 1185933: insert-headline-time should insert at cursor</vh></v>
<v t="davy.20141209154025.93"><vh>Fixed bug 1228312: Find tab selected in log pane disables Minibuffer</vh></v>
<v t="davy.20141209154025.94"><vh>Fixed bug 1228452: related to the radio buttons in the Find pane</vh></v>
<v t="davy.20141209154025.95"><vh>Fixed bug 1228458: Inconsistency between Find-forward and Find-backward</vh></v>
<v t="davy.20141209154025.96"><vh>Fixed bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented</vh></v>
<v t="davy.20141209154025.97"><vh>Fixed bug 1244461: Numpad 'Enter' key does not work in minibuffer</vh></v>
<v t="davy.20141209154025.98"><vh>Fixed bug 1245535: API allows headlines to contain newlines</vh></v>
<v t="davy.20141209154025.99"><vh>Fixed bug 1245616: Autocomplete ? function...does not work</vh></v>
<v t="davy.20141209154025.100"><vh>Fixed bug 1251252: Minibuffer commands created by mod_scripting.py have no docstrings</vh></v>
<v t="davy.20141209154025.101"><vh>Fixed bug 1254861: Ctrl-f doesn't ensure find input field visible</vh></v>
<v t="davy.20141209154025.102"><vh>Fixed bug 1258373: failed find focus fails</vh></v>
<v t="davy.20141209154025.103"><vh>Fixed bug 1260415: exception writing external files" is insufficient</vh></v>
<v t="davy.20141209154025.104"><vh>Fixed bug 1264350: Up-arrow on the first node in a chapter switches to another chapter </vh></v>
<v t="davy.20141209154025.105"><vh>Fixed bug 1267921: isearch-forward accepts non-alphanumeric keys as input</vh></v>
<v t="davy.20141209154025.106"><vh>Fixed bug 1276236: unicode problem in the log pane</vh></v>
<v t="davy.20141209154025.107"><vh>Fixed bug 613153: unable to describe root directory on thumb drive</vh></v>
<v t="davy.20141209154025.108"><vh>Fixed bug 735938: file association crash</vh></v>
<v t="davy.20141209154025.109"><vh>Fixed bug 969391: setup.py confuses newbies</vh></v>
</v>
<v t="davy.20141209154025.110"><vh>Fixed 30+ other bugs</vh>
<v t="davy.20141209154025.111"><vh>eliminated "can not exedute commands from headlines"</vh></v>
<v t="davy.20141209154025.112"><vh>find-all now uses exising find pattern</vh></v>
<v t="davy.20141209154025.113"><vh>Fixed a startup error involving --ipython</vh></v>
<v t="davy.20141209154025.114"><vh>Fixed annoyance: shift-ctrl-w leaves .leo file as dirty</vh></v>
<v t="davy.20141209154025.115"><vh>Fixed autocompleter bug</vh></v>
<v t="davy.20141209154025.116"><vh>Fixed bug re the factor language</vh></v>
<v t="davy.20141209154025.117"><vh>Fixed bug: activate events now properly restore focus</vh></v>
<v t="davy.20141209154025.118"><vh>Fixed bug: Find-previous fails at last node</vh></v>
<v t="davy.20141209154025.119"><vh>Fixed clone-find-all command</vh></v>
<v t="davy.20141209154025.120"><vh>Fixed Crash deleting body editor</vh></v>
<v t="davy.20141209154025.121"><vh>Fixed find bug</vh></v>
<v t="davy.20141209154025.122"><vh>Fixed important security hole in mod_scripting plugin</vh></v>
<v t="davy.20141209154025.123"><vh>Fixed leoGlobals bug (per Reinhard Engle)</vh></v>
<v t="davy.20141209154025.124"><vh>Fixed modes/md.py</vh></v>
<v t="davy.20141209154025.125"><vh>Fixed problem with 1-character reverse searches!</vh></v>
<v t="davy.20141209154025.126"><vh>Fixed problems with clone-expansion</vh></v>
<v t="davy.20141209154025.127"><vh>Fixed QCompleter bug</vh></v>
<v t="davy.20141209154025.128"><vh>Fixed recent bug in change command</vh></v>
<v t="davy.20141209154025.129"><vh>Fixed recursive import bug</vh></v>
<v t="davy.20141209154025.130"><vh>Fixed serious bug in c.deletePositionsInList</vh></v>
<v t="davy.20141209154025.131"><vh>Fixed several crashers re no-to-all during startup</vh></v>
<v t="davy.20141209154025.132"><vh>Fixed suboutline only find bug</vh></v>
<v t="davy.20141209154025.133"><vh>Fixed tab cycling</vh></v>
<v t="davy.20141209154025.134"><vh>Fixed tab-completion problems</vh></v>
<v t="davy.20141209154025.135"><vh>Fixed unwanted scrolling in abbreviations</vh></v>
<v t="davy.20141209154025.136"><vh>Gave the Find Tab the intended amount of border</vh></v>
<v t="davy.20141209154025.137"><vh>Improved ctrl-o code</vh></v>
<v t="davy.20141209154025.138"><vh>Investigated bug: fill-region &amp; format-body can hang</vh></v>
<v t="davy.20141209154025.139"><vh>Made beautify commands compatible with pep8</vh></v>
<v t="davy.20141209154025.140"><vh>Re-enabled command completion for @button commands</vh></v>
<v t="davy.20141209154025.141"><vh>Reported QTextEdit bug</vh></v>
<v t="davy.20141209154025.142"><vh>Set the default syntax color for operators to black</vh></v>
<v t="davy.20141209154025.143"><vh>Suppressed duplicate console messages</vh></v>
<v t="davy.20141209154025.144"><vh>Worked around a strange PyQt5 bug in LeoQtGui.runSaveFileDialog</vh></v>
</v>
</v>
<v t="davy.20141209154025.145"><vh>Invalid/won't fix</vh>
<v t="davy.20141209154025.146"><vh>5.0b1</vh>
<v t="davy.20141209154025.147"><vh>Invalid bug 1286909: Settings in file A propagate to file B when editing A and B is opened</vh></v>
<v t="davy.20141209154025.148"><vh>Investigated bug 1240786: Corner case bug in tab-cycle-next and tab-cycle-previous</vh></v>
<v t="davy.20141209154025.149"><vh>Investigated bug 1249684: "add body editor" adds editor pane in wrong tab</vh></v>
<v t="davy.20141209154025.150"><vh>Investigated bug 1258302: Window, Toggle Split Direction Error</vh></v>
<v t="davy.20141209154025.151"><vh>Investigated bug 1269540: File importing problems: Path doesn't properly appear as node header</vh></v>
<v t="davy.20141209154025.152"><vh>Investigated bug 1286914: A custom menu that seems correct, but does nothing</vh></v>
<v t="davy.20141209154025.153"><vh>Won't fix bug 1286913: After the "menu already exists"...</vh></v>
<v t="davy.20141209154025.154"><vh>Won't fix bug 1292207: Disabling Plugins disables menu actions</vh></v>
<v t="davy.20141209154025.155"><vh>Won't fix bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display</vh></v>
</v>
<v t="davy.20141209154025.156"><vh>5.0a1</vh>
<v t="davy.20141209154025.157"><vh>Cleared bug 1228457: Beginning find at the current node's body cursor when that cursor is not displayed</vh></v>
<v t="davy.20141209154025.158"><vh>Cleared bug 1228713: Find-backward skips headlines under some conditions</vh></v>
<v t="davy.20141209154025.159"><vh>Cleared bug 1254864: Can't search from current cursor position downward in body text</vh></v>
<v t="davy.20141209154025.160"><vh>Investigated bug  524890: Incomplete derived file</vh></v>
<v t="davy.20141209154025.161"><vh>Investigated bug 1177355: node-only wrapped search does not work in long nodes</vh></v>
<v t="davy.20141209154025.162"><vh>Investigated bug 1193820: Focus change on tree pane after saving current Leo file</vh></v>
<v t="davy.20141209154025.163"><vh>Investigated bug 1266269: Mac: alt-x does not work in body pane</vh></v>
<v t="davy.20141209154025.164"><vh>Investigated bug 1268970: Leo does not remember window maximized state</vh></v>
<v t="davy.20141209154025.165"><vh>Investigated bug 1282362: shadow file name collisions cause spontaneous clone creation</vh></v>
<v t="davy.20141209154025.166"><vh>Investigated bug 869098: Context menu settings lost if save as used</vh></v>
</v>
</v>
</v>
<v t="davy.20141209154025.167"><vh>Code</vh>
<v t="davy.20141209154025.168"><vh>A beautiful and general design pattern</vh></v>
<v t="davy.20141209154025.169"><vh>A major reorg of Leo's code</vh></v>
<v t="davy.20141209154025.170"><vh>Added support for qt5</vh></v>
<v t="davy.20141209154025.171"><vh>added the IdleTime class</vh></v>
<v t="davy.20141209154025.172"><vh>All unit tests now pass when run externally</vh></v>
<v t="davy.20141209154025.173"><vh>API changes</vh></v>
<v t="davy.20141209154025.174"><vh>Changed most calls to k.setLabel to k.setStatusLabel</vh></v>
<v t="davy.20141209154025.175"><vh>Cleaned up command-name handling a bit</vh></v>
<v t="davy.20141209154025.176"><vh>code: regularized .wrapper and .widget ivars</vh></v>
<v t="davy.20141209154025.177"><vh>Completed generalization of importers</vh></v>
<v t="davy.20141209154025.178"><vh>Created g.IdleTime and qtGui.IdleTime</vh></v>
<v t="davy.20141209154025.179"><vh>Delayed allocation of gnx's...</vh></v>
<v t="davy.20141209154025.180"><vh>Delayed allocation of vnodes</vh></v>
<v t="davy.20141209154025.181"><vh>Improved idle-time handling</vh></v>
<v t="davy.20141209154025.182"><vh>Improved p.isAncestorOf and c.positionExists</vh></v>
<v t="davy.20141209154025.183"><vh>Improved speed of selection logic</vh></v>
<v t="davy.20141209154025.184"><vh>Leo imports importers &amp; writers from home/.leo</vh>
<v t="davy.20141209154025.185"><vh> demo script</vh></v>
</v>
<v t="davy.20141209154025.186"><vh>Leo now uses a new xml namespace</vh></v>
<v t="davy.20141209154025.187"><vh>Rewrote &amp; simplified k.getArg</vh></v>
<v t="davy.20141209154025.188"><vh>Simplified gnx scan logic</vh></v>
<v t="davy.20141209154025.189"><vh>Split qtGui.py into separate files</vh></v>
<v t="davy.20141209154025.190"><vh>The @auto write code now uses writer plugins</vh></v>
<v t="davy.20141209154025.191"><vh>Wanted: w.getTextLength and p/v.get_b_length</vh></v>
<v t="davy.20141209154025.192"><vh>c.executeScript adds '.' to sys.path</vh></v>
</v>
<v t="davy.20141209154025.193"><vh>Features</vh>
<v t="davy.20141209154025.194"><vh>New commands</vh>
<v t="davy.20141209154025.195"><vh>Added focus-to-find/spell commands</vh></v>
<v t="davy.20141209154025.196"><vh>Added clone-find-parents command</vh></v>
<v t="davy.20141209154025.197"><vh>Added clone-to-last-node</vh></v>
<v t="davy.20141209154025.198"><vh>Added flatten-outline-to-node</vh></v>
<v t="davy.20141209154025.199"><vh>Added help-for-drag-and-drop command</vh></v>
<v t="davy.20141209154025.200"><vh>Added idle-time commands</vh></v>
<v t="davy.20141209154025.201"><vh>Added insert-file-name command</vh></v>
<v t="davy.20141209154025.202"><vh>Added pylint command</vh></v>
<v t="davy.20141209154025.203"><vh>Added spell-as-you-type commands</vh></v>
</v>
<v t="davy.20141209154025.204"><vh>Improved commands</vh>
<v t="davy.20141209154025.205"><vh>Improved find/replace-all commands</vh></v>
<v t="davy.20141209154025.206"><vh>(Optional) beautify command now uses PythonTidy</vh></v>
<v t="davy.20141209154025.207"><vh>Improved check outline</vh></v>
<v t="davy.20141209154025.208"><vh>Added Yes To All and No To All buttons to dialogs</vh></v>
<v t="davy.20141209154025.209"><vh>Added more files to pylint -a &amp; -p</vh></v>
<v t="davy.20141209154025.210"><vh>The clean-all-lines command strips trailing whitespace</vh></v>
</v>
<v t="davy.20141209154025.211"><vh>Other features</vh>
<v t="davy.20141209154025.212"><vh>Added some support for scintilla</vh></v>
<v t="davy.20141209154025.213"><vh>Added support for dart language</vh></v>
<v t="davy.20141209154025.214"><vh>Added support for delegate languages</vh></v>
<v t="davy.20141209154025.215"><vh>Added warning buttons when selecting large text</vh></v>
<v t="davy.20141209154025.216"><vh>Eliminated cycle-all-focus command</vh></v>
<v t="davy.20141209154025.217"><vh>Removed stand-alone globals</vh></v>
</v>
</v>
<v t="davy.20141209154025.218"><vh>Plugins &amp; leo/external </vh>
<v t="davy.20141209154025.219"><vh>Added livecode plugin</vh></v>
<v t="davy.20141209154025.220"><vh>Added nodetags.py plugin</vh></v>
<v t="davy.20141209154025.221"><vh>Added viewrendered2 plugin</vh></v>
<v t="davy.20141209154025.222"><vh>Added wikiview plugin</vh></v>
<v t="davy.20141209154025.223"><vh>Converted 7 plugins so they work with PyQt5</vh></v>
<v t="davy.20141209154025.224"><vh>leo/external/leoftsindex.py</vh></v>
<v t="davy.20141209154025.225"><vh>Rewrote at_produce plugin</vh></v>
</v>
<v t="davy.20141209154025.226"><vh>Settings &amp; command-line options</vh>
<v t="davy.20141209154025.227"><vh>Added --no-persist command-line option</vh></v>
<v t="davy.20141209154025.228"><vh>Added --trace-plugins option</vh></v>
<v t="davy.20141209154025.229"><vh>Added @int max-pre-loaded-body-chars</vh></v>
<v t="davy.20141209154025.230"><vh>Added @bool auto-scroll-find-tab</vh></v>
<v t="davy.20141209154025.231"><vh>Added support for html handlebar syntax coloring</vh></v>
<v t="davy.20141209154025.232"></v>
<v t="davy.20141209154025.233"><vh>Leo stylesheets now support all color names in leoColor.py</vh></v>
</v>
</v>
<v t="davy.20141209154025.234"><vh>Leo 5.0b2 release notes</vh>
<v t="davy.20141209154025.235"><vh>Highlights</vh>
<v t="davy.20141209154025.236"><vh>Better integration with Vim, Emacs &amp; pylint</vh>
<v t="davy.20141209154025.237"><vh>vim mode</vh></v>
<v t="davy.20141209154025.238"><vh>Better support for pylint</vh></v>
<v t="davy.20141209154025.239"><vh>Full support for org-mode (.org) and vimoutline (.otl) files</vh></v>
</v>
<v t="davy.20141209154025.240"><vh>Power features</vh>
<v t="davy.20141209154025.241"><vh>Added command history</vh></v>
<v t="davy.20141209154025.242"><vh>@data nodes can now be composed from a tree of nodes</vh></v>
<v t="davy.20141209154025.243"><vh>Clones expand and contract independently</vh></v>
<v t="davy.20141209154025.244"><vh>File name completion</vh></v>
<v t="davy.20141209154025.245"><vh>Better support for nodes containing large text</vh></v>
<v t="davy.20141209154025.246"><vh>Leo now colors text at idle time</vh></v>
<v t="davy.20141209154025.433"><vh>Fully parameterized style sheet</vh></v>
<v t="davy.20141209154025.248"><vh>The style-reload command changes Leo's appearance instantly</vh></v>
<v t="davy.20141209154025.249"><vh>A plugable architecture for @auto nodes</vh></v>
</v>
<v t="davy.20141209154025.250"><vh>Leo's default workbook contains Leo's quickstart guide</vh></v>
</v>
<v t="davy.20141209154025.251"><vh>Bugs fixed</vh>
<v t="davy.20141209154025.252"><vh>Bugs fixed in 5.0b2</vh>
<v t="davy.20141209154025.253"><vh>Fixed bug  38: autocompleter gives a strange traceback</vh></v>
<v t="davy.20141209154025.254"><vh>Fixed bug  78?: find-next target not always scrolled into view</vh></v>
<v t="davy.20141209154025.255"><vh>Fixed bug  80: Find-previous fails at last node with mouse click</vh></v>
<v t="davy.20141209154025.256"><vh>Fixed bug 101: IPython issues</vh></v>
<v t="davy.20141209154025.257"><vh>Fixed bug 102: Loading @file node with embedded code broken</vh></v>
<v t="davy.20141209154025.258"><vh>Fixed bug 103: Installation Issues on Linux</vh></v>
<v t="davy.20141209154025.259"><vh>Installer window now shows version</vh></v>
<v t="davy.20141209154025.260"><vh>Investigated bug 66: support @path with md importer/writer/rclick</vh></v>
<v t="davy.20141209154025.261"><vh>Made sure the .json file is part of the .zip file.</vh></v>
</v>
<v t="davy.20141209154025.262"><vh>Bugs fixed in 5.0b1</vh>
<v t="davy.20141209154025.263"><vh>Fixed</vh>
<v t="davy.20141209154025.264"><vh>The spell checker handles apostrophes correctly</vh></v>
<v t="davy.20141209154025.265"><vh>fixed bug 1159490: "Open with" fails to copy changes by external editor back to Leo-Editor node</vh></v>
<v t="davy.20141209154025.266"><vh>Fixed bug 1338773: Autocompleter error</vh></v>
<v t="davy.20141209154025.267"><vh>Fixed bug 1338172: ReplaceAll will not replace newlines indicated as \n in target string</vh></v>
<v t="davy.20141209154025.268"><vh>Fixed bug 92: Tab loses focus when executing a button defined in an unopened settings file</vh></v>
<v t="davy.20141209154025.269"><vh>Fixed bug 66: errors inhibited read @auto foo.md</vh></v>
<v t="davy.20141209154025.270"><vh>Disable activate/deactivate logic</vh></v>
<v t="davy.20141209154025.271"><vh>fixed pythonw bug</vh></v>
</v>
</v>
<v t="davy.20141209154025.272"><vh>Bugs fixed in 5.0a2</vh></v>
<v t="davy.20141209154025.273"><vh>Bugs fixed in 5.0a1</vh>
<v t="davy.20141209154025.274"><vh>Fixed 14 github bugs</vh>
<v t="davy.20141209154025.275"><vh>Fixed bug 12: when hoisted, the (alt-)arrow keys can't navigate to the top node</vh></v>
<v t="davy.20141209154025.276"><vh>Fixed bug 28: Leo hangs when a node with too large body is selected</vh></v>
<v t="davy.20141209154025.277"><vh>Fixed bug 31: 'undo' on a freshly-loaded outline</vh></v>
<v t="davy.20141209154025.278"><vh>Fixed bug 35: leoBridge sometimes assigns the same GNX to two distinct vnodes</vh></v>
<v t="davy.20141209154025.279"><vh>Fixed bug 36: @auto file not found produces a script error</vh></v>
<v t="davy.20141209154025.280"><vh>Fixed bug 50: Important body text lost switching @file to @auto-rst</vh></v>
<v t="davy.20141209154025.281"><vh>Fixed bug 59: drag and drop: target too small</vh></v>
<v t="davy.20141209154025.282"><vh>Fixed bug 60: create relative paths &amp; urls when dragging files to Leo</vh></v>
<v t="davy.20141209154025.283"><vh>Fixed bug 63: refresh-from-disk does not clear big text load delay UI</vh></v>
<v t="davy.20141209154025.284"><vh>Fixed bug 64: https://github.com/leo-editor/leo-editor/issues/64</vh></v>
<v t="davy.20141209154025.285"><vh>Fixed bug 74: problems with @button if defined in myLeoSettings.leo</vh></v>
<v t="davy.20141209154025.286"><vh>Fixed bug 75: write-opml-file always produces an empty file</vh></v>
<v t="davy.20141209154025.287"><vh>Fixed bug 76: erroneous clone markers in @auto trees</vh></v>
<v t="davy.20141209154025.288"><vh>Fixed bug 78: F3 find-next target not always highlighted</vh></v>
</v>
<v t="davy.20141209154025.289"><vh>Fixed 20+ Launchpad bugs</vh>
<v t="davy.20141209154025.290"><vh>Fixed bug 1028986: create relative urls when dragging binary files to Leo</vh></v>
<v t="davy.20141209154025.291"><vh>Fixed bug 1041906: underlying C/C++ object has been deleted</vh></v>
<v t="davy.20141209154025.292"><vh>Fixed bug 1090950: refresh from disk - cut node resurrection</vh></v>
<v t="davy.20141209154025.293"><vh>Fixed bug 1185933: insert-headline-time should insert at cursor</vh></v>
<v t="davy.20141209154025.294"><vh>Fixed bug 1228312: Find tab selected in log pane disables Minibuffer</vh></v>
<v t="davy.20141209154025.295"><vh>Fixed bug 1228452: related to the radio buttons in the Find pane</vh></v>
<v t="davy.20141209154025.296"><vh>Fixed bug 1228458: Inconsistency between Find-forward and Find-backward</vh></v>
<v t="davy.20141209154025.297"><vh>Fixed bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented</vh></v>
<v t="davy.20141209154025.298"><vh>Fixed bug 1244461: Numpad 'Enter' key does not work in minibuffer</vh></v>
<v t="davy.20141209154025.299"><vh>Fixed bug 1245535: API allows headlines to contain newlines</vh></v>
<v t="davy.20141209154025.300"><vh>Fixed bug 1245616: Autocomplete ? function...does not work</vh></v>
<v t="davy.20141209154025.301"><vh>Fixed bug 1251252: Minibuffer commands created by mod_scripting.py have no docstrings</vh></v>
<v t="davy.20141209154025.302"><vh>Fixed bug 1254861: Ctrl-f doesn't ensure find input field visible</vh></v>
<v t="davy.20141209154025.303"><vh>Fixed bug 1258373: failed find focus fails</vh></v>
<v t="davy.20141209154025.304"><vh>Fixed bug 1260415: exception writing external files" is insufficient</vh></v>
<v t="davy.20141209154025.305"><vh>Fixed bug 1264350: Up-arrow on the first node in a chapter switches to another chapter</vh></v>
<v t="davy.20141209154025.306"><vh>Fixed bug 1267921: isearch-forward accepts non-alphanumeric keys as input</vh></v>
<v t="davy.20141209154025.307"><vh>Fixed bug 1276236: unicode problem in the log pane</vh></v>
<v t="davy.20141209154025.308"><vh>Fixed bug 613153: unable to describe root directory on thumb drive</vh></v>
<v t="davy.20141209154025.309"><vh>Fixed bug 735938: file association crash</vh></v>
<v t="davy.20141209154025.310"><vh>Fixed bug 969391: setup.py confuses newbies</vh></v>
</v>
<v t="davy.20141209154025.311"><vh>Fixed 30+ other bugs</vh>
<v t="davy.20141209154025.312"><vh>eliminated "can not exedute commands from headlines"</vh></v>
<v t="davy.20141209154025.313"><vh>find-all now uses exising find pattern</vh></v>
<v t="davy.20141209154025.314"><vh>Fixed a startup error involving --ipython</vh></v>
<v t="davy.20141209154025.315"><vh>Fixed annoyance: shift-ctrl-w leaves .leo file as dirty</vh></v>
<v t="davy.20141209154025.316"><vh>Fixed autocompleter bug</vh></v>
<v t="davy.20141209154025.317"><vh>Fixed bug re the factor language</vh></v>
<v t="davy.20141209154025.318"><vh>Fixed bug: activate events now properly restore focus</vh></v>
<v t="davy.20141209154025.319"><vh>Fixed bug: Find-previous fails at last node</vh></v>
<v t="davy.20141209154025.320"><vh>Fixed clone-find-all command</vh></v>
<v t="davy.20141209154025.321"><vh>Fixed Crash deleting body editor</vh></v>
<v t="davy.20141209154025.322"><vh>Fixed find bug</vh></v>
<v t="davy.20141209154025.323"><vh>Fixed important security hole in mod_scripting plugin</vh></v>
<v t="davy.20141209154025.324"><vh>Fixed leoGlobals bug (per Reinhard Engle)</vh></v>
<v t="davy.20141209154025.325"><vh>Fixed modes/md.py</vh></v>
<v t="davy.20141209154025.326"><vh>Fixed problem with 1-character reverse searches!</vh></v>
<v t="davy.20141209154025.327"><vh>Fixed problems with clone-expansion</vh></v>
<v t="davy.20141209154025.328"><vh>Fixed QCompleter bug</vh></v>
<v t="davy.20141209154025.329"><vh>Fixed recent bug in change command</vh></v>
<v t="davy.20141209154025.330"><vh>Fixed recursive import bug</vh></v>
<v t="davy.20141209154025.331"><vh>Fixed serious bug in c.deletePositionsInList</vh></v>
<v t="davy.20141209154025.332"><vh>Fixed several crashers re no-to-all during startup</vh></v>
<v t="davy.20141209154025.333"><vh>Fixed suboutline only find bug</vh></v>
<v t="davy.20141209154025.334"><vh>Fixed tab cycling</vh></v>
<v t="davy.20141209154025.335"><vh>Fixed tab-completion problems</vh></v>
<v t="davy.20141209154025.336"><vh>Fixed unwanted scrolling in abbreviations</vh></v>
<v t="davy.20141209154025.337"><vh>Gave the Find Tab the intended amount of border</vh></v>
<v t="davy.20141209154025.338"><vh>Improved ctrl-o code</vh></v>
<v t="davy.20141209154025.339"><vh>Investigated bug: fill-region &amp; format-body can hang</vh></v>
<v t="davy.20141209154025.340"><vh>Made beautify commands compatible with pep8</vh></v>
<v t="davy.20141209154025.341"><vh>Re-enabled command completion for @button commands</vh></v>
<v t="davy.20141209154025.342"><vh>Reported QTextEdit bug</vh></v>
<v t="davy.20141209154025.343"><vh>Set the default syntax color for operators to black</vh></v>
<v t="davy.20141209154025.344"><vh>Suppressed duplicate console messages</vh></v>
<v t="davy.20141209154025.345"><vh>Worked around a strange PyQt5 bug in LeoQtGui.runSaveFileDialog</vh></v>
</v>
</v>
<v t="davy.20141209154025.346"><vh>Invalid/won't fix</vh>
<v t="davy.20141209154025.347"><vh>5.0b1</vh>
<v t="davy.20141209154025.348"><vh>Invalid bug 1286909: Settings in file A propagate to file B when editing A and B is opened</vh></v>
<v t="davy.20141209154025.349"><vh>Investigated bug 1240786: Corner case bug in tab-cycle-next and tab-cycle-previous</vh></v>
<v t="davy.20141209154025.350"><vh>Investigated bug 1249684: "add body editor" adds editor pane in wrong tab</vh></v>
<v t="davy.20141209154025.351"><vh>Investigated bug 1258302: Window, Toggle Split Direction Error</vh></v>
<v t="davy.20141209154025.352"><vh>Investigated bug 1269540: File importing problems: Path doesn't properly appear as node header</vh></v>
<v t="davy.20141209154025.353"><vh>Investigated bug 1286914: A custom menu that seems correct, but does nothing</vh></v>
<v t="davy.20141209154025.354"><vh>Won't fix bug 1286913: After the "menu already exists"...</vh></v>
<v t="davy.20141209154025.355"><vh>Won't fix bug 1292207: Disabling Plugins disables menu actions</vh></v>
<v t="davy.20141209154025.356"><vh>Won't fix bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display</vh></v>
</v>
<v t="davy.20141209154025.357"><vh>5.0a1</vh>
<v t="davy.20141209154025.358"><vh>Cleared bug 1228457: Beginning find at the current node's body cursor when that cursor is not displayed</vh></v>
<v t="davy.20141209154025.359"><vh>Cleared bug 1228713: Find-backward skips headlines under some conditions</vh></v>
<v t="davy.20141209154025.360"><vh>Cleared bug 1254864: Can't search from current cursor position downward in body text</vh></v>
<v t="davy.20141209154025.361"><vh>Investigated bug  524890: Incomplete derived file</vh></v>
<v t="davy.20141209154025.362"><vh>Investigated bug 1177355: node-only wrapped search does not work in long nodes</vh></v>
<v t="davy.20141209154025.363"><vh>Investigated bug 1193820: Focus change on tree pane after saving current Leo file</vh></v>
<v t="davy.20141209154025.364"><vh>Investigated bug 1266269: Mac: alt-x does not work in body pane</vh></v>
<v t="davy.20141209154025.365"><vh>Investigated bug 1268970: Leo does not remember window maximized state</vh></v>
<v t="davy.20141209154025.366"><vh>Investigated bug 1282362: shadow file name collisions cause spontaneous clone creation</vh></v>
<v t="davy.20141209154025.367"><vh>Investigated bug 869098: Context menu settings lost if save as used</vh></v>
</v>
</v>
</v>
<v t="davy.20141209154025.368"><vh>Code</vh>
<v t="davy.20141209154025.369"><vh>A beautiful and general design pattern</vh></v>
<v t="davy.20141209154025.370"><vh>A major reorg of Leo's code</vh></v>
<v t="davy.20141209154025.371"><vh>Added support for qt5</vh></v>
<v t="davy.20141209154025.372"><vh>added the IdleTime class</vh></v>
<v t="davy.20141209154025.373"><vh>All unit tests now pass when run externally</vh></v>
<v t="davy.20141209154025.374"><vh>API changes</vh></v>
<v t="davy.20141209154025.375"><vh>Changed most calls to k.setLabel to k.setStatusLabel</vh></v>
<v t="davy.20141209154025.376"><vh>Cleaned up command-name handling a bit</vh></v>
<v t="davy.20141209154025.377"><vh>code: regularized .wrapper and .widget ivars</vh></v>
<v t="davy.20141209154025.378"><vh>Completed generalization of importers</vh></v>
<v t="davy.20141209154025.379"><vh>Created g.IdleTime and qtGui.IdleTime</vh></v>
<v t="davy.20141209154025.380"><vh>Delayed allocation of gnx's...</vh></v>
<v t="davy.20141209154025.381"><vh>Delayed allocation of vnodes</vh></v>
<v t="davy.20141209154025.382"><vh>Improved idle-time handling</vh></v>
<v t="davy.20141209154025.383"><vh>Improved p.isAncestorOf and c.positionExists</vh></v>
<v t="davy.20141209154025.384"><vh>Improved speed of selection logic</vh></v>
<v t="davy.20141209154025.385"><vh>Leo imports importers &amp; writers from home/.leo</vh>
<v t="davy.20141209154025.386"><vh> demo script</vh></v>
</v>
<v t="davy.20141209154025.387"><vh>Leo now uses a new xml namespace</vh></v>
<v t="davy.20141209154025.388"><vh>Rewrote &amp; simplified k.getArg</vh></v>
<v t="davy.20141209154025.389"><vh>Simplified gnx scan logic</vh></v>
<v t="davy.20141209154025.390"><vh>Split qtGui.py into separate files</vh></v>
<v t="davy.20141209154025.391"><vh>The @auto write code now uses writer plugins</vh></v>
<v t="davy.20141209154025.392"><vh>Wanted: w.getTextLength and p/v.get_b_length</vh></v>
<v t="davy.20141209154025.393"><vh>c.executeScript adds '.' to sys.path</vh></v>
</v>
<v t="davy.20141209154025.394"><vh>Features</vh>
<v t="davy.20141209154025.395"><vh>New commands</vh>
<v t="davy.20141209154025.396"><vh>Added focus-to-find/spell commands</vh></v>
<v t="davy.20141209154025.397"><vh>Added clone-find-parents command</vh></v>
<v t="davy.20141209154025.398"><vh>Added clone-to-last-node</vh></v>
<v t="davy.20141209154025.399"><vh>Added flatten-outline-to-node</vh></v>
<v t="davy.20141209154025.400"><vh>Added help-for-drag-and-drop command</vh></v>
<v t="davy.20141209154025.401"><vh>Added idle-time commands</vh></v>
<v t="davy.20141209154025.402"><vh>Added insert-file-name command</vh></v>
<v t="davy.20141209154025.403"><vh>Added pylint command</vh></v>
<v t="davy.20141209154025.404"><vh>Added spell-as-you-type commands</vh></v>
</v>
<v t="davy.20141209154025.405"><vh>Improved commands</vh>
<v t="davy.20141209154025.406"><vh>Improved find/replace-all commands</vh></v>
<v t="davy.20141209154025.407"><vh>(Optional) beautify command now uses PythonTidy</vh></v>
<v t="davy.20141209154025.408"><vh>Improved check outline</vh></v>
<v t="davy.20141209154025.409"><vh>Added Yes To All and No To All buttons to dialogs</vh></v>
<v t="davy.20141209154025.410"><vh>Added more files to pylint -a &amp; -p</vh></v>
<v t="davy.20141209154025.411"><vh>The clean-all-lines command strips trailing whitespace</vh></v>
</v>
<v t="davy.20141209154025.412"><vh>Other features</vh>
<v t="davy.20141209154025.413"><vh>Added some support for scintilla</vh></v>
<v t="davy.20141209154025.414"><vh>Added support for dart language</vh></v>
<v t="davy.20141209154025.415"><vh>Added support for delegate languages</vh></v>
<v t="davy.20141209154025.416"><vh>Added warning buttons when selecting large text</vh></v>
<v t="davy.20141209154025.417"><vh>Eliminated cycle-all-focus command</vh></v>
<v t="davy.20141209154025.418"><vh>Removed stand-alone globals</vh></v>
</v>
</v>
<v t="davy.20141209154025.419"><vh>Plugins &amp; leo/external</vh>
<v t="davy.20141209154025.420"><vh>Added livecode plugin</vh></v>
<v t="davy.20141209154025.421"><vh>Added nodetags.py plugin</vh></v>
<v t="davy.20141209154025.422"><vh>Added viewrendered2 plugin</vh></v>
<v t="davy.20141209154025.423"><vh>Added wikiview plugin</vh></v>
<v t="davy.20141209154025.424"><vh>Converted 7 plugins so they work with PyQt5</vh></v>
<v t="davy.20141209154025.425"><vh>leo/external/leoftsindex.py</vh></v>
<v t="davy.20141209154025.426"><vh>Rewrote at_produce plugin</vh></v>
</v>
<v t="davy.20141209154025.427"><vh>Settings &amp; command-line options</vh>
<v t="davy.20141209154025.428"><vh>Added --no-persist command-line option</vh></v>
<v t="davy.20141209154025.429"><vh>Added --trace-plugins option</vh></v>
<v t="davy.20141209154025.430"><vh>Added @int max-pre-loaded-body-chars</vh></v>
<v t="davy.20141209154025.431"><vh>Added @bool auto-scroll-find-tab</vh></v>
<v t="davy.20141209154025.432"><vh>Added support for html handlebar syntax coloring</vh></v>
<v t="davy.20141209154025.433"></v>
<v t="davy.20141209154025.434"><vh>Leo stylesheets now support all color names in leoColor.py</vh></v>
</v>
</v>
<v t="davy.20141209154025.435"><vh>Leo 5.0a2 release notes</vh>
<v t="davy.20141209154025.436"><vh>Highlights</vh>
<v t="davy.20141209154025.437"><vh>Better integration with Vim, Emacs &amp; pylint</vh>
<v t="davy.20141209154025.438"><vh>vim mode</vh></v>
<v t="davy.20141209154025.439"><vh>Better support for pylint</vh></v>
<v t="davy.20141209154025.440"><vh>Full support for Emacs org-mode</vh></v>
</v>
<v t="davy.20141209154025.441"><vh>Power features</vh>
<v t="davy.20141209154025.442"><vh>@data nodes can now be composed from a tree of nodes</vh></v>
<v t="davy.20141209154025.443"><vh>Clones expand and contract independently</vh></v>
<v t="davy.20141209154025.444"><vh>File name completion</vh></v>
<v t="davy.20141209154025.445"><vh>Better support for nodes containing large text</vh></v>
<v t="davy.20141209154025.446"><vh>Leo now colors text at idle time</vh></v>
<v t="davy.20141209154025.595"><vh>Fully parameterized style sheet</vh></v>
<v t="davy.20141209154025.448"><vh>The style-reload command changes Leo's appearance instantly</vh></v>
<v t="davy.20141209154025.449"><vh>A plugable architecture for @auto nodes</vh></v>
</v>
<v t="davy.20141209154025.450"><vh>Leo's default workbook contains Leo's quickstart guide</vh></v>
</v>
<v t="davy.20141209154025.451"><vh>Bugs fixed</vh>
<v t="davy.20141209154025.452"><vh>Bugs fixed in 5.0a2</vh></v>
<v t="davy.20141209154025.453"><vh>Bugs fixed in 5.0a1</vh>
<v t="davy.20141209154025.454"><vh>Fixed 14 github bugs</vh>
<v t="davy.20141209154025.455"><vh>Fixed bug 12: when hoisted, the (alt-)arrow keys can't navigate to the top node</vh></v>
<v t="davy.20141209154025.456"><vh>Fixed bug 28: Leo hangs when a node with too large body is selected</vh></v>
<v t="davy.20141209154025.457"><vh>Fixed bug 31: 'undo' on a freshly-loaded outline</vh></v>
<v t="davy.20141209154025.458"><vh>Fixed bug 35: leoBridge sometimes assigns the same GNX to two distinct vnodes</vh></v>
<v t="davy.20141209154025.459"><vh>Fixed bug 36: @auto file not found produces a script error</vh></v>
<v t="davy.20141209154025.460"><vh>Fixed bug 50: Important body text lost switching @file to @auto-rst</vh></v>
<v t="davy.20141209154025.461"><vh>Fixed bug 59: drag and drop: target too small</vh></v>
<v t="davy.20141209154025.462"><vh>Fixed bug 60: create relative paths &amp; urls when dragging files to Leo</vh></v>
<v t="davy.20141209154025.463"><vh>Fixed bug 63: refresh-from-disk does not clear big text load delay UI</vh></v>
<v t="davy.20141209154025.464"><vh>Fixed bug 64: https://github.com/leo-editor/leo-editor/issues/64</vh></v>
<v t="davy.20141209154025.465"><vh>Fixed bug 74: problems with @button if defined in myLeoSettings.leo</vh></v>
<v t="davy.20141209154025.466"><vh>Fixed bug 75: write-opml-file always produces an empty file</vh></v>
<v t="davy.20141209154025.467"><vh>Fixed bug 76: erroneous clone markers in @auto trees</vh></v>
<v t="davy.20141209154025.468"><vh>Fixed bug 78: F3 find-next target not always highlighted</vh></v>
</v>
<v t="davy.20141209154025.469"><vh>Fixed 20+ Launchpad bugs</vh>
<v t="davy.20141209154025.470"><vh>Cleared/investigated bugs</vh>
<v t="davy.20141209154025.471"><vh>Cleared bug 1228457: Beginning find at the current node's body cursor when that cursor is not displayed</vh></v>
<v t="davy.20141209154025.472"><vh>Cleared bug 1228713: Find-backward skips headlines under some conditions</vh></v>
<v t="davy.20141209154025.473"><vh>Cleared bug 1254864: Can't search from current cursor position downward in body text</vh></v>
<v t="davy.20141209154025.474"><vh>Investigated bug  524890: Incomplete derived file</vh></v>
<v t="davy.20141209154025.475"><vh>Investigated bug 1177355: node-only wrapped search does not work in long nodes</vh></v>
<v t="davy.20141209154025.476"><vh>Investigated bug 1193820: Focus change on tree pane after saving current Leo file</vh></v>
<v t="davy.20141209154025.477"><vh>Investigated bug 1266269: Mac: alt-x does not work in body pane</vh></v>
<v t="davy.20141209154025.478"><vh>Investigated bug 1268970: Leo does not remember window maximized state</vh></v>
<v t="davy.20141209154025.479"><vh>Investigated bug 1282362: shadow file name collisions cause spontaneous clone creation</vh></v>
<v t="davy.20141209154025.480"><vh>Investigated bug 869098: Context menu settings lost if save as used</vh></v>
</v>
<v t="davy.20141209154025.481"><vh>Fixed bug 1028986: create relative urls when dragging binary files to Leo</vh></v>
<v t="davy.20141209154025.482"><vh>Fixed bug 1041906: underlying C/C++ object has been deleted</vh></v>
<v t="davy.20141209154025.483"><vh>Fixed bug 1090950: refresh from disk - cut node resurrection</vh></v>
<v t="davy.20141209154025.484"><vh>Fixed bug 1185933: insert-headline-time should insert at cursor</vh></v>
<v t="davy.20141209154025.485"><vh>Fixed bug 1228312: Find tab selected in log pane disables Minibuffer</vh></v>
<v t="davy.20141209154025.486"><vh>Fixed bug 1228452: related to the radio buttons in the Find pane</vh></v>
<v t="davy.20141209154025.487"><vh>Fixed bug 1228458: Inconsistency between Find-forward and Find-backward</vh></v>
<v t="davy.20141209154025.488"><vh>Fixed bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented</vh></v>
<v t="davy.20141209154025.489"><vh>Fixed bug 1244461: Numpad 'Enter' key does not work in minibuffer</vh></v>
<v t="davy.20141209154025.490"><vh>Fixed bug 1245535: API allows headlines to contain newlines</vh></v>
<v t="davy.20141209154025.491"><vh>Fixed bug 1245616: Autocomplete ? function...does not work</vh></v>
<v t="davy.20141209154025.492"><vh>Fixed bug 1251252: Minibuffer commands created by mod_scripting.py have no docstrings</vh></v>
<v t="davy.20141209154025.493"><vh>Fixed bug 1254861: Ctrl-f doesn't ensure find input field visible</vh></v>
<v t="davy.20141209154025.494"><vh>Fixed bug 1258373: failed find focus fails</vh></v>
<v t="davy.20141209154025.495"><vh>Fixed bug 1260415: exception writing external files" is insufficient</vh></v>
<v t="davy.20141209154025.496"><vh>Fixed bug 1264350: Up-arrow on the first node in a chapter switches to another chapter</vh></v>
<v t="davy.20141209154025.497"><vh>Fixed bug 1267921: isearch-forward accepts non-alphanumeric keys as input</vh></v>
<v t="davy.20141209154025.498"><vh>Fixed bug 1276236: unicode problem in the log pane</vh></v>
<v t="davy.20141209154025.499"><vh>Fixed bug 613153: unable to describe root directory on thumb drive</vh></v>
<v t="davy.20141209154025.500"><vh>Fixed bug 735938: file association crash</vh></v>
<v t="davy.20141209154025.501"><vh>Fixed bug 969391: setup.py confuses newbies</vh></v>
</v>
<v t="davy.20141209154025.502"><vh>Fixed 30+ other bugs</vh>
<v t="davy.20141209154025.503"><vh>eliminated "can not exedute commands from headlines"</vh></v>
<v t="davy.20141209154025.504"><vh>find-all now uses exising find pattern</vh></v>
<v t="davy.20141209154025.505"><vh>Fixed a startup error involving --ipython</vh></v>
<v t="davy.20141209154025.506"><vh>Fixed annoyance: shift-ctrl-w leaves .leo file as dirty</vh></v>
<v t="davy.20141209154025.507"><vh>Fixed autocompleter bug</vh></v>
<v t="davy.20141209154025.508"><vh>Fixed bug re the factor language</vh></v>
<v t="davy.20141209154025.509"><vh>Fixed bug: activate events now properly restore focus</vh></v>
<v t="davy.20141209154025.510"><vh>Fixed bug: Find-previous fails at last node</vh></v>
<v t="davy.20141209154025.511"><vh>Fixed clone-find-all command</vh></v>
<v t="davy.20141209154025.512"><vh>Fixed Crash deleting body editor</vh></v>
<v t="davy.20141209154025.513"><vh>Fixed find bug</vh></v>
<v t="davy.20141209154025.514"><vh>Fixed important security hole in mod_scripting plugin</vh></v>
<v t="davy.20141209154025.515"><vh>Fixed leoGlobals bug (per Reinhard Engle)</vh></v>
<v t="davy.20141209154025.516"><vh>Fixed modes/md.py</vh></v>
<v t="davy.20141209154025.517"><vh>Fixed problem with 1-character reverse searches!</vh></v>
<v t="davy.20141209154025.518"><vh>Fixed problems with clone-expansion</vh></v>
<v t="davy.20141209154025.519"><vh>Fixed QCompleter bug</vh></v>
<v t="davy.20141209154025.520"><vh>Fixed recent bug in change command</vh></v>
<v t="davy.20141209154025.521"><vh>Fixed recursive import bug</vh></v>
<v t="davy.20141209154025.522"><vh>Fixed serious bug in c.deletePositionsInList</vh></v>
<v t="davy.20141209154025.523"><vh>Fixed several crashers re no-to-all during startup</vh></v>
<v t="davy.20141209154025.524"><vh>Fixed suboutline only find bug</vh></v>
<v t="davy.20141209154025.525"><vh>Fixed tab cycling</vh></v>
<v t="davy.20141209154025.526"><vh>Fixed tab-completion problems</vh></v>
<v t="davy.20141209154025.527"><vh>Fixed unwanted scrolling in abbreviations</vh></v>
<v t="davy.20141209154025.528"><vh>Gave the Find Tab the intended amount of border</vh></v>
<v t="davy.20141209154025.529"><vh>Improved ctrl-o code</vh></v>
<v t="davy.20141209154025.530"><vh>Investigated bug: fill-region &amp; format-body can hang</vh></v>
<v t="davy.20141209154025.531"><vh>Made beautify commands compatible with pep8</vh></v>
<v t="davy.20141209154025.532"><vh>Re-enabled command completion for @button commands</vh></v>
<v t="davy.20141209154025.533"><vh>Reported QTextEdit bug</vh></v>
<v t="davy.20141209154025.534"><vh>Set the default syntax color for operators to black</vh></v>
<v t="davy.20141209154025.535"><vh>Suppressed duplicate console messages</vh></v>
<v t="davy.20141209154025.536"><vh>Worked around a strange PyQt5 bug in LeoQtGui.runSaveFileDialog</vh></v>
</v>
</v>
</v>
<v t="davy.20141209154025.537"><vh>Code</vh>
<v t="davy.20141209154025.538"><vh>A beautiful and general design pattern</vh></v>
<v t="davy.20141209154025.539"><vh>A major reorg of Leo's code</vh></v>
<v t="davy.20141209154025.540"><vh>Added support for qt5</vh></v>
<v t="davy.20141209154025.541"><vh>added the IdleTime class</vh></v>
<v t="davy.20141209154025.542"><vh>All unit tests now pass when run externally</vh></v>
<v t="davy.20141209154025.543"><vh>API changes</vh></v>
<v t="davy.20141209154025.544"><vh>Changed most calls to k.setLabel to k.setStatusLabel</vh></v>
<v t="davy.20141209154025.545"><vh>Cleaned up command-name handling a bit</vh></v>
<v t="davy.20141209154025.546"><vh>code: regularized .wrapper and .widget ivars</vh></v>
<v t="davy.20141209154025.547"><vh>Completed generalization of importers</vh></v>
<v t="davy.20141209154025.548"><vh>Created g.IdleTime and qtGui.IdleTime</vh></v>
<v t="davy.20141209154025.549"><vh>Delayed allocation of gnx's...</vh></v>
<v t="davy.20141209154025.550"><vh>Delayed allocation of vnodes</vh></v>
<v t="davy.20141209154025.551"><vh>Improved idle-time handling</vh></v>
<v t="davy.20141209154025.552"><vh>Improved p.isAncestorOf and c.positionExists</vh></v>
<v t="davy.20141209154025.553"><vh>Improved speed of selection logic</vh></v>
<v t="davy.20141209154025.554"><vh>Leo imports importers &amp; writers from home/.leo</vh>
<v t="davy.20141209154025.555"><vh> demo script</vh></v>
</v>
<v t="davy.20141209154025.556"><vh>Leo now uses a new xml namespace</vh></v>
<v t="davy.20141209154025.557"><vh>Rewrote &amp; simplified k.getArg</vh></v>
<v t="davy.20141209154025.558"><vh>Simplified gnx scan logic</vh></v>
<v t="davy.20141209154025.559"><vh>Split qtGui.py into separate files</vh></v>
<v t="davy.20141209154025.560"><vh>The @auto write code now uses writer plugins</vh></v>
<v t="davy.20141209154025.561"><vh>Wanted: w.getTextLength and p/v.get_b_length</vh></v>
</v>
<v t="davy.20141209154025.562"><vh>Features</vh>
<v t="davy.20141209154025.563"><vh>New commands</vh>
<v t="davy.20141209154025.564"><vh>Added clone-find-parents command</vh></v>
<v t="davy.20141209154025.565"><vh>Added clone-to-last-node</vh></v>
<v t="davy.20141209154025.566"><vh>Added flatten-outline-to-node</vh></v>
<v t="davy.20141209154025.567"><vh>Added help-for-drag-and-drop command</vh></v>
<v t="davy.20141209154025.568"><vh>Added idle-time commands</vh></v>
<v t="davy.20141209154025.569"><vh>Added insert-file-name command</vh></v>
<v t="davy.20141209154025.570"><vh>Added pylint command</vh></v>
<v t="davy.20141209154025.571"><vh>Added spell-as-you-type commands</vh></v>
</v>
<v t="davy.20141209154025.572"><vh>Improved commands</vh>
<v t="davy.20141209154025.573"><vh>Improved find/replace-all commands</vh></v>
<v t="davy.20141209154025.574"><vh>(Optional) beautify command now uses PythonTidy</vh></v>
<v t="davy.20141209154025.575"><vh>Improved check outline</vh></v>
<v t="davy.20141209154025.576"><vh>Added Yes To All and No To All buttons to dialogs</vh></v>
</v>
<v t="davy.20141209154025.577"><vh>Other features</vh>
<v t="davy.20141209154025.578"><vh>Added warning buttons when selecting large text</vh></v>
<v t="davy.20141209154025.579"><vh>Added some support for scintilla</vh></v>
<v t="davy.20141209154025.580"><vh>Added support for delegate languages</vh></v>
</v>
</v>
<v t="davy.20141209154025.581"><vh>Plugins &amp; leo/external</vh>
<v t="davy.20141209154025.582"><vh>Added livecode plugin</vh></v>
<v t="davy.20141209154025.583"><vh>Added nodetags.py plugin</vh></v>
<v t="davy.20141209154025.584"><vh>Added viewrendered2 plugin</vh></v>
<v t="davy.20141209154025.585"><vh>Added wikiview plugin</vh></v>
<v t="davy.20141209154025.586"><vh>Converted 7 plugins so they work with PyQt5</vh></v>
<v t="davy.20141209154025.587"><vh>leo/external/leoftsindex.py</vh></v>
<v t="davy.20141209154025.588"><vh>Rewrote at_produce plugin</vh></v>
</v>
<v t="davy.20141209154025.589"><vh>Settings &amp; command-line options</vh>
<v t="davy.20141209154025.590"><vh>Added --no-persist command-line option</vh></v>
<v t="davy.20141209154025.591"><vh>Added --trace-plugins option</vh></v>
<v t="davy.20141209154025.592"><vh>Added @int max-pre-loaded-body-chars</vh></v>
<v t="davy.20141209154025.593"><vh>Added @bool auto-scroll-find-tab</vh></v>
<v t="davy.20141209154025.594"><vh>Added support for html handlebar syntax coloring</vh></v>
<v t="davy.20141209154025.595"></v>
<v t="davy.20141209154025.596"><vh>Leo stylesheets now support all color names in leoColor.py</vh></v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.63"><vh>Latest version</vh></v>
</v>
<v t="davy.20141209134323.292"><vh>Treecatching</vh>
<v t="davy.20141209134323.293"><vh>Python list based description of trees ('objtrees')</vh></v>
<v t="davy.20141209134323.294"><vh>Using objtrees for caching</vh></v>
<v t="davy.20141209134323.295"><vh>The `Leo database` (c.db, g.app.db)</vh></v>
</v>
<v t="davy.20141209134323.13"><vh>@rst jythonShell</vh>
<v t="davy.20141209134323.14"><vh>@rst-no-head jythonShell declarations</vh></v>
<v t="davy.20141209134323.15"><vh>Autocompleter Actions</vh></v>
<v t="davy.20141209134323.16"><vh>Keystrokes</vh></v>
<v t="davy.20141209134323.17"><vh>Alt Slash: Dynamic Abbreviations</vh></v>
<v t="davy.20141209134323.18"><vh>Object Introspection</vh></v>
<v t="davy.20141209134323.19"><vh>System access</vh></v>
<v t="davy.20141209134323.20"><vh>Magic Commands</vh>
<v t="davy.20141209134323.21"><vh>%alias anAlias</vh></v>
<v t="davy.20141209134323.22"><vh>%autocall</vh></v>
<v t="davy.20141209134323.23"><vh>%autoindent</vh></v>
<v t="davy.20141209134323.24"><vh>%bg</vh></v>
<v t="davy.20141209134323.25"><vh>%cd</vh></v>
<v t="davy.20141209134323.26"><vh>%clean</vh></v>
<v t="davy.20141209134323.27"><vh>%clear</vh></v>
<v t="davy.20141209134323.28"><vh>%cwd</vh></v>
<v t="davy.20141209134323.29"><vh>%cwd aReference</vh></v>
<v t="davy.20141209134323.30"><vh>%deserialize aReference</vh></v>
<v t="davy.20141209134323.31"><vh>%ed</vh></v>
<v t="davy.20141209134323.32"><vh>%edit [options] [args]</vh></v>
<v t="davy.20141209134323.33"><vh>%env</vh></v>
<v t="davy.20141209134323.34"><vh>%hist [-n] [n1] [n2]</vh></v>
<v t="davy.20141209134323.35"><vh>%kill n</vh></v>
<v t="davy.20141209134323.36"><vh>%ls</vh></v>
<v t="davy.20141209134323.37"><vh>%ls aReference</vh></v>
<v t="davy.20141209134323.38"><vh>%lsmagic</vh></v>
<v t="davy.20141209134323.39"><vh>%macro aMacro</vh></v>
<v t="davy.20141209134323.40"><vh>%magic</vh></v>
<v t="davy.20141209134323.41"><vh>%p</vh></v>
<v t="davy.20141209134323.42"><vh>%pdb</vh></v>
<v t="davy.20141209134323.43"><vh>%pdoc anObject</vh></v>
<v t="davy.20141209134323.44"><vh>%pfile obj</vh></v>
<v t="davy.20141209134323.45"><vh>%pinfo aReference</vh></v>
<v t="davy.20141209134323.46"><vh>%prun statement</vh></v>
<v t="davy.20141209134323.47"><vh>%ps</vh></v>
<v t="davy.20141209134323.48"><vh>%r</vh></v>
<v t="davy.20141209134323.49"><vh>%rehash and %rehashx</vh></v>
<v t="davy.20141209134323.50"><vh>%reset</vh></v>
<v t="davy.20141209134323.51"><vh>%run [-n -i -t [-N n] -d [-b n] -p [profile options]] file [args]</vh></v>
<v t="davy.20141209134323.52"><vh>%save filename n1:n2 n3:n4 ... n5 .. n6 ...</vh></v>
<v t="davy.20141209134323.53"><vh>%sc [options] varname=command</vh></v>
<v t="davy.20141209134323.54"><vh>%see</vh></v>
<v t="davy.20141209134323.55"><vh>%send n aReference</vh></v>
<v t="davy.20141209134323.56"><vh>%serialize aReference</vh></v>
<v t="davy.20141209134323.57"><vh>%swing aReference</vh></v>
<v t="davy.20141209134323.58"><vh>%sx aCommand</vh></v>
<v t="davy.20141209134323.59"><vh>%threads</vh></v>
<v t="davy.20141209134323.60"><vh>%unalias anAlias</vh></v>
<v t="davy.20141209134323.61"><vh>%url ref aUrl</vh></v>
<v t="davy.20141209134323.62"><vh>%wait n</vh></v>
<v t="davy.20141209134323.63"><vh>%who</vh></v>
<v t="davy.20141209134323.64"><vh>%who\_ls</vh></v>
<v t="davy.20141209134323.65"><vh>%whos</vh></v>
<v t="davy.20141209134323.66"><vh>%xslt ref1 ref2 ref3</vh></v>
</v>
<v t="davy.20141209134323.67"><vh>A Note on JPIDs and the CWD</vh></v>
</v>
<v t="davy.20141209134323.7"><vh>@rst docModeOnlyTest</vh>
<v t="davy.20141209134323.8"><vh>Documentation for leoFind.py</vh>
<v t="davy.20141209134323.9"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="davy.20141209134323.10"><vh>leoFind.\_\_init\_\_</vh></v>
</v>
<v t="davy.20141209134323.11"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh></v>
<v t="davy.20141209134323.12"><vh>batchChange (sets start of change-all group)</vh></v>
</v>
<v t="ekr.20131008041326.16176"><vh>@rst design</vh>
<v t="ekr.20100807120250.4399"><vh>Outlines embody design</vh></v>
<v t="ekr.20100807120250.4398"><vh>Nodes hide details</vh></v>
<v t="ekr.20100807120250.4400"><vh>Clones create views</vh></v>
<v t="ekr.20100807120250.4401"><vh>Nodes create context</vh></v>
</v>
<v t="davy.20141209134323.271"><vh>@rst techReport</vh>
<v t="davy.20141209134323.272"><vh>@rst-no-head techReport2 declarations</vh></v>
<v t="davy.20141209134323.273"><vh>`Old &lt;#id1&gt;`__</vh>
<v t="davy.20141209134323.274"><vh>`Leo’s window, outlines &amp; clones &lt;#id2&gt;`__</vh></v>
<v t="davy.20141209134323.275"><vh>`Relations: organizer nodes, views, tasks and metadata &lt;#id3&gt;`__</vh></v>
<v t="davy.20141209134323.276"><vh>`Plugins &lt;#id4&gt;`__</vh></v>
<v t="davy.20141209134323.277"><vh>`Derived files and special nodes &lt;#id5&gt;`__</vh></v>
<v t="davy.20141209134323.278"><vh>`Markup for scripts &lt;#id6&gt;`__</vh></v>
<v t="davy.20141209134323.279"><vh>`Scripting Leo &lt;#id7&gt;`__</vh></v>
<v t="davy.20141209134323.280"><vh>`Leo’s modules and classes &lt;#id8&gt;`__</vh></v>
<v t="davy.20141209134323.281"><vh>`Predefined symbols in scripts &lt;#id9&gt;`__</vh></v>
<v t="davy.20141209134323.282"><vh>`Accessing data &lt;#id10&gt;`__</vh></v>
<v t="davy.20141209134323.283"><vh>`Traversing outlines &lt;#id11&gt;`__</vh></v>
<v t="davy.20141209134323.284"><vh>`Executing commands from scripts &lt;#id12&gt;`__</vh></v>
<v t="davy.20141209134323.285"><vh>`Bringing scripts to data &lt;#id13&gt;`__</vh></v>
<v t="davy.20141209134323.286"><vh>`Unit Testing with @test and @suite nodes &lt;#id14&gt;`__</vh></v>
<v t="davy.20141209134323.287"><vh>`Plugins and hooks &lt;#id15&gt;`__</vh></v>
<v t="davy.20141209134323.288"><vh>`Contacts &lt;#id16&gt;`__</vh></v>
</v>
</v>
<v t="ekr.20100808120531.4284"><vh>@rst nutshell</vh></v>
<v t="ekr.20050901101608"><vh>@rst outlines</vh>
<v t="ekr.20050901101608.1"><vh>@rst-no-head links</vh></v>
<v t="sps.20100710110337.12187"><vh>@rst-no-head Outline Related</vh>
<v t="ekr.20060929040750"><vh>Navigating through the outline</vh></v>
<v t="EKR.20040524104904.40"><vh>Expanding &amp; contracting nodes</vh></v>
<v t="EKR.20040524104904.36"><vh>Creating and destroying nodes</vh></v>
<v t="EKR.20040524104904.37"><vh>Cutting, pasting and deleting nodes</vh></v>
<v t="EKR.20040524104904.44"><vh>Moving &amp; Reorganizing nodes</vh></v>
<v t="EKR.20040524104904.27"><vh>Cloning nodes</vh></v>
<v t="EKR.20040524104904.43"><vh>Marking nodes</vh></v>
<v t="EKR.20040524104904.38"><vh>Dragging nodes</vh></v>
</v>
<v t="sps.20100710110337.12188"><vh>@rst-no-head Body Related</vh>
<v t="EKR.20040524104904.39"><vh>Editing body text</vh></v>
<v t="EKR.20040524104904.41"><vh>Indenting body text automatically</vh></v>
<v t="ekr.20060920145745"><vh>Creating and destroying multiple body editors</vh></v>
</v>
<v t="sps.20100710110337.12189"><vh>@rst-no-head Miscellaneous</vh>
<v t="EKR.20040524104904.48"></v>
<v t="EKR.20040524104904.47"><vh>Resizing panes</vh></v>
<v t="EKR.20040524104904.45"><vh>Opening URL's automatically</vh></v>
<v t="ekr.20070623145346.2"><vh>Using chapters</vh></v>
</v>
</v>
<v t="ekr.20100808120531.4281"><vh>@rst outline-commands</vh></v>
<v t="davy.20141209134323.1019"><vh>TODO DEV</vh>
<v t="ekr.20141112070001.4"><vh>* To do: Leo 5.0 final</vh>
<v t="ekr.20141114054312.7"><vh>Fix bug 103: Installation Issues on Linux</vh></v>
<v t="ekr.20141114054312.6"><vh>Fix bug 102: Loading @file node with embedded code broken</vh></v>
<v t="ekr.20141113123533.4"><vh>#66: support @path with md importer/writer/rclick</vh></v>
<v t="ekr.20141113114751.1"><vh>Window title of Leo installer should give version</vh></v>
<v t="ekr.20141112070001.6"><vh>Fix markdown unit test</vh></v>
<v t="ekr.20141110223158.9"><vh>Fix bug 101: IPython issues</vh></v>
<v t="ekr.20141112094313.4"><vh>Fix bugs re plugins</vh></v>
<v t="ekr.20141110154742.6"><vh>Fix bug 78: find-next target not always scrolled into view</vh></v>
<v t="ekr.20141113102829.5"><vh>Maybe</vh>
<v t="ekr.20141109160640.8"><vh>Fix bug 99: MacOs custom hotkey can not work on 1st call</vh></v>
<v t="ekr.20130806072439.20650"><vh>Wishlist: brew install leo</vh></v>
</v>
</v>
<v t="ekr.20141103113220.22"><vh>Next</vh>
<v t="ekr.20141030042423.13"><vh>Top 4 wishlist items</vh>
<v t="ekr.20130807203905.16596"><vh>PortableFileAssociator</vh></v>
<v t="ekr.20130806072439.20732"><vh>Runnable Leo in one .zip file w/ virtual machine</vh>
<v t="ekr.20130806072439.20736"><vh>Re: Runnable Leo in one .zip file.</vh></v>
<v t="ekr.20130806072439.20744"><vh>Re: Runnable Leo in one .zip file.</vh></v>
</v>
<v t="ekr.20130807203905.16594"><vh>Wishlist for newbies (Fidel)</vh></v>
<v t="ekr.20141024211256.7"><vh>Improve help-for command</vh></v>
</v>
<v t="ekr.20141017150357.18271"><vh>3 Launchpad bugs assigned to Terry</vh></v>
<v t="ekr.20141030042423.14"><vh>12 Launchpad bugs re plugins</vh></v>
<v t="ekr.20140824043305.18303"><vh>12 Not in any bug tracker</vh>
<v t="ekr.20130806072439.20380"><vh>auto-rst error? need more robust?</vh></v>
<v t="ekr.20111114085925.9932"><vh>Why does the unittest/output folder contain empty files?</vh></v>
<v t="ekr.20130806072439.20371"><vh>@wrap now suppresses horizontal scrolling</vh></v>
<v t="ekr.20111125072438.10214"><vh>Fix bug: Another @shadow bug (test4.leo) (maybe)</vh></v>
<v t="ekr.20111123095018.13632"><vh>Fix bug: expand Find tab as needed for bigger fonts</vh></v>
<v t="ekr.20111010162047.15678"><vh>Fix bug: Imports to @file should put @first/@last directives in root node</vh>
<v t="ekr.20111221102703.10289"><vh>@@@nosent ../test/at-auto-at-first-test.py</vh></v>
</v>
<v t="ekr.20120219152142.34262"><vh>Fix bug: Revert moves the reverted tab to the right</vh></v>
<v t="ekr.20111125072438.10217"><vh>Fix bug: shell interprets characters in at-mime headings</vh></v>
<v t="ekr.20120327163022.9744"><vh>Fix bug: The @auto script *must* put @first nodes in root node</vh></v>
<v t="ekr.20111018104244.15920"><vh>Fix bug: Use QLocalSocket in LProtoClient.connect</vh></v>
<v t="ekr.20141017110114.18267"><vh>@data qt-scintilla-styles only works in leoSetting.leo</vh></v>
<v t="ekr.20130806072439.20485"><vh>Whitespace when importing java file using @auto</vh></v>
</v>
</v>
<v t="ekr.20120226183512.10195"><vh>All other bugs</vh>
<v t="ekr.20141026191037.6"><vh>Can't fix bug 83: Bracket completion doesn't work</vh></v>
<v t="ekr.20130926053913.11562"><vh>Bug-tracker: Hard</vh>
<v t="ekr.20140824163757.20587"><vh>Bug 1022140: scroll problem in the body pane (Hard)</vh>
<v t="ekr.20130806072439.20497"><vh>** Leo does not display all content of a node ...</vh>
<v t="ekr.20130806072439.20498"><vh>Re: Leo does not display all content of a node ...</vh></v>
<v t="ekr.20130806072439.20499"><vh>Re: Leo does not display all content of a node ...</vh></v>
<v t="ekr.20130806072439.20501"><vh>Re: Leo does not display all content of a node ...</vh></v>
<v t="ekr.20130806072439.20531"><vh>Response to Leo does not display... Styling in Leo</vh></v>
</v>
</v>
<v t="ekr.20130805080841.21380"><vh>Bug 1222947: javascript import bug (Hard)</vh></v>
<v t="ekr.20130916105324.19894"><vh>Bug 1226353: @shadow does not retain outline structure properly (Hard)</vh></v>
<v t="ekr.20130908104426.11242"><vh>Bug 914221: bound method ViewRenderedController.updated (Hard)</vh></v>
</v>
<v t="ekr.20141107085700.5"><vh>A recent warning</vh></v>
</v>
<v t="ekr.20120516140545.9987"><vh>Wishlist</vh>
<v t="ekr.20141109053526.7"><vh>* Most important</vh>
<v t="ekr.20141108064630.19"><vh>Wishlist: resolve clone wars based on modification dates</vh></v>
<v t="ekr.20140402091953.16863"><vh>Add rope to Leo</vh></v>
</v>
<v t="ekr.20140521095206.16728"><vh>* Important</vh>
<v t="ekr.20140921072018.17937"><vh>New separate-process commands</vh>
<v t="ekr.20140921072018.17938"><vh>Settings for at-produce plugin?</vh></v>
<v t="ekr.20140919052413.17946"><vh>Revise leoBridge docs</vh>
<v t="ekr.20140922043414.17947"><vh>Solution 1</vh>
<v t="ekr.20140921072018.17943"><vh>leo_bridge_test.py (defined in ekr.leo)</vh></v>
</v>
<v t="ekr.20140922043414.17948"><vh>Solution 2 (test)</vh></v>
<v t="ekr.20140922043414.17949"><vh>Solution 0 (already documented)</vh></v>
</v>
</v>
<v t="ekr.20140115052524.16699"><vh>Allow clones *anywhere* in @file nodes</vh></v>
<v t="ekr.20140104063158.16448"><vh>reload-abbreviations and reload-key-bindings commands</vh>
<v t="ekr.20140312052111.16811"><vh>Notes</vh></v>
<v t="ekr.20140630071432.16748"><vh>Related methods</vh></v>
<v t="ekr.20140104063158.17235"><vh>Found: \w*\.\w*\s*=\s*c.config.get</vh></v>
</v>
<v t="ekr.20111017132257.15883"><vh>Use IPython completion?</vh></v>
<v t="ekr.20140610063815.17693"><vh>Sentinel files</vh>
<v t="ekr.20140426030229.16869"><vh>prototype of sentinel files</vh></v>
<v t="ekr.20140611055007.17696"><vh>original post</vh></v>
</v>
<v t="ekr.20141103113220.10"><vh>Parameterized template nodes</vh>
<v t="ekr.20141103113220.11"><vh>OP: Re: Parameterized template nodes</vh></v>
</v>
<v t="ekr.20120527053550.10117"><vh>Create find-def command</vh></v>
<v t="ekr.20130806072439.21225"><vh>Distributed collaboration tool</vh></v>
<v t="ekr.20120520113447.9874"><vh>Kent: select node from traceback</vh></v>
<v t="ekr.20110528034751.18272"><vh>Use free_layout to implement body editors</vh></v>
<v t="ekr.20130508084413.10631"><vh>add g.etrace</vh></v>
<v t="ekr.20120520055508.11873"><vh>Add split-window commands</vh></v>
<v t="ekr.20130806072439.21204"><vh>Comparison leo outline type with other outliner's types?</vh></v>
<v t="ekr.20140704052551.17955"><vh>Create myLeoSettings and workbook automatically</vh></v>
<v t="ekr.20130806072439.21241"><vh>Free range body editors</vh></v>
<v t="ekr.20140306114536.16869"><vh>Handle multiple (headline?) selections</vh></v>
<v t="ekr.20130806072439.21248"><vh>Idea/needed: system command queue (g.execute_shell_commands?)</vh></v>
<v t="ekr.20130806072439.21254"><vh>Idea: easy key bindings</vh></v>
<v t="ekr.20131117054619.16683"><vh>Improve Find</vh>
<v t="ekr.20131118113639.17705"><vh>Done</vh></v>
<v t="ekr.20131123071505.16462"><vh>Crash in undoer</vh></v>
<v t="ekr.20131207054442.16335"><vh>check isearch</vh></v>
</v>
<v t="ekr.20140704052551.17954"><vh>Improve p.isVisible</vh></v>
<v t="ekr.20060227131611"><vh>Kent: extensible auto-completion-like capabilities</vh></v>
<v t="ekr.20130806072439.21301"><vh>Leo doc-generation and Wiki integration - GitIt and Pandocs</vh>
<v t="ekr.20130806072439.21302"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21303"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21304"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21305"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21306"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21307"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21308"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
<v t="ekr.20130806072439.21309"><vh>Re: Leo doc-generation and Wiki integration - GitIt and Pandocs</vh></v>
</v>
<v t="ekr.20130806072439.21323"><vh>Leo reader as a web app</vh></v>
<v t="ekr.20130806072439.21332"><vh>Leo tags *</vh></v>
<v t="ekr.20130806072439.20430"><vh>minor dabbrev improvements</vh></v>
<v t="ekr.20130806072439.21341"><vh>Node pipes</vh>
<v t="ekr.20130806072439.21342"><vh>Re: Node pipes</vh></v>
<v t="ekr.20130806072439.21344"><vh>Re: Node pipes</vh></v>
</v>
<v t="ekr.20130806072439.21349"><vh>OMG: @nosent should put headlines as comments</vh></v>
<v t="ekr.20111125072438.10219"><vh>Open file dialogs starting with @path directory</vh>
<v t="ekr.20111221114145.10217"><vh>Found: runOpenFileDialog</vh></v>
</v>
<v t="ekr.20130806072439.21370"><vh>Parameterized template nodes</vh>
<v t="ekr.20130806072439.21371"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806072439.21372"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806072439.21375"><vh>Re: Parameterized template nodes</vh></v>
</v>
<v t="ekr.20130806072439.21380"><vh>QML - new window / gui / coding for Leo?</vh></v>
<v t="ekr.20100223123910.5930"><vh>recentFilesController</vh></v>
<v t="ekr.20130806072439.21428"><vh>Set of markup2html converter</vh></v>
<v t="ekr.20131225061403.16375"><vh>Support @bookmark-view</vh>
<v t="ekr.20131225061403.16377"><vh>g.command(view-pack)</vh></v>
</v>
<v t="ekr.20111026075003.16481"><vh>Support ~/.leo_config.py</vh></v>
<v t="ekr.20130806072439.21443"><vh>threaded saveAll()</vh>
<v t="ekr.20130806072439.21444"><vh>Re: threaded saveAll()</vh></v>
<v t="ekr.20130806072439.21445"><vh>Re: threaded saveAll()</vh></v>
<v t="ekr.20130806072439.21446"><vh>Re: threaded saveAll()</vh></v>
<v t="ekr.20130806072439.21447"><vh>Re: threaded saveAll()</vh></v>
<v t="ekr.20130806072439.21448"><vh>Re: threaded saveAll()</vh></v>
</v>
<v t="ekr.20130806072439.21298"><vh>Treat leo tree as a flat memory structure</vh></v>
<v t="ekr.20130806072439.21464"><vh>UI idea: body editors in a grid</vh>
<v t="ekr.20130806072439.21465"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21466"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21467"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21468"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21469"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21470"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21471"><vh>RE: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21472"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21473"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21474"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21475"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21476"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21477"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21478"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21479"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21480"><vh>Re: UI idea: body editors in a grid</vh></v>
<v t="ekr.20130806072439.21481"><vh>Re: UI idea: body editors in a grid</vh></v>
</v>
<v t="ekr.20111019104425.15894"><vh>Use templates to create Wizards (Kent)</vh></v>
<v t="ekr.20130806072439.21337"><vh>Wanted: better C importer</vh></v>
<v t="ekr.20130806072439.21482"><vh>Wish list: xiki window for leo</vh>
<v t="ekr.20130806072439.21483"><vh>Re: Wish list: xiki window for leo</vh></v>
<v t="ekr.20130806072439.21484"><vh>Re: Wish list: xiki window for leo</vh></v>
<v t="ekr.20130806072439.21485"><vh>Re: Wish list: xiki window for leo</vh></v>
<v t="ekr.20130806072439.21487"><vh>Re: Wish list: xiki window for leo</vh></v>
</v>
<v t="ekr.20110621085435.6532"><vh>Request: have equal-sized-panes resize vr pane</vh></v>
</v>
<v t="ekr.20130908104426.11269"><vh>** Bug-tracker: Wish-list</vh>
<v t="ekr.20111125072438.10204"><vh>882243: (Wishlist) Clones sometimes not saved: change how @others works</vh>
<v t="ekr.20111216105907.10218"><vh>My response: this is a wishlist item</vh></v>
</v>
<v t="ekr.20130806072439.20374"><vh>aha moment when using leo script with @url, and feature request ;-)</vh></v>
<v t="ekr.20130806072439.20377"><vh>An unexpected phenomenon(Using @url node) in @shadow</vh></v>
<v t="ekr.20130806072439.20369"><vh>@paragraph(s)</vh></v>
<v t="ekr.20130806072439.20523"><vh>RST3 Tables with Nodes as Rows</vh></v>
<v t="ekr.20130806072439.20387"><vh>wishlist: Autosaving when external file saved</vh>
<v t="ekr.20130806072439.20394"><vh>Re: Autosaving when external file saved</vh></v>
<v t="ekr.20130806072439.20395"><vh>Re: Autosaving when external file saved</vh></v>
<v t="ekr.20130806072439.20396"><vh>Re: Autosaving when external file saved</vh></v>
<v t="ekr.20130806072439.20397"><vh>Re: Autosaving when external file saved</vh></v>
</v>
<v t="ekr.20130806211959.17373"><vh>wishlist: meld integration</vh></v>
</v>
<v t="ekr.20120527053550.12058"><vh>** Fun</vh>
<v t="ekr.20110918204546.6809"><vh>convert-to-class script</vh></v>
<v t="ekr.20111018104244.15933"><vh>script to create documentation for commands/plugins</vh></v>
<v t="ekr.20130806211959.17377"><vh>Add coffeescript importer</vh></v>
<v t="ekr.20081119132758.2"><vh>Support @ifgui in settings trees</vh></v>
</v>
<v t="ekr.20141014131442.18346"><vh>** Ideas for implementors</vh>
<v t="ekr.20130807203905.16679"><vh>Centralizing focus handling (to make debugging easier)</vh></v>
<v t="ekr.20130807203905.16681"><vh>Free "continuous integration" for Leo</vh></v>
<v t="ekr.20130806211959.17365"><vh>Leo as PIM and authoring tool</vh></v>
</v>
<v t="ekr.20140730175636.17982"><vh>** Vim to-do</vh>
<v t="ekr.20140808182202.18183"><vh>Maybe</vh></v>
<v t="ekr.20140822072856.18255"><vh>Substitution notes</vh></v>
<v t="ekr.20140822160427.19046"><vh>Unfinished operations</vh></v>
<v t="ekr.20100113075303.6270"><vh>vim problems (from Tom L)</vh>
<v t="ekr.20140822160427.19049"><vh>Can not be solved using @mode</vh>
<v t="ekr.20100112051224.6239"><vh>Displaying mode help</vh></v>
<v t="ekr.20100113075303.6271"><vh>Need mode-oriented bindings</vh></v>
<v t="ekr.20100112051224.6238"><vh>Some commands do not work in headline</vh></v>
<v t="ekr.20100112051224.6222"><vh>Commands requesting user input</vh></v>
<v t="ekr.20100112051224.6223"><vh>Editing node headlines using @mode nodes</vh></v>
<v t="ekr.20110529115328.18247"><vh>Block cursor</vh></v>
<v t="ekr.20090629183608.8446"><vh>Copy/paste/yank/delete</vh></v>
<v t="ekr.20100112051224.6226"><vh>Range prefix to commands/objects (k.getArgs)</vh></v>
</v>
<v t="ekr.20140822160427.19047"><vh>To be solved in new vim mode</vh>
<v t="ekr.20080616110054.2"><vh>Support vim dot command</vh></v>
<v t="ekr.20100112051224.6234"><vh>Move current line (to screen position)</vh></v>
<v t="ekr.20100112051224.6235"><vh>Move body text up/down</vh></v>
<v t="ekr.20110202094848.12568"><vh>Named marks</vh></v>
<v t="ekr.20100112051224.6236"><vh>Two kinds of words</vh></v>
</v>
<v t="ekr.20100521090440.5887"><vh>Generalize minibuffer code</vh></v>
</v>
<v t="ekr.20131105122124.16479"><vh>vim reference card (do not delete)</vh>
<v t="ekr.20131105122124.16482"><vh> keys (do not sort!!)</vh></v>
<v t="ekr.20131108082341.18235"><vh>motion keys</vh></v>
<v t="ekr.20131108082341.18226"><vh>motions</vh></v>
<v t="ekr.20131105122124.16483"><vh>vim regex</vh></v>
<v t="ekr.20131105122124.16484"><vh>keys in insert mode</vh></v>
<v t="ekr.20131105122124.16485"><vh>complex</vh></v>
<v t="ekr.20131105122124.16486"><vh>text object</vh></v>
<v t="ekr.20131105122124.16487"><vh>offsets after search command</vh></v>
<v t="ekr.20131105122124.16488"><vh>Examples</vh></v>
<v t="ekr.20131105122124.16489"><vh>Options overview</vh></v>
<v t="ekr.20131105122124.16490"><vh>Command-line completion</vh></v>
<v t="ekr.20131105122124.16491"><vh>Special Ex characters</vh></v>
<v t="ekr.20131105122124.16492"><vh>Ex ranges</vh></v>
<v t="ekr.20131105122124.16493"><vh>Starting vim</vh></v>
<v t="ekr.20131105122124.16494"><vh>: commands unsorted</vh></v>
<v t="ekr.20131105122124.16495"><vh>: commands merged (do not sort!)</vh></v>
</v>
</v>
<v t="ekr.20140704052551.17951"><vh>Code</vh>
<v t="ekr.20120208062900.10146"><vh>Complete new_modes</vh></v>
<v t="ekr.20080628095358.1"><vh>Make each Leo command a class</vh></v>
<v t="ekr.20100219083854.5615"><vh>Improve caching</vh>
<v t="ekr.20100209160132.5770"><vh>cache notes</vh>
<v t="ekr.20100209114432.5751"><vh>Cache expansion bits</vh></v>
</v>
<v t="ekr.20100211095442.6201"><vh>cache notes 2</vh></v>
<v t="ekr.20100223075705.5635"><vh>Don't write expansion bits</vh></v>
<v t="ekr.20100210163813.5748"><vh>Caching buglets?</vh></v>
<v t="ekr.20100225102636.5627"><vh>Use the string returned by cacher</vh></v>
</v>
<v t="ekr.20111101050427.16716"><vh>Make g.openWithFileName "reentrant"</vh></v>
<v t="ekr.20111125072438.10216"><vh>Regularize slashes and back-slashes</vh>
<v t="ekr.20130503061707.10515"><vh>@@test path computations</vh>
<v t="ekr.20130503061707.10516"><vh>@path rel-path</vh>
<v t="ekr.20130503061707.10517"><vh>@@file fj-test-1</vh></v>
</v>
</v>
</v>
<v t="ekr.20111003232155.6988"><vh>Use c.db for marks &amp; expansion bits</vh></v>
<v t="ekr.20120516140545.9993"><vh>zz Unlikely</vh>
<v t="ekr.20111010093113.15548"><vh>Lighten Leo's code base; remove wrapper layers</vh></v>
<v t="ekr.20111021035504.9467"><vh>Play with PyQt Qtest framework</vh></v>
<v t="ekr.20120205022040.15412"><vh>Refactor the key code</vh></v>
<v t="ekr.20120226183512.10202"><vh>Use QSignalSpy?</vh></v>
<v t="ekr.20110605121601.18838"><vh>Remove or complete x.createBindings</vh></v>
<v t="ekr.20110605121601.18840"><vh>Support cascade menu</vh>
<v t="ekr.20110605121601.18841"><vh>cascade</vh></v>
</v>
<v t="ekr.20110605121601.18842"><vh>Should leoQtMenu.index do something?</vh></v>
</v>
</v>
<v t="ekr.20140704052551.17957"><vh>Coloring</vh>
<v t="ekr.20060824110846"><vh>* Add colorizing for cweb, rapidq</vh></v>
<v t="ekr.20110605121601.18839"><vh>* Create color picker</vh></v>
<v t="ekr.20130803073926.12442"><vh>* Waiting</vh></v>
<v t="ekr.20110614123640.6587"><vh>Add headline/color functions to Leo's core</vh></v>
<v t="ekr.20111028195854.16607"><vh>Allow ruleset-specific colors</vh></v>
</v>
<v t="ekr.20120229094652.15178"><vh>Commands</vh>
<v t="ekr.20141105050314.23"><vh>Problems with @g.command decorator</vh>
<v t="ekr.20141105050314.24"><vh>What I did</vh></v>
</v>
<v t="ekr.20111010122531.15569"><vh>print-bindings/commands/settings create nodes??</vh></v>
<v t="ekr.20130508084413.10634"><vh>quickmove-jump-to adds button</vh></v>
<v t="ekr.20111019104425.15868"><vh>Render to tex, pdf, rst, etc.</vh></v>
<v t="ekr.20120515193246.10083"><vh>Find &amp; spell</vh>
<v t="ekr.20111018104244.15928"><vh>Improve Find panel</vh></v>
<v t="ekr.20111014134653.15672"><vh>Search across multiple Leo files</vh></v>
<v t="ekr.20051110155735.1"><vh>Improve spell checking</vh></v>
<v t="ekr.20110520051220.18203"><vh>Cross-tab search</vh></v>
<v t="ekr.20111027143736.16558"><vh>Work-flow improvements</vh></v>
<v t="ekr.20041022083005.2"><vh>add a Stop button for find/change</vh></v>
<v t="ekr.20041219162724"><vh>Add dialog to insert recent directories</vh></v>
</v>
<v t="ekr.20120515193246.10084"><vh>Import/export</vh>
<v t="ekr.20101004092958.5914"><vh>Write treepad scanner</vh>
<v t="ekr.20101004092958.5939"><vh>treepad.py</vh>
<v t="ekr.20101004092958.5940"><vh>treepad declarations</vh></v>
<v t="ekr.20101004092958.5941"><vh>class Node</vh>
<v t="ekr.20101004092958.5942"><vh>__init__ (Node/treepad)</vh></v>
<v t="ekr.20101004092958.5943"><vh>__str__</vh></v>
<v t="ekr.20101004092958.5944"><vh>addchild</vh></v>
<v t="ekr.20101004092958.5945"><vh>findparent</vh></v>
<v t="ekr.20101004092958.5946"><vh>writenode</vh></v>
<v t="ekr.20101004092958.5947"><vh>writetree</vh></v>
</v>
<v t="ekr.20101004092958.5948"><vh>class NodeReader</vh>
<v t="ekr.20101004092958.5949"><vh>__init__ (NodeReader)</vh></v>
<v t="ekr.20101004092958.5950"><vh>expect</vh></v>
<v t="ekr.20101004092958.5951"><vh>readstart</vh></v>
<v t="ekr.20101004092958.5952"><vh>readnode</vh></v>
</v>
<v t="ekr.20101004092958.5953"><vh>class TreeReader</vh>
<v t="ekr.20101004092958.5954"><vh>__init__(TreeReader)</vh></v>
<v t="ekr.20101004092958.5955"><vh>add</vh></v>
<v t="ekr.20101004092958.5956"><vh>read</vh></v>
</v>
<v t="ekr.20101004092958.5957"><vh>class TreeWriter</vh>
<v t="ekr.20101004092958.5958"><vh>__init__ (TreeWriter)</vh></v>
<v t="ekr.20101004092958.5959"><vh>write</vh></v>
</v>
<v t="ekr.20101004092958.5960"><vh>class Main</vh>
<v t="ekr.20101004092958.5961"><vh>__init__ (Main)</vh></v>
<v t="ekr.20101004092958.5962"><vh>Run</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.790"><vh>Import dialog improvements</vh></v>
<v t="ekr.20060227124411"><vh>Import/export from wiki's</vh></v>
<v t="ekr.20031218072017.748"><vh>Import/Export to yaml</vh></v>
</v>
<v t="ekr.20041130123243"><vh>Clear Undo command</vh></v>
<v t="ekr.20050127110221"><vh>Printing &amp; flash</vh></v>
<v t="ekr.20031218072017.807"><vh>Put up file dialog on empty @url, etc.</vh></v>
<v t="ekr.20140824043305.18297"><vh>Unlikely...</vh>
<v t="ekr.20041016134312.2"><vh>Standard Weave command</vh></v>
<v t="ekr.20110529115328.18238"><vh>Emacs related</vh>
<v t="ekr.20110529104352.18248"><vh>Complete k.universalDispatcher</vh></v>
<v t="ekr.20110529104352.18249"><vh>Complete number-to-register command</vh></v>
<v t="ekr.20031218072017.753"><vh>Emacs comint-mode</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20071004120359.2"><vh>expand-region-abbrev</vh></v>
<v t="ekr.20060123091352"><vh>Incremental search in switch-to-buffer</vh></v>
<v t="ekr.20060628103226.3"><vh>Make sure repeat counts work on basic editing commands</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
</v>
</v>
<v t="ekr.20041022083226"><vh>Directives</vh>
<v t="ekr.20031218072017.805"><vh>Allow other section delims besides &lt;&lt; and &gt;&gt;</vh></v>
<v t="ekr.20031218072017.745"><vh>@@first &lt;n&gt;</vh></v>
<v t="ekr.20031218072017.795"><vh>Metatags</vh></v>
<v t="ekr.20041130104552"><vh>(Support bird-track programs/comments?)</vh></v>
<v t="ekr.20111010122531.15568"><vh>@render-rest, @render-html trees</vh></v>
<v t="ekr.20031218072017.797"><vh>Allow @file http &amp; @file ftp</vh>
<v t="ekr.20031218072017.810"><vh>Remote access Scott Powell</vh></v>
</v>
</v>
<v t="ekr.20140824043305.18292"><vh>Docs</vh>
<v t="ekr.20131029095615.17089"><vh>A cool tricks section</vh></v>
<v t="ekr.20130807203905.16650"><vh>Leo in a nutshell (statistics)</vh></v>
<v t="ekr.20060227123536"><vh>Tiddlywiki and related comments about rendering body text (Mulder)</vh></v>
<v t="ekr.20111018104244.15924"><vh>Revise Leo's wiki</vh></v>
</v>
<v t="ekr.20120515193246.10087"><vh>DOM</vh>
<v t="ekr.20071001052501"><vh>Versioning for nodes</vh></v>
<v t="ekr.20080802070659.11"><vh>Make node attributes visible, and supported by Leo's core</vh></v>
<v t="ekr.20111019104425.15896"><vh>Enhansed node attributes: ctime, atime, mtime (Kent)</vh></v>
<v t="ekr.20111027103125.16546"><vh>Fossil</vh></v>
</v>
<v t="ekr.20090131200406.15"><vh>File &amp; file format</vh>
<v t="ekr.20141017110114.18265"><vh>Use uuid's in gnx's</vh></v>
<v t="ekr.20061002093442"><vh>Add opml support to new,open, save commands</vh></v>
<v t="ekr.20080311135649.2"><vh>Allow different .leo formats</vh></v>
<v t="ekr.20080626081829.2"><vh>Allow headline comments for @nosent files</vh></v>
<v t="ekr.20080922115725.1"><vh>Finish @shadow</vh>
<v t="ekr.20081004102201.2"><vh>Log file for @shadow</vh></v>
<v t="ekr.20081001062423.1"><vh>Can @shadow mark externally changed nodes?</vh></v>
<v t="ekr.20090402072059.13"><vh>Create a general mechanism for aux (shadow, _db) files</vh></v>
<v t="ekr.20100826110728.5839"><vh>Relocating .leo_shadow directories</vh></v>
</v>
<v t="ekr.20111019104425.15895"><vh>LeoFS (Kent)</vh></v>
<v t="ekr.20110613110911.16421"><vh>Read/write files in json format</vh>
<v t="ekr.20111009230326.7037"><vh>Leo-to-json script for IPython?</vh>
<v t="ekr.20110527084258.18378"><vh>New file format</vh>
<v t="ekr.20110609042343.16546"><vh>Notes</vh>
<v t="ekr.20110609042343.16548"><vh>File format, v3 draft 5</vh></v>
<v t="ekr.20110421132230.6107"><vh>File format, v3 draft 4</vh></v>
<v t="ekr.20110419083918.6104"><vh>File format, v3 graphml</vh></v>
<v t="ekr.20090218115025.3"><vh>Why are attributes pickled by default?</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080919085541.3"><vh>Use sqlite data base as an alternative representation for .leo files</vh></v>
</v>
<v t="ekr.20120515193246.10085"><vh>Gui</vh>
<v t="ekr.20110929074744.15449"><vh>generalize show/hide/select gui elements commands</vh></v>
<v t="ekr.20110929074744.15499"><vh>Allow more panes to be part of the free_layout "action" buttons</vh></v>
<v t="ekr.20131121090013.17108"><vh>Import pane, similar to the Find pane</vh></v>
<v t="ekr.20101104191857.5820"><vh>QWebView makes Leo a presentation tool</vh></v>
<v t="ekr.20111019104425.15888"><vh>Support an openGL window in Leo</vh></v>
<v t="ekr.20111019104425.15892"><vh>Buttons (Kent)</vh></v>
<v t="ekr.20120604071051.10187"><vh>Add multiple body editors to session machinery</vh></v>
<v t="ekr.20140824043305.18299"><vh>zz Unlikely</vh>
<v t="ekr.20110620083705.14901"><vh>Fix or disable curses gui</vh></v>
<v t="ekr.20111019104425.15887"><vh>Host the PyQt demo inside Leo</vh></v>
</v>
</v>
<v t="ekr.20050509085713"><vh>Installer (wishlist)</vh>
<v t="ekr.20070929125944"><vh>Emulate Orange's download philosophy</vh></v>
<v t="ekr.20130807203905.16773"><vh>Leo for portableapps?</vh></v>
</v>
<v t="ekr.20140704052551.17950"><vh>IPython</vh>
<v t="ekr.20121005105428.12866"><vh>Ipython notebook stuff</vh>
<v t="ekr.20121005105428.10112"><vh>ipynb example</vh></v>
<v t="ekr.20121005105428.10095"><vh>&lt;&lt; ipynb example &gt;&gt;</vh></v>
<v t="ekr.20121005105428.10109"><vh>JSON Reference</vh>
<v t="ekr.20121005105428.10102"><vh>class NoteBookReader</vh></v>
<v t="ekr.20121005105428.10108"><vh>JSONReader(NotebookReader)</vh></v>
<v t="ekr.20121005105428.10107"><vh>class BytesEncoder</vh></v>
<v t="ekr.20121005105428.10097"><vh>From v3/nbjson.py</vh></v>
<v t="ekr.20121005105428.10098"><vh>From v3/rwbase.py</vh>
<v t="ekr.20121005105428.10103"><vh>fromDict</vh></v>
<v t="ekr.20121005105428.10104"><vh>restore_bytes</vh></v>
<v t="ekr.20121005105428.10105"><vh>_join_lines</vh></v>
<v t="ekr.20121005105428.10106"><vh>rejoin_lines</vh></v>
</v>
</v>
<v t="ekr.20121008100945.10295"><vh>Installation notes for ipython 0.13</vh></v>
</v>
<v t="ekr.20130806072439.21299"><vh>Leo and IPython</vh></v>
</v>
<v t="ekr.20130803125244.17100"><vh>Marketing</vh>
<v t="ekr.20131121211048.16378"><vh>* More screenshots!</vh></v>
<v t="ekr.20131101080215.16488"><vh>* Outreach to magazine editors</vh></v>
<v t="ekr.20130909111702.13058"><vh>Allow paypal donations to Leo</vh></v>
<v t="ekr.20130503155210.24814"><vh>Tutorials/Screencasts (revise)</vh></v>
<v t="ekr.20131213072223.16397"><vh>Video tutorials (revise)</vh>
<v t="ekr.20131221065129.16519"><vh>- Basic: Basic operations</vh>
<v t="ekr.20131221065129.16522"><vh>Basic focus operations</vh></v>
<v t="ekr.20131221065129.16524"><vh>Basic outline operations</vh></v>
<v t="ekr.20131221065129.16520"><vh>Basic text operations</vh></v>
</v>
<v t="ekr.20131208103040.16342"><vh>- Basic: Settings</vh>
<v t="ekr.20131121050226.16328"><vh>settings vid</vh></v>
</v>
<v t="ekr.20131211054925.16380"><vh>- Basic: Creating external files</vh></v>
<v t="ekr.20131208103040.16343"><vh>- Basic: Getting help</vh></v>
<v t="ekr.20131208103040.16349"><vh>- Intermediate: Importing files</vh></v>
<v t="ekr.20131116212505.16666"><vh>- Intermediate: More about scripting</vh>
<v t="ekr.20131116212505.16668"><vh>Ctrl-B (execute-script)</vh></v>
<v t="ekr.20131116212505.16669"><vh>Ctrl-B on selected text</vh></v>
<v t="ekr.20131116212505.16667"><vh>g</vh></v>
</v>
<v t="ekr.20131208103040.16344"><vh>- Intermediate: Auto-completion</vh></v>
<v t="ekr.20131208103040.16350"><vh>- Find command (needed?)</vh>
<v t="ekr.20131116123026.16661"><vh>Example</vh>
<v t="ekr.20131116123026.16662"><vh>spam</vh></v>
<v t="ekr.20131116123026.16663"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20111018220642.15862"><vh>Plugins</vh>
<v t="ekr.20111017132257.15882"><vh>Study import_xml plugin</vh></v>
<v t="ekr.20111004090723.15495"><vh>Finish leoOPML plugin</vh></v>
<v t="ekr.20111027143736.16557"><vh>Study leo_screen</vh></v>
</v>
<v t="ekr.20110930075237.15474"><vh>Settings</vh>
<v t="ekr.20120516140545.9992"><vh>Matt Wilkie</vh></v>
<v t="ekr.20061011111007"><vh>@bool autoload_most_recent_leo_file</vh></v>
</v>
<v t="ekr.20111109083738.9798"><vh>Testing</vh>
<v t="ekr.20111105222316.9706"><vh>Unit test: no unit tests omitted</vh></v>
<v t="ekr.20111105222316.9707"><vh>Unit test: importing a plugin changes nothing</vh></v>
<v t="ekr.20111114151846.9856"><vh>Unit test: verifies class relationships</vh>
<v t="ekr.20111114151846.9852"><vh>mustBeDefined...</vh>
<v t="ekr.20111114151846.9850"><vh>From baseTextWidget</vh>
<v t="ekr.20081031074455.3"><vh>baseTextWidget.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20081031074455.4"><vh>baseTextWidget.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20081031074455.5"><vh>baseTextWidget.mustBeDefined...</vh></v>
</v>
<v t="ekr.20111114151846.9851"><vh>From leoBody</vh>
<v t="ekr.20081005065934.9"><vh>leoBody.mustBeDefined</vh></v>
<v t="ekr.20031218072017.3660"><vh>leoBody.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20061109102912"><vh>define leoBody.mustBeDefinedOnlyInBaseClass</vh></v>
</v>
<v t="ekr.20111114151846.9853"><vh>from leoFrame</vh>
<v t="ekr.20080429051644.1"><vh>leoFrame.mustBeDefined</vh></v>
<v t="ekr.20061109120726"><vh>leoFrame.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109120704"><vh>leoFrame.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20111114151846.9854"><vh>from leoTree</vh>
<v t="ekr.20081005065934.7"><vh>leoTree.mustBeDefined</vh></v>
<v t="ekr.20061109164512"><vh>leoTree.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109164610"><vh>leoTree.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20111114151846.9855"><vh>from leoGui</vh>
<v t="ekr.20061109211054"><vh>leoGui.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109211022"><vh>leoGui.mustBeDefinedInSubclasses</vh></v>
</v>
</v>
</v>
<v t="ekr.20100131161507.6303"><vh>Unit test: all commands have docstrings</vh></v>
<v t="ekr.20140322090829.16832"><vh>Improve Sherlock</vh></v>
<v t="ekr.20120226180525.10191"><vh>Run unit tests interactively?</vh></v>
</v>
<v t="ekr.20040123102724"><vh>zz Can't or won't do</vh>
<v t="ekr.20140824043305.18296"><vh>Can't do</vh>
<v t="ekr.20111011062533.15693"><vh>Make headline widgets scrollable</vh></v>
<v t="ekr.20031218072017.670"><vh>Possible webbrowser bug</vh></v>
<v t="ekr.20050202073944"><vh>Mac bugs</vh>
<v t="ekr.20050201175325.2"><vh>Can't delete script buttons</vh></v>
<v t="ekr.20050201175325.1"><vh>Icon buttons are not colored, nor do they have square borders, etc.</vh></v>
<v t="ekr.20110111100539.12257"><vh>Fix end-of-line problem (MacOS)</vh>
<v t="ekr.20110111100539.12258"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20031218072017.673"><vh>Tk bugs</vh>
<v t="ekr.20081208102356.1"><vh>Threading colorizer doesn't handle multiple body editors</vh></v>
<v t="ekr.20041201071145"><vh>Tk Freezes on debean when libtk is compiled with thread support</vh></v>
<v t="EKR.20040523192553"><vh>(Crash when pasting large text into headlines)</vh>
<v t="EKR.20040606104355"><vh>Report</vh></v>
</v>
<v t="ekr.20031218072017.674"><vh>Caps lock affects keyboard shortcuts on Windows</vh></v>
<v t="ekr.20031218072017.675"><vh>Tree problems</vh></v>
<v t="ekr.20031218072017.676"><vh>Control-T can't be overridden in canvas text.</vh></v>
<v t="ekr.20031218072017.677"><vh>(Alt-ctrl = Alt)</vh></v>
<v t="ekr.20031218072017.718"><vh>(tab bug)</vh>
<v t="ekr.20040117092727"><vh>This is definitely a Tk bug</vh></v>
<v t="ekr.20040118090055"><vh>Patch and bug report</vh></v>
<v t="ekr.20031218072017.719"><vh>Report</vh></v>
<v t="ekr.20040105070023.5"><vh>Report 2</vh></v>
<v t="ekr.20031218072017.720"><vh>Minimal test</vh></v>
<v t="ekr.20031218072017.721"><vh>Test File for Non Expanding Tabs</vh></v>
</v>
<v t="ekr.20031218072017.672"><vh>Control-V doesn't work on Linux</vh></v>
<v t="ekr.20040220110030"><vh>Change cursor when caps lock is down</vh></v>
</v>
<v t="ekr.20040115165036"><vh>bug in xml doc parts (hard to fix?)</vh>
<v t="ekr.20040115165036.1"><vh>Demo XML comment bug</vh></v>
<v t="ekr.20040115165036.3"><vh>@file xmlcommentbug.xml</vh></v>
<v t="ekr.20040115165036.4"><vh>xmlcommentbug.xml</vh></v>
</v>
<v t="ekr.20110619173515.14896"><vh>Wrong modality level on autocompleter</vh></v>
</v>
<v t="ekr.20140824043305.18295"><vh>Won't do</vh>
<v t="ekr.20130919120947.12506"><vh>* Why Leo won't be a web app</vh></v>
<v t="ekr.20040216054459"><vh>@h @f @endh and @endf directives</vh></v>
<v t="ekr.20101119030344.5838"><vh>Bad idea: script to turn all commands into @g.command nodes</vh>
<v t="ekr.20101119030344.5841"><vh>find_all_defs</vh></v>
<v t="ekr.20101119030344.5839"><vh>find</vh></v>
<v t="ekr.20101119030344.5840"><vh>adjust</vh></v>
</v>
<v t="ekr.20130803125244.17077"><vh>bug: web site for Leo google group is out of date</vh></v>
<v t="ekr.20080815174457.5"><vh>Consider deleting private shadow files</vh></v>
<v t="ekr.20131019061259.16697"><vh>Fix broken links on Leo's web site</vh></v>
<v t="ekr.20100830120622.5829"><vh>Fix python import problems</vh></v>
<v t="ekr.20131121050226.16327"><vh>Reload command</vh></v>
<v t="ekr.20111019104425.15863"><vh>Use pygments for syntax coloring</vh></v>
</v>
</v>
</v>
</v>
<v t="davy.20141209134323.1018"><vh>NOTES</vh>
<v t="ekr.20131005214621.16081"><vh>Notes</vh>
<v t="ekr.20090202064534.4"><vh> Your mission, should you choose to accept it</vh>
<v t="ekr.20100223100750.5843"><vh>Original post by Robin Dunn</vh></v>
<v t="ekr.20100223100750.5842"><vh>Post to pyxides, 2010/02/23</vh></v>
<v t="ekr.20110616084347.14800"><vh>Post to pyxides, 2011/07/10</vh></v>
</v>
<v t="ekr.20061116060847"><vh>@url http://www.jhorman.org/wikidPad/</vh></v>
<v t="ekr.20131011050613.16839"><vh>About autocompletion</vh>
<v t="ekr.20131011050613.16840"><vh>UI notes</vh></v>
<v t="ekr.20131011050613.16841"><vh>Appearance</vh></v>
<v t="ekr.20131011050613.16842"><vh>Performance</vh></v>
</v>
<v t="ekr.20131011050613.16843"><vh>About Key handling</vh>
<v t="ekr.20131011050613.16849"><vh>Key bindings</vh></v>
<v t="ekr.20131011050613.16850"><vh>Handling key events</vh>
<v t="ekr.20131011050613.16851"><vh>All events are key events</vh></v>
<v t="ekr.20131011050613.16852"><vh>c.check_event</vh></v>
</v>
<v t="ekr.20131011050613.16853"><vh>About the KeyStroke class</vh></v>
<v t="ekr.20131011050613.16854"><vh>Simplifying the Qt input code</vh></v>
<v t="ekr.20131011050613.16855"><vh>Typed dicts</vh></v>
</v>
<v t="ekr.20091218120633.6299"><vh>Bzr</vh>
<v t="ekr.20080917153158.10"><vh>Bzr notes</vh></v>
<v t="ekr.20090713080429.6042"><vh>Bzr workflow notes</vh></v>
<v t="ekr.20081113095540.1"><vh>Bzr/ubuntu notes</vh></v>
</v>
<v t="ekr.20101024062147.6004"><vh>Documentation notes</vh>
<v t="ekr.20060306194040"><vh>The curse of knowledge</vh></v>
<v t="ekr.20100828074347.5828"><vh>Slide show resources</vh></v>
<v t="ekr.20100904134301.8336"><vh>Generate pdf on Linux</vh></v>
</v>
<v t="ekr.20130807203905.16683"><vh>ENB: fixing the key binding bug</vh></v>
<v t="ekr.20130502104323.10581"><vh>github notes</vh></v>
<v t="ekr.20031218072017.365"><vh>How to...</vh>
<v t="ekr.20060208112908"><vh>BZR stuff...</vh>
<v t="ekr.20060331094112"><vh>How to generate keys using putty</vh></v>
<v t="ekr.20031218072017.366"><vh>How to add and remove files from CVS repository</vh></v>
<v t="ekr.20031218072017.391"><vh>How to use CVS branches</vh></v>
</v>
<v t="ekr.20031218072017.367"><vh>How to add support for a new language</vh></v>
<v t="ekr.20080814134319.1"><vh>How to create and push to a private bzr branch</vh></v>
<v t="ekr.20051203084725"><vh>How to expand java .jar files</vh></v>
<v t="ekr.20031218072017.384"><vh>How to export syntax colored code preserving colors</vh></v>
<v t="ekr.20031218072017.385"><vh>How to Increase environment space</vh></v>
<v t="ekr.20051203084725.1"><vh>How to install and run jythonShell</vh></v>
<v t="ekr.20050316092232"><vh>How to install jyLeo</vh>
<v t="ekr.20050716104357"><vh>Old instructions</vh></v>
<v t="ekr.20050317153447"><vh>jy-Leo install instructions by Paul Paterson</vh></v>
</v>
<v t="ekr.20051129084430"><vh>How to install jython</vh>
<v t="ekr.20051129084430.1"><vh>@url http://www.jython.org/install.html</vh></v>
</v>
<v t="ekr.20101004092958.6050"><vh>How to make codewise work</vh></v>
<v t="ekr.20070623150151"><vh>How to make Leo commands undoable</vh></v>
<v t="ekr.20091217112515.6070"><vh>How to make the codewise completer work</vh>
<v t="ekr.20091217112515.6069"><vh>Others posts</vh></v>
<v t="ekr.20091217112515.6071"><vh>plugin docs</vh></v>
</v>
<v t="ekr.20131017100502.16702"><vh>How to profile Leo</vh></v>
<v t="ekr.20031218072017.386"><vh>How to remove cursed newlines: use binary mode</vh>
<v t="ekr.20031218072017.387"><vh>The solution</vh></v>
<v t="ekr.20031218072017.388"><vh>cursed newline answer</vh></v>
<v t="ekr.20031218072017.389"><vh>cursed newline answer 2</vh></v>
</v>
<v t="ekr.20061023153133"><vh>How to run patch</vh></v>
<v t="ekr.20050510071834"><vh>How to use a temp file with pdb</vh></v>
</v>
<v t="ekr.20130812034101.12581"><vh>Installation Notes</vh>
<v t="ekr.20130807090137.11461"><vh>Linux</vh>
<v t="ekr.20130806072439.20730"><vh>PyPi package: 4.11 test release: Matt</vh></v>
<v t="ekr.20130806072439.20664"><vh>finding debian package</vh></v>
<v t="ekr.20130806072439.20683"><vh>linux users: please test pip install</vh></v>
</v>
<v t="ekr.20130807090137.11462"><vh>Windows</vh>
<v t="ekr.20130806072439.20677"><vh>Installing pip on windows</vh></v>
<v t="ekr.20130806072439.20707"><vh>Portable Leo from scratch on Windows</vh>
<v t="ekr.20130807090137.11463"><vh>script</vh></v>
<v t="ekr.20130806072439.20712"><vh>Re: Portable Leo from scratch on Windows</vh></v>
</v>
<v t="ekr.20130806072439.20722"><vh>apt on windows</vh></v>
<v t="ekr.20130806072439.20643"><vh>Tip about install leo with EPD</vh></v>
</v>
</v>
<v t="ekr.20130814140750.17191"><vh>IPython notes</vh>
<v t="ekr.20130814140750.17192"><vh>Ipython now has cell magic</vh></v>
<v t="ekr.20130814140750.17193"><vh>IPython code notes</vh></v>
</v>
<v t="ekr.20091218120633.6300"><vh>Other notes</vh>
<v t="ekr.20090601083544.6066"><vh>Cool plugins &amp; Leo code</vh></v>
<v t="ekr.20070614094933"><vh>EasyInstall installation notes--XP</vh></v>
<v t="ekr.20071104222805"><vh>Emacs/Pymacs notes</vh>
<v t="ekr.20071102191642.1"><vh>xemacs/pymacs install notes</vh></v>
<v t="ekr.20071103090504"><vh>Pymacs docs</vh>
<v t="ekr.20071103090504.1"><vh>Emacs Lisp structures and Python objects</vh>
<v t="ekr.20071103090504.2"><vh>Emacs lisp structures and Python</vh></v>
<v t="ekr.20071103090504.3"><vh>Simple objects</vh></v>
<v t="ekr.20071103090504.4"><vh>Sequences</vh></v>
</v>
<v t="ekr.20071103090504.5"><vh>Opaque objects</vh>
<v t="ekr.20071103090504.6"><vh>Emacs lisp handles</vh></v>
<v t="ekr.20071103090504.7"><vh>Python handles</vh></v>
</v>
<v t="ekr.20071103090504.8"><vh>Usages on the Emacs lisp side</vh>
<v t="ekr.20071103090504.9"><vh>pymacs-eval/apply</vh></v>
<v t="ekr.20071103090504.10"><vh>pymacs-load</vh></v>
</v>
<v t="ekr.20071103091052"><vh>Usage on the Python side</vh>
<v t="ekr.20071103091052.1"><vh>Python setup</vh></v>
<v t="ekr.20071103091052.2"><vh>Response mode</vh></v>
<v t="ekr.20071103091052.3"><vh>Emacs lisp symbols</vh></v>
<v t="ekr.20071103091052.4"><vh>Dynamic bindings (The let class)</vh></v>
<v t="ekr.20071103091052.5"><vh>Raw Emacs lisp expression</vh></v>
<v t="ekr.20071103091052.6"><vh>User interaction</vh></v>
<v t="ekr.20071103091052.7"><vh>Key bindings</vh></v>
</v>
<v t="ekr.20071103092153"><vh>Debugging</vh>
<v t="ekr.20071103092153.1"><vh>The *pymacs* buffer</vh></v>
<v t="ekr.20071103092153.2"><vh>Usual Emacs debugging</vh></v>
<v t="ekr.20071103092153.3"><vh>Auto-reloading on save</vh></v>
</v>
<v t="ekr.20071103092153.4"><vh>Example 1: defining an Emacs command in Python</vh></v>
<v t="ekr.20071103093725"><vh>Example 3: defining a rebox tool</vh>
<v t="ekr.20071103094355"><vh>The python side</vh></v>
<v t="ekr.20071103094355.1"><vh>The emacs side</vh></v>
<v t="ekr.20071103093725.1"><vh>rebox.py</vh>
<v t="ekr.20071103093725.2"><vh>rebox declarations</vh></v>
<v t="ekr.20071103093725.3"><vh>main</vh></v>
<v t="ekr.20071103093725.4"><vh>pymacs_load_hook</vh></v>
<v t="ekr.20071103093725.5"><vh>class Emacs_Rebox</vh>
<v t="ekr.20071103093725.6"><vh>__init__ (Emacs_Rebox)</vh></v>
<v t="ekr.20071103093725.7"><vh>set_default_style</vh></v>
<v t="ekr.20071103093725.8"><vh>region</vh></v>
<v t="ekr.20071103093725.9"><vh>comment</vh></v>
<v t="ekr.20071103093725.10"><vh>emacs_engine</vh></v>
<v t="ekr.20071103093725.11"><vh>ask_for_style</vh></v>
<v t="ekr.20071103093725.12"><vh>find_region</vh></v>
<v t="ekr.20071103093725.13"><vh>find_comment</vh></v>
<v t="ekr.20071103093725.14"><vh>remainder_of_line</vh></v>
<v t="ekr.20071103093725.15"><vh>clean_undo_after_old</vh></v>
<v t="ekr.20071103093725.16"><vh>clean_undo_after</vh></v>
</v>
<v t="ekr.20071103093725.17"><vh>engine</vh></v>
<v t="ekr.20071103093725.18"><vh>guess_language</vh></v>
<v t="ekr.20071103093725.19"><vh>guess_template</vh></v>
<v t="ekr.20071103093725.20"><vh>left_margin_size</vh></v>
<v t="ekr.20071103093725.21"><vh>merge_styles</vh></v>
<v t="ekr.20071103093725.22"><vh>refill_lines</vh></v>
<v t="ekr.20071103093725.23"><vh>class Marker</vh>
<v t="ekr.20071103093725.24"><vh>save_position</vh></v>
<v t="ekr.20071103093725.25"><vh>get_position</vh></v>
</v>
<v t="ekr.20071103093725.26"><vh>class Template</vh>
<v t="ekr.20071103093725.27"><vh>__init_ (Template)_</vh></v>
<v t="ekr.20071103093725.28"><vh>__cmp__</vh></v>
<v t="ekr.20071103093725.29"><vh>characters</vh></v>
<v t="ekr.20071103093725.30"><vh>match</vh></v>
<v t="ekr.20071103093725.31"><vh>unbuild</vh></v>
<v t="ekr.20071103093725.32"><vh>build</vh></v>
</v>
<v t="ekr.20071103093725.33"><vh>regexp_quote</vh></v>
<v t="ekr.20071103093725.34"><vh>regexp_ruler</vh></v>
<v t="ekr.20071103093725.35"><vh>unbuild_clean</vh></v>
<v t="ekr.20071103093725.36"><vh>make_generic</vh></v>
<v t="ekr.20071103093725.37"><vh>&lt;&lt; templates &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070215183046"><vh>IronPython notes</vh></v>
<v t="ekr.20050214055018"><vh>Mac Notes</vh>
<v t="ekr.20050221054932"><vh>How to make monolithic Leo app on MacOS X</vh></v>
<v t="ekr.20050214055018.4"><vh>@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)</vh></v>
<v t="ekr.20050214055018.5"><vh>@url http://www.wordtech-software.com/leo.html  (Mac Bundle)</vh></v>
<v t="ekr.20050513164506"><vh>Problems with run script command on Mac x11</vh></v>
<v t="ekr.20040104162835.8"><vh>Linux/Mac notes: Dan Winkler</vh>
<v t="ekr.20040104162835.13"><vh>Fink &amp; aqua</vh></v>
<v t="ekr.20040104162835.14"><vh>Mac, Fink, etc.</vh></v>
<v t="ekr.20040104162835.15"><vh>Double clicking on Linux</vh></v>
</v>
</v>
<v t="ekr.20060111112513.1"><vh>New jyLeo notes</vh></v>
<v t="ekr.20031218072017.392"><vh>Python Notes...</vh>
<v t="ekr.20031218072017.398"><vh>How to call any Python method from the C API</vh></v>
<v t="ekr.20031218072017.399"><vh>How to run Python programs easily on NT,2K,XP</vh>
<v t="ekr.20031218072017.400"><vh>setting the PATHEXT env var</vh></v>
<v t="ekr.20031218072017.401"><vh>Yet another Python .bat wrapper</vh></v>
</v>
</v>
<v t="ekr.20080110082845"><vh>pyxides: code completion</vh></v>
<v t="ekr.20070308062440"><vh>Thread notes</vh>
<v t="ekr.20070308062440.1"><vh>Posting 2</vh></v>
</v>
<v t="ekr.20050306070535"><vh>Tk Notes</vh>
<v t="ekr.20050306070535.3"><vh>How to detect changes in text</vh></v>
</v>
</v>
<v t="ekr.20130807203905.16727"><vh>Porting docutils (failed)</vh>
<v t="ekr.20130807203905.16728"><vh>notes re 2to3 fixers</vh></v>
<v t="ekr.20130807203905.16729"><vh>New 2to3 fixers</vh>
<v t="ekr.20130807203905.16730"><vh>@@nosent C:\Python27\Lib\lib2to3\fixes\fix_unified_unicode.py</vh></v>
<v t="ekr.20130807203905.16731"><vh>@@nosent C:\Python27\Lib\lib2to3\fixes\fix_unified_imports.py</vh>
<v t="ekr.20130807203905.16732"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20130807203905.16733"><vh>&lt;&lt; define mapping &gt;&gt;</vh></v>
<v t="ekr.20130807203905.16734"><vh>alternates</vh></v>
<v t="ekr.20130807203905.16735"><vh>build_pattern</vh></v>
<v t="ekr.20130807203905.16736"><vh>class FixUnifiedImports</vh>
<v t="ekr.20130807203905.16737"><vh>build_pattern</vh></v>
<v t="ekr.20130807203905.16738"><vh>compile_pattern</vh></v>
<v t="ekr.20130807203905.16739"><vh>dump</vh></v>
<v t="ekr.20130807203905.16740"><vh>match</vh></v>
<v t="ekr.20130807203905.16741"><vh>start_tree</vh></v>
<v t="ekr.20130807203905.16742"><vh>transform (fix_unified_imports)</vh></v>
<v t="ekr.20130807203905.16743"><vh>find_name (EKR)</vh></v>
</v>
</v>
<v t="ekr.20130807203905.16744"><vh>trace</vh></v>
</v>
<v t="ekr.20130807203905.16745"><vh>Scripts</vh>
<v t="ekr.20130807203905.16746"><vh>Script: write constants to log pane</vh></v>
<v t="ekr.20130807203905.16747"><vh>Script: check syntax of all docutils files</vh></v>
<v t="ekr.20130807203905.16748"><vh>Script: restore newlines</vh></v>
<v t="ekr.20130807203905.16749"><vh>Script: create ords arrays</vh>
<v t="ekr.20130807203905.16750"><vh>compare and helper</vh></v>
</v>
<v t="ekr.20130807203905.16751"><vh>Script: test quote_pairs</vh></v>
</v>
<v t="ekr.20130807203905.16752"><vh>Tests</vh>
<v t="ekr.20130807203905.16753"><vh>@@test special chars script &amp; helpers</vh>
<v t="ekr.20130807203905.16754"><vh>punctuation_samples</vh></v>
<v t="ekr.20130807203905.16755"><vh>unicode_charlists</vh></v>
<v t="ekr.20130807203905.16756"><vh>compare</vh></v>
<v t="ekr.20130807203905.16757"><vh>dump</vh></v>
<v t="ekr.20130807203905.16758"><vh>test</vh></v>
</v>
<v t="ekr.20130807203905.16759"><vh>consistency check (was in punctuation chars</vh></v>
<v t="ekr.20130807203905.16760"><vh>docutils test imports</vh></v>
<v t="ekr.20130807203905.16761"><vh>six.u tests</vh>
<v t="ekr.20130807203905.16762"><vh>&lt;&lt; tex2unichar dicts &gt;&gt;</vh></v>
</v>
<v t="ekr.20130807203905.16763"><vh>u test</vh>
<v t="ekr.20130807203905.16764"><vh>from latex2e/__init__py</vh></v>
</v>
</v>
<v t="ekr.20130807203905.16765"><vh>Files with u and ur constants</vh></v>
</v>
<v t="ekr.20131001045038.19027"><vh>Quotes from "Why Leo isn't more popular"</vh>
<v t="ekr.20131001045038.19028"><vh>Fidel</vh></v>
<v t="ekr.20131001045038.19029"><vh>Jacob Peck</vh></v>
<v t="ekr.20131001045038.19030"><vh>Kent</vh></v>
<v t="ekr.20131001045038.19031"><vh>Fidel</vh></v>
<v t="ekr.20131001045038.19032"><vh>dufriz</vh></v>
<v t="ekr.20131001045038.19034"><vh>dufriz</vh></v>
<v t="ekr.20131003040744.18223"><vh>dufriz **</vh></v>
<v t="ekr.20131001045038.19035"><vh>Terry</vh></v>
<v t="ekr.20131001045038.19036"><vh>Miles Fidelman (improve wiki)</vh></v>
<v t="ekr.20131001045038.19038"><vh>Chris George</vh></v>
<v t="ekr.20131001045038.19039"><vh>Chris George</vh></v>
<v t="ekr.20131001045038.19040"><vh>Terry's new code</vh></v>
<v t="ekr.20131001045038.19041"><vh>Chris George</vh></v>
<v t="ekr.20131001045038.19042"><vh>Terry's new markup_inline plugin</vh></v>
<v t="ekr.20131001045038.19043"><vh>Ludwig Schwardt: MacOS brew instructions</vh></v>
<v t="ekr.20131001045038.19044"><vh>EKR</vh></v>
<v t="ekr.20131001045038.19045"><vh>EKR</vh></v>
<v t="ekr.20131001100335.15927"><vh>Links to Book about Leo</vh></v>
<v t="ekr.20131001100335.15926"><vh>derwish</vh></v>
<v t="ekr.20131012060912.16765"><vh>matt</vh></v>
</v>
<v t="ekr.20090105132011.6"><vh>Regex notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
</v>
<v t="ekr.20110527084258.18374"><vh>Summary of the Ashland sprint</vh></v>
<v t="ekr.20101127152442.5878"><vh>Url's</vh>
<v t="ekr.20101127154340.5935"><vh>Apps</vh>
<v t="ekr.20101127154340.6806"><vh>@url review board: code review</vh></v>
<v t="ekr.20101127154340.6824"><vh>@url scrivener: cool MacOS outliner</vh></v>
<v t="ekr.20101127154340.5934"><vh>@url tomboy: wiki-like notes</vh></v>
</v>
<v t="ekr.20101127152442.5879"><vh>Autocompletion</vh>
<v t="ekr.20101127152442.5881"><vh>@url ctagscompleter.py (Ville's suggestion)</vh></v>
<v t="ekr.20101127152442.5880"><vh>@url pydiction (autocompletion for vim)</vh></v>
<v t="ekr.20101127154340.5931"><vh>@url pysmell: python IDE completion helper</vh></v>
<v t="ekr.20101127154340.6828"><vh>@url SciTe Java api</vh>
<v t="ekr.20101127154340.6829"><vh>@url tags2api.py: python</vh></v>
<v t="ekr.20101127154340.6830"><vh>@url generates python api for scite</vh></v>
</v>
</v>
<v t="ekr.20101127201907.5952"><vh>Data bases</vh>
<v t="ekr.20101127154340.6856"><vh>@url lazysoft: cool db (sentences)</vh></v>
<v t="ekr.20101127201907.5953"><vh>@url persistent trees: couchDB</vh></v>
</v>
<v t="ekr.20101127201907.5947"><vh>Docs</vh>
<v t="ekr.20101127201907.5949"><vh>@url new design for colorer</vh></v>
<v t="ekr.20101127201907.5945"><vh>@url docs for my successor</vh></v>
<v t="ekr.20101127201907.5946"><vh>@url Leo's MVC architecture</vh></v>
<v t="ekr.20101127201907.5948"><vh>@url one damn fine checkin</vh></v>
<v t="ekr.20101127201907.5951"><vh>@url Stupendous Aha re unit tests</vh></v>
</v>
<v t="ekr.20101127154340.6805"><vh>Editors</vh>
<v t="ekr.20101127154340.6807"><vh>@url pyxides</vh></v>
<v t="ekr.20101127154340.6813"><vh>Vim</vh>
<v t="ekr.20101127154340.6814"><vh>@url vim cheat sheet</vh></v>
<v t="ekr.20101127154340.6815"><vh>@url vim reference guide</vh></v>
<v t="ekr.20101127154340.6816"><vh>@url slight advance intro to vim</vh></v>
<v t="ekr.20101127154340.6817"><vh>@url voom: vim 2-page outliner</vh></v>
<v t="ekr.20101127154340.6818"><vh>@url why do those nutheads use vim</vh></v>
<v t="ekr.20101127154340.6819"><vh>@url viper</vh></v>
<v t="ekr.20101127154340.6820"><vh>@ulr learning vim the pragmatic way</vh></v>
</v>
<v t="ekr.20101127154340.6822"><vh>@url python-UNO (Open Office)</vh></v>
<v t="ekr.20101127154340.6823"><vh>@url open komodo forums</vh></v>
<v t="ekr.20101127154340.6825"><vh>@url org-babel</vh></v>
</v>
<v t="ekr.20101127152442.5884"><vh>Feature requests</vh>
<v t="ekr.20101127152442.5885"><vh>Better find/replace dialog</vh></v>
<v t="ekr.20101127152442.5886"><vh>@image find/replace dialog</vh></v>
</v>
<v t="ekr.20101127154340.6808"><vh>Graphics</vh>
<v t="ekr.20101127154340.6843"><vh>@url inkscape: open source svg editor</vh></v>
<v t="ekr.20101127154340.6835"><vh>@url interactive map of Linux kernel</vh></v>
<v t="ekr.20101127154340.6836"><vh>@url blender: open source content creation</vh></v>
<v t="ekr.20101127154340.6809"><vh>@url tinkerpop: graphics tools</vh></v>
<v t="ekr.20101129064803.6061"><vh>@url problem solving with graph traversals</vh></v>
</v>
<v t="ekr.20101127152442.5887"><vh>Gui</vh>
<v t="ekr.20101127152442.5888"><vh>@url cool hack: detach body editor</vh></v>
<v t="ekr.20101127152442.5889"><vh>@url fast syntax highlighting</vh></v>
<v t="ekr.20101127152442.5890"><vh>@url code bubbles: an alternative to clones</vh></v>
<v t="ekr.20101127154340.6840"><vh>@url SIKULI: test gui's</vh></v>
</v>
<v t="ekr.20101127152442.5882"><vh>Leo projects</vh>
<v t="ekr.20101127152442.5883"><vh>@url @data contextmenu_commands</vh></v>
<v t="ekr.20101127152442.5912"><vh>@url fuse: Leo as a file system</vh></v>
<v t="ekr.20101127154340.5936"><vh>@url proto of a Leo forum</vh></v>
<v t="ekr.20101129064803.6062"><vh>@url stickynotes_plus and markdown</vh></v>
<v t="ekr.20101129064803.6063"><vh>@url leo+emacs+pida</vh></v>
<v t="ekr.20101129064803.6065"><vh>@url leoremote.py</vh>
<v t="ekr.20101129064803.6066"><vh>@url  Ville's script</vh></v>
<v t="ekr.20101129064803.6067"><vh>@url Terry's led script</vh></v>
</v>
<v t="ekr.20101127152442.5903"><vh>Ville</vh>
<v t="ekr.20101127152442.5904"><vh>@url use json to represent trees</vh></v>
<v t="ekr.20101127152442.5905"><vh>@url dump snippets as yaml</vh></v>
<v t="ekr.20101127152442.5906"><vh>@url creating debian packages</vh></v>
<v t="ekr.20101127154340.5927"><vh>@url objtrees: object trees for unit testing</vh></v>
<v t="ekr.20101127154340.6852"><vh>@url codewise: ville's code completer</vh></v>
<v t="ekr.20101129064803.6060"><vh>@url server code to interact with a running Leo</vh></v>
</v>
</v>
<v t="ekr.20101127154340.6826"><vh>Leo urls</vh>
<v t="ekr.20101127154340.6827"><vh>@url NSIS manual</vh></v>
<v t="ekr.20101127154340.6833"><vh>@url leo-editor-files</vh></v>
<v t="ekr.20101127154340.6851"><vh>@url upload to source forge</vh></v>
</v>
<v t="ekr.20101127154340.6837"><vh>Math</vh>
<v t="ekr.20101127154340.6838"><vh>@url sage: mathematics software system</vh></v>
<v t="ekr.20101127154340.6839"><vh>@url viewdog: viewer for math functions</vh></v>
</v>
<v t="ekr.20101127152442.5910"><vh>Python tools</vh>
<v t="ekr.20101127152442.5911"><vh>@url clonedigger: find similar code</vh></v>
<v t="ekr.20101127154340.5928"><vh>@url pyexpect: spawn child apps</vh></v>
<v t="ekr.20101129064803.6059"><vh>@url pynotify: wait for a file to change</vh></v>
<v t="ekr.20101127154340.6804"><vh>@url python trace module</vh>
<v t="ekr.20101127154340.6803"><vh>Call hierarchy tracing (using python 'trace' module)</vh></v>
</v>
<v t="ekr.20101127154340.5932"><vh>@url pythoscope: create unit tests automatically</vh></v>
<v t="ekr.20101127154340.5933"><vh>@url rope: refactoring library</vh></v>
</v>
<v t="ekr.20101127152442.5891"><vh>Scientific</vh>
<v t="ekr.20101127152442.5892"><vh>@url calioPY Scientific environment using Leo</vh></v>
<v t="ekr.20101127154340.6812"><vh>@url reinteract: scientific platform</vh></v>
</v>
<v t="ekr.20101127152442.5893"><vh>Text</vh>
<v t="ekr.20101127152442.5894"><vh>Related to viewrendered plugin</vh>
<v t="ekr.20101127152442.5895"><vh>@url enthought editor for restructured text</vh></v>
<v t="ekr.20101127152442.5896"><vh>@url autosphinx (related to enthought editor)</vh></v>
<v t="ekr.20101127152442.5913"><vh>@url manuel: rST testing tool</vh></v>
</v>
<v t="ekr.20101127152442.5897"><vh>@url controlling tex parameter from rst markup</vh>
<v t="ekr.20101127152442.5898"><vh>solution 1: use @raw</vh></v>
<v t="ekr.20101127152442.5899"><vh>solution 2: use make</vh></v>
</v>
<v t="ekr.20101127152442.5900"><vh>@url rst to anything</vh></v>
<v t="ekr.20101127154340.6845"><vh>@url mxTextTools: python text tools</vh></v>
<v t="ekr.20101127154340.6847"><vh>@url 2die4 games: TL (very cool rst stuff)</vh></v>
<v t="ekr.20101127201907.5950"><vh>@url idea - presentation tool</vh></v>
<v t="ekr.20101127201907.5954"><vh>@url rst/html in email</vh></v>
<v t="ekr.20101129064803.6064"><vh>@url rst/latex tricks</vh></v>
</v>
<v t="ekr.20101127152442.5901"><vh>Video tools</vh>
<v t="ekr.20101127154340.6841"><vh>@url screenr: instant screencasts for twitter</vh></v>
<v t="ekr.20101127154340.6842"><vh>@url jing</vh></v>
</v>
<v t="ekr.20101127152442.5907"><vh>Web technologies</vh>
<v t="ekr.20101127154340.6811"><vh>@url 0mq: socket library</vh></v>
<v t="ekr.20101127154340.6810"><vh>@url flask: micro devel framework for python</vh></v>
<v t="ekr.20101127154340.6848"><vh>@url google app engine</vh></v>
<v t="ekr.20101127154340.6849"><vh>@url browser shots: web page testing</vh></v>
<v t="ekr.20101127154340.6850"><vh>@url goosh: google shell</vh></v>
<v t="ekr.20101127152442.5908"><vh>@url json</vh></v>
<v t="ekr.20101127152442.5909"><vh>@url places to ask questions</vh></v>
<v t="ekr.20101127154340.5930"><vh>@url pyjamas: AJAX tool kit</vh></v>
<v t="ekr.20101127154340.6846"><vh>@url w3c: web standards page</vh></v>
</v>
<v t="ekr.20101127154340.6853"><vh>Windows</vh>
<v t="ekr.20101127154340.6854"><vh>@url cmd</vh></v>
<v t="ekr.20101127154340.6844"><vh>@url process monitor for windows</vh></v>
<v t="ekr.20101127154340.6855"><vh>@url windows shortcuts</vh></v>
</v>
</v>
</v>
<v t="ekr.20131213072223.16396"><vh>Old screencast scripts</vh>
<v t="ekr.20131211054925.16385"><vh>- Introduction to Leo</vh>
<v t="ekr.20131211054925.16391"><vh>Leo has standard outline operations</vh></v>
<v t="ekr.20131211054925.16392"><vh>Leo has three unique features</vh>
<v t="ekr.20131211054925.16389"><vh>Leo outlines can create files</vh></v>
<v t="ekr.20131211054925.16390"><vh>Leo outlines are scriptable</vh></v>
<v t="ekr.20131211054925.16393"><vh>Nodes can be cloned</vh>
<v t="ekr.20131212054637.16399"><vh>Node A</vh>
<v t="ekr.20131212054637.16400"><vh>Node B</vh></v>
<v t="ekr.20131212054637.16400"></v>
</v>
<v t="ekr.20131212054637.16399"></v>
</v>
</v>
<v t="ekr.20131211054925.16394"><vh>Summary</vh></v>
</v>
</v>
<v t="ekr.20140212062130.16585"><vh>Prewriting for theory of operation for @auto-view</vh>
<v t="ekr.20140212062130.16586"><vh>Distinction: bare and nested organizers</vh></v>
<v t="ekr.20140212062130.16587"><vh>Two Ahas re nested organizers</vh></v>
<v t="ekr.20140212062130.16588"><vh>Moving bare organizers</vh></v>
<v t="ekr.20140212062130.16589"><vh>Intermediate organizers</vh></v>
<v t="ekr.20140212062130.16590"><vh>Aha: organizers relationships are stable</vh></v>
<v t="ekr.20140212062130.16591"><vh>Summary</vh></v>
<v t="ekr.20140212062130.16592"><vh>Headines are important</vh></v>
<v t="ekr.20140212062130.16593"><vh>Existing organizer nodes</vh></v>
<v t="ekr.20140212062130.16594"><vh>Fixing move_nodes_to_organizers</vh></v>
<v t="ekr.20140212062130.16595"><vh>Supporting @existing-organizers</vh></v>
<v t="ekr.20140212062130.16596"><vh>Supporting custom headlines (@headlines)</vh></v>
<v t="ekr.20140212062130.16597"><vh>Automatic conversion of @file to @auto</vh></v>
<v t="ekr.20140212062130.16598"><vh>Why the new code is solid</vh></v>
<v t="ekr.20140212062130.16599"><vh>docstring for vc.demote (not necessarily correct)</vh></v>
</v>
<v t="ekr.20140914042331.19494"><vh>@@data OLD qt-gui-plugin-style-sheet</vh></v>
<v t="ekr.20031218072017.434"><vh>Unused code</vh>
<v t="ekr.20140918124632.19462"><vh>Keep</vh>
<v t="ekr.20050920084036.207"><vh>QueryReplaceCommandsClass (limited to single node)</vh>
<v t="ekr.20050920084036.208"><vh> ctor &amp; init (QueryReplaceCommandsClass)</vh></v>
<v t="ekr.20050920084036.209"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.210"><vh>Entry points</vh></v>
<v t="ekr.20051005151838"><vh>Helpers</vh>
<v t="ekr.20050920084036.212"><vh>doOneReplace</vh></v>
<v t="ekr.20050920084036.219"><vh>findNextMatch (query-replace)</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt; (tag_add &amp; tag_config) LATER</vh></v>
</v>
<v t="ekr.20050920084036.211"><vh>getUserResponse</vh></v>
<v t="ekr.20050920084036.220"><vh>quitSearch</vh></v>
<v t="ekr.20050920084036.215"><vh>stateHandler</vh></v>
</v>
</v>
<v t="ekr.20101031172539.5880"><vh>Existing autocompleter: do not delete</vh>
<v t="ekr.20061031131434.43"><vh>completeSelf (not used yet)</vh></v>
<v t="ekr.20061031131434.60"><vh>class ForgivingParserClass (not used)</vh>
<v t="ekr.20061031131434.61"><vh>ctor (ForgivingParserClass)</vh></v>
<v t="ekr.20061031131434.62"><vh>parse</vh></v>
<v t="ekr.20061031131434.63"><vh>forgivingParser (leoKeys)</vh></v>
<v t="ekr.20061031131434.64"><vh>computeErrorNode (leoKeys)</vh></v>
<v t="ekr.20061031131434.65"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20061031131434.66"><vh>class ClassScannerClass (not used)</vh>
<v t="ekr.20061031131434.67"><vh>ctor (classScannerClass)</vh></v>
<v t="ekr.20061031131434.68"><vh>scan</vh></v>
<v t="ekr.20061031131434.69"><vh>findParentClass</vh></v>
<v t="ekr.20061031131434.70"><vh>findClass &amp; helpers</vh>
<v t="ekr.20061031131434.71"><vh>endsDoc</vh></v>
<v t="ekr.20061031131434.72"><vh>startsClass</vh></v>
<v t="ekr.20061031131434.73"><vh>startsDoc</vh></v>
</v>
</v>
<v t="ekr.20061031131434.57"><vh>Proxy classes and objects</vh>
<v t="ekr.20061031131434.58"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20061031131434.59"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20080924032842.3"><vh>getExternalCompletions</vh></v>
</v>
<v t="ekr.20131111105746.16556"><vh>class VimTestCase (not used)</vh>
<v t="ekr.20131111105746.16557"><vh> __init__(VimTestCase)</vh></v>
<v t="ekr.20131111105746.16558"><vh>vtc.fail</vh></v>
<v t="ekr.20131111140646.16533"><vh>vtc.compare</vh></v>
<v t="ekr.20131111140646.16534"><vh>vtc.deleteChildren</vh></v>
<v t="ekr.20131111105746.16559"><vh>vtc.editBody</vh></v>
<v t="ekr.20131111105746.16560"><vh>vtc.runTest</vh></v>
<v t="ekr.20131111105746.16561"><vh>vtc.setUp</vh></v>
<v t="ekr.20131111105746.16562"><vh>vtc.shortDescription</vh></v>
<v t="ekr.20131111105746.16563"><vh>vtc.tearDown</vh></v>
</v>
<v t="ekr.20131109090612.29139"><vh>normal_cmd (execute command,revised)</vh>
<v t="ekr.20131109090612.29156"><vh>&lt;&lt; init vars &gt;&gt;</vh>
<v t="ekr.20131109090612.29155"><vh>&lt;&lt; use remembered count before entering an operator &gt;&gt;</vh></v>
</v>
<v t="ekr.20131109090612.29154"><vh>&lt;&lt; check for pending operator &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29153"><vh>&lt;&lt; reset the count &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29152"><vh>&lt;&lt; restore counts before receiving K_CURSORHOLD &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29151"><vh>&lt;&lt; get command character from user &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29150"><vh>&lt;&lt; handle special caces for visual/select mode &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29149"><vh>&lt;&lt; invert horizontal movements and operations &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29148"><vh>&lt;&lt; get additional character &gt;&gt;</vh>
<v t="ekr.20131109090612.29158"><vh>&lt;&lt; get second or third character &gt;&gt;</vh></v>
</v>
<v t="ekr.20131109090612.29147"><vh>&lt;&lt; flush the showcmd characters to the screen &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29157"><vh>&lt;&lt; goto normal_end on ESC &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29146"><vh>&lt;&lt; remember where the cursor was &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29159"><vh>&lt;&lt; set msg_ vars &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29143"><vh>&lt;&lt; reset oap-regname &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29144"><vh>&lt;&lt; set old_mapped_len &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29145"><vh>&lt;&lt; handle pending operator &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29142"><vh>&lt;&lt; wait to write message &gt;&gt;</vh></v>
<v t="ekr.20131109090612.29141"><vh>&lt;&lt; finish up &gt;&gt;</vh>
<v t="ekr.20131109090612.29140"><vh>&lt;&lt; possibly restart edit &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20131122162143.16455"><vh>Script: isSearchableWidget</vh></v>
<v t="ekr.20140526082700.18006"><vh>Old stc classes (keep)</vh>
<v t="ekr.20140526082700.18397"><vh> Deduction stuff</vh>
<v t="ekr.20140526082700.18398"><vh>DeductionTraverser class</vh>
<v t="ekr.20140526082700.18399"><vh> dt.ctor</vh></v>
<v t="ekr.20140526082700.18400"><vh> dt.traverse</vh></v>
<v t="ekr.20140526082700.18401"><vh>dt.Contexts</vh>
<v t="ekr.20140526082700.18402"><vh>dt.ClassDef</vh></v>
<v t="ekr.20140526082700.18403"><vh>dt.FunctionDef</vh></v>
<v t="ekr.20140526082700.18404"><vh>dt.Module</vh></v>
</v>
<v t="ekr.20140526082700.18405"><vh>dt.Operands</vh>
<v t="ekr.20140526082700.18406"><vh>dt.Attribute (rewrite)</vh></v>
<v t="ekr.20140526082700.18407"><vh>dt.bool</vh></v>
<v t="ekr.20140526082700.18408"><vh>dt.Bytes</vh></v>
<v t="ekr.20140526082700.18409"><vh>dt.Call</vh></v>
<v t="ekr.20140526082700.18410"><vh>dt.comprehension</vh></v>
<v t="ekr.20140526082700.18411"><vh>dt.Dict</vh></v>
<v t="ekr.20140526082700.18412"><vh>dt.Ellipsis</vh></v>
<v t="ekr.20140526082700.18413"><vh>dt.ExtSlice</vh></v>
<v t="ekr.20140526082700.18414"><vh>dt.Index</vh></v>
<v t="ekr.20140526082700.18415"><vh>dt.int</vh></v>
<v t="ekr.20140526082700.18416"><vh>dt.Keyword</vh></v>
<v t="ekr.20140526082700.18417"><vh>dt.List</vh></v>
<v t="ekr.20140526082700.18418"><vh>dt.ListComp</vh></v>
<v t="ekr.20140526082700.18419"><vh>dt.Name</vh></v>
<v t="ekr.20140526082700.18420"><vh>dt.Num</vh></v>
<v t="ekr.20140526082700.18421"><vh>dt.Slice</vh></v>
<v t="ekr.20140526082700.18422"><vh>dt.Str</vh></v>
<v t="ekr.20140526082700.18423"><vh>dt.Subscript</vh></v>
<v t="ekr.20140526082700.18424"><vh>dt.Tuple</vh></v>
</v>
<v t="ekr.20140526082700.18425"><vh>dt.Statements</vh>
<v t="ekr.20140526082700.18426"><vh>dt.Assign</vh></v>
<v t="ekr.20140526082700.18427"><vh>dt.AugAssign</vh></v>
<v t="ekr.20140526082700.18428"><vh>dt.Call</vh></v>
<v t="ekr.20140526082700.18429"><vh>dt.For</vh></v>
<v t="ekr.20140526082700.18430"><vh>dt.Global</vh></v>
<v t="ekr.20140526082700.18431"><vh>dt.Import &amp; helpers</vh></v>
<v t="ekr.20140526082700.18432"><vh>dt.ImportFrom</vh></v>
<v t="ekr.20140526082700.18433"><vh>dt.Lambda &amp; helper</vh></v>
<v t="ekr.20140526082700.18434"><vh>dt.Return</vh></v>
<v t="ekr.20140526082700.18435"><vh>dt.With</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18436"><vh>old Deduction ctor</vh></v>
<v t="ekr.20140526082700.18437"><vh>e.become_known (To do)</vh></v>
<v t="ekr.20140526082700.18438"><vh>e.is_known</vh></v>
</v>
<v t="ekr.20140527123213.17048"><vh> Inference-related classes</vh>
<v t="ekr.20140526082700.18046"><vh>class CacheTraverser (AstTraverser)</vh>
<v t="ekr.20140526082700.18047"><vh>ct.show_cache</vh></v>
<v t="ekr.20140526082700.18048"><vh>ct.run</vh></v>
<v t="ekr.20140526082700.18049"><vh>ct.traversers</vh>
<v t="ekr.20140526082700.18050"><vh>ct.visit</vh></v>
<v t="ekr.20140526082700.18051"><vh>ct.visit_cache</vh></v>
</v>
<v t="ekr.20140526082700.18052"><vh>ct.visitors</vh>
<v t="ekr.20140526082700.18053"><vh>ct.ClassDef</vh></v>
<v t="ekr.20140526082700.18054"><vh>ct.functionDef</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18055"><vh>class ChainPrinter (OpPatternFormatter)</vh>
<v t="ekr.20140526082700.18056"><vh>Attribute</vh></v>
<v t="ekr.20140526082700.18057"><vh>showChains</vh></v>
</v>
<v t="ekr.20140526082700.18058"><vh>class Context &amp; subclasses</vh>
<v t="ekr.20140526082700.18059"><vh>&lt;&lt; define class Context &gt;&gt;</vh>
<v t="ekr.20140526082700.18060"><vh> cx ctor</vh></v>
<v t="ekr.20140526082700.18061"><vh>cx.__getstate__</vh></v>
<v t="ekr.20140526082700.18062"><vh>cx.__hash__</vh></v>
<v t="ekr.20140526082700.18063"><vh>cx.__repr__ &amp; __str__</vh></v>
<v t="ekr.20140526082700.18064"><vh>cx.__eq__ &amp; __ne__(others return NotImplemented)</vh></v>
<v t="ekr.20140526082700.18065"><vh>cx.description &amp; short_description</vh></v>
<v t="ekr.20140526082700.18066"><vh>cx.dump_statements</vh></v>
<v t="ekr.20140526082700.18067"><vh>cx.full_name</vh></v>
<v t="ekr.20140526082700.18068"><vh>cx.generators &amp; getters</vh>
<v t="ekr.20140526082700.18069"><vh>cx.assignments</vh></v>
<v t="ekr.20140526082700.18070"><vh>cx.assignments_to (rewritten)</vh></v>
<v t="ekr.20140526082700.18071"><vh>cx.assignments_using</vh></v>
<v t="ekr.20140526082700.18072"><vh>cx.call_args_of</vh></v>
<v t="ekr.20140526082700.18073"><vh>cx.calls</vh></v>
<v t="ekr.20140526082700.18074"><vh>cx.calls_to</vh></v>
<v t="ekr.20140526082700.18075"><vh>cx.classes</vh></v>
<v t="ekr.20140526082700.18076"><vh>cx.contexts &amp; getters</vh>
<v t="ekr.20140526082700.18077"><vh>get_contexts and get_unique_context</vh></v>
</v>
<v t="ekr.20140526082700.18078"><vh>cx.defs</vh></v>
<v t="ekr.20140526082700.18079"><vh>cx.parent_contexts</vh></v>
<v t="ekr.20140526082700.18080"><vh>cx.returns (dubious)</vh></v>
<v t="ekr.20140526082700.18081"><vh>cx.statements (new)</vh></v>
<v t="ekr.20140526082700.18082"><vh>cx.symbol_tables &amp; getters</vh>
<v t="ekr.20140526082700.18083"><vh>get_symbol_tables and get_unique_symbol_table</vh></v>
</v>
<v t="ekr.20140526082700.18084"><vh>cx.symbol_table_entries</vh></v>
<v t="ekr.20140526082700.18085"><vh>cx.local_statements</vh></v>
</v>
<v t="ekr.20140526082700.18086"><vh>cx.line_number (not used)</vh></v>
<v t="ekr.20140526082700.18087"><vh>cx.token_range (TO DO) (Uses tree_ptr)</vh></v>
</v>
<v t="ekr.20140526082700.18088"><vh>class ClassContext</vh>
<v t="ekr.20140526082700.18089"><vh>ClassContext.__init__</vh></v>
<v t="ekr.20140526082700.18090"><vh>ClassContext.__repr__&amp; __str__</vh></v>
<v t="ekr.20140526082700.18091"><vh>ClassContext.short_description</vh></v>
</v>
<v t="ekr.20140526082700.18092"><vh>class DefContext</vh>
<v t="ekr.20140526082700.18093"><vh>DefContext.__init__</vh></v>
<v t="ekr.20140526082700.18094"><vh>DefContext.__repr__ &amp; __str__</vh></v>
<v t="ekr.20140526082700.18095"><vh>DefContext.short_description</vh></v>
</v>
<v t="ekr.20140526082700.18096"><vh>class LambdaContext</vh></v>
<v t="ekr.20140526082700.18097"><vh>class LIbraryModuleContext</vh></v>
<v t="ekr.20140526082700.18098"><vh>class ModuleContext</vh></v>
</v>
<v t="ekr.20140526082700.18290"><vh>class ScopeBinder</vh>
<v t="ekr.20140526082700.18291"><vh>sb.check &amp; helper</vh>
<v t="ekr.20140526082700.18292"><vh>check_context</vh></v>
</v>
<v t="ekr.20140526082700.18293"><vh>sb.dump_symbol_table</vh></v>
<v t="ekr.20140526082700.18294"><vh>sb.init_dicts</vh></v>
<v t="ekr.20140526082700.18295"><vh>sb.lookup</vh></v>
<v t="ekr.20140526082700.18296"><vh>sb.run</vh></v>
<v t="ekr.20140526082700.18297"><vh>sb.visit &amp; visitors</vh>
<v t="ekr.20140526082700.18298"><vh>sb.FunctionDef</vh></v>
<v t="ekr.20140526082700.18299"><vh>sb.Name</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18204"><vh>class Pass1 (AstFullTraverser)</vh>
<v t="ekr.20140526082700.18205"><vh> p1.ctor</vh></v>
<v t="ekr.20140526082700.18206"><vh> p1.run (entry point)</vh></v>
<v t="ekr.20140526082700.18207"><vh> p1.visit</vh></v>
<v t="ekr.20140526082700.18208"><vh>p1.helpers</vh>
<v t="ekr.20140526082700.18209"><vh>p1.bind_name</vh></v>
<v t="ekr.20140526082700.18210"><vh>p1.bind_unbound_name</vh></v>
<v t="ekr.20140526082700.18211"><vh>p1.def_args_helper</vh></v>
<v t="ekr.20140526082700.18212"><vh>p1.get_import_names</vh></v>
<v t="ekr.20140526082700.18213"><vh>p1.resolve_import_name</vh></v>
</v>
<v t="ekr.20140526082700.18214"><vh>p1.visitors</vh>
<v t="ekr.20140526082700.18215"><vh>p1.Assign</vh></v>
<v t="ekr.20140526082700.18216"><vh>p1.Attribute</vh></v>
<v t="ekr.20140526082700.18217"><vh>p1.AugAssign</vh></v>
<v t="ekr.20140526082700.18218"><vh>p1.Call (Stats only)</vh></v>
<v t="ekr.20140526082700.18219"><vh>p1.ClassDef</vh></v>
<v t="ekr.20140526082700.18220"><vh>p1.Expr</vh></v>
<v t="ekr.20140526082700.18221"><vh>p1.For</vh></v>
<v t="ekr.20140526082700.18222"><vh>p1.FunctionDef</vh></v>
<v t="ekr.20140526082700.18223"><vh>p1.Global</vh></v>
<v t="ekr.20140526082700.18224"><vh>p1.Import</vh></v>
<v t="ekr.20140526082700.18225"><vh>p1.ImportFrom</vh></v>
<v t="ekr.20140526082700.18226"><vh>p1.Interactive</vh></v>
<v t="ekr.20140526082700.18227"><vh>p1.Lambda</vh></v>
<v t="ekr.20140526082700.18228"><vh>p1.ListComp</vh></v>
<v t="ekr.20140526082700.18229"><vh>p1.Module</vh></v>
<v t="ekr.20140526082700.18230"><vh>p1.Name</vh></v>
<v t="ekr.20140526082700.18231"><vh>p1.Return</vh>
<v t="ekr.20140526082700.18232"><vh>p1.Operators...</vh></v>
</v>
<v t="ekr.20140526082700.18233"><vh>p1.With</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18234"><vh>class Resolver (keep for now)</vh>
<v t="ekr.20140526082700.18235"><vh> r.ctor &amp; helper</vh></v>
<v t="ekr.20140526082700.18236"><vh> r.generators</vh>
<v t="ekr.20140526082700.18237"><vh>r.classes</vh></v>
<v t="ekr.20140526082700.18238"><vh>r.contexts</vh></v>
<v t="ekr.20140526082700.18239"><vh>r.modules</vh></v>
<v t="ekr.20140526082700.18240"><vh>r.statements</vh></v>
<v t="ekr.20140526082700.18241"><vh>r.unresolved_names (TEST)</vh></v>
</v>
<v t="ekr.20140526082700.18242"><vh>r.resolve &amp; initers</vh>
<v t="ekr.20140526082700.18243"><vh>r.init_class_names</vh></v>
<v t="ekr.20140526082700.18244"><vh>r.init_module_names</vh></v>
<v t="ekr.20140526082700.18245"><vh>r.init_self</vh></v>
<v t="ekr.20140526082700.18246"><vh>r.main_algorithm</vh></v>
<v t="ekr.20140526082700.18247"><vh>r.make_global_dicts</vh></v>
<v t="ekr.20140526082700.18248"><vh>r.make_known &amp; op handlers</vh>
<v t="ekr.20140526082700.18249"><vh>Do-nothings (not used at present)</vh>
<v t="ekr.20140526082700.18250"><vh>r.Arg</vh></v>
<v t="ekr.20140526082700.18251"><vh>r.Arguments</vh></v>
<v t="ekr.20140526082700.18252"><vh>r.AugAssign</vh></v>
<v t="ekr.20140526082700.18253"><vh>r.Keyword</vh></v>
</v>
<v t="ekr.20140526082700.18254"><vh>Known types</vh>
<v t="ekr.20140526082700.18255"><vh>r.Bytes</vh></v>
<v t="ekr.20140526082700.18256"><vh>r.Dict</vh></v>
<v t="ekr.20140526082700.18257"><vh>r.List</vh></v>
<v t="ekr.20140526082700.18258"><vh>r.Num</vh></v>
<v t="ekr.20140526082700.18259"><vh>r.Str</vh></v>
<v t="ekr.20140526082700.18260"><vh>r.Tuple</vh></v>
</v>
<v t="ekr.20140526082700.18261"><vh>Names &amp; Builtins</vh>
<v t="ekr.20140526082700.18262"><vh>r.Builtin</vh></v>
<v t="ekr.20140526082700.18263"><vh>r.Name</vh></v>
</v>
<v t="ekr.20140526082700.18264"><vh>Not ready yet</vh>
<v t="ekr.20140526082700.18265"><vh>r.Comprehension</vh></v>
<v t="ekr.20140526082700.18266"><vh>r.GenExp</vh></v>
<v t="ekr.20140526082700.18267"><vh>r.Index</vh></v>
<v t="ekr.20140526082700.18268"><vh>r.ListComp</vh></v>
<v t="ekr.20140526082700.18269"><vh>r.Slice</vh></v>
<v t="ekr.20140526082700.18270"><vh>r.Subscript</vh></v>
</v>
<v t="ekr.20140526082700.18271"><vh>Operators</vh>
<v t="ekr.20140526082700.18272"><vh>r.Attribute</vh></v>
<v t="ekr.20140526082700.18273"><vh>r.BinOp</vh></v>
<v t="ekr.20140526082700.18274"><vh>r.BoolOp</vh></v>
<v t="ekr.20140526082700.18275"><vh>r.Call</vh></v>
<v t="ekr.20140526082700.18276"><vh>r.CompareOp</vh></v>
<v t="ekr.20140526082700.18277"><vh>r.TernaryOp</vh></v>
<v t="ekr.20140526082700.18278"><vh>r.UnaryOp</vh></v>
</v>
<v t="ekr.20140526082700.18279"><vh>r.Assign</vh></v>
<v t="ekr.20140526082700.18280"><vh>r.do_nothing</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18281"><vh>The hard part</vh>
<v t="ekr.20140526082700.18282"><vh>r.analyze_assignments (to do)</vh></v>
<v t="ekr.20140526082700.18283"><vh>r.analyze_calls (to do)</vh></v>
<v t="ekr.20140526082700.18284"><vh>r.analyze_returns (To do)</vh></v>
<v t="ekr.20140526082700.18285"><vh>r.resolve_class_relationships</vh></v>
<v t="ekr.20140526082700.18286"><vh>r.analyze_classes &amp; helpers</vh>
<v t="ekr.20140526082700.18287"><vh>r.analyze_class_pair</vh></v>
</v>
<v t="ekr.20140526082700.18288"><vh>r.resolve_ivars</vh></v>
<v t="ekr.20140526082700.18289"><vh>r.resolve_aliases (will be removed)</vh></v>
</v>
</v>
<v t="ekr.20140526082700.17394"><vh>class TypeInferrer (AstFullTraverser)</vh>
<v t="ekr.20140526082700.17395"><vh>ti.clean (*revise*)</vh></v>
<v t="ekr.20140528102444.17989"><vh>ti.has_children</vh></v>
<v t="ekr.20140526082700.17396"><vh>ti.format</vh></v>
<v t="ekr.20140526082700.17397"><vh>ti.init</vh></v>
<v t="ekr.20140526082700.17398"><vh>ti.run (entry point)</vh></v>
<v t="ekr.20140526082700.17399"><vh>ti.type helpers</vh></v>
<v t="ekr.20140526082700.17400"><vh>ti.visit</vh></v>
<v t="ekr.20140526082700.17401"><vh>ti.visitors</vh>
<v t="ekr.20140526082700.17402"><vh>ti.expressions</vh>
<v t="ekr.20140526082700.17403"><vh>ti.Attribute &amp; check_attr (check super classes for attributes)</vh>
<v t="ekr.20140526082700.17404"><vh>ti.check_attr</vh></v>
</v>
<v t="ekr.20140526082700.17405"><vh>ti.BinOp &amp; helper</vh></v>
<v t="ekr.20140526082700.17406"><vh>ti.BoolOp</vh></v>
<v t="ekr.20140526082700.17407"><vh>ti.Call &amp; helpers</vh>
<v t="ekr.20140526082700.17408"><vh>ti.class_instance</vh></v>
<v t="ekr.20140526082700.17409"><vh>ti.find_call_e</vh></v>
<v t="ekr.20140526082700.17410"><vh>ti.infer_actual_args</vh></v>
<v t="ekr.20140526082700.17411"><vh>ti.infer_def &amp; helpers (sets call cache)</vh>
<v t="ekr.20140526082700.17412"><vh>ti.bind_args (ti.infer_def helper) (To do: handle self)</vh></v>
<v t="ekr.20140526082700.17413"><vh>ti.infer_assignments</vh></v>
<v t="ekr.20140526082700.17414"><vh>ti.infer_outer_expressions</vh></v>
<v t="ekr.20140526082700.17415"><vh>ti.infer_return_statements</vh></v>
</v>
</v>
<v t="ekr.20140526082700.17416"><vh>ti.Compare</vh></v>
<v t="ekr.20140526082700.17417"><vh>ti.comprehension</vh></v>
<v t="ekr.20140526082700.17418"><vh>ti.Expr</vh></v>
<v t="ekr.20140526082700.17419"><vh>ti.GeneratorExp</vh></v>
<v t="ekr.20140526082700.17420"><vh>ti.IfExp</vh></v>
<v t="ekr.20140526082700.17421"><vh>ti.Index</vh></v>
<v t="ekr.20140526082700.17422"><vh>ti.Lambda</vh></v>
<v t="ekr.20140526082700.17423"><vh>ti.ListComp</vh></v>
<v t="ekr.20140526082700.17424"><vh>ti.Name (**rewrite)</vh></v>
<v t="ekr.20140526082700.17425"><vh>ti.Slice</vh></v>
<v t="ekr.20140526082700.17426"><vh>ti.Subscript (to do)</vh></v>
<v t="ekr.20140526082700.17427"><vh>ti.UnaryOp</vh></v>
</v>
<v t="ekr.20140526082700.17428"><vh>ti.primitive Types</vh>
<v t="ekr.20140526082700.17429"><vh>ti.Builtin</vh></v>
<v t="ekr.20140526082700.17430"><vh>ti.Bytes</vh></v>
<v t="ekr.20140526082700.17431"><vh>ti.Dict</vh></v>
<v t="ekr.20140526082700.17432"><vh>ti.List</vh></v>
<v t="ekr.20140526082700.17433"><vh>ti.Num</vh></v>
<v t="ekr.20140526082700.17434"><vh>ti.Str</vh></v>
<v t="ekr.20140526082700.17435"><vh>ti.Tuple</vh></v>
</v>
<v t="ekr.20140526082700.17436"><vh>ti.statements</vh>
<v t="ekr.20140526082700.17437"><vh>ti.arguments</vh></v>
<v t="ekr.20140526082700.17438"><vh>ti.Assign (**rewrite)</vh></v>
<v t="ekr.20140526082700.17439"><vh>ti.ClassDef (could be default)</vh></v>
<v t="ekr.20140526082700.17440"><vh>ti.For</vh></v>
<v t="ekr.20140526082700.17441"><vh>ti.FunctionDef &amp; helpers (**rewrite)</vh>
<v t="ekr.20140526082700.17442"><vh>ti.count_full_args</vh></v>
<v t="ekr.20140526082700.17443"><vh>ti.infer_outer_def &amp; helper</vh>
<v t="ekr.20140526082700.17444"><vh>ti_bind_outer_args (ti.infer_outer_def helper)</vh></v>
</v>
</v>
<v t="ekr.20140526082700.17445"><vh>ti.Import (not used)</vh></v>
<v t="ekr.20140526082700.17446"><vh>ti.ImportFrom (not used)</vh></v>
<v t="ekr.20140526082700.17447"><vh>ti.Return &amp; ti.Yield &amp; helper</vh>
<v t="ekr.20140526082700.17448"><vh>ti.return_helper</vh></v>
</v>
<v t="ekr.20140526082700.17449"><vh>ti.With</vh></v>
</v>
</v>
</v>
<v t="ekr.20140526082700.18325"><vh>class TypeInferer (AstTraverser)</vh>
<v t="ekr.20140526082700.18326"><vh> ti.ctor</vh></v>
<v t="ekr.20140526082700.18327"><vh> ti.run (entry point)</vh></v>
<v t="ekr.20140526082700.18328"><vh>ti.caches</vh>
<v t="ekr.20140526082700.18329"><vh>ti.cache_hash</vh></v>
<v t="ekr.20140526082700.18330"><vh>ti.get_cache</vh></v>
<v t="ekr.20140526082700.18331"><vh>ti.get_call_cache</vh></v>
<v t="ekr.20140526082700.18332"><vh>ti.method_hash</vh></v>
<v t="ekr.20140526082700.18333"><vh>ti.set_cache</vh></v>
<v t="ekr.20140526082700.18334"><vh>ti.set_call_cache</vh></v>
<v t="ekr.20140526082700.18335"><vh>ti.show_cache</vh></v>
</v>
<v t="ekr.20140528102444.17991"><vh>ti.has_children</vh></v>
<v t="ekr.20140526082700.18336"><vh>ti.helpers</vh>
<v t="ekr.20140526082700.18337"><vh>ti.clean</vh></v>
<v t="ekr.20140526082700.18338"><vh>ti.cross_product</vh></v>
<v t="ekr.20140526082700.18339"><vh>ti.switch/restore_context</vh></v>
<v t="ekr.20140526082700.18340"><vh>ti.type helpers</vh></v>
</v>
<v t="ekr.20140526082700.18341"><vh>ti.trace</vh></v>
<v t="ekr.20140526082700.18342"><vh>ti.traversers</vh>
<v t="ekr.20140526082700.18343"><vh> ti.visit</vh></v>
<v t="ekr.20140526082700.18344"><vh> ti.visit_children</vh></v>
<v t="ekr.20140526082700.18345"><vh> ti.visit_list</vh></v>
</v>
<v t="ekr.20140526082700.18346"><vh>ti.visitors</vh>
<v t="ekr.20140526082700.18347"><vh>ti.arguments</vh></v>
<v t="ekr.20140526082700.18348"><vh>ti.Assign (sets cache)</vh></v>
<v t="ekr.20140526082700.18349"><vh>ti.Attribute &amp; check_attr (check super classes for attributes)</vh>
<v t="ekr.20140526082700.18350"><vh>ti.check_attr</vh></v>
</v>
<v t="ekr.20140526082700.18351"><vh>ti.Builtin</vh></v>
<v t="ekr.20140526082700.18352"><vh>ti.Call &amp; helpers</vh>
<v t="ekr.20140526082700.18353"><vh>ti.class_instance</vh></v>
<v t="ekr.20140526082700.18354"><vh>ti.find_call_e</vh></v>
<v t="ekr.20140526082700.18355"><vh>ti.infer_actual_args</vh></v>
<v t="ekr.20140526082700.18356"><vh>ti.infer_def &amp; helpers (sets call cache)</vh>
<v t="ekr.20140526082700.18357"><vh>ti.bind_args (ti.infer_def helper) (To do: handle self)</vh></v>
<v t="ekr.20140526082700.18358"><vh>ti.infer_assignments</vh></v>
<v t="ekr.20140526082700.18359"><vh>ti.infer_outer_expressions</vh></v>
<v t="ekr.20140526082700.18360"><vh>ti.infer_return_statements</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18361"><vh>ti.ClassDef</vh></v>
<v t="ekr.20140526082700.18362"><vh>ti.Expr (new)</vh></v>
<v t="ekr.20140526082700.18363"><vh>ti.FunctionDef &amp; helpers</vh>
<v t="ekr.20140526082700.18364"><vh>ti.count_full_args</vh></v>
<v t="ekr.20140526082700.18365"><vh>ti.infer_outer_def &amp; helper</vh>
<v t="ekr.20140526082700.18366"><vh>ti_bind_outer_args (ti.infer_outer_def helper)</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18367"><vh>ti.Lambda</vh></v>
<v t="ekr.20140526082700.18368"><vh>ti.operators</vh>
<v t="ekr.20140526082700.18369"><vh>ti.BinOp &amp; helper</vh></v>
<v t="ekr.20140526082700.18370"><vh>ti.BoolOp</vh></v>
<v t="ekr.20140526082700.18371"><vh>ti.Compare</vh></v>
<v t="ekr.20140526082700.18372"><vh>ti.comprehension</vh></v>
<v t="ekr.20140526082700.18373"><vh>ti.Expr (not used)</vh></v>
<v t="ekr.20140526082700.18374"><vh>ti.GeneratorExp</vh></v>
<v t="ekr.20140526082700.18375"><vh>ti.IfExp (Ternary operator)</vh></v>
<v t="ekr.20140526082700.18376"><vh>ti.Index (default, at present)</vh></v>
<v t="ekr.20140526082700.18377"><vh>ti.ListComp</vh></v>
<v t="ekr.20140526082700.18378"><vh>ti.Slice</vh></v>
<v t="ekr.20140526082700.18379"><vh>ti.Subscript (*** to do)</vh></v>
<v t="ekr.20140526082700.18380"><vh>ti.UnaryOp</vh></v>
</v>
<v t="ekr.20140526082700.18381"><vh>ti.primitive Types</vh>
<v t="ekr.20140526082700.18382"><vh>ti.Builtin</vh></v>
<v t="ekr.20140526082700.18383"><vh>ti.Bytes</vh></v>
<v t="ekr.20140526082700.18384"><vh>ti.Dict</vh></v>
<v t="ekr.20140526082700.18385"><vh>ti.List</vh></v>
<v t="ekr.20140526082700.18386"><vh>ti.Num</vh></v>
<v t="ekr.20140526082700.18387"><vh>ti.Str</vh></v>
<v t="ekr.20140526082700.18388"><vh>ti.Tuple</vh></v>
</v>
<v t="ekr.20140526082700.18389"><vh>ti.statements</vh>
<v t="ekr.20140526082700.18390"><vh>ti.For</vh></v>
<v t="ekr.20140526082700.18391"><vh>ti.Import (not used)</vh></v>
<v t="ekr.20140526082700.18392"><vh>ti.ImportFrom (not used)</vh></v>
<v t="ekr.20140526082700.18393"><vh>ti.Return &amp; ti.Yield &amp; helper</vh>
<v t="ekr.20140526082700.18394"><vh>ti.return_helper (sets cache)</vh></v>
</v>
<v t="ekr.20140526082700.18395"><vh>ti.With</vh></v>
</v>
<v t="ekr.20140526082700.18396"><vh>ti.Name (***ivars don't work)</vh></v>
</v>
</v>
</v>
<v t="ekr.20140527123213.17049"><vh> Traverser classes</vh>
<v t="ekr.20140526082700.18007"><vh>  class AstTraverser</vh>
<v t="ekr.20140526082700.18008"><vh> a.Birth</vh></v>
<v t="ekr.20140526082700.18009"><vh>a.traversers</vh>
<v t="ekr.20140526082700.18010"><vh>a.find_function_call</vh></v>
<v t="ekr.20140526082700.18011"><vh>a.get/push/pop_context</vh></v>
<v t="ekr.20140526082700.18012"><vh>a.get_child_nodes</vh></v>
<v t="ekr.20140526082700.18013"><vh>a.has_children</vh></v>
<v t="ekr.20140526082700.18014"><vh>a.run (default entry)</vh></v>
<v t="ekr.20140526082700.18015"><vh>a.visit</vh></v>
<v t="ekr.20140526082700.18016"><vh>a.visit_children</vh></v>
<v t="ekr.20140526082700.18017"><vh>a.visit_list</vh></v>
</v>
<v t="ekr.20140526082700.18018"><vh>a.utils</vh>
<v t="ekr.20140526082700.18019"><vh>a.attribute_base</vh></v>
<v t="ekr.20140526082700.18020"><vh>a.attribute_target (To be deleted)</vh></v>
<v t="ekr.20140526082700.18021"><vh>a.check_visitor_names</vh>
<v t="ekr.20140526082700.18022"><vh>&lt;&lt; ast abstract grammar &gt;&gt;</vh></v>
<v t="ekr.20140526082700.18023"><vh>&lt;&lt; define names &gt;&gt;</vh></v>
</v>
<v t="ekr.20140526082700.18024"><vh>a.info</vh></v>
<v t="ekr.20140526082700.18025"><vh>a.kind</vh></v>
<v t="ekr.20140526082700.18026"><vh>a.op_name</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18027"><vh>  class StatementTraverser</vh>
<v t="ekr.20140526082700.18028"><vh>stat.run</vh></v>
<v t="ekr.20140526082700.18029"><vh>stat.visit &amp; helpers</vh></v>
<v t="ekr.20140526082700.18030"><vh>stat.Do nothings</vh>
<v t="ekr.20140526082700.18031"><vh>stat.Assert</vh></v>
<v t="ekr.20140526082700.18032"><vh>stat.Assign</vh></v>
<v t="ekr.20140526082700.18033"><vh>stat.AugAssign</vh></v>
<v t="ekr.20140526082700.18034"><vh>stat.Break</vh></v>
<v t="ekr.20140526082700.18035"><vh>stat.Continue</vh></v>
<v t="ekr.20140526082700.18036"><vh>stat.Delete</vh></v>
<v t="ekr.20140526082700.18037"><vh>stat.Exec</vh></v>
<v t="ekr.20140526082700.18038"><vh>stat.Expr</vh></v>
<v t="ekr.20140526082700.18039"><vh>stat.Global</vh></v>
<v t="ekr.20140526082700.18040"><vh>stat.Import &amp; ImportFrom</vh></v>
<v t="ekr.20140526082700.18041"><vh>stat.Pass</vh></v>
<v t="ekr.20140526082700.18042"><vh>stat.Print</vh></v>
<v t="ekr.20140526082700.18043"><vh>stat.Raise</vh></v>
<v t="ekr.20140526082700.18044"><vh>stat.Return</vh></v>
<v t="ekr.20140526082700.18045"><vh>stat.Yield</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18199"><vh>class IterativeAstTraverser</vh>
<v t="ekr.20140526082700.18200"><vh>iterative.traversers</vh>
<v t="ekr.20140526082700.18201"><vh>private_visit</vh></v>
<v t="ekr.20140526082700.18202"><vh>_iterative_postorder_nodes</vh></v>
<v t="ekr.20140526082700.18203"><vh>_children</vh></v>
</v>
</v>
<v t="ekr.20140526082700.18196"><vh>class HybridAstTraverser</vh>
<v t="ekr.20140526082700.18197"><vh>visit</vh></v>
<v t="ekr.20140526082700.18198"><vh>visit_children</vh></v>
</v>
<v t="ekr.20140526082700.18300"><vh>class StringReportTraverser (AstFormatter)</vh>
<v t="ekr.20140526082700.18301"><vh>srt.__init__</vh>
<v t="ekr.20140526082700.18302"><vh>define_html_header</vh></v>
</v>
<v t="ekr.20140526082700.18303"><vh>srt.report(entry_point)</vh></v>
<v t="ekr.20140526082700.18304"><vh>srt.show_all &amp; helper</vh></v>
<v t="ekr.20140526082700.18305"><vh>srt.show</vh></v>
<v t="ekr.20140526082700.18306"><vh>srt.visit</vh></v>
<v t="ekr.20140526082700.18307"><vh>srt.visitors</vh>
<v t="ekr.20140526082700.18308"><vh>srt.Assign</vh></v>
<v t="ekr.20140526082700.18309"><vh>srt.Expr</vh></v>
<v t="ekr.20140526082700.18310"><vh>srt.Return</vh></v>
<v t="ekr.20140526082700.18311"><vh>str.Str</vh></v>
</v>
</v>
</v>
<v t="ekr.20140526082700.18099"><vh>class GeneralTest (StcTest)</vh></v>
</v>
<v t="ekr.20131230090121.16504"><vh>from leoViews.py</vh>
<v t="ekr.20131230090121.16506"><vh>&lt;&lt; imports &gt;&gt; (leoViews.py)</vh></v>
<v t="ekr.20140106215321.16672"><vh>class OrganizerData</vh></v>
<v t="ekr.20131230090121.16508"><vh>class ViewController</vh>
<v t="ekr.20131230090121.16507"><vh> &lt;&lt; docstring &gt;&gt; (class ViewController)</vh></v>
<v t="ekr.20131230090121.16509"><vh> vc.ctor &amp; vc.init</vh></v>
<v t="ekr.20131230090121.16514"><vh>vc.Entry points</vh>
<v t="ekr.20140125071842.10474"><vh>vc.convert_at_file_to_at_auto</vh>
<v t="ekr.20140125071842.10475"><vh>class ConvertController</vh>
<v t="ekr.20140202110830.17501"><vh>cc.delete_at_auto_view_nodes</vh></v>
<v t="ekr.20140125071842.10477"><vh>cc.import_from_string</vh></v>
<v t="ekr.20140125071842.10478"><vh>cc.run</vh></v>
<v t="ekr.20140125141655.10476"><vh>cc.set_expected_imported_headlines</vh></v>
<v t="ekr.20140125071842.10479"><vh>cc.strip_sentinels</vh></v>
</v>
</v>
<v t="ekr.20140102052259.16394"><vh>vc.pack &amp; helper</vh>
<v t="ekr.20140102052259.16397"><vh>vc.create_view_node</vh></v>
</v>
<v t="ekr.20140102052259.16395"><vh>vc.unpack</vh></v>
<v t="ekr.20131230090121.16511"><vh>vc.update_before_write_at_auto_file</vh>
<v t="ekr.20140123132424.10471"><vh>vc.create_at_headlines</vh></v>
<v t="ekr.20140123132424.10472"><vh>vc.find_special_nodes</vh></v>
</v>
<v t="ekr.20131230090121.16513"><vh>vc.update_after_read_at_auto_file &amp; helpers</vh>
<v t="ekr.20140109214515.16643"><vh>vc.check</vh></v>
<v t="ekr.20131230090121.16545"><vh>vc.create_clone_link</vh></v>
<v t="ekr.20131230090121.16533"><vh>vc.create_clone_links</vh></v>
<v t="ekr.20131230090121.16532"><vh>vc.create_organizer_nodes &amp; helpers</vh></v>
<v t="ekr.20140124111748.10635"><vh>vc.update_headlines_after_read</vh></v>
</v>
</v>
<v t="ekr.20140120105910.10488"><vh>vc.Main Lines</vh>
<v t="ekr.20140115180051.16709"><vh>vc.precompute_all_data &amp; helpers</vh>
<v t="ekr.20140113181306.16690"><vh>1: vc.find_imported_organizer_nodes</vh></v>
<v t="ekr.20140106215321.16674"><vh>2: vc.create_organizer_data (od.p &amp; od.parent)</vh>
<v t="ekr.20140126044100.15449"><vh>vc.create_ods</vh></v>
<v t="ekr.20140126044100.15450"><vh>vc.finish_create_organizers</vh></v>
<v t="ekr.20140126044100.15451"><vh>vc.finish_create_existing_organizers</vh></v>
</v>
<v t="ekr.20140106215321.16675"><vh>3: vc.create_actual_organizer_nodes</vh></v>
<v t="ekr.20140108081031.16612"><vh>4: vc.create_tree_structure &amp; helper</vh>
<v t="ekr.20140109214515.16633"><vh>vc.compute_descendants</vh></v>
</v>
<v t="ekr.20140115180051.16706"><vh>5: vc.compute_all_organized_positions</vh></v>
<v t="ekr.20140117131738.16727"><vh>6: vc.create_anchors_d</vh></v>
</v>
<v t="ekr.20140104112957.16587"><vh>vc.demote &amp; helpers</vh>
<v t="ekr.20140117131738.16717"><vh>vc.add</vh></v>
<v t="ekr.20140109214515.16646"><vh>vc.add_organizer_node</vh></v>
<v t="ekr.20140127143108.15463"><vh>vc.add_to_bare_list</vh></v>
<v t="ekr.20140117131738.16719"><vh>vc.add_to_pending</vh></v>
<v t="ekr.20140127143108.15462"><vh>vc.add_to_work_list</vh></v>
<v t="ekr.20140127143108.15460"><vh>vc.anchor_decr</vh></v>
<v t="ekr.20140127143108.15461"><vh>vc.anchor_incr</vh></v>
<v t="ekr.20140129164001.16251"><vh>vc.clear_pending</vh></v>
<v t="ekr.20140117131738.16723"><vh>vc.enter_organizers</vh></v>
<v t="ekr.20140120105910.10490"><vh>vc.find_organizer</vh></v>
<v t="ekr.20140117131738.16724"><vh>vc.terminate_organizers</vh></v>
<v t="ekr.20140129164001.16252"><vh>vc.terminate_all_open_organizers</vh></v>
</v>
<v t="ekr.20140106215321.16678"><vh>vc.move_nodes &amp; helpers</vh>
<v t="ekr.20140109214515.16636"><vh>vc.move_nodes_to_organizers</vh></v>
<v t="ekr.20140109214515.16637"><vh>vc.move_bare_organizers</vh></v>
<v t="ekr.20140112112622.16663"><vh>vc.copy_tree_to_last_child_of</vh></v>
</v>
</v>
<v t="ekr.20131230090121.16515"><vh>vc.Helpers</vh>
<v t="ekr.20140103105930.16448"><vh>vc.at_auto_view_body and match_at_auto_body</vh></v>
<v t="ekr.20131230090121.16522"><vh>vc.clean_nodes (not used)</vh></v>
<v t="ekr.20140109214515.16640"><vh>vc.comments...</vh>
<v t="ekr.20131230090121.16526"><vh>vc.comment_delims</vh></v>
<v t="ekr.20140109214515.16641"><vh>vc.delete_leading_comments</vh></v>
<v t="ekr.20140105055318.16754"><vh>vc.is_comment_node</vh></v>
<v t="ekr.20140109214515.16642"><vh>vc.is_comment_organizer_node</vh></v>
<v t="ekr.20140109214515.16639"><vh>vc.post_move_comments</vh></v>
<v t="ekr.20140106215321.16679"><vh>vc.pre_move_comments</vh></v>
</v>
<v t="ekr.20140103062103.16442"><vh>vc.find...</vh>
<v t="ekr.20140102052259.16402"><vh>vc.find_absolute_unl_node</vh></v>
<v t="ekr.20131230090121.16520"><vh>vc.find_at_auto_view_node &amp; helper</vh></v>
<v t="ekr.20131230090121.16516"><vh>vc.find_clones_node</vh></v>
<v t="ekr.20140123132424.10474"><vh>vc.find_at_headlines_node</vh></v>
<v t="ekr.20131230090121.16547"><vh>vc.find_gnx_node</vh></v>
<v t="ekr.20131230090121.16518"><vh>vc.find_organizers_node</vh></v>
<v t="ekr.20131230090121.16539"><vh>vc.find_position_for_relative_unl</vh></v>
<v t="ekr.20131230090121.16544"><vh>vc.find_representative_node</vh></v>
<v t="ekr.20131230090121.16519"><vh>vc.find_views_node</vh></v>
</v>
<v t="ekr.20140103062103.16443"><vh>vc.has...</vh>
<v t="ekr.20140103105930.16447"><vh>vc.has_at_auto_view_node</vh></v>
<v t="ekr.20131230090121.16529"><vh>vc.has_clones_node</vh></v>
<v t="ekr.20140124111748.10637"><vh>vc.has_at_headlines_node</vh></v>
<v t="ekr.20131230090121.16531"><vh>vc.has_organizers_node</vh></v>
<v t="ekr.20131230090121.16535"><vh>vc.has_views_node</vh></v>
</v>
<v t="ekr.20140105055318.16755"><vh>vc.is...</vh>
<v t="ekr.20131230090121.16524"><vh>vc.is_at_auto_node</vh></v>
<v t="ekr.20140102052259.16398"><vh>vc.is_cloned_outside_parent_tree</vh></v>
<v t="ekr.20131230090121.16525"><vh>vc.is_organizer_node</vh></v>
</v>
<v t="ekr.20140112112622.16660"><vh>vc.testing...</vh>
<v t="ekr.20140109214515.16648"><vh>vc.compare_test_trees</vh></v>
<v t="ekr.20140115215931.16710"><vh>vc.compare_trial_writes</vh></v>
<v t="ekr.20140115215931.16707"><vh>vc.dump_list</vh></v>
<v t="ekr.20140109214515.16644"><vh>vc.trial_write</vh></v>
</v>
<v t="ekr.20140105055318.16760"><vh>vc.unls...</vh>
<v t="ekr.20140105055318.16762"><vh>vc.drop_all_organizers_in_unl</vh></v>
<v t="ekr.20140105055318.16761"><vh>vc.drop_unl_tail &amp; vc.drop_unl_parent</vh></v>
<v t="ekr.20140106215321.16673"><vh>vc.get_at_organizer_unls</vh></v>
<v t="ekr.20131230090121.16541"><vh>vc.relative_unl &amp; unl</vh></v>
<v t="ekr.20140106215321.16680"><vh>vc.source_unl</vh></v>
<v t="ekr.20140114145953.16696"><vh>vc.unl_tail</vh></v>
</v>
</v>
</v>
<v t="ekr.20140102051335.16506"><vh>vc.Commands</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18097"><vh>lengthHelper (LeoQTextEditWidget)</vh></v>
<v t="ekr.20140829172618.18477"><vh>LeoTree.remove_big_text_buttons (unused)</vh></v>
<v t="ekr.20140829172618.20682"><vh>LeoTree.is_big_text (not used)</vh></v>
<v t="ekr.20141021083702.18356"><vh>unused from leoPersistence.py</vh>
<v t="ekr.20140711111623.17859"><vh>pd.find_gnx_node</vh></v>
<v t="ekr.20140716021139.17767"><vh>pd.recover_ua_for_gnx</vh></v>
<v t="ekr.20141021083702.18355"><vh>from delete_at_data_children</vh></v>
<v t="ekr.20140716021139.17772"><vh>pd.find_at_recovery_node</vh></v>
<v t="ekr.20140716021139.17770"><vh>pd.has_at_recovery_node</vh></v>
</v>
<v t="ekr.20031218072017.1999"><vh>ni.toString</vh></v>
<v t="ekr.20141023110422.2"><vh>clone-find-all no longer used</vh>
<v t="ekr.20051113110735"><vh>find.createCloneFindAllNode (no longer used)</vh></v>
<v t="ekr.20140424102007.16875"><vh>find.linkCloneFindAllNode (no longer used)</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20131007143750.16111"><vh>TODO DOC</vh>
<v t="ekr.20131028213522.17137"><vh>Examples for cheat sheet</vh></v>
<v t="ekr.20131023180133.17111"><vh>Example Leo patterns</vh>
<v t="ekr.20131023180133.17112"><vh>Request</vh></v>
</v>
<v t="ekr.20131001100335.15942"><vh>Leo &amp; other programs</vh>
<v t="ekr.20131001100335.15943"><vh>Leo vs Emacs</vh>
<v t="ekr.20131025044901.17143"><vh>post Leo vs Emacs</vh></v>
</v>
<v t="ekr.20131027064821.17131"><vh>Leo vs emacs &amp; vim</vh></v>
<v t="ekr.20131001100335.15945"><vh>Leo vs IPython</vh></v>
<v t="ekr.20131001100335.15944"><vh>Leo vs Vim</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040518070558">Leo 4.2 alpha 2           May 18, 2004

This is an important milestone in Leo's history; the two defining features of
the 4.2 code base are complete:

1. This is the first stable version using the "shared nodes" code base.

Shared nodes dramatically improve the time needed to insert, delete, and move
nodes. Moreover, the new code base is code compatible with the old. Indeed, much
of Leo still uses the old code base. See the Scripting Leo for full details of how to
script Leo with the 4.2 code base.

2. This is the first version to use @file-thin for most external files.

@file-thin makes it possible to use Leo effectively in a cvs environment.  Indeed, cvs now contains only a "dummy" version of LeoPy.leo.  The idea is that:

- LeoPyRef.leo hardly ever changes. Developers will download LeoPyRef.leo once
from cvs, then rename LeoPyRef.leo to be LeoPy.leo. LeoPy.leo is private to each
developer.

- Developers will commit and update to cvs only thin external files. There is no
longer any need to keep .leo files and the files derived from them "in synch".

- Similar remarks apply to LeoPlugins.leo. Cvs contains only LeoPluginsRef.leo,
and contributors will need only to submit thin external files.

I have been using the new code base without incident for weeks now, and I am
fairly confident that it is safe to use. Nevertheless, I would suggest routine
caution when dealing with this version until more people have tested it.

Known bugs

- Cutting and pasting an @file-thin node does not work properly. This will be
easy to fix, I think.

- The present algorithm for reading thin external files probably does not handle
properly the situation in which a named node is some kind of grand child of the
referencing node rather than being an immediate child of the referencing node.
This is a rare situation, easily avoided, and it doesn't happen at all in
LeoPy.leo. Nevertheless, something must be done.

Other improvements:

- Fixed a number of problems with using Leo on MacOS X. In particular, Leo now
uses the clover key as is usual on the Mac. More Mac and *nix specific
improvements are coming.

Still to do:

- Perfect import and @import. - Make the Go To Line Number command work with
@file-thin files. - Fix minor bugs and add new features See the "To Do: 4.2"
node in the leoToDo.txt node in LeoPy.leo.
</t>
<t tx="EKR.20040518070824"></t>
<t tx="EKR.20040518070824.1">- Moved call to assignFileIndices into write_Leo_file.
- Called assignFileIndices in writeAtFileNodes, writeDirtyAtFileNodes, writeMissingAtFileNodes
</t>
<t tx="EKR.20040518070940"></t>
<t tx="EKR.20040518070940.156">After a match, the find-next command searched only in the suboutline where the first match occurred.
To fix this, we call g.app.findFrame.handleUserClick in various Tk event handlers.
</t>
<t tx="EKR.20040518070940.164">@nocolor


p.v.t.visitedBit was used for two purposes:

- To mark the nodes to be written.
- To mark nodes that are not orphan.

What I did:

- Added t.is/set/clearWriteBit.
- Call t.setWriteBit in putVnode unless we are in a thin node.
- putTnodes tests for t.writeBit rather than t.visitedBit.
</t>
<t tx="EKR.20040518070940.5">What I did:

File format

Added -thin field to @+leo sentinel

Recognizers

- Added vnode recognizers for @file-thin option.
- Added position proxies for vnode recognizers.

Directives &amp; sentinels
- Added support for @all.

Writing

- Added top-level atFile code to write @file-thin tree.
- DO write @file-thin vnodes if there was an error writing the external file.
	- No autosave for @file-thin.
 	- Leo writes @file nodes first, so this is not a problem.
	- putVnode checks orphan bit, which gets set if there was an error.
- Don't write vnodes (or related tnodes) for @file-thin trees. (fileCommands).
- Do write empty nodes in @thin trees.
- Don't generate close node sentinels until all children have been generated.

Reading

- Set at.thinFile when reading thin files.
- Suppressed changed message and related items for thin files.
- Modified scanText4 and allies to read thin external files.
	- Don't look for tnodeList for thin files.
	- Initially, at.lastThinNode is at.root.v
	- readStartNode calls createThinChild
	- createThinChild makes a child of at.lastThinNode if needed and sets at.lastThinNode.
- Updated fc.tnodesDict in at.createThinChild.
	Otherwise clones existing only in two thin files won't be linked properly.
</t>
<t tx="EKR.20040518071415">Leo did not handle moving a node to the root position of the outline correctly.
</t>
<t tx="EKR.20040518075457">Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import External File... 
</t>
<t tx="EKR.20040523192553"></t>
<t tx="EKR.20040524104904.100"></t>
<t tx="EKR.20040524104904.101">The ``new`` (Ctrl-N) command creates a new Leo main window. The
``open-outline`` (Ctrl-O) command opens an existing Leo file and shows it
in a main window. The ``close-window`` (Ctrl-F4) command closes the
selected Leo window, giving you an opportunity to save your work if you
haven't yet done so.

The ``save-file`` (Ctrl-S), ``save-file-as`` and ``save-file-to`` commands
save the Leo window to a file. The ``save-files-as`` command changes the
name of the outline being edited; the ``save-file-to`` command does not.
The ``save-file-as-zipped`` command is the same as the ``save-file-as``
command except that the resulting .leo file is compressed with Python's
zipfile module. Similarly, the ``save-file-as-unzipped`` command is the
same as the ``save-as`` command except that the resulting .leo file is not
compressed. The ``save-file``, ``save-file-as`` and ``save-file-to``
commands compress the file if it was originally compressed. **Note**: Leo
writes files with .leo extension, regardless of whether the file is zipped
or not. Zipped .leo files contain a single archive, whose name is the same
as the .leo file itself. Outside of Leo you can change the extension to
.leo.zip and use stuffit or other program to expand the .leo file contained
within. The ``revert`` command reloads a file, discarding any changes made
to the file since it was last saved.

The Recent Files menu shows a list of recently opened files. Choosing an
item in this submenu opens the selected file or brings it to the front. The
``clear-recent-files`` command deletes all entries in the Recent Files
submenu except the most recent file. The files themselves are not affected,
just the menu entries.

The following commands are located in the File:Read/Write menu...

The ``read-outline-only`` command reads an outline using only the .leo
file, not any files derived from @file nodes. This command is useful for
reverting a project to a previously saved state. The ``read-at-file-nodes``
command updates all @file nodes in an outline. This ensures that the state
of an outline matches all files derived from \@file nodes. The
``write-outline-only`` command saves an outline without writing any \@file
trees. Useful for inserting an @file node into an outline without modifying
a external file with the same name. The ``write-at-file-nodes`` command
forces an update of all @file trees. The ``write-dirty-at-file-nodes``
command writes all @file trees that have been changed.
</t>
<t tx="EKR.20040524104904.102">The ``open-with`` command allows you to communicate with external editor.
When you select this command Leo creates a temporary file and invokes an
external program. Leo periodically checks whether this temporary file has
changed; Leo changes the corresponding node in the outline if so. You must
create the entries using an \@openwith in myLeoSettings.leo. See the
documentation in leoSettings.leo.
</t>
<t tx="EKR.20040524104904.108">The ``import-file`` command imports a file in various ways depending on the
contents of the file. For plain files, the command creates an \@file node.
If the file looks like an external file written by Leo, the import command
will recreate the outline structure based on the sentinels in the file.
This command can also read files written in MORE outline format.
</t>
<t tx="EKR.20040524104904.109">The ``outline-to-cweb`` command creates a `CWEB`_ file from the selected
outline. The ``outline-to-noweb`` command creates a `noweb`_ file from the
selected outline. The ``flatten-outline`` command creates a text file in
MORE format from the selected outline. The ``remove-sentinels`` command
removes all sentinel lines from a file derived from an @file node. The
``weave`` command formats the selected text and writes it to a file.
</t>
<t tx="EKR.20040524104904.110">The ``exit-leo`` (Ctrl-Q or Alt-F4) command causes Leo to exit. You may
also exit Leo by closing the main window. You will be prompted to save any
file that has been altered but not saved.
</t>
<t tx="EKR.20040524104904.111"></t>
<t tx="EKR.20040524104904.112">Leo supports unlimited undo and redo with the ``undo`` (Ctrl-Z) and
``redo`` (Ctrl-Shift-Z) commands. Think of actions that may be undone or
redone as a string of beads. A "bead pointer" points to the present bead.
Performing an operation creates a new bead after the present bead and
removes all following beads. Undoing an operation moves the bead pointer
backwards; redoing an operation moves the bead pointer forwards. The ``undo``
command is disabled when the bead pointer moves in front of the first bead;
the ``redo`` command is disabled when the bead pointer points to the last bead.

The @string undo_granularity setting controls the granularity of undo.
There are four possible values:

node
    Starts a new undo unit when typing moves to a new node.

line (default)
    Starts a new undo unit when typing moves to new line.

word
    Starts a new undo unit when typing starts a new word.

char (not recommended)
    Starts a new undo unit for each character typed.
    This wastes lots of computer memory.
</t>
<t tx="EKR.20040524104904.113">Leo supports the standard editing commands: ``cut-text`` (Ctrl-X),
``copy-text`` (Ctrl-C) and ``paste-text`` (Ctrl-V), and ``select-all``
(Ctrl-A) commands. These commands work with either headline or body text.
</t>
<t tx="EKR.20040524104904.114">The ``indent-region`` (Tab) and ``unindent-region`` (Shift-Tab) commands
shift selected lines in the body text left or right one tab position. These
commands shift the entire line if any characters in that line are selected.
If no text is selected, the Tab character insert a hard or soft tab
depending on the value of the \@tabwidth directive in effect.
</t>
<t tx="EKR.20040524104904.115">The ``extract`` (Ctrl-Shift-D) command creates a new node whose headline is
the first line of selected body text and whose body is all other lines of
selected text. Previously selected text is deleted from the original body
text. The ``extract-names`` (Ctrl-Shift-Command) command creates one or
more child nodes, one for each section name in the selected body text. The
headline of each created node is the section name.
</t>
<t tx="EKR.20040524104904.116">The ``convert-tabs`` command converts leading tabs to blanks in a single
node. The ``convert-blanks`` command converts blanks to tabs in a single
node. The ``convert-all-tabs`` command converts leading tabs to blanks
throughout the selected tree. The ``convert-all-blanks`` command converts
leading blanks to tabs throughout the selected tree. All these commands
convert between tabs and blanks using the \@tabwidth setting presently in
effect.
</t>
<t tx="EKR.20040524104904.117">The ``execute-script`` (Ctrl-B) command executes body text as a Python
script. Leo execute the selected text, or the entire body text if no text
is selected. The Execute Script command pre-defines the values c, g and p
as follows:

- c is the commander of the outline containing the script.
- g is the leoGlobals modules.
- p is c.p, that is, c.currentPosition().

**Important**: Body text may contain Leo directives and section references.
You can use all of Leo's features to organize scripts that you execute
interactively. Section definitions must appear in the node containing the
script or in descendant nodes.

Leo preprocesses all scripts by simulating the writing of a external file
to a string. The ``execute-script`` command sets app.scriptDict["script1"]
to the value of the script before preprocessing, and sets
app.scriptDict["script2"] to the value of the script after preprocessing.
Scripts may examine and change app.scriptDict as they please.
</t>
<t tx="EKR.20040524104904.118"></t>
<t tx="EKR.20040524104904.134">The ``goto-global-line`` (Alt-G) command selects the locations in your
outlines corresponding to a line in a external file.
</t>
<t tx="EKR.20040524104904.136">The ``insert-body-time`` and ``insert-headline-time`` commands insert
formatted time and date into body or headline text. You must be editing a
headline to be able to insert the time/date into the headline. The
body_time_format_string and headline_time_format_string settings specify
the format of the inserted text. These settings are the format string
passed to time.strftime. For a complete list of the format options see
http://www.python.org/doc/current/lib/module-time.html The "%m/%d/%Y
%H:%M:%S" format is used by default, resulting in a time/date format like::

    1/30/2003 8:31:55
</t>
<t tx="EKR.20040524104904.137">The ``reformat-paragraph`` (Ctrl-Shift-P) command rearranges the words in a
text paragraph to fill each line as full as possible, up to the \@pagewidth
setting. A paragraph is delimited by blank lines, Leo directives, and (of
course) start and end of text in a node. The width of the line used by the
reformatting operation is governed by @pagewidth and the indentation that
would be applied to the node when Leo writes the file.

The command operates on the paragraph containing the insert cursor. If the
insert cursor is on a blank line or directive, nothing happens. If the
cursor is on a line containing text, then the paragraph containing that
text line is reformatted and the insert cursor is moved to the next
paragraph.

**Note**: Hanging indentation is preserved. This is most useful for
bulleted or numbered lists, such as::

  1. This is the first paragraph,
     and it has a hanging indentation.

  2. This is the second paragraph,
     and it too has a hanging indentation.
</t>
<t tx="EKR.20040524104904.139">The ``match-brackets`` command is enabled if the cursor is next to one of the
following characters in the body pane:

    ( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through
the body text if the cursor is next to ``)`` ``]`` ``}`` or ``&gt;`` and
searching forward through the text otherwise. If the cursor is between two
brackets the search is made for the bracket matching the leftmost bracket.
If a match is found, the entire range of characters delimited by the
brackets is highlighted and the cursor is placed just to the left of the
matching characters. Thus, executing this command twice highlights the
range of matched characters without changing the cursor.
</t>
<t tx="EKR.20040524104904.140">Leo stores options in **@settings trees**, outlines whose headline is
@settings. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.
This scheme allows for the following kinds of settings:

- Per-installation or per-machine settings.
- Per-user settings.
- Per-folder settings.
- Per-file settings.

There are four kinds of settings files:

1. **Default settings files**, named **leoSettings.leo**.
   Although they can be used in other ways, they typically contain default settings.

2. **Personal settings files**, named **myLeoSettings.leo**. They provide a way
   of ensuring that your customized settings are not altered when updating Leo
   from git or while installing a new version of Leo. The myLeoSettings.leo acts
   much like Python's site-customize.py file. myLeoSettings.leo will never be
   part of any Leo distribution, and it will never exist in Leo's cvs
   repository. This solution is *much* better than trying to update
   leoSettings.leo with scripts.

3. **Machine settings files**, named **LeoSettings.leo** (note the capital 'L'),
   and appearing in a unique directory.

4. **Command-line settings files**, specified using Leo's -c command-line
   option. Any .leo file may be used, provided it has an @settings tree. These
   files typically provide a common set of settings for files scattered in
   various places on the file system.

The following sections describe the kinds of nodes in @settings trees.
</t>
<t tx="EKR.20040524104904.143"></t>
<t tx="EKR.20040524104904.144">The ``check-outline`` command checks the outline for consistency. Leo
automatically check the syntax of Python external files when Leo
writes the external file.

The ``pretty-print-python-code`` and ``pretty-print-all-python-code``
pretty print body text. You can customize this code by overriding the
following methods of class prettyPrinter in leoCommands.py::

    putOperator:      puts whitespace around operators.
    putNormalToken:   puts whitespace around everything else.
</t>
<t tx="EKR.20040524104904.148">The ``hoist`` command redraws the screen so presently selected tree becomes
the only visible part of the outline. You may hoist an outline as many
times as you wish. The ``dehoist`` command undoes the effect of the
previous ``hoist`` command.
</t>
<t tx="EKR.20040524104904.151">-   The Equal Sized Panes command adjusts the sizes of the outline and body
    panes so that they are the same height.
-   The Cascade command cleans up the screen by cascading all Leo windows.
-   The Minimize All command minimizes all Leo windows.
-   The Toggle Active Pane command toggles keyboard focus between the outline and body panes.
-   The Toggle Split Direction command switches between vertical and horizontal
    orientations of the Leo window. In the vertical orientation, the body pane
    appears below the pane containing the outline and log panes. In the horizontal
    orientation, the body pane appears to the left the pane containing the outline
    and log panes. By default, the ratio of pane outline pane to the body pane is
    0.5 in the vertical orientation and 0.3 in the horizontal orientation. These two
    ratios may be changed using settings.
-   The Open Compare Window command opens a dialog that allows you to compare
    two files, one containing sentinels and one not.
</t>
<t tx="EKR.20040524104904.157">-   The About Leo command puts up a dialog box showing the version of Leo.
-   The Online Home Page command opens Leo's home page at http://leoeditor.com.
-   The Open Online Tutorial command opens Joe Orr's excellent ScreenBook tutorial at
    http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm.
-   The Open Offline Tutorial command opens the file sbooks.chm if it exists.
    Otherwise, you will be asked whether you want to download it from Leo's SourceForge web site.
    If you say yes, the page http://sourceforge.net/project/showfiles.php?group_id=3458 will open.
    You may then download sbooks.sbm to the folder containing leo.py.
-   The Open LeoDocs.leo command opens LeoDocs.leo.
-   The Open LeoPlugins.leo command opens LeoPlugins.leo.
-   The Open LeoSettings.leo command opens LeoSettings.leo.

</t>
<t tx="EKR.20040524104904.211"></t>
<t tx="EKR.20040524104904.224" str_atime="1376412038.0">Naively using plugins can expose you and your .leo files to malicious attacks.
The fundamental principles are::

    Scripts and plugins must never blindly execute code from untrusted sources.

and::

    .leo files obtained from other people may potentially contain hostile code.

Stephen Schaefer summarizes the danger this way::

    I foresee a future in which the majority of leo projects come from
    marginally trusted sources...a world of leo documents sent hither and yon -
    resumes, project proposals, textbooks, magazines, contracts - and as a race
    of Pandora's, we cannot resist wanting to see "What's in the box?" And are
    we going to fire up a text editor to make a detailed examination of the
    ASCII XML? Never! We're going to double click on the cute leo file icon, and
    leo will fire up in all its raging glory. Just like Word (and its macros) or
    Excel (and its macros).

In other words::

    When we share "our" .leo files we can NOT assume that
    we know what is in our "own" documents!

Not all environments are untrustworthy. Code in a commercial cvs repository is
probably trustworthy: employees might be terminated for posting malicious code.
Still, the potential for abuse exists anywhere.

In Python it is very easy to write a script that will blindly execute other scripts::

    # Warning: extremely dangerous code

    # Execute the body text of all nodes that start with `@script`.
    def onLoadFile():
        for p in c.all_positions():
            h = p.h.lower()
            if g.match_word(h,0,"@script"):
                s = p.b
                if s and len(s) &gt; 0:
                    try: # SECURITY BREACH: s may be malicious!
                        exec(s + '\n')
                    except:
                        es_exception()

Executing this kind of code is typically an intolerable security risk.
**Important**: rexec provides *no protection whatever*.
Leo is a repository of source code, so any text operation is potentially malicious.
For example, consider the following script, which is valid in rexec mode::

    badNode = c.p
    for p in c.all_positions():
        &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt;
    &lt;&lt; delete badNode &gt;&gt;
    &lt;&lt; clear the undo stack &gt;&gt;

This script will introduce a security hole the .leo file without doing anything
prohibited by rexec, and without leaving any traces of the perpetrating script
behind. The damage will become permanent *outside* this script when the user
saves the .leo file.
</t>
<t tx="EKR.20040524104904.240" str_atime="1376411987.0">If a plugin has a function at the outer (module) level called unitTest,
Leo's unit tests will call that function.

So it would be good if writers of plugins would create such a unitTest
function. To indicate a failure the unitTest can just throw an exception.
Leo's plugins test suite takes care of the rest.
</t>
<t tx="EKR.20040524104904.242">Leo reads and writes "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files as follows:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for
  any tnode or vnode whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are dictionaries whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if a vnode or tnode contains an unknownAttributes ivar.

- The only native attribute of &lt;t&gt; elements is tx.

- The native attributes of &lt;v&gt; elements are a, t, vtag and tnodeList.

- The native attributes of &lt;v&gt; elements are marks, expanded and descendentTnodeUnknownAttributes.

- Non-native attributes are called **foreign** attributes.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.
Like this::

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes ["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about
how to avoid potential conflicts in naming new attributes.

All members of these dictionaries should be "pickleable". That is, Leo uses
Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

Leo writes only t.unknownAttributes when writing @thin trees to the .leo
file. Leo puts (the encoding of) these elements into an attribute called
descendentTnodeUnknownAttributes. This attribute is part of the &lt;v&gt;
element representing the @thin node. Leo does _not_ write
v.unknownAttributes in @thin trees because *only tnodes have gnx's in
thin external files*. In effect, vnodes are anonymous. We could attempt to get
around this by identifying vnodes by their corresponding tnodes, but that's not
a general solution and it is, in effect, equivalent to writing only
t.unknownAttributes. So it seems pointless to "pretend" to be writing
v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. This won't work in all cases. For example, a
plugin that creates an arbitrary directed graph between vnodes must distinguish
between joined vnodes. In that case, the plugin should confine itself to @file
trees, or just vnodes in .leo files, for that matter.
</t>
<t tx="EKR.20040524104904.247">In May of 1999 I began work on the Borland version of Leo for Windows.  The
Borland Delphi classes were a pleasure to use and free of bugs.  I redesigned
Leo's file format for the Windows version of Leo; the Yellow Box file format is
a binary format that requires the Yellow Box runtime.  Fortunately, I choose to
use XML for Leo's file format.  I have Marc-Antoine Parent to thank for this
decision; he urged me to use XML and patiently explained how to use XML
properly.  However, there are two significant problems with the Borland version
of Leo.  First, it works only on Windows.  Second, it can never be Open
software, because it uses Borland's Delphi classes and a commercial syntax
coloring component. 

In October of 2001 I began work on the leo.py, an Open Software version of
leo.py, a version of Leo written in Python and Tk.  At last I have found the
proper platform for Leo.  leo.py naturally supports scripting in Python.  The
combination of Python and Tk is incredibly powerful, very easy to use, and truly
cross platform.  I rewrote Leo in Python in about two months!  For the first
time in my career I no longer am anxious while programming; it simply isn't
possible to create bad bugs in Python.

Tk was officially retired in June 2011.
</t>
<t tx="EKR.20040524104904.248">The following sections give a pseudo-chronological list of the major Aha's
involved in creating Leo2. These Aha's form the real design and theory of
operation of Leo. See the "Diary", "Notes" and "Letters to Speed Ream" sections
in LeoDocs.leo for a more accurate and less tidy history of Leo2.

I am writing these notes for several reasons. First, the initial design and
coding of Leo2, spanning a period of about 8 weeks, was some of the most
creative and rewarding work I have ever done. The result is elegant and simple.
I'm proud of it. Second, much of the design work is not reflected in the code,
because improved design often eliminated code entirely. The final code is so
elegant that it obscures the hard work that created it. Third, you must
understand this design in order to understand the implementation of @file trees
and their external files. Someday someone else may take charge of Leo. That
person should know what really makes Leo2 work.
</t>
<t tx="EKR.20040524104904.249">In the summer of 2001 I began work on a project that for a long time I had
considered impossible. I had long considered that "private" file formats such as
.leo files were the only way to represent an outline properly and safely. I'm
not sure exactly what changed my mind, but I finally was willing to consider
that information embedded in external files might be useful. This meant accepting
the possibility that sentinel lines might be corrupted. This was a crucial first
step. If we can trust the user not to corrupt sentinel lines than we can embed
almost any kind of information into a external file.

There were several motivations for this work. I wanted to eliminate the need for
explicit Tangle and Untangle commands. I thought of this as "Untangle on
Read/Tangle on Write." If tangling and untangling could be made automatic it
would save the user a lot of work. I also wanted to make external files the
primary sources files. .leo files might be made much smaller external files
contained the primary source information. This hope turned out to be false.

The result of this design work was something I originally called Leo2, though I
now usually prefer to talk about @file trees. Initially most design issues were
unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not
knowing in advance what that might involve. I also wanted to solve what I
thought of as the "cross-file clone" problem: clones that point from a .leo
outline into a external file. With Leo1 cross-file clones do not exist;
everything is in the same .leo file. It was clear that Leo2 would have to change
some aspects of clones, but all details were fuzzy.
</t>
<t tx="EKR.20040524104904.250">The next step was also crucial. I started to use Leo1 as a prototype to design
what the new body pane would look like to the user. In retrospect, using Leo1 as
a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1.
Both prototypes marked the true beginning of their respective projects. The Leo2
prototype was a mockup in Python of the code for reading and writing derived
files. The file LeoDocs.leo contain these first prototype nodes.

Writing the prototype got me thinking about improving noweb. With my experience
with Leo1, I was able to create a new markup language that took advantage of
outline structure. I called the new language "simplified noweb", though that
terminology is obsolete. I created @file nodes to distinguish between the old
and new ways of creating external files. In Leo1, the @code directive is simply
an abbreviation for a section definition line. Simplified noweb used @c as an
abbreviation for @code. More importantly, simplified noweb used @c to separate
doc parts from code parts without necessarily specifying a section name. It
quickly became apparent that most nodes could be unnamed. All I needed was the
@others directive to specify the location for all such unnamed nodes.

From the start, simplified noweb was a joy to use. Indeed, the @others directive
could replace all section definition lines. Furthermore, I could make @doc
directive optional if the body pane started in "code mode". But this meant that
plain body text could become a program! This was an amazing discovery. These
Aha's got me excited about Leo2. This was important, as it motivated me to do a
lot of difficult design work.
</t>
<t tx="EKR.20040524104904.251">In spite of this excitement, I was uneasy. After much "daydreaming" I realized
that I was afraid that reading and writing external files would be interrupted by
a long series of alerts. I saw that designing the "user interaction" during
reading and writing would be very important. The next Aha was that I could
replace a long series of alerts with messages to the log window, followed by a
single "summary" alert. Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors" while reading
external files. Warnings would alert the user that something non-serious had
happened. True errors would alert the user that data might have been lost.
Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file
node, then read errors could endanger such nodes. Much later I saw that a robust
error recovery scheme demands that @file nodes not contain orphan and @ignored
nodes. (More on this subject later.) But if orphan and @ignored nodes are moved
out of @file trees, there are no read errors that can cause data loss! So the
distinction between warnings and errors finally went away.
</t>
<t tx="EKR.20040524104904.252">I next turned my attention to writing @file nodes. A huge Aha: I realized that
sentinel lines must contain both a leading and a trailing newline. The general
principle is this: the write code must contain absolutely no "conditional"
logic, because otherwise the read code could not figure out whether the
condition should be true or false. So external files contain blank lines between
sentinel lines. These "extra" newlines are very useful, because the read
(untangle) code can now easily determine exactly where every blank, tab and
newline of the external file came from. It would be hard to overstate how
important this simplifying principle was in practice.

Much later, with urging from a customer, I realized that the write code could
safely remove "extra" newlines between sentinels with a caching scheme in the
low level atFile::os() routine. This scheme does not alter the body of the write
code in any way: in effect, sentinels still contain leading and trailing
"logical" newlines. The read code had to be modified to handle "missing" leading
newlines, but this can always be done assuming that sentinels still contain
logical leading and trailing newlines!

At about this time I designed a clever way of having the write code tell the
read code which newlines were inserted in doc parts. (The whole point of doc
parts is to have the write code format long comments by splitting long lines.)
To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted
line breaks: A line in a doc part is followed by an inserted newline if and only
if the newline is preceded by whitespace. This is a really elegant convention,
and is essentially invisible to the user. Tangle outputs words until the line
would become too long, and then it inserts a newline. To preserve all
whitespace, tangle always includes the whitespace that terminates a word on the
same line as the word itself. Therefore, split lines always end in whitespace.
To make this convention work, tangle only has to delete the trailing whitespace
of all lines that are followed by a 'real' newline."
</t>
<t tx="EKR.20040524104904.253">After the write code was working I turned my attention to the read (untangle)
code. Leo's Untangle command is the most complex and difficult code I have ever
written. Imagine my surprise when I realized that the Leo2 read code is
essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The
read code scans lines of a external files looking for "opcodes", that is,
sentinel lines, and executes some simple code for each separate opcode. The
heart of this code is the scanText routine in atFile.cpp.

The read code was written and debugged in less than two days! It is the most
elegant code I have ever written. While perfecting the read code I realized that
sentinel lines should show the complete nesting structure found in the outline,
even if this information seems redundant. For example, I was tempted to use a
single sentinel to represent an @other directive, but finally abandoned this
plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the read code and made the structure of
external files absolutely clear. Moreover, it turned out that we need, in
general, all the information created by the present sentinel lines. In short,
sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes
will be correctly inserted into the outline. createNthChild must be bullet-proof
if the Read code is to be robust. Note that the write code outputs @node
sentinels, that is, section definitions, in the order in which sections are
referenced in the outline, not the order in which sections appear in the
outline. So createNthChild must insert the n'th node of parent p properly even
if p contains fewer than n-1 children! The write code ensures that section
references are properly nested: @node sentinels are enclosed in @node sentinels
for all their ancestors in the @file tree. createNthChild creates dummy siblings
as needed, then replaces the dummy siblings later when their actual definitions,
that is, @node sentinels, are encountered.

At this point the fundamental read/write code was complete. I found three minor
bugs in the code over the next week or so, but it was clear that the read/write
code formed a rock-solid base from which to continue design and implementation.
This was an entirely unexpected surprise.
</t>
<t tx="EKR.20040524104904.254">At this point I could read and write external files "by hand", using temporary
Read and Write commands. The next step was to integrate the reading and writing
of external files with the loading and saving of .leo files. From time to time I
made minor changes to the drivers for the read/write code to accommodate the
Load and Save code, but at no time did I significantly alter the read or write
code itself.

The user interaction of the Load and Save commands drove the design and
implementation of the load/store code. The most important questions were: "what
do we tell the user?", and "what does the user do with the information?" It
turns out that the user can't make any complex decision during error recovery
because the user doesn't have nearly enough information to make an informed
choice. In turn, this means that certain kinds of error recovery schemes are out
of the question...
</t>
<t tx="EKR.20040524104904.255">I now turned my attention to "attributes" of nodes. Most attributes, like user
marks, are non-essential. However, clone information is essential; we must never
lose clone links. At this time I had a preliminary design for cross-file clones
that involved a two part "pointer" consisting of a full path name and an
immutable clone index within the external file. Eventually such pointers
completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node
sentinels in the external file, but experience showed that would be irritating.
Indeed, one wants Leo2 to rewrite external files only if something essential has
changed. For example, one doesn't want to rewrite the external file just because
a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all
non-essential attributes. For example, this means that the .leo file, not the
external files, will change if we select a new node. In effect, the .leo file
mirrors the external file. The only reason to store nodes in the .leo file under
an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do
not reference body text. Much later I saw that dummy nodes were dangerous and
that .leo files should contain all information found in external files.
</t>
<t tx="EKR.20040524104904.256">The concept of mirroring created a huge breakthrough with cross-file clones:
Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all
nodes in a external file, those dummy nodes can carry clone info! I changed one
line to make sure that the write code always writes clone info in dummy vnodes
and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged. Everything "just
works".
</t>
<t tx="EKR.20040524104904.257">At first I thought we could make sure that the .leo file always correctly
mirrors all external file, but disastrous experience showed that is a completely
false hope. Indeed, backup .leo files will almost never mirror external file
correctly. So it became urgent to find a completely fool-proof error recovery
scheme.

I had known for quite a while that error recovery should work "as if" the
mirroring nodes were deleted, then recreated afresh. Several failed attempts at
an error recovery scheme convinced me that error recovery would actually have to
delete all dummy nodes and then do a complete reread. This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes--by
definition such nodes appear nowhere in the external file. Therefore, I had to
enforce the rule that @file nodes should contain no such nodes. Here is an email
I wrote to my brother, Speed Ream discussing what turned out to be the
penultimate error recovery scheme:

"The error recovery saga continues. After much pondering and some trial coding I
have changed my mind about orphans and @ignored nodes. They simply should never
appear as descendants of @file nodes. Fortunately, this simplifies all aspects
of Leo2. Leo2 will issue a warning (not an error) if an orphan or @ignored node
appears as the descendant of an @file node when a .leo file is being saved. If
any warnings occur while writing the external file, Leo2 will write the
"offending" @file tree to the .leo file instead of the external file. This has
several advantages:

1. The user gets warned about orphan nodes. These are useful warnings! Orphan
nodes arise from missing @others directives or missing section references.

2. The user doesn't have to change anything immediately in order to save an
outline. This is very important. Besides warnings about orphans, Leo2 will also
warn about undefined or unreferenced sections. User's shouldn't have to fix
these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the user's
anxiety level goes way down. At worst, some informational message will be sent
to the log. The user will never have to make important decisions during Loads or
Saves. [At last the dubious distinction between errors and warnings disappears.]

4. Error recovery can be bullet-proof. Simple code will guarantee that after any
read operation the structure of an @file node will match the structure of the
external file. Also, sentinels in external files will now account for all children
of an @file node. There are no more "missing nodes" that must be filled in using
the .leo file. Finally, error recovery will never change the @file tree in any
way: no more "recovered nodes" nodes.

5. The present read code can be used almost unchanged. The only addition is the
posting of a warning if the structure of the .leo file does not match the
structure of the external file. We need a warning because non-essential attribute
of nodes (like user marks) may be altered."

This ends the original history of Leo2. In fact, it took quite a while before
Leo recovered properly from all errors. I finally saw that .leo files should
duplicate all information in external files. This allows a .leo file to be used a
single backup file and allows maximal error recovery in all situations. It took
several months to stamp out several subtle bugs involving clones that caused
spurious read errors. Such errors undermine confidence in Leo and can cause
disastrous reversions. See my diary entries for January 2002 in leo.py for
details.
</t>
<t tx="EKR.20040524104904.268">Leo's grand strategy for handling text is as follows:

1. Internally, Leo uses unicode objects for all text.

2. When reading files or user input, Leo converts all plain (encoded)
   strings to unicode.

3. When reading or writing files, Leo converts unicode strings to encoded
   strings.
   
To make this strategy work, Leo must know the encoding used for external
files. This is why Leo supports the @encoding directive and various
encoding-related settings.

The g.toUnicode and g.toEncodedString functions convert to and from
unicode. These methods catch all unicode-related exceptions.

The g.u function should be used *only* to convert from the Qt string type
(a wrapper for a unicode string) to unicode. Do not use g.u instead of
g.toUnicode.
</t>
<t tx="EKR.20040524104904.27">A cloned node is a copy of a node that changes when the original changes.
One may also think of it as a single node that is hooked into the outline
at multiple positions. Because that single node brings along all its
descendants, changes are maintained across all the the clones of a node,
along with changes to its offspring (children, grandchildren, etc.), i.e.,
any changes are simultaneously made to the corresponding offspring of all
of those clones. A small red arrow in the icon box marks cloned nodes. You
can think of the arrow as pointing out that there are other paths to get to
this same node. There is no real distinction between the "original" node
and any of its clones. Any headline or body update of a clone headed
subtree affects all of its clones simultaneously. A cloned node becomes a
regular node whenever deletion of its other clones makes it the only one
left. Clones are useful for making alternate views of a program. See
`Clones and views`_ for full details.

The ``clone-node`` (Ctrl-\`) command creates a clone as the immediate
sibling of a selected node. You have to place it where you want it by
either using move commands, or cutting and paste the clone.
</t>
<t tx="EKR.20040524104904.354">Leo uses unicode internally for all strings.

1.  Leo converts headline and body text to unicode when reading .leo files and external files.
    Both .leo files and external files may specify their encoding.  The default is utf-8.
    If the encoding used in a external file is not "utf-8" it is represented in the @+leo sentinel line.
    For example::

        #@+leo-encoding=iso-8859-1.

    The utf-8 encoding is a "lossless" encoding (it can represent all unicode code points),
    so converting to and from utf-8 plain strings will never cause a problem.
    When reading or writing a character not in a "lossy" encoding,
    Leo converts such characters to '?' and issues a warning. 

2.  When writing .leo files and external files Leo uses the same encoding used to read the file,
    again with utf-8 used as a default.

3.  leoSettings.leo contains the following Unicode settings, with the defaults as shown::

        default_derived_file_encoding = UTF-8 
        new_leo_file_encoding = UTF-8 

    These control the default encodings used when writing external files and .leo files.
    Changing the new_leo_file_encoding setting is not recommended.
    See the comments in leoSettings.leo.
    You may set default_derived_file_encoding to anything that makes sense for you.

4.  The @encoding directive specifies the encoding used in a external file.
    You can't mix encodings in a single external file.
</t>
<t tx="EKR.20040524104904.357">Here are the XML elements that may appear in Leo files:

&lt;?xml&gt;
    Leo files start with the following line::

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;?xml-stylesheet&gt;
    An xml-stylesheet line is option.  For example::

        &lt;?xml-stylesheet ekr_stylesheet?&gt;

&lt;leo_file&gt;
    The &lt;leo_file&gt; element opens an element that contains the entire file.
    &lt;/leo_file&gt; ends the file.

&lt;leo_header&gt; 
    The &lt;leo_header&gt; element specifies version information and other information
    that affects how Leo parses the file.  For example::

        &lt;leo_header file_format="2" tnodes="0" max_tnode_index="5725" clone_windows="0"/&gt;

    The file_format attribute gives the 'major' format number.
    It is '2' for all 4.x versions of Leo.
    The tnodes and clone_windows attributes are no longer used.
    The max_tnode_index	attribute is the largest tnode index.

&lt;globals&gt;
    The globals element specifies information relating to the entire file.
    For example::

        &lt;globals body_outline_ratio="0.50"&gt;
            &lt;global_window_position top="27" left="27" height="472" width="571"/&gt;
            &lt;global_log_window_position top="183" left="446" height="397" width="534"/&gt;
        &lt;/globals&gt;

    -   The body_outline_ratio attribute specifies the ratio of the height of the body pane to
        the total height of the Leo window.
        It initializes the position of the splitter separating the outline pane from the body pane.

    -   The global_window_position and global_log_window_position elements
        specify the position of the Leo window and Log window in global coordinates:

&lt;preferences&gt;
    This element is vestigial.
    Leo ignores the &lt;preferences&gt; element when reading.
    Leo writes an empty &lt;preferences&gt; element.

&lt;find_panel_settings&gt;
    This element is vestigial.
    Leo ignores the &lt;find_panel_settings&gt; element when reading.
    Leo writes an empty &lt;find_panel_settings&gt; element.

&lt;clone_windows&gt;
    This element is vestigial.
    Leo ignores the &lt;clone_windows&gt; element when reading.
    Leo no longer writes &lt;clone_windows&gt; elements.

&lt;vnodes&gt;
    A single &lt;vnodes&gt; element contains nested &lt;v&gt; elements.
    &lt;v&gt; elements correspond to vnodes.
    The nesting of &lt;v&gt; elements indicates outline structure in the obvious way.

&lt;v&gt;
    The &lt;v&gt; element represents a single vnode and has the following form::

        &lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt;

    The &lt;vh&gt; element specifies the headline text.
    sss is the headline text encoded with the usual XML escapes.
    As shown above, a &lt;v&gt; element may contain nested &lt;v&gt; elements.
    This nesting indicates outline structure in the obvious way.
    Zero or more of the following attributes may appear in &lt;v&gt; elements::

        t=name.timestamp.n
        a="xxx"

    The t="Tnnn" attribute specifies the &lt;t&gt; element associated with a &lt;v&gt; element.
    The a="xxx" attribute specifies vnode attributes.
    The xxx denotes one or more upper-case letters whose meanings are as follows::

        C	The vnode is a clone. (Not used in 4.x)
        E	The vnode is expanded so its children are visible.
        M	The vnode is marked.
        T	The vnode is the top visible node.
        V	The vnode is the current vnode.

    For example, a="EM"  specifies that the vnode is expanded and is marked.

    **New in 4.0**:

    -   &lt;v&gt; elements corresponding to @file nodes now contain tnodeList attributes.
        The tnodeList attribute allows Leo to recreate the order in which nodes should appear in the outline.
        The tnodeList attribute is a list of gnx's: global node indices.
        See Format of external files (4.x) for the format of gnx's.

    -   Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt; elements.
        See `Writing plugins`_ for details.

&lt;tnodes&gt;
    A single &lt;tnodes&gt; element contains a non-nested list of &lt;t&gt; elements.

&lt;t&gt;
    The &lt;t&gt; element represents the body text of the corresponding &lt;v&gt; element.
    It has this form::

        &lt;t tx="&lt;gnx&gt;"&gt;sss&lt;/t&gt;

    The tx attribute is required.
    The t attribute of &lt;v&gt; elements refer to this tx attribute.
    sss is the body text encoded with the usual XML escapes.

    **New in 4.0**: Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt;
    elements. See `Writing plugins`_ for details.
</t>
<t tx="EKR.20040524104904.36">The ``insert-node`` (Ctrl-I or Insert) command inserts a new node into the
outline. When invoked, (from any pane), it inserts a new node below the
presently selected node, and at the same level as that node, or at the
child level if it has a visible child. The ``delete-node`` command deletes
a node and all its children; it is initially unbound. If you want to retain
the children you must promote all the children before you do the delete.
</t>
<t tx="EKR.20040524104904.37">The ``cut-node`` (Ctrl-Shift-X) ``paste-node`` (Ctrl-Shift-V),
``copy-node`` (Ctrl-Shift-C) and ``delete-node`` commands work on nodes
rather than text. The ``cut-node`` and ``copy-node`` commands copy a text
representation of the outline to the clipboard. This representation is the
same as Leo's .leo file format with some information deleted. You may copy
this text representation into a body pane (or into any other text editor)
using Edit-&gt;Paste in the menus, Ctrl-V, or Alt-X paste-text.

**Warning**: If you want to preserve the "cloned" attribute of a node, or
want to paste the node as a clone of the node you cut or copied, use the
``past-retaining-clones`` command, which in the Outline menu is called
"Paste Node as Clone". The ``paste-node`` command instead creates a new,
distinct version of the node you previously cut or copied, though if there
were descendant nodes which were clones of each other, the new version will
have parallel, distinct nodes that are also clones of each other (just not
of the originals). You may paste a node between .leo files, but there can
be no clone relationship across files.

The ``paste-retaining-clones`` command is disabled if it would cause a node
to become a parent of itself. The Leo outline is thus mathematically a
*directed acyclic graph*: clones make it more flexible than a tree, but not
a generalized graph.
</t>
<t tx="EKR.20040524104904.38">You may drag a node (including all its descendants) from one place to
another in an outline. To start a drag, press the main (left) mouse button
while the cursor is over the icon for a node. The cursor will change to a
hand icon. If you release the mouse button while the hand cursor is above
the icon for another node, Leo will move the dragged node after that node.
If you release the mouse button when the hand cursor is not over an icon,
Leo will leave the outline pane as it is. Leo scrolls the outline pane as
the result of mouse-moved events, so to continue scrolling you must keep
moving the mouse.
</t>
<t tx="EKR.20040524104904.39">-   Clicking mouse button 1 positions the insertion cursor just before the character
    underneath the mouse cursor, sets the input focus to this widget, and clears any
    selection in the widget. Dragging with mouse button 1 strokes out a selection
    between the insertion cursor and the character under the mouse. 

-   Double-clicking mouse button 1 selects the word under the mouse and
    positions the insertion cursor at the end of the word.

-   The ends of the selection can be adjusted by dragging with mouse button 1 while
    the Shift key is down; this will adjust the end of the selection that was
    nearest to the mouse cursor when button 1 was pressed. 

-   If there is no selection, normal printing characters are inserted at the point of the insertion cursor. 

-   If there is a selection, normal printing characters replace the selection.

-   If the mouse is dragged out of the body pane while button 1 is pressed, the
    entry will automatically scroll to make more text visible.

-   Left Arrow and Right Arrow move the cursor one character to the left or right
    and clear any selection in the text.

-   Shift Left or Shift Right move the cursor and modify the selection.

-   Control-Left and Control-Right move the insertion cursor by words,
    and Control-Shift-Left and Control-Shift-Right move the insertion
    cursor by words and also extend the selection.

-   Up Arrow and Down Arrow move the insertion cursor one line up or down and
    clear any selection in the text. 

-   Shift Up and Shift Right move the cursor and extend the selection.

-   Control-Up and Control-Down move the insertion cursor by paragraphs.

-   Control-Shift-Up and Control-Shift-Down move the insertion cursor by
    paragraphs and extend the selection.

-   Next (Page Down) and Prior (Page Up) keys move the
    insertion cursor one screen and clear any text selection.

-   Shift Next and Shift Prior move the cursor one screen and extend the selection.

-   Line movement is by text lines terminated by hard returns (newlines), not by
    displayed lines; if a text line is long and wraps across more than one display
    line, then the Up and Down movement will skip the extra wrapped display lines.

-   Home moves the insertion cursor to the beginning of its line and clears any
    selection in the widget.

-   Shift-Home moves the insertion cursor to the beginning of the line and extends the selection. 

-   End moves the insertion cursor to the end of the line and clears any selection in
    the widget.

-   Shift-End moves the cursor to the end of the line and extends the selection. 

-   Control-Home moves the insertion cursor to the beginning of the text and clears
    any selection in the widget.

-   Control-Shift-Home moves the insertion cursor to the beginning of the text and extends the selection. 

-   Control-End moves the insertion cursor to the end of the text and clears any
    selection.

-   Control-Shift-End moves the cursor to the end of the text and extends the selection. 

-   Select and Control-Space set the selection anchor to the position of the
    insertion cursor. They don't affect the current selection.

-   Shift-Select and Control-Shift-Space adjust the selection to the current position of the
    insertion cursor, selecting from the anchor to the insertion cursor if there was
    no previous selection. 

-   F16  (Copy on many Sun workstations) or Control-c copies the
    selection in the widget to the clipboard, if there is a selection.

-   F20 (Cut on many Sun workstations) or Control-x copies the
    selection in the widget to the clipboard and deletes the selection.
    These keys have no effect if no text is selected.

-   F18 (Paste on many Sun workstations) or Control-v inserts the
    contents of the clipboard at the position of the insertion cursor.

-   Delete deletes the text selection, or the character to the right of the cursor
    if there is no text selection.

-   Backspace deletes the selection, or the character to the left of the cursor
    if there is no text selection.
</t>
<t tx="EKR.20040524104904.40">You can expand or contract a node by clicking in the tree view icon to the
left of the headline. The icon in the Qt gui matches the native OS's tree
view icon, i.e. for Mac's, a triangle pointing right or down; on Windows, a
square containing a plus or minus. Expanding a node shows its immediate
children; contracting a node hides all its children. The corresponding
commands are ``expand-node`` and ``contract-node``. For more convenient
navigation, there are ``expand-and-go-right`` (Alt-Right) and
``contract-or-go-up`` (Alt-Left) commands.

The ``expand-all`` command expands every node in the outline.
``contract-all`` (Alt-hypen) contracts every node in the outline. Both
commands are available in the Outline-&gt;Expand/Contract... submenu.
``contract-all`` In all but the smallest outlines, ``expand-all`` is rarely
used, and is does not have a key binding.
</t>
<t tx="EKR.20040524104904.41">Leo auto indents unless @nocolor is in effect.  Typing a newline
automatically inserts the same leading whitespace present on the previous line.

If Python is the present language, Leo inserts an additional tab if the previous
line ends with a colon.  When the smart_auto_indent setting is True, Leo uses Emacs-style
auto-indentation instead.  This style of auto-indent aligns newly created lines
with unmatched ( [ or { brackets in the previous line.
</t>
<t tx="EKR.20040524104904.43">You can mark nodes in several ways:

- With the ``mark`` (Ctrl-M), ``mark-changed-items``, or ``mark-subheads``
  commands. The ``mark`` command unmarks the selected node if it is already
  marked.

- With the Find or Change commands. The "mark changes" and "mark finds"
  options are initially cleared; you can change them with the
  ``toggle-find-mark-changes-option`` and ``toggle-find-mark-finds-option``
  commands. Using those commands will put focus in the Find tab of the log
  pane. When the Find tab is visible, Alt in combination with the
  underlined option character will put focus on that option, and then the
  space bar will toggle the option. You can also change the options by
  clicking on them in the Find tab.

The ``goto-next-marked`` command selects the next marked node.
</t>
<t tx="EKR.20040524104904.44">The ``move-outline-up`` (Ctrl-U or Alt-Shift-Up), ``move-outline-down``
(Ctrl-D or Alt-Shift-Down), ``move-outline-left`` (Ctrl-L or
Alt-Shift-Left), and ``move-outline-right`` (Ctrl-R or Alt-Shift-Right)
commands move the currently selected node. **Important**: When focus is in
the outline pane, you can move nodes whithout adding the Alt modifier.
Shift-Up moves the select node up, etc.

The ``promote`` (Ctrl-[) command makes all the children of
a node siblings of the node. The ``demote`` (Ctrl-]) command makes all following
siblings of a node children of the node.
</t>
<t tx="EKR.20040524104904.45">Double-clicking the icon box of a node whose headline has the form::

    @url &lt;any url&gt;

executes the URL in your default web browser.

Leo checks that the URL is valid before doing so. A valid URL is:

-   3 or more lowercase alphas
-   followed by one :
-   followed by one or more of:
-   ``$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~``
-   followed by one of: ``$%&amp;'()*+/0-9:=?@A-Z_a-z}~`` (i.e., comma, hyphen and open curly brace may not be the last character)

URL's should contain no spaces: use %20 to indicate spaces. You may use any
type of URL that your browser supports: http, mailto, ftp, file, etc.
</t>
<t tx="EKR.20040524104904.47">You can change the relative sizes of the outline and body panes by dragging the
splitter bar. The ``equal-sized-panes`` (Window-&gt;Equal Sized Panes) command resizes the panes so that each
fills half of the main window.
</t>
<t tx="EKR.20040524104904.48">Leo supports unlimited undo for all typing and all commands. The
'undo_granularity' setting controls the granularity of undo. There are four
possible values:

node
    Starts a new undo unit when typing moves to a new node.

line (default)
    Starts a new undo unit when typing moves to new line.

word
    Starts a new undo unit when typing starts a new word.

char (not recommended)
    Starts a new undo unit for each character typed.
    This wastes lots of computer memory.

Internally, setUndoTypingParams() calls recognizeStartOfTypingWord() to recognize the
start of words. Plugins can modify recognizeStartOfTypingWord(). It should
return True if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity. setUndoTypingParams() calls this
method only when the typing could possibly continue a previous word. In other
words, undo will work safely regardless of the value returned. See the actual
code for recognizeStartOfTypingWord() for more details.
</t>
<t tx="EKR.20040524104904.99"></t>
<t tx="EKR.20040601084317">Leo 4.2 alpha 3           June 1, 2004

This version fixes completes the essential features of version 4.2. All known
incompletions and bugs involving shared nodes and Leo's new file format have
been fixed. BTW, this version of Leo completes Leaps 201 and 202.

It should be safe to use this version for collaboration between Leo's
developers. I hereby encourage people to start using cvs for collaboration. Only
by doing so will we discover any possible problems.

The only item that must be completed before releasing 4.2 beta is fixing the Go
To Line Number command so it supports thin external files.

There are many known bugs in this version: most are minor bugs that have been
around for a long time. All known bugs will be fixed by the first release
candidate. See the to-do list in LeoPy.leo for the complete list.

The highlights of this version:

- All features of @file-thin are now complete and appear to be stable. - All
	.leo files in the distribution use @thin files where possible. - Leo ignores
	all directives within the range of the @all directive. - The @+middle and
	@-middle sentinels allow sections to be defined in any descendant node. -
	The @clone sentinel marks duplicate cloned siblings. - The beginnings of a
	new undo scheme are in place. - @thin, @nosent, @noref and @asis are
	abbreviations for @file-thin, @file-nosent, @file-noref and @file-asis. -
	Created new iterators that return lists of vnodes and tnodes, including
	iterators that remove all duplicates from those lists.
</t>
<t tx="EKR.20040601084317.102">Added u.registerUndoHandlers.

This will become largely unnecessary in the new undo scheme.  It's good to have though.
</t>
<t tx="EKR.20040601084317.142">When writing .leo files Leo now pickle's and hexlify's all data in the
v.unknownAttribute and t.unknownAttribute dictionaries. When reading .leo files
Leo does the reverse.

Leo ignores all elements in these dictionaries if some element can not be pickled.
</t>
<t tx="EKR.20040601084317.161">I have fallen madly in love with generators.
The following new iterators are defined with generators.

c.all_positions_iter
c.all_tnodes_iter
c.all_vnodes_iter
c.all_unique_tnodes_iter
c.all_unique_vnodes_iter

p.tnodes_iter
p.vnodes_iter
p.unique_tnodes_iter
p.unique_vnodes_iter

v.self_and__subtree_iter
v.self_and_unique_subtree_iter
</t>
<t tx="EKR.20040601084317.2"></t>
<t tx="EKR.20040601084317.99">This happened after write errors such as orphan nodes.
</t>
<t tx="EKR.20040601101118">If the copied node was an @thin or @file-thin node node only the root node was copied.
</t>
<t tx="EKR.20040601101227"></t>
<t tx="EKR.20040601101227.1"></t>
<t tx="EKR.20040601101430">This bug exists in 4.1 final. Leo did not properly show the found text in
headlines. The fix was in the code that redraws the screen, not in the
find/change code itself.
</t>
<t tx="EKR.20040601101430.1"></t>
<t tx="EKR.20040601101510"></t>
<t tx="EKR.20040601101547"></t>
<t tx="EKR.20040601102115"></t>
<t tx="EKR.20040601102703">The new scheme simply saves all information in one or more vnodes and their
associated tnodes. This is a general scheme that can be used by almost any
command.

At present only the u.saveTree method exists. Coming soon, u.saveNode,
u.saveNodeAndChildren and u.saveListOfNodes.
</t>
<t tx="EKR.20040601102808">See the to-do list in LeoPy.leo for a list of known bugs in this version.

None of these bugs is serious:  I consider this version to be suitable for day-to-day work.
</t>
<t tx="EKR.20040606104355">@nocolor

From: &lt;eltronic@juno.com&gt;
To: &lt;edreamleo@charter.net&gt;
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


&gt; found a fatal bug in Leo headline handling.
&gt; not sure if anyone reported before,
&gt; an oversize string can crash python 2.3.3
&gt; 
&gt; 
&gt; the text was about 4500 bytes. nothing but text.
&gt; opened the  leo again, copy a large page of text,
&gt; insert headline, paste, fatal error in python.
&gt; 
&gt; I have by mistake pasted whatever node xml was in 
&gt; the copy buffer into a headline w/o problem.
&gt; but that was just dumb luck. just verified,
&gt; had the node been large enough it crashes.
&gt; 
&gt; Leo 4.1 final, py2.3.3 win98
&gt; PYTHON caused an invalid page fault in
&gt; module TK84.DLL at 0167:1022b74f.
&gt; 
&gt; Leo 4.1 final, py2.2 win98
&gt; paste a 15k node copy into headline. no problem.
&gt; 
&gt; this is the first repeatable hard crash I've stumbled on
&gt; and thought it best to report it privately.
&gt; I can think of no advantage to allowing a headline 
&gt; of this size anyway. think of the tooltip that would create!
&gt; 
&gt; there are latent bugs in the selectall and delete from 
&gt; the edit menu related to headline as well on the todo list.
&gt; reported many times. 
&gt; covert destruction of the selected body text.
&gt; use of virtual events, with out proper focus to headline.
&gt; 
&gt; without myself being able to supply a patch, I'll guess,
&gt; the virtual event paste called can as well point 
&gt; to a function that checks the size before pasting.
&gt; or simply sets the headline directly with 
&gt; g.app.gui.getTextFromClipboard()[:1024]
&gt; 
&gt; 
&gt; e
</t>
<t tx="EKR.20040628095213">Leo 4.2 beta 2           July 5, 2004
Leo 4.2 beta 1           June 30, 2004

The highlights of 4.2 beta 2:

- Leo now writes the entire contents of @ignore'd @thin trees to the .leo file.
This change ensures that users can create and remove @ignore directives without
any chance of losing data inadvertently.

- Leo now saves and restores marks and the expansion state of nodes in @thin trees.

- Leo marks @thin nodes as dirty whenever they become "newly unignored", i.e.,
when an @thin node no longer falls in the range of an @ignore directive.

Beta 1 completes all fundamental work in the 4.2 code base. All essential code
is complete. Dozens of bugs have been fixed since the Alpha 3 release about a
month ago.

Known bugs in 4.2 beta 2:

- Not all plugins work correctly.
- Some plugins leak memory very slightly.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

Other features of 4.2:

- Leo is now much more friendly to using spaces instead of tabs.
- The Execute Script command reports erroneous lines more clearly.
- The usual assortment of bug features and minor features.

Coming soon in 4.2:

- Perfect Import will guarantee that Leo imports file perfectly.
- @import will allow you to study files using Leo without changing those files.
</t>
<t tx="EKR.20040628095213.109">http://sourceforge.net/forum/message.php?msg_id=2429098

The Leo icon can eliminate the need for the word Leo.

What I did:

- Eliminate Leo in name of Find panel.
- Derived leoTkinterPrefs from leoTkinterDialog: creates icon.
- Derived leoComparePanel from leoTkinterDialog: creates icon.
- Eliminated the -t option when opening Idle: the idle window is now called "Python Shell"
</t>
<t tx="EKR.20040628095213.110">- Added @language html when importing ".htm" and ".html" files.
- Added @nocolor when importing ".txt" and ".text" files
</t>
<t tx="EKR.20040628095213.113">When in headline, the Select All command selected the body text.
</t>
<t tx="EKR.20040628095213.121">- idle_body_key must call g.scanDirectives in order to support @tab_width.
	- This must be done for tabs and newlines.

- Fixed bug in g.scanDirectives that was rejecting negative tabwidth values.
	- This bug did not exist in the other versions of scanDirectives.

- With a negative tabwidth, a backspace now computes what spaces are equivalent
to a tab and delete all of those. This is easy to do!
</t>
<t tx="EKR.20040628095213.143"></t>
<t tx="EKR.20040628095213.160"></t>
<t tx="EKR.20040628095213.192"></t>
<t tx="EKR.20040628095213.197">doc\leoUsersGuide.txt
doc\leoFAQ.txt
doc\leoLeaps.txt
</t>
<t tx="EKR.20040628095213.198">The old code used at c.tab_width.  It should also look for @tabwidth directives.

This was not good when @tabwidth -4 was in effect.
</t>
<t tx="EKR.20040628095213.202">atFile.scanHeader was not handling -encoding fields properly.
</t>
<t tx="EKR.20040628095213.213"></t>
<t tx="EKR.20040628095213.225"></t>
<t tx="EKR.20040628095213.23">@color

Added the following hooks:

tag argument                                               keys in keywords
(hook name)           overrides    when called           dictionary argument
---------             ---------    -----------           -------------------

"draw-outline-box"       yes   start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"      yes   start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"      yes   start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"  yes   start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"       yes   start of tree.drawTree    tree,p,v,x,y,h,level,hoistFlag (note 6)
</t>
<t tx="EKR.20040628095213.246">Namespace not handled very well.
</t>
<t tx="EKR.20040628095213.264"></t>
<t tx="EKR.20040628095213.269"></t>
<t tx="EKR.20040628095213.279">I inserted "import time", and while I was at it I improved the error checking.
</t>
<t tx="EKR.20040628095213.282">- By default, finishPaste command reassigns all indices in copied nodes.
- Created pasteOutlineRetainingClones.
- Added reassignIndices arg to pasteOutline, getLeoOutline and finishPaste.
- Added &lt;&lt; recreate tnodesDict &gt;&gt; in getLeoOutline.
- Simplified getTnode slightly: the "if t" code is the same for both kinds of reads.
</t>
<t tx="EKR.20040628095213.297">The code now limits what can be pasted to a maximum of one line or a about 250 characters.
</t>
<t tx="EKR.20040628095213.3">- Leo calls g.enableIdleTimeHook at end of startup code.
	- This means that g.idleTimeHookHandler gets called periodically, even if no hooks have been defined.
	- g.enableIdleTime hook now calls g.app.gui.setIdleTimeHook at most once.

- app.forceShutdown now calls "end1" hook before calling app.finishQuit.
	- This ensures that the "end1" hook always gets called once.
	- app.finishQuit calls doHook("end1",...) only if it hasn't been called before.
		- This isn't necessary, but it makes traces in doHook less confusing.

- idleTimeHookHandler now calls the idle-time hook for all open windows.
	- So having multiple windows open should not affect idle-time hooks.

** Warning: new convention required to workaround apparent Tk problems.
	- "idle" hooks should return if g.app.killed is True.
</t>
<t tx="EKR.20040628095213.308"></t>
<t tx="EKR.20040628095213.311">@nocolor

- Leo now uses True and False everywhere instead of true and false.

- All of Leo's code uses spaces instead of tabs for indentation.
</t>
<t tx="EKR.20040628095213.312"></t>
<t tx="EKR.20040628095213.314"></t>
<t tx="EKR.20040628095213.324">- Set removeTrailing to True unless ch is a newline.

This allows Alt-f to work properly.

- Return "break" after the "final" text has been computed if nothing has changed.

This suppresses spurious newlines.

A new idea:  Make sure the text _does_ have a newline at all times.  I'm not sure this will work...

- ALWAYS set the text in select.  This prevents some weird problems with trailing newlines.
</t>
<t tx="EKR.20040628095213.334">- The string passed to exec now includes sentinels.

goToLineNumber needs sentinels to work properly.

- es_exception now gets the error line number from the traceback.

- Added new keyword arguments to goToLineNumber.

- Created goToScriptLineNumber, which just calls goToLineNumber.
</t>
<t tx="EKR.20040628095213.346">Hitting return in middle of a headline didn't work.
</t>
<t tx="EKR.20040628095213.348"></t>
<t tx="EKR.20040628095213.354"></t>
<t tx="EKR.20040628095213.366"></t>
<t tx="EKR.20040628095213.368"></t>
<t tx="EKR.20040628095213.377">Changed getVnode so it checks for v = None after calling getExistingVnode.  Creating the node seems to work in this case: I wouldn't bet my life that it works in all cases.
</t>
<t tx="EKR.20040628095213.391">- Added toString to most write methods.
- Retained scriptFile option for compatibility with plugins.
</t>
<t tx="EKR.20040628095213.404"></t>
<t tx="EKR.20040628095213.407"></t>
<t tx="EKR.20040628095213.408"></t>
<t tx="EKR.20040628095213.412"></t>
<t tx="EKR.20040628095213.425"></t>
<t tx="EKR.20040628095213.442">This only happened after previous write error.

The fix was to init self.errors in openWriteFile.

The whole atFile logic is pretty gruesome.  It's got to be cleaned up.
</t>
<t tx="EKR.20040628095213.444">- Allow indented @all.
    - Changed to g.is_special
    - Changed leoColor.doAtKeyword

- Fixed bug in is_special that broke p.isAtAllNode.
</t>
<t tx="EKR.20040628095213.485">There was a small hole in the format of external files. Leo assumed that comment
delimiters do not change within any particular external file. This assumption is
not necessarily true in files like leoProjects.txt.

What I did:

- putDirective and readDirective now check for @langauge and @comment, and
change comment delims appropriately.

This is slightly dubious: after all, an @langauge directive in the middle of
most external files will cause havoc. However, one could say that this is the
users problem :-)

BTW, this doesn't really solve all problems in @all trees: Leo can still get
mightily confused about comment delims if the user doesn't put proper @language
directives in @all trees.
</t>
<t tx="EKR.20040628095213.490">readEndNode uses the existing tempBodyString attribute to determine if the body text has changed.  If so, we mark the tnode dirty.  The code in 

top_df.read.&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;

propagates the dirty marks to all ancestor @file nodes.  This can't be done in readEndNode because no positions are available at that time.
</t>
<t tx="EKR.20040628095213.493"></t>
<t tx="EKR.20040628095213.499"></t>
<t tx="EKR.20040628095213.501">Leo now writes t.unknownAttributes to the .leo file when writing the &lt;v&gt; element
corresponding to the root of an @thin tree. Leo will do this by writing a new
xml attribute, descendentTnodeUnknownAttributes, in &lt;v&gt; element.

Leo will only write t.unknownAttributes, not v.unknownAttributes. This is
because only tnodes have gnx's in thin external files. In effect, vnodes are
anonymous. We could attempt to get around this by identifying vnodes by their
corresponding tnodes, but that's not a general solution and it is, in effect,
equivalent to writing only t.unknownAttributes. This being so, it seems
pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. As I've stated in the past, this won't do if,
for example, a plugin is trying create an arbitrary directed graph between
vnodes. In that case, the plugin should confine itself to @file trees, or just
vnodes in .leo files, for that matter.
</t>
<t tx="EKR.20040628095213.512">The problem was setting endSentinelComment to None instead of "" in readDirective.

The code is pretty fragile; it should handle either None or "", but in fact it requires "".
</t>
<t tx="EKR.20040628095213.513"></t>
<t tx="EKR.20040628095213.52"></t>
<t tx="EKR.20040628095213.56"></t>
<t tx="EKR.20040628095213.60">Added support for RapidQ, css, shell scripts and PHP.
</t>
<t tx="EKR.20040628100535">@killcolor
</t>
<t tx="EKR.20040628100535.1"></t>
<t tx="TL.20080804095315.1"></t>
<t tx="TL.20080804095315.2">###################
Using Vim with Leo
###################

This chapter discusses these topics:

- How to enable and use Leo's new vim-emulation mode.
- How to import and export vim's .otl files.
- How to install and use stand-alone vim-like bindings.

.. contents::
    :depth: 3
</t>
<t tx="TL.20080804095315.4">Place a copy of the "@keys Vim bindings" node and its sub-nodes,
located in the leoSettings.leo file, under the "@settings" node
in the myLeoSettings.leo file

The same procedure is performed to update to a new version.

Note: Place any local customized key bindings in a separate
"@keys My Vi" node in the myLeoSettings.leo file to prevent
them from being overwritten when updating to a new version.
</t>
<t tx="TL.20080804095315.5">The following commands are always available.

State change commands::

    i           Change state to insert from command state
    Esc         Change state to command from insert state
    Ctrl-[      Same as ESC

Save/Exit/Quite commands::

    :e          Revert
    :w&lt;return&gt;  Save '.leo' file
    :wq&lt;return&gt; Save '.leo' file and quit Leo
    :q&lt;return&gt;  Quit Leo   (Leo will prompt if file not saved)
    ZZ          Save leo file and exit

Undo/Redo commands::

    u           Undo previous command
    Ctrl-r      Redo previous command


Search options::

    Ctrl-/      Prompt for option to change
                Options:
                    a   Search all nodes (also &lt;cr&gt; key)
                    h   Toggle headline search
                    b   Toggle body search
                    m   Toggle marking of nodes (specify sub-option)
                        f   Toggle marking of nodes with found text
                        c   Toggle marking of nodes with changed text
                            (only supported with 'Alt-/', 'Alt-p')
                    r   Toggle regex matches
                        ('/' key turns off regex. 'n' key uses regex if turned on)

    Note: Whether a search is limited to node's body or the node's sub-outline
          is determined by which pane has focus when search text specified.
          (See "Find text commands:" sub-sections in Outline/Body Pane sections)

Miscellaneous commands::

    Tab         Toggle focus between Outline and Body pane
    =           Simulate double-click on current node's icon box
    Alt-G       Go to specified line number (relative to external file)
    Ctrl-:      Enter Leo's command line
</t>
<t tx="TL.20080804095315.6">Move cursor commands::

    h           Go back 1 character
       LtArrow  Mapped to "h" for convenience
    j           Go down 1 line
       DnArrow  Mapped to "j" for convenience
    k           Go up 1 line
       UpArrow  Mapped to "k" for convenience
    l           Go forward 1 character
       RtArrow  Mapped to "l" for convenience

    w           Go to beginning of next word
       W        Mapped to "w" until "stop after blank characters" supported
    b           Go to beginning of current/previous word
       B        Mapped to "b" until "stop at blank character" supported
    e           Go to end of current/next word
       E        Mapped to "e" until "stop at blank character" supported

    Note: Move by word commands stop at non-alpha characters

    |           Goto beginning of current line
    ^           Go to 1st non-blank character on current line
    $           Goto end of current line

    %           Go to matching bracket

    (           Go to beginning of current sentence
    )           Go to beginning of next sentence
    {           Go to beginning of current paragraph
    }           Go to beginning of next paragraph

    gg          Go to the first line (Cursor at column 1)
    G           Go to the last line  (Cursor at column 1)

Mark commands::

    m&lt;label&gt;    Assign cursor location to a single character label
    `&lt;label&gt;    Go to location associated with label

      Note: Only character count is tracked. Any inserts or deletes will change mark.
          Mark's are not node specific; `&lt;label&gt; will go to location in current node.

Select commands::

    Ctrl-v      Toggle text select mode (Vim's "visual" mode)
       V        Mapped to 'Ctrl-v' for convenience (Should toggle line select)

Insert/substitute commands::

    a           Insert at cursor
    i           Mapped to "a" until "cursor on a character" supported
    A           Insert at end of line
    I           Insert at first non-space
    o           Open new line below current line
    O           Open new line above current line
    R           Overwrite text
    s           Substitute character (Delete character, enter insert state)
    S           Substitute line (Delete line, enter insert state)

Change commands::

    C           Change to end of line
    cc          Change all of current line
    cw          Change to end of word
    cb          Change to beginning of word
    c)          Delete to end of sentence
    c(          Delete to beginning of sentence
    c}          Delete to end of paragraph
    c{          Delete to beginning of paragraph
    c%          Change from current bracket type its matching bracket type
    ct&lt;char&gt;    Selects forward to &lt;char&gt; (follow with 'i' to change selection)
    cT&lt;char&gt;    Selects backward to &lt;char&gt; (follow with 'i' to change selection)
    c&lt;cr&gt;       Change selected text

Delete commands::

    x           Delete next character
    delete      Delete next character
    D           Delete to the end of the current line
    dd          Delete current line
    dw          Delete to end of word
    db          Delete to beginning of word
    d)          Delete to end of sentence
    d(          Delete to beginning of sentence
    d}          Delete to end of paragraph
    d{          Delete to start of paragraph
    d%          Delete from current bracket type to its apposing bracket
    dt&lt;ch&gt;      Delete to character (not limited to current line)
    d&lt;cr&gt;       Delete selected text

    J           Join next line to end of current line (deletes carriage return)

Yank text commands::

    Y           Yank to end of line
    yy          Yank line
    yw          Yank to beginning of next word
    yb          Yank to beginning of current word
    y)          Yank to end of sentence
    y(          Yank to beginning of sentence
    y}          Yank to end of paragraph
    y{          Yank to beginning of paragraph
    y%          Yank from current bracket type to its opposing bracket
    yt&lt;char&gt;    Select forward to &lt;char&gt;  (use 'y&lt;cr&gt;' to yank selection)
    yT&lt;char&gt;    Select backward to &lt;char&gt; (use 'y&lt;cr&gt;' to yank selection)
    y&lt;cr&gt;       Yank selected text (Vim uses 'y' in visual mode)

Find character commands::

    f           Find next occurrence of user specified character
    F           Find previous occurrence of user specified character

Find text commands::

    /           Search forward within current node's body text
    ?           Search backward within current node's body text
    n           Find next (same scope, same direction)
    N           Find next (same scope, other direction)

    Note: See "Search options" in General Commands section to change options.

Replace [and find next] commands::

    Commands using Paste buffer (clipboard)
    P           Paste text before cursor.
    p           Mapped to "P" until character based cursor supported.
    Ctrl-p      Paste then find next match
                Note: Use 'pn' instead of 'Ctrl-p' in headlines (Leo limitation)
                      Command will continue to paste when match no longer found.

    Commands prompting for replace string
    Note: Scope and direction taken from last use of '/','?' or 'Ctrl-/'(scope only)
    Alt-/       Prompt for search &amp; replace string
    Alt-p       Replace then search (use after Alt-/)
                Note: Works in headlines and body panes.
                      Doesn't paste unless last search found a match.

Indent/Unindent line commands::

    &gt;&gt;          Indent the current line
    &gt;)          Indent to the end of sentence
    &gt;(          Indent to the beginning of sentence
    &gt;}          Indent to the end of paragraph
    &gt;{          Indent to the beginning of paragraph
    &gt;g          Indent to the start of buffer
    &gt;G          Indent to the end of buffer

    &lt;&gt;          Unindent the current line
    &lt;)          Unindent to the end of sentence
    &lt;(          Unindent to the beginning of sentence
    &lt;}          Unindent to the end of paragraph
    &lt;{          Unindent to the beginning of paragraph
    &lt;g          Unindent to the start of buffer
    &lt;G          Unindent to the end of buffer

Format commands::

    gqap        Split long line into separate lines
    gwap        Split long line into separate lines
    gqq         Split long line into separate lines
    gww         Split long line into separate lines

    Note: 'gwap' and 'gww' should not move cursor but do.

Scroll commands::

    Ctrl-b      Scroll text up by pane's height
    Ctrl-f      Scroll text down by pane's height
       Ctrl-y   Mapped to Ctrl-b until scroll up one line is supported
       Ctrl-e   Mapped to Ctrl-f until scroll down one line is supported
       Ctrl-u   Mapped to Ctrl-b until scroll up half a pane height is supported
       Ctrl-d   Mapped to Ctrl-f until scroll down half a pane height is supported

Window commands::

    Ctrl-w s    Open another view into current node's body (Vim: Split window)
       Ctrl-w n Mapped to "Ctrl-w s" (Vim: New buffer in split window)
    Ctrl-w w    Switch to next view (Vim: Go to up/left window w/wrapping)
       Ctrl-w p Mapped to "Ctrl-w w" (Vim: Cycle through windows)
       Ctrl-w k Mapped to "Ctrl-w w" (Vim: Go to window above current window)
       Ctrl-w j Mapped to "Ctrl-w w" (Vim: Go to window below current window)
    Ctrl-w c    Close current view in body pane (Vim: Close current window)
       Ctrl-w q Mapped to "Ctrl-w c" (Vim: Quit current window)

Node commands::

    Go to another node while focus remains in the body pane.
    Ctrl-j      Go to next visible node
    Ctrl-k      Go to previous visible node
    Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level
    Ctrl-l      Display sub-nodes or, if displayed, go down 1 level
       Ctrl-DnArrow    Mapped to "Ctrl-j" for convenience
       Ctrl-UpArrow    Mapped to "Ctrl-k" for convenience
       Ctrl-LtArrow    Mapped to "Ctrl-h" for convenience
       Ctrl-RtArrow    Mapped to "Ctrl-l" for convenience
</t>
<t tx="TL.20080804095315.7">The following commands are supported when in a headline's command mode.

State change commands::

    Ctrl-i      Change state to command from grayed state
    return      Change state to command from insert state
    Ctrl-]      Change state to grayed from command state

Cursor movement commands::

    h           Go to previous character
       LtArrow  Mapped to 'h' for convenience
    l           Go to next character
       RtArrow  Mapped to "l" for convenience

    Note: 'j' and 'k' will scroll the buffer contents up and down;
          leaving the focus in the outline pane.

    w           Go to beginning of next word
       W        Mapped to "w" until "stop after blank characters" supported
    b           Go to beginning of current/previous word
       B        Mapped to "b" until "stop at blank character" supported
    e           Go to end of current/next word
       E        Mapped to "e" until "stop at blank character" supported

    Note: Move by word commands stop at non-alpha characters

    |           Go to beginning of line
    ^           Go to beginning of line
    $           Go to end of line

    %           Go to matching bracket

Edit commands::

    x           Delete next character
    delete      Delete next character
    dd          kill-line

    s           Select current character

    v           Toggle text select mode (issue cursor movement commands)
    y&lt;return&gt;   Yank selected text

    C           Select to end of line (follow with 'i' to change text)
    cc          Delete line (follow with 'i' to change text)

    D           Select to end of line (follow with 'x' to delete text)
    dd          Delete line

    Y           Select to end of line (follow with 'y&lt;return&gt;' to yank text)
    yy          Select line (follow with 'y&lt;return&gt;' to yank text)

Find character commands::

    f           Find next occurrence of user specified character
    F           Find previous occurrence of user specified character

Find text commands::

    /           Search forward within current node and its subnodes
    n           Find next (same scope, same direction)
    N           Find next (same scope, other direction)

    Note: See "Search options" section above to change options using 'Ctrl-/'

Replace [and find next] commands::

    Commands that use Paste buffer (clipboard)
    Note: Paste-then-search command not possible in headlines (Use 'pn')
    P           Paste text before cursor.
    p           Mapped to "P" until character based cursor supported.

    Commands that prompt for the replace string
    Alt-/       Prompt for search &amp; replace string
    Alt-p       Replace then search (use after Alt-/)
                Note: Works in headlines and body panes.
                      Doesn't paste unless last search found a match.

Node edit commands::

    o           Insert node after current node

    Ctrl-x      Delete current node
    Ctrl-c      Yank current node
    Ctrl-v      Paste current node

Node goto commands::

    G           Go to the outline's last node
    gg          Go to the outline's first node

    Ctrl-j      Go to next visible node
    Ctrl-k      Go to previous visible node
    Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level
    Ctrl-l      Display sub-nodes or, if displayed, go down 1 level

       DnArrow  Mapped to "Ctrl-j" for convenience
       UpArrow  Mapped to "Ctrl-k" for convenience

       Ctrl-DnArrow Mapped to "Ctrl-j" for convenience
       Ctrl-UpArrow Mapped to "Ctrl-k" for convenience
       Ctrl-LtArrow Mapped to "Ctrl-h" for convenience
       Ctrl-RtArrow Mapped to "Ctrl-l" for convenience

Node move commands::

    Ctrl-Shift-k    Move node down
    Ctrl-Shift-h    Move node left
    Ctrl-Shift-l    Move node right
    Ctrl-Shift-j    Move node up

       Ctrl-Shift-DnArrow    Mapped to "Ctrl-Shift-k" for convenience
       Ctrl-Shift-LtArrow    Mapped to "Ctrl-Shift-h" for convenience
       Ctrl-Shift-RtArrow    Mapped to "Ctrl-Shift-l" for convenience
       Ctrl-Shift-UpArrow    Mapped to "Ctrl-Shift-j" for convenience

Node mark commands::

    m           Toggle node mark
    Ctrl-m      Go to next marked node
    Alt-m       Clear all marked nodes

Node clone commands::

    t           Clone the current node (transclude)
    Ctrl-t      Go to next clone of current node

Outline scroll commands::

   Ctrl-y       Scroll outline up one line
   Ctrl-e       scroll outline down one line
   Ctrl-u       Scroll outline up one half page
   Ctrl-d       scroll outline down one half page
   Ctrl-b       Scroll outline up one page
   Ctrl-f       scroll outline down one page

</t>
<t tx="TL.20080804095315.8">Notable missing editing commands::

    t&lt;char&gt;     Move cursor to character before specified character
    r           Replace a single character with a single character
    0           Go to 1st column in current line (Use '|' instead)
    bksp        Move one character to the left
    ~           Toggle character's case
    .           Repeat last editing command
    ;           Repeat last cursor movement command
    &lt;n&gt;&lt;cmd&gt;    Perform command 'n' number of times
    &lt;cmd&gt;&lt;n&gt;&lt;object&gt;    Perform the command on the n'th or up to the n'th object

Notable missing body pane commands::

    &lt;num&gt;G      Go to specified line number
    z&lt;movement&gt; Slide buffer to put current line at top/middle/bottom of pane
    '&lt;command&gt;  Go to line of last edit, jump, ...
    `&lt;command&gt;  Go to character of last edit, jump, ...
</t>
<t tx="TL.20080804095315.9">If you use the open-with command to open a node text in Vim and your
Vim's "tag" file refers to external files then there is a risk that a
external file that is initially displayed via the "tag" command" in
Vim is accidentally edited and saved from the external Vim editor
while your Leo session still contains the external file's original
text that may later recreate the original external file during a Leo
save operation (overwriting the changes saved from the Vim editor).

To prevent this problem, modifications to external files can be avoided by using
Vim's "modeline" feature to disable editing of external files.

Vim's "modeline" feature scans each loaded buffer for text at the top or bottom
of the file containing " vim:" followed by a series of Vim options. The text is
usually embedded within a comment. The following example prevents modifications
to a buffer in a Python file::

    # vim:noma (A space is required between the '#' and "vim:noma")

If this line is placed in a separate Leo node at the top or bottom of the list
of nodes under a external file node (ex: @file) then any external file saved and
then later loaded into Vim will, by default, not be modifiable. If a derived
file does need to be edited then modifications can be re-enabled on a
file-by-file basis by issuing Vim's ":ma" command while viewing the derived
file.

The number of lines that Vim checks at the top and bottom of the buffer is
configurable. The following Vim command must be placed in the vimrc file to
allow for Leo's trailing sentinel lines::

    set modelines=8

Issue the ":help modeline" command within Vim for the more information about
modelines.
</t>
<t tx="davy.20141202225703.2">TODO with rst</t>
<t tx="davy.20141202225703.527">################
Leo’s Home Page
################

.. epigraph::

   Leo is a revolutionary step in the right direction for programming.

   -- Brian Takita

.. epigraph::

    Leo is the best IDE that I have had the pleasure to use. It has totally changed not only the way that I program, but also the way that I store and organize all of the information that I need for the job that I do.
    
    -- Ian Mulvany 

.. epigraph::

    When first I opened Leo, it was out of curiosity. But having used it, I'll never go back. They'll have to pry Leo out of my cold, dead fingers!
    
    -- Travers A. Hough 

Leo is a `PIM &lt;https://en.wikipedia.org/wiki/Personal_information_manager&gt;`_, `IDE &lt;https://en.wikipedia.org/wiki/Integrated_development_environment&gt;`_ and outliner that **accelerates the work flow** of programmers, authors and web designers. Leo's unique features **organize data in a revolutionary way**:

* Leo outlines are views on an underlying `graph &lt;https://en.wikipedia.org/wiki/Directed_acyclic_graph&gt;`_.

* Outline nodes can reside in **many** places within a single outline.

* Leo is fully scriptable in `Python`_.

* Leo scripts have full access to Leo's source code and all outline data.

* :doc:`Outline-oriented &lt;tutorial-programming&gt;` markup generates `external files &lt;tutorial-basics.html#creating-external-files-with-file-and-all&gt;`_ from outlines.

|Learn why Leo is special.|_

|Learn about Leo in two hours.|_

.. |Learn why Leo is special.| replace:: **Learn why Leo is special.**
.. _Learn why Leo is special.: preliminaries.html#preface

.. |Learn about Leo in two hours.|  replace:: **Learn about Leo in two hours.**
.. _Learn about Leo in two hours.:  tutorial.html

Furthermore:

* Leo is `Open Software &lt;http://www.opensource.org/&gt;`_ , written in pure `Python`_.

* Leo a `PyQt &lt;http://www.riverbankcomputing.co.uk/software/pyqt/intro&gt;`_ app that runs on Linux, Windows and MacOS.

* Leo works well with `emacs &lt;http://www.gnu.org/software/emacs/&gt;`_ , `xemacs &lt;http://www.xemacs.org/&gt;`_, `vim &lt;http://www.vim.org/&gt;`_, and `ipython &lt;http://ipython.org/&gt;`_.

**We welcome your questions and comments!**

Ask us anything at the medium traffic leo-editor  `GroupGoogle &lt;http://groups.google.com/group/leo-editor&gt;`_.

If you use Leo, please `send us a postcard &lt;http://groups.google.com/group/leo-editor&gt;`_, telling how you use Leo. Thanks !

Here is a slightly reduced screenshot of Leo's main window:

|renderSVGsrc|

.. _Python: http://sphinx.pocoo.org

.. |renderSVGsrc|   image:: /images/screen-shots/render-svg-sources.png</t>
<t tx="davy.20141205111505.3"></t>
<t tx="davy.20141207133842.11">Templates for the sidebar :




</t>
<t tx="davy.20141207133842.7"></t>
<t tx="davy.20141207133842.8">##################
API Documentation
##################


.. autosummary::
   :toctree:
   
   leo.core.leoApp.LeoApp
   leo.core.leoApp.LeoApp.createDefaultGui
</t>
<t tx="davy.20141208113259.3">@language python
"""Make html for all @rst childs of "sources" node"""
&lt;&lt; import &gt;&gt;
&lt;&lt; paths &gt;&gt;
&lt;&lt; config &gt;&gt;
from leo.core.leoRst import RstCommands

rstcommands = RstCommands(c)

pos = c.find_h("sources")[0]

if pos:
    test=rstcommands.processTopTree(pos)
    g.es(test)
else:
    g.es('No "sources" node found',color='red')

g.redirectStderr()
g.redirectStdout()
@others
make(builder='html',outdir=htmldir,rstfile=None,freshenv=False,buildAllFiles=False)</t>
<t tx="davy.20141208121156.278"># Options that are usually defined whithin **conf.py**

# Please, follow the rule :  ** one option = one line **

# Be carefull, do **not** introduce new lines in the middle of an option !
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# myGoodsetting = ['this', 'is', 'good']

# myWrongSetting = [
#                                   'this',
#                                   'is',
#                                   'not',
#                                   'good !'
#                                   ]</t>
<t tx="davy.20141208130053.14"># A list of paths that contain custom static files (such as style sheets or script files).
html_static_path = [g.os_path_join(srcdir,'static')]</t>
<t tx="davy.20141208130053.28">#  A dictionary of options that influence the look and feel of the selected theme.  These are theme-specific.
# Here are options for the "default" theme
html_theme_options = {'collapsiblesidebar': True,'sidebarbgcolor': "#fffdbc",'sidebartextcolor': 'black','sidebarlinkcolor':'black','bgcolor': "#fffbdc"}
</t>
<t tx="davy.20141208130053.29"># The style sheet to use for HTML pages.
html_style = 'leo.css'</t>
<t tx="davy.20141208130053.3">extensions= [ 'sphinx.ext.autodoc','sphinx.ext.autosummary']

#         'sphinx.ext.doctest',
#         'sphinx.ext.intersphinx',
#         'sphinx.ext.todo',
#         'sphinx.ext.coverage',
#         'sphinx.ext.viewcode'</t>
<t tx="davy.20141208130053.30">html_logo = 'static/Leo4-80-border.jpg'</t>
<t tx="davy.20141208130053.39">#  Custom sidebar templates, must be a dictionary that maps document names to template names.
#  Buildin temlplate are default one ['localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html'] plus 'globaltoc.html'
html_sidebars = {'**':['globaltoc.html','searchbox.html','flattrSidebar.html'],  'index':['leoHomeSidebar.html','searchbox.html','flattrSidebar.html']}
</t>
<t tx="davy.20141208130053.4"># The documentation project name
project='Leo'</t>
<t tx="davy.20141208130053.5"># A copyright statement in the style ``'2008, Author Name'``.
copyright = '2014, Edward K. Ream'
</t>
<t tx="davy.20141208130053.52"></t>
<t tx="davy.20141208130053.53"></t>
<t tx="davy.20141208130053.6"># The major project version, used as the replacement for ``|version|``.  For example, for the Python documentation, this may be something like ``2.6``.
version = '5.0'
</t>
<t tx="davy.20141208130053.7">#The full project version, used as the replacement for ``|release|`` and e.g. in the HTML templates.  
#For example, for the Python documentation, this may be something like ``2.6.0rc1``.
#If you don't need the separation provided between `version` and `release`, just set them both to the same value.
release = '5.0'
</t>
<t tx="davy.20141208130053.8"># A list of paths that contain extra templates (or templates that overwrite builtin/theme-specific templates).
# This is especially usefull for our custom sidebar and autosummary templates 
templates_path=[g.os_path_join(srcdir,'templates')]

</t>
<t tx="davy.20141208130053.9"># These options influence HTML as well as HTML Help output, and other builders that use Sphinx' HTMLWriter class.

</t>
<t tx="davy.20141208134720.10"></t>
<t tx="davy.20141208134720.11"></t>
<t tx="davy.20141208134720.12"></t>
<t tx="davy.20141208134720.13"></t>
<t tx="davy.20141208134720.14"></t>
<t tx="davy.20141208134720.15">def make(builder='html',outdir=g.os_path_join('build','html'),rstfile=None,freshenv=False,buildAllFiles=False):
    """
    Function derived from sphinx-build command.
    Build all files for a given `builder`.
    Optionally build only a given `rstfile`
    Set `freshenv` to True to rebuild the entire toctree.
    Set `buildAllFiles` to True to rebuild every files (otherwise, rebuild only changed ones)
    """
    

    #Verify if rstfile exist if given
    if rstfile:
      if not g.os_path_isfile(rstfile[0]):
        g.es('Error: Cannot find file %r.' % rstfile,color='red')

    # Message verbosity handling
    status = sys.stdout
    warning = sys.stderr
    error = sys.stderr

    # Remove unsupported colorized terminal
    nocolor() 

    # Do not display stdout
    if quiet:
        status = None

    # Do not display stdout and warnings
    if veryQuiet:
        status = warning = None

    # Write warnings and error to file ...
    if warningToFile:
        try:
            warnfp = open(warningToFile, 'w')
        except Exception as exc:
            g.es('Error: Cannot open warning file %r: %s' %
                  (warningToFile, exc), color='red')
        warning = Tee(warning, warnfp)
        error = warning
    
    app = None
    try:
        app = Sphinx(srcdir, confdir, outdir, doctreedir, builder, confoverrides, status, warning, freshenv,                    warningiserror, tags, verbosity, jobs)
                   
        app.build(buildAllFiles, rstfile)
    
        return app.statuscode
               
    except (Exception, KeyboardInterrupt) as err:
        if PDB:
            import pdb
            print(red('Exception occurred while building, starting debugger:'),
                  file=error)
            traceback.print_exc()
            pdb.post_mortem(sys.exc_info()[2])
        else:
            print(file=error)
            if verbosity or Traceback:
                traceback.print_exc(None, error)
                print(file=error)
            if isinstance(err, KeyboardInterrupt):
                print('interrupted!', file=error)
            elif isinstance(err, SystemMessage):
                print(red('reST markup error:'), file=error)
                print(terminal_safe(err.args[0]), file=error)
            elif isinstance(err, SphinxError):
                print(red('%s:' % err.category), file=error)
                print(terminal_safe(text_type(err)), file=error)
            elif isinstance(err, UnicodeError):
                print(red('Encoding error:'), file=error)
                print(terminal_safe(text_type(err)), file=error)
                tbpath = save_traceback(app)
                print(red('The full traceback has been saved in %s, if you want '
                          'to report the issue to the developers.' % tbpath),
                      file=error)
            else:
                print(red('Exception occurred:'), file=error)
                print(format_exception_cut_frames().rstrip(), file=error)
                tbpath = save_traceback(app)
                print(red('The full traceback has been saved in %s, if you '
                          'want to report the issue to the developers.' % tbpath),
                      file=error)
                print('Please also report this if it was a user error, so '
                      'that a better error message can be provided next time.',
                      file=error)
                print('A bug report can be filed in the tracker at '
                      '&lt;https://bitbucket.org/birkenfeld/sphinx/issues/&gt;. Thanks!',
                      file=error)
            return 1
</t>
<t tx="davy.20141208134720.2">
# Set working dir
os.chdir(g.os_path_dirname(c.fileName()))

# Path to Doc sources
srcdir = g.os_path_abspath('sources')
    
# Check files and directories
if not g.os_path_isdir(srcdir):
  g.es('Error: Cannot find source directory `%s\'.' % srcdir, color='red')
  
# Path to built Doc
outdir = g.os_path_abspath('build')

# Path to leo's html builds
htmldir = g.os_path_join(outdir,'html')

# Path to doctree cache 
doctreedir = g.os_path_join(outdir,'.doctrees')</t>
<t tx="davy.20141208134720.3"># We don't use a conf.py but a confoverrides dict
confdir = None

# Build a conf.py like dictionary from @data conf.py
confoverrides={}
for conf in c.config.getData('conf.py', strip_comments=True, strip_data=True):
  confoverrides[str(conf.split('=')[0].strip())]=eval(conf.split('=')[1])

# Get command line like options from @setting or set default
if c.config.getInt('jobs'):
  jobs = c.config.getInt('jobs')
else:
  jobs=1

if c.config.getData('tags'):
  tags = c.config.getData('tags')
else:
  tags = []

if c.config.getInt('verbosity'):
  verbosity = c.config.getInt('verbosity')
else:
  verbosity=0

if c.config.getBool('traceback'):
  Traceback = c.config.getBool('traceback')
else:
  Traceback=False

if c.config.getBool('quiet'):
  quiet = c.config.getBool('quiet')
else:
  quiet=False
  
if c.config.getBool('veryQuiet'):
  veryQuiet = c.config.getBool('veryQuiet')
else:
  veryQuiet=False

if c.config.getString('warningToFile'):
  warningToFile = c.config.getString('warningToFile')
else:
  warningToFile=False

if c.config.getBool('warningiserror'):
  warningiserror = c.config.getBool('warningiserror')
else:
  warningiserror=False
  
if c.config.getBool('pdb'):
  PDB = c.config.getBool('pdb')
else:
  PDB=False
</t>
<t tx="davy.20141208134720.4"># List of builders to append in Sphinx/Make... menu

#Make standalone HTML files
html

#Make HTML files named index.html in directories
dirhtml

#Make a single large HTML file
singlehtml

#Make pickle files
pickle

#Make JSON files
json

#Make HTML files and a HTML help project
htmlhelp

#Make HTML files and a qthelp project
qthelp

#Make HTML files and a Devhelp project
devhelp

#Make an epub
epub

#Make LaTeX files, you can set PAPER=a4 or PAPER=letter
latex

#Make LaTeX files and run them through pdflatex
latexpdf

#Make LaTeX files and run them through platex/dvipdfmx
latexpdfja

#Make text files
text

#Make manual pages
man

#Make Texinfo files
texinfo

#Make Texinfo files and run them through makeinfo
info

#Make PO message catalogs
gettext

#Make an overview of all changed/added/deprecated items
changes

#Make Docutils-native XML files
xml

#Make pseudoxml-XML files for display purposes
pseudoxml

#Check all external links for integrity
linkcheck

#Run all doctests embedded in the documentation (if enabled)
doctest
</t>
<t tx="davy.20141208134720.5"></t>
<t tx="davy.20141208134720.8"></t>
<t tx="davy.20141208134720.9"></t>
<t tx="davy.20141208151446.2">from __future__ import print_function

import os
import sys
import traceback
from sphinx.errors import SphinxError
from docutils.utils import SystemMessage
from sphinx.util.console import red, nocolor, color_terminal
from sphinx.application import Sphinx
from six import text_type, binary_type
from sphinx.util.pycompat import terminal_safe
from sphinx.util import Tee, format_exception_cut_frames, save_traceback
</t>
<t tx="davy.20141208151446.4">#  If true (and :confval:`html_copy_source` is true as well), links to the reST sources will be added to the sidebar.
#  The default is ``True``.
html_show_sourcelink = False

</t>
<t tx="davy.20141208151446.5"># If true, the reST sources are included in the HTML build as `_sources/{name}`.  
# The default is ``True``.
html_copy_source = False
</t>
<t tx="davy.20141208152655.2">@language python
"""Make html of current @rst node/tree"""
&lt;&lt; import &gt;&gt;
&lt;&lt; paths &gt;&gt;
&lt;&lt; config &gt;&gt;
@others

aList = c.rstCommands.rst3()
if aList:
    filename = aList[0].h.replace('@rst ','').strip()+'.rst'
    rstfile = g.os_path_join(srcdir,filename)
    if g.os_path_isfile(rstfile):
        g.redirectStderr()
        g.redirectStdout()
        make(builder='html',outdir=htmldir,rstfile=[rstfile ],freshenv=False,buildAllFiles=False)
    else:
        g.es('No file '+rstfile+ 'found', color='red')
    </t>
<t tx="davy.20141208152655.3">plugins_menu.py
contextmenu.py
leo_to_html.py
mod_scripting.py
nav_qt.py
quicksearch.py
stickynotes.py
todo.py
viewrendered.py
printing.py
rst3.py


# Alphabetical list of all Leo plugins.

# active_path.py
# add_directives.py
# at_folder.py
# at_produce.py
# at_view.py
# attrib_edit.py
# backlink.py
# bibtex.py
# bookmarks.py
# bzr_qcommands.py
# chapter_hoist.py
# codewisecompleter.py
# colorize_headlines.py
# contextmenu.py
# ctagscompleter.py
# cursesGui.py
# datenodes.py
# debugger_pudb.py
# detect_urls.py
# dragdropgoodies.py
# dtest.py
# dump_globals.py
# empty_leo_file.py
# enable_gc.py
# expfolder.py
# FileActions.py
# free_layout.py
# ftp.py
# geotag.py
# gitarchive.py
# graphcanvas.py
# import_cisco_config.py
# initinclass.py
# interact.py
# jinjarender.py
# leo_interface.py
# leo_pdf.py
# leo_to_html.py
# leo_to_rtf.py
# leocursor.py
# leofeeds.py
# leomail.py
# leomylyn.py
# leoOPML.py
# leoremote.py
# leoscreen.py
# lineNumbers.py
# macros.py
# maximizeNewWindows.py
# mime.py
# mnplugins.py
# mod_autosave.py
# mod_framesize.py
# mod_http.py
# mod_leo2ascd.py
# mod_read_dir_outline.py
# mod_scripting.py
# mod_speedups.py
# mod_tempfname.py
# mod_timestamp.py
# multifile.py
# nav_qt.py
# nested_splitter.py
# niceNosent.py
# nodeActions.py
# nodediff.py
# nodetags.py
# nodewatch.py
# notebook.py
# open_shell.py
# outline_export.py
# paste_as_headlines.py
# plugins_menu.py
# pluginsTest.py
# pretty_print.py
# projectwizard.py
# qt_quicksearch.py
# qtframecommands.py
# quickMove.py
# quicksearch.py
# quit_leo.py
# read_only_nodes.py
# redirect_to_log.py
# rss.py
# rst3.py
# run_nodes.py
# screen_capture.py
# screencast.py
# screenshots.py
# script_io_to_body.py
# scripts_menu.py
# setHomeDirectory.py
# sftp.py
# slideshow.py
# spydershell.py
# startfile.py
# stickynotes.py
# stickynotes_plus.py
# systray.py
# testRegisterCommand.py
# textnode.py
# todo.py
# tomboy_import.py
# trace_gc_plugin.py
# trace_keys.py
# trace_tags.py
# valuespace.py
# viewrendered.py
# vim.py
# wikiview.py
# word_count.py
# word_export.py
# xemacs.py
# xml_edit.py
# xsltWithNodes.py
# zenity_file_dialogs.py
</t>
<t tx="davy.20141208162909.10">
*  Go back to master ::

    git checkout master

*  Clone webpages as submodule ::

    rm -R doc/build/html
    git submodule add -b gh-pages git@github.com:leo-editor/leo-editor.git doc/build/html

* Add the submodule to master branch ::

    git add doc/build/html

* Commit the changes ::

    git commit -m 'Add website as a submodule'
    
</t>
<t tx="davy.20141208162909.11">See how to do it with 
cd build/html
git clone -b gh-pages --single-branch git@github.com:davy39/leo-editor.git .

http://davy39.github.io/leo-editor</t>
<t tx="davy.20141208162909.2"></t>
<t tx="davy.20141208162909.3">Of course sphinx is needed to perform the build :

  (sudo) pip install sphinx  

To publish via git on various platforms, we'll use dulwish pure python git implementation : https://github.com/jelmer/dulwich

Please, install the module ::

  (sudo) pip install dulwich  

</t>
<t tx="davy.20141208162909.4">* Go inside your git repository ::

    cd leo-editor

* Creates our branch, without any parents (it's an orphan!) ::

    git checkout --orphan gh-pages

*  Remove all files from the old working tree ::

    git rm -rf .
    rm '.gitignore'

* Add an empty file to disable jekyll an so be able to read _static files ::

    touch .nojekyll

*  Add .nojekyll to git ::

    git add .nojekyll

*  Commit the changes ::

    git commit -m "Initialize Github pages for Sphinx"

*  Push the changes ::

    git push origin gh-pages
</t>
<t tx="davy.20141208162909.8">Github is providing a static web hosting very convenient for sphinx powered websites.

There are two options for publishing :

 * One personal website : https://leo-editor.github.io/

 * One per project website : http://leo-editor.github.io/leo-editor, http://davy39.github.io/leo-editor

Apperently, leo-editor already use personal website for blogging.

So weither you move leo's blog to http://leo-editor.github.io/blog/

Or host Leo's website **as a project website**.

This is the option I'm gonna detail.

.. note::

Both solution allows to host your own domain name so you could redirect http://leo-editor.com to http://leo-editor.github.io

.. see::

https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/</t>
<t tx="davy.20141208162909.9"></t>
<t tx="davy.20141208214654.10">@language python
from leo.core.leoRst import RstCommands

rstcommands = RstCommands(c)

pos = c.find_h("sources")[0]

if pos:
    test=rstcommands.processTopTree(pos)
    g.es(test)
else:
    g.es('No "sources" node found',color='red')
</t>
<t tx="davy.20141208214654.11"></t>
<t tx="davy.20141208214654.3">Those are the Jinja2 templates for generation of autosummary apidoc.
For now these base, module and class files are the defaut ones, waiting for customization

It would also be possible to create another specific ones : :

*    autosummary/function.rst – template for functions

*    autosummary/attribute.rst – template for class attributes

*   autosummary/method.rst – template for class methods
    

The following variables are available in the templates:

* name

    Name of the documented object, excluding the module and class parts.

* objname

    Name of the documented object, excluding the module parts.

* fullname

    Full name of the documented object, including module and class parts.

* module

    Name of the module the documented object belongs to.

* class

    Name of the class the documented object belongs to. Only available for methods and attributes.

* underline

    A string containing len(full_name) * '='.

* members

    List containing names of all members of the module or class. Only available for modules and classes.

* functions

    List containing names of “public” functions in the module. Here, “public” here means that the name does not start with an underscore. Only available for modules.

* classes

    List containing names of “public” classes in the module. Only available for modules.

* exceptions

    List containing names of “public” exceptions in the module. Only available for modules.

* methods

    List containing names of “public” methods in the class. Only available for classes.

* attributes

    List containing names of “public” attributes in the class. Only available for classes.
</t>
<t tx="davy.20141208214654.4">Those are extra html part to be included in sidebar of specific pages.
See `html_sidebars` option in @data conf.py</t>
<t tx="davy.20141208214654.5">
Templates for layout.html</t>
<t tx="davy.20141208214654.9"></t>
<t tx="davy.20141209024434.2">@language python
"""Write the rst file of the current selected @ rst node"""
#ToDo write a condition for @rst or @rst child
c.rstCommands.rst3()


</t>
<t tx="davy.20141209091210.35">@language python
"""Commit &amp; push html files on github"""
import os
from dulwich.porcelain import  add, commit, push, log

&lt;&lt; paths &gt;&gt;

&lt;&lt; commit &gt;&gt;

# dullwich want a string
htmldir=str(htmldir)

g.redirectStderr()
g.redirectStdout()

add(htmldir)
commit(htmldir, message, author, committer)
push(htmldir, remote, 'refs/heads/gh-pages')</t>
<t tx="davy.20141209091210.36">message = "One click update again..."
committer = author = "Cottet Davy &lt;cottet_davy@yahoo.fr&gt;"
remote = "git+ssh://git@github.com/davy39/leo-editor"</t>
<t tx="davy.20141209091210.39"># We have to exclude template directory from building otherwise sphinx will try to build templates/autosummary/*.rst files
exclude_patterns = ['templates']</t>
<t tx="davy.20141209134323.10"></t>
<t tx="davy.20141209134323.1018">@language rest

@all
</t>
<t tx="davy.20141209134323.1019">@language rest # override the default .txt coloring.

@all
</t>
<t tx="davy.20141209134323.11">New in 4.3: - These are the names of leoFind ivars. (no more \_flag
hack). - There are no corresponding commander ivars to keep in synch
(hurray!) - These ivars are inited (in the subclass by init) when this
class is created. - These ivars are updated (in the subclass by
update\_ivars) just before doing any find. Initializing a wrapped search
is tricky. The search() method will fail if p==wrapPosition and pos &gt;=
wrapPos. selectNextPosition() will fail if p == wrapPosition. We set
wrapPos on entry, before the first search. We set wrapPosition in
selectNextPosition after the first search fails. We also set
wrapPosition on exit if the first search succeeds.

</t>
<t tx="davy.20141209134323.12">This routine performs a single batch change operation, updating the head
or body string of p and leaving the result in s\_ctrl. We update the
body if we are changing the body text of c.currentVnode().

s\_ctrl contains the found text on entry and contains the changed text
on exit. pos and pos2 indicate the selection. The selection will never
be empty. NB: we can not assume that self.p is visible.
</t>
<t tx="davy.20141209134323.13" rst-import="7d710028550b756e6465726c696e657332710155007102550b756e6465726c696e657331710355023d2d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
@ignore</t>
<t tx="davy.20141209134323.14">This chapter describes how to use the Jython Shell created by LeoUser.

</t>
<t tx="davy.20141209134323.15">-  Up-Down Arrow moves the selection up or down.
-  Tab inserts the current selection.

The completion list shows the best prefix entered after the '.' Any
other key withdraws the autocompleter.

</t>
<t tx="davy.20141209134323.16">Enter
    Processes the current line from the prompt to the end, regardless of
    where the cursor is.
Ctrl Enter
    This keystroke has two meanings:

    #. process the current line with a ':' appended to the end of it,
       regardless of where the cursor is. This is the behavior if there
       is character data on the line.
    #. If the line is pure whitespace, then the line is interpreted as a
       '' string with a length of 0.

</t>
<t tx="davy.20141209134323.17">Executing will dynamically expand a prefix to matching words already
entered within the interpreter. For example: cactus cac( keystroke )
will expand cac to cactus. This will cycle through all matches to cac
within the buffer upon repeated execution.

Ctrl A
    Moves current position to the end of the prompt.
Ctrl E
    Moves current position to the end of the line.
Ctrl K
    Removes all text from current position to end of the line.
Ctrl N
    Start typing, and then use this keystroke to search downwards only
    through the history items that match what you've typed so far. If
    you use this keystroke at a blank prompt, they just behave like
    normal arrow keys.
Ctrl P
    Start typing, and then use this keystroke to search upwards through
    only the history items that match what you ve typed so far. If you
    use this keystroke at a blank prompt, they just behave like normal
    arrow keys.
Ctrl R
    Opens a search prompt. Begin typing and the system searches your
    history for lines that contain what you ve typed so far, completing
    as much as it can.
Ctrl T
    Places triple quotes around the text on the current line.
Ctrl Z
    Suppresses the current output for the duration of the execution
    statement. This is useful in cases where there is a tremendous
    amount of output occurring and the user decides that he no longer
    wishes to see all of it. For gigantic outputs, this can be a shell
    saver.
Delete
    Removes all text from the prompt to the end of the line.
Down
    Moves the current line down one item in the history. By moving, this
    means the current line is replaced with history item.
Up
    Moves the current line up one item in the history By moving, this
    means the current line is replaced with history item.

</t>
<t tx="davy.20141209134323.18">Typing a reference name followed by a ? will create a object view which
gives the user a variety of information about the Object in question.
Example:

.. code:: literal-block

    a = 'meoooowwww'
    a? # Upon Enter, a panel will appear below showing Object information.

</t>
<t tx="davy.20141209134323.19">Typing ! at the command prompt followed by the system command you wish
to execute will start the command as a process and return a JPID for the
process that can be manipulated by the magic command set.

</t>
<t tx="davy.20141209134323.2">This file file to simplify and automatize builds of Leo Documentation.

It aim to self contain all needed informations to build Leo's website, from sources to publication scripts, including settings, and build buttons.

 * **Quick update** : clones of nodes most often updated
 
 * **sources** : all @rst nodes that are converted to .rst file (rst3) then to html (sphinx)
 
 * **templates** c
 
 * **@settings** : include most of the build  settings
 
 * **@Settings/Sphinx options/@data conf.py** especially contains basic sphinx configuration. 

 * **templates** : customization of sidebar, layout, and API doc
 
 * **css** : css use to modify Leo's website design (note that a lot can be done just with @data conf.py html_theme_options)

 * **commands** : scripts and button to generate rst &amp; html and publish it
 
 * **orphan** : Documentation files that are not (anymore / yet) included into website 
 
 * **TODO DOC**: List of tasks related with documentation</t>
<t tx="davy.20141209134323.20">Entering one of the following commands will cause its corresponding
command to execute:

</t>
<t tx="davy.20141209134323.21">``%alias`` *anAlias* defines alias name as an alias for cmd. Afterwards,
typing alias name params will execute the system command cmd params
(from your underlying operating system). Aliases have lower precedence
than magic functions and Python normal variables, so if foo is both a
Python variable and an alias, the alias can not be executed until you
remove the Python using ``del foo``.

</t>
<t tx="davy.20141209134323.22">Toggles autocalling off and on. Autocalling is the ability to do
something like:

.. code:: literal-block

    dir a

instead of dir( a ).

</t>
<t tx="davy.20141209134323.23">Toggles autoindenting off and on.

</t>
<t tx="davy.20141209134323.24">Runs a method/function in a background thread. For example:

.. code:: literal-block

    %bg doit()

This executes doit in a thread. The status of the operation can be seen
by looking at the jobs object:

.. code:: literal-block

    jobs.status()  #Prints the status of the jobs.

Alternatively you can access the status like so:

.. code:: literal-block

    jobs[jobnumber].result

jobnumber is printed out when the method/function is about to execute.
The result will be the return value of the method/function or it will
tell you the job isn't finished yet.

</t>
<t tx="davy.20141209134323.25">Changes the current working directory of the Jython Shell. ``..``
signifies the parent directory. Absolute and relative paths are allowed.

</t>
<t tx="davy.20141209134323.26">Destroys all JPIDs.

</t>
<t tx="davy.20141209134323.27">Clears the shell of all text and starts over with a fresh prompt.

</t>
<t tx="davy.20141209134323.271" rst-import="7d710028550b756e6465726c696e657332710155007102550b756e6465726c696e657331710355023d2d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="davy.20141209134323.272">Contents

-  `Old &lt;#old&gt;`__

   -  `Leo’s window, outlines &amp; clones &lt;#leos-window-outlines-clones&gt;`__
   -  `Relations: organizer nodes, views, tasks and
      metadata &lt;#relations-organizer-nodes-views-tasks-and-metadata&gt;`__
   -  `Plugins &lt;#plugins&gt;`__
   -  `Derived files and special
      nodes &lt;#derived-files-and-special-nodes&gt;`__
   -  `Markup for scripts &lt;#markup-for-scripts&gt;`__
   -  `Scripting Leo &lt;#scripting-leo&gt;`__
   -  `Leo’s modules and classes &lt;#leos-modules-and-classes&gt;`__
   -  `Predefined symbols in scripts &lt;#predefined-symbols-in-scripts&gt;`__
   -  `Accessing data &lt;#accessing-data&gt;`__
   -  `Traversing outlines &lt;#traversing-outlines&gt;`__
   -  `Executing commands from
      scripts &lt;#executing-commands-from-scripts&gt;`__
   -  `Bringing scripts to data &lt;#bringing-scripts-to-data&gt;`__
   -  `Unit Testing with @test and @suite
      nodes &lt;#unit-testing-with-test-and-suite-nodes&gt;`__
   -  `Plugins and hooks &lt;#plugins-and-hooks&gt;`__
   -  `Contacts &lt;#contacts&gt;`__

</t>
<t tx="davy.20141209134323.273"></t>
<t tx="davy.20141209134323.274">Leo organizes all data into nodes containing a **headline**, an
expandable page of **body text** and a (possibly empty) subtree of
**descendant nodes**. The **contents** of a node are its headline and
body text. Leo’s main window contains an **outline** pane at the top
left, a **log pane** at the top right, and a **body pane** at the
bottom. The outline pane shows headlines; the body pane shows the body
text of the selected headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same
content and descendants. All clones of the same node are equivalent, so
changing the contents of one node (call it node N) changes the contents
of all clones of N. Furthermore, inserting, deleting or changing any
descendant of node N causes the corresponding insertion, deletion or
change in all other clones of N.

</t>
<t tx="davy.20141209134323.275">Clones allow you to organize data in multiple ways within the same
outline. You do not have to choose a single ‘correct’ organization: you
can organize your data in as many ways as you like.

You can use **organizer nodes** to create explicit relations
(relationships) among the data in your outline. The headline of the
organizer node is the relationship’s name. Now make clones of nodes from
other parts of the outline that participate in the relation. Drag the
newly created clones so they become children of the organizer node. You
may want to create other (non-cloned) children of the organizer node
that contain data found nowhere else in the outline. Voilà: you have
just created the set of all nodes that pertain to the relationship. The
organizer node is the relation; the terms relation, relationship and
organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a
relation (an organizer node) containing all nodes related to a desired
view (or slice) of the data in the outline. Similarly, a **task** is an
organizer node containing all nodes related to a task. Relations are not
limited to tasks or views: the notion of relationship is completely
general. Headlines naturally describe the data in body text. That is,
nodes relate **metadata** (descriptions of data) to data. Separating
data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.

</t>
<t tx="davy.20141209134323.276">Plugins are Python (.py) files contained in Leo’s plugins folder. Users
can write plugins to change how Leo works and to add new features
without changing Leo’s core code. We’ll discuss plugins in more detail
later.

</t>
<t tx="davy.20141209134323.277">Leo can generate many external files called **derived files** from an
outline. Leo outlines can organize files throughout your computer’s file
system. Nodes whose headlines start with ‘@’ are special nodes. Several
**special nodes** indicate the root of a tree that generates a derived
file:

.. code:: literal-block

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes:

.. code:: literal-block

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an
outline:

.. code:: literal-block

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of
special nodes:

.. code:: literal-block

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.

</t>
<t tx="davy.20141209134323.278">Leo’s Execute Script command **preprocesses** the script to be executed
by scanning a node N and its descendents looking for markup. **Markup**
is special syntax that controls this preprocessing. If node N contains
no markup, the resulting script is just N’s body text. Otherwise, the
preprocessed script will include text from descendent nodes as described
below. The main kinds of markup are **section references**,
**directives** and **doc parts**.

#. **Section references** have the form:

   .. code:: literal-block

       &lt;&lt;section name&gt;&gt;

   The &lt;&lt; and &gt;&gt; must appear on the same line. Conversely, any line
   containing &lt;&lt; and &gt;&gt; is a section reference, regardless of context.
   However, section references are not recognized in doc parts. Any
   characters may appear between &lt;&lt; and &gt;&gt;.

   Section references are functional pseudo-code: while preprocessing a
   script, Leo replaces section references by the actual text of the
   section’s definition. Sections are defined in **section definition
   nodes**, whose headlines start with a section reference and whose
   body text defines the section. Each section definition node must
   descend from the node containing the section reference.

#. **Directives** start with ‘@’ in the leftmost column of body text.
   Directives specify options and control Leo’s operation. The @others
   directive is the minimal markup needed to organize scripts. @others
   tells Leo to insert the preprocessed text of all descendant nodes
   (except section definition nodes) at the spot at which the @others
   directive occurs. Nodes are inserted in **outline order**, the order
   in which nodes appear in the outline. **Important**: Leo adds the
   whitespace preceding the @others directive to the indentation of all
   preprocessed text.

   Using @others is more convenient than using section references. Use
   @others when the order of included text does not matter:

   .. code:: literal-block

       class myClass:
               @others # Include the methods of the class. Order doesn’t matter.

   Use section references when the order of included text does matter.
   In the following script, for example, &lt;&lt; imports &gt;&gt; ensures that
   imports come first. The @others directive then includes the body text
   of all other descendant nodes:

   .. code:: literal-block

       @language python
       &lt;&lt; imports&gt;&gt;
       @others # Define classes &amp; functions in child nodes.
       main()

   Here is a list of all of Leo’s standard directives:

   .. code:: literal-block

       @whitespace (or @doc)   Starts a doc part &amp; ends code part.
       @all                    Like @others, but includes all descendent nodes.
       @c, @code               Starts a code part and ends a doc part.
       @color                  Enables syntax coloring.
       @delims                 Temporarily changes comment delims.
       @nocolor, @killcolor    Disables syntax coloring.
       @comment                Sets comment delimiters in external (derived) files.
       @language languagename  Sets language for syntax coloring and comments.
       @lineending lineending  Sets ending of lines in derived files.
       @others                 Inserts body text of all descendents except definition nodes.
       @pagewidth n            Sets page width for justifying comments in doc parts.
       @path path              Sets prefix to use in relative file names in @file nodes, etc.
       @root filename          Marks the root of a tree that creates an external file.
       @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
       @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
       @wrap, @nowrap          Controls wrapping of text in body pane.

#. Doc parts start with the ‘@’ directive and continue until the end of
   the body text or until the ‘@c’ directive. Body text not in a doc
   part is in a code part. Here is an example of a doc part:

   .. code:: literal-block

       @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
       Leo reformats the doc part by justifying lines so they are no longer than the page width.
       @c

   Leo reformats doc parts by justifying the text into comment lines.
   The @pagewidth directive controls the length of these comment lines.
   The @language and @comment directives specify the comment delimiters
   used in doc parts.

</t>
<t tx="davy.20141209134323.279">The Execute Script command preprocesses the selected text of the
presently selected outline node, or the entire text of the node if there
is no selected text. See the section called Markup for Scripts for a
discussion of how Leo preprocesses scripts. That section also discusses
how Leo organizes scripts using outlines. Conversely, scripts can use
outlines to organize their data. To write such scripts you must
understand at least the basics of Leo’s modules and classes...

</t>
<t tx="davy.20141209134323.28">Shows the current working directory of the Jython Shell.

</t>
<t tx="davy.20141209134323.280">Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo
(Leo’s full source code) for more details: scripts have full access to
all of Leo’s classes and data.

#. The **leoGlobals** module contains utility functions. By convention,
   in Leo’s code g is always the leoGlobals module.
#. The **leoApp** module defines a class representing the entire Leo
   application. **g.app** is the singleton object of this class: the
   application object. The instance variables (ivars) of the application
   object are Leo’s global variables.
#. The leoCommands module defines the Commands class. A commander is an
   instance of this class. Commanders contain the operations that can be
   performed on a particular outline. Each open Leo outline has its own
   commander. By convention, in Leo’s code **c** is always a commander.
#. The leoFrame module defines the base leoFrame class for objects that
   create and manage the visual appearance of Leo’s windows and panes.
   The **leoTkinterFrame** and **leoTkinterTree** modules contain
   subclasses of the base classes in the leoFrame module. A frame (an
   instance of the leoFrame class, or a subclass) contains all the
   internal data needed to manage a Leo window. **c.frame** is the frame
   associated with commander c. If **f** is a frame, **f.c** is the
   frame’s commander, **f.body** is the frame’s body pane, **f.tree** is
   the frame’s outline pane, and **f.log** is the frame’s log pane.
#. The leoNodes module defines several classes that implement Leo’s
   fundamental data structures. These classes are complex. Happily,
   scripts can and should ignore these complications by accessing nodes
   using high-level methods of the position class.

A **position** (an instance of the position class) is the state of some
traversal of an outline. Equivalently, a position is a particular visual
place in an outline. Cloned nodes may appear many times in an outline.
Non-cloned nodes may also appear in many places: consider a non-cloned
descendant of a cloned node. By convention, in Leo’s source code p is a
position.

</t>
<t tx="davy.20141209134323.281">When executing scripts Leo predefines the following three symbols: **c**
is the commander of the outline in which the script is defined, **g** is
the leoGlobals module and **p** is the position of the selected node in
c’s outline, i.e., c.currentPosition().

</t>
<t tx="davy.20141209134323.282">Scripts should get and set data using high-level access methods. Here
are some important getters:

.. code:: literal-block

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters:

.. code:: literal-block

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.

</t>
<t tx="davy.20141209134323.283">Scripts can visit some or all of the nodes of a Leo outline using the
following iterators:

.. code:: literal-block

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly
indented:

.. code:: literal-block

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()

</t>
<t tx="davy.20141209134323.284">Scripts may open other Leo outlines, or execute any of Leo’s commands.
Here are some examples:

.. code:: literal-block

    ok,frame = g.openWithFileName(path,c)       # Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see Chapter 7: Scripting Leo with Python, in Leo’s
Users Guide.

</t>
<t tx="davy.20141209134323.285">The scripting plugin creates two buttons in the icon area at the top of
the Leo window. The Run Script button executes the script in the
selected node just like the Execute Script command. The Script Button
button creates a new button whose headline is the headline of the
presently selected node, call it node N. Pressing this button executes
the script in node N with p predefined as c.currentPosition() at the
time the script is executed. This clever trick brings the script to the
data in the selected outline.

</t>
<t tx="davy.20141209134323.286">test.leo contains all of Leo’s unit tests. An @button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button
executes all the unit tests specified by @test and @suite nodes in the
selected outline. **Important**: @button, @test and @suite nodes require
the scripting plugin to be enabled.

@test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each @test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the @test node. There is no need to
create TestCase objects explicitly!

@suite nodes support legacy unit tests. When the Unit Test script button
finds an @suite node it executes the script in its body text. This
script should create a suite of unit tests and set:

.. code:: literal-block

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.

</t>
<t tx="davy.20141209134323.287">Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy
to create new plugins: Leo’s users have contributed dozens of plugins
that extend Leo’s capabilities in new ways. Leo imports all enabled
plugins during startup. The file pluginsManager.txt lists all enabled
plugins. You can use the plugin manager plugin to control plugins
without updating pluginsManager.txt by hand.

Plugins can override any class, method or function in Leo’s core, the
files in Leo’s src subdirectory (the files derived from LeoPy.leo).
Besides altering Leo’s core, plugins can register functions called hooks
that Leo calls at various times during Leo’s execution. Events that
trigger hooks include key pressed events, screen drawing events, node
selection events and many others. When importing a plugin, Leo will call
the top-level init() function if it exists. This function should
register the plugin’s hooks by calling leoPlugins.registerHandler.

For full details about hooks and events see Chapter 8: Customizing Leo,
in Leo’s Users Guide. The file leoPlugins.leo contains all plugins that
are presently distributed with Leo; studying these plugins is a good way
of learning to write your own plugins.

</t>
<t tx="davy.20141209134323.288">-  Leo’s home page: google edreamleo or
   http://webpages.charter.net/edreamleo/front.html
-  Edward K. Ream: edreamleo@charter.net, 166 N. Prospect Ave., Madison
   WI 53726, (608) 231-0766

</t>
<t tx="davy.20141209134323.29">Sets the reference to a java.io.File instance representing the current
directory.

</t>
<t tx="davy.20141209134323.291">@language plain
@tabwidth -4
@all
</t>
<t tx="davy.20141209134323.292" rst-import="7d710028550b756e6465726c696e657332710155007102550b756e6465726c696e657331710355013d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="davy.20141209134323.293">Positions and trees are objects that exists only within Leo instance. However,
trees can have "serialized" representation in .leo xml files (where structure is
described by xml hierarchy), or @file nodes (where structure is described by
sentinels).

Sometimes, both formats are too heavyweight. Both xml and "flat" text files involve nontrivial callback-based
(or worse) parsing. Luckily, trees can be represented naturally with python lists, which can be pickled and 
passed around with almost zero cost in CPU consumption or code complexity. In theory position objects
can be passed around in this fashion as well, but positions always have to exist in the tree (there
is no concept of 'detached' position) and they can't be pickled or moved around outside the Leo instance.

For the purposes of this discussion (and for the sheer narcissistic pleasure of inventing new terminology), I'm 
calling these data structures `objtrees`.

The structure of objtrees is a standard Python list of the form::

    [headline, bodystring, gnx, [children...]]

Where `children` is a recursive tree. Here's an example objtree (from ILeo session)::

    ileo[~/hashcache]|11&gt; g.tree_at_position(p)
                     &lt;11&gt;
    [u'root',
     u'Root body',
     'ville.20090601215420.1449',
     [[u'ch1 head',
       u'child 1 body',
       'ville.20090609184451.5679',
       [[u'ch1.1 head', u'ch1.1 body', 'ville.20090609184451.5680', []],
        [u'ch1.2 head', u'ch1.2 body', 'ville.20090609184451.5681', []]]],
      [u'ch2 head',
       u'ch2 body',
       'ville.20090609184451.5682',
       [[u'ch2.1 head', u'', 'ville.20090609184451.5683', []]]]]]

Note that these trees are constructed using `g.tree_at_position(pos)`. These objtrees can be re-incorporated to 
Leo document using `g.create_tree_at_vnode(c, v, tree)`, which rebuilds the structure at position p. The "vnode"
is available as p.v attribute. This functions also creates clones if necessary (according to gnx). If 
you want to avoid creating clones (e.g. to implement simple copy-paste functionality), you can use `g.create_tree_at_position(p)`.
create_tree_at_position also server as a trivial example for recursing through objtree data structure::

    def create_tree_at_position(p, tree):
        """ Like create_tree_at_vnode, but slower, simpler, without clone/gnx support
        """
        h,b,gnx,chi = tree

        p.h = h
        p.b = b

        for el in chi:
            chpos = p.insertAsLastChild().copy()
            # recurse
            create_tree_at_position(chpos, el)

`g.create_tree_at_vnode` is more complex, but faster and supports clones. It relies on 
`g.fast_add_last_child(c, parent_v, gnxString)`, which adds a new node to the tree
as last child of parent_v (vnode), It either returns the created vnode, or None 
if it created a clone (i.e. a node with same gnx was already found in the document). 
This is a conscious design choice, as it prevents you from accidentally manipulating
the tree of the clone (since it already has a tree of its own!).

</t>
<t tx="davy.20141209134323.294">Objtrees are not without real life applications. They are used to implement the
content hash based node cache that radically speeds up Leo's startup
(effectively eliminating the delay caused by Leo parsing @file / @auto nodes -
something which made trees with several @auto or @file nodes intolerable in
practice. The trick here relies on the fact that:

- The whole content of external file (say, foo.py) can be described by
calculating an md5sum of the file - The same external file content will always
create the same leo tree.

In brief, 

- When we are reading in a @file node foo.cpp, we first read in the whole file and calculate
  md5sum of its contents. Let's say the md5 sum is 8095e2dabbfe90b349066209fb090df6. 
- Leo tries to look for existing cached version in ~/.leo/db/LeoDocs.leo/fcache/8095e2dabbfe90b349066209fb090df6. Initially, it doesn't exist,
  so Leo executes the standard (slow) @file code parsing routine and creates the tree normally
- After creating the tree, Leo executes g.tree_at_position and pickles the objtree to file 
  ~/.leo/db/LeoDocs.leo/fcache/8095e2dabbfe90b349066209fb090df6
- Now, on the next startup, Leo *will* find the cached pickle, read it in and execute `g.create_tree_at_vnode`

</t>
<t tx="davy.20141209134323.295">Previous discussion omitted one fact - Leo doesn't actually operate on files directly, but 
uses the `pickleshare` library (shipped with Leo) to access the cached pickles. In essence, the database is 
always associated with one specific Leo document, and is available through c.db. So, storing a tree is
(in simplified form) about doing::

   cachename = "fcache/8095e2dabbfe90b349066209fb090df6"
   if cachename in c.db:
        g.trace('Already cached')
    else:
        tree = g.tree_at_position(pos)
        c.db[cachename] = tree

Pickleshare (as used by Leo) stores the pickles in zlib-compressed form, which yields 
significant size benefits for large pickles like objtrees.

Note that c.db is available to all plugins and scripts, and in no way limited to this 
specific caching purpose. In practice, it's useful for data you want to persist
through Leo sessions, but not added to .leo document (which is what unknownAttributes
are used for).

In addition to c.db, there is g.app.db that can be used for global (non-document specific)
persisted data. E.g.::

    g.app.db['foo'] = [1,2,3]  

The underlying files for c.db are at under ~/.leo/db/somedocument.leo_somehash.

Files for g.app.db are at ~/.leo/db/global.

</t>
<t tx="davy.20141209134323.3">These are nodes that were not included in any toctree</t>
<t tx="davy.20141209134323.30">Deserialize an Object stored on disk into the reference.

</t>
<t tx="davy.20141209134323.31">Same as %edit.

</t>
<t tx="davy.20141209134323.32">Brings up the Jython Shell editor and executes the resulting code.

This command allows you to conveniently edit multi-line code right in
your JythonShell session. If called without arguments, ``%edit`` opens
up an empty editor with a temporary file and will execute the contents
of this file when you close it (don t forget to save it!). Options:

+--------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -p                                                                                                                                   | -x                                                                                                                                                                                            |
| Calls the editor with the same data as the previous time it was used, regardless of how long ago (in your current session) it was.   | Suppresses execution of the edited code upon exit. This is mainly useful if you are editing programs which need to be called with command line arguments, which you can then do using %run.   |
+--------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

If args are given, the following possibilities exist:

-  The arguments are numbers or pairs of colon-separated numbers, e.g.,
   ``1 4:8 9``. These are interpreted as lines of previous input to be
   loaded into the editor. The syntax is the same of the %macro command.
-  If the argument doesn't start with a number, it is evaluated as a
   variable and its contents loaded into the editor. You can thus edit
   any string which contains python code (including the result of
   previous edits).

</t>
<t tx="davy.20141209134323.33">Prints all environment variables.

</t>
<t tx="davy.20141209134323.34">Prints all or part of the history. If given, the ``-n`` argument
signifies that line numbers should not be printed out.

%hist [ -n ]
    Prints the total history or the last 40 items in it.
%hist [ -n ] n1
    Prints the last n1 items in the history.
%hist [ -n ] n1 n2
    Prints the items from index n1 to index n2.

</t>
<t tx="davy.20141209134323.35">Destroys JPID n.

</t>
<t tx="davy.20141209134323.36">Shows the contents of the current working directory.

</t>
<t tx="davy.20141209134323.37">Shows a java array of File instances. For example:

.. code:: literal-block

    %ls a # a now holds a java array of File instances

</t>
<t tx="davy.20141209134323.38">Returns the current available set of magic commands.

</t>
<t tx="davy.20141209134323.39">Defines a macro that can be executed by using the name given. For
example:

.. code:: literal-block

    %macro macex 9:10 11 12:13 4

creates a macro called macex and puts line 9-10, 11 12-13 and 4 from the
history into it Hence entering macex and typing enter will cause those
lines to rexecute.

To see the contents of the macro type: ``print macroname``. To remove a
macro type: ``del macroname``.

</t>
<t tx="davy.20141209134323.4">
######################################################
Clones of nodes to be modified most often.
######################################################</t>
<t tx="davy.20141209134323.40">%magic
    Prints out the description of the magic commands.
%magic %magiccommandname
    Prints the usage/description of the given magic command.

</t>
<t tx="davy.20141209134323.41">Same as 'print'.

</t>
<t tx="davy.20141209134323.42">%pdb
    Starts the Pdb debugger.

%pdb filename

    Runs the file under Pdb in the shell.

%pdb [on\|1\|off\|0 ]
    Toggles automatic startup of Pdb on an exception. Examples:

    .. code:: last

        %pdb on  --&gt; now on
        %pdb off --&gt; now off
        %pdb 1 --&gt; now on
        %pdb 0 --&gt; now off

</t>
<t tx="davy.20141209134323.43">Prints out the doc string of the passed in object if one can be found,
otherwise does nothing.

The object may be a module, a method, an object, etc.

</t>
<t tx="davy.20141209134323.44">Attempts to locate the source file of the passed in object and displays
the contents of the source in the shell.

</t>
<t tx="davy.20141209134323.45">An alias for the ? object viewer syntax. If the references is valid, a
widget containing info on the reference will appear.

</t>
<t tx="davy.20141209134323.46">Executes a statement entered on the same line in the profile module.

</t>
<t tx="davy.20141209134323.47">%ps
    Prints out all JPID's the JythonShell has collected.
%ps aReference
    Puts a java Set of Processes in the reference. For example:

        %ps a #a now holds a Set of Processes.

</t>
<t tx="davy.20141209134323.48">Repeats the last input.

</t>
<t tx="davy.20141209134323.49">%rehash
    Updates the alias table with all entries in $PATH. This command does
    **not** check execute permissions or whether the contents of $PATH
    are truly files (instead of directories or something else).
%rehashx
    Updates the alias table with all executable files in $PATH. This
    command **does** explicitly check that every entry in $PATH is a
    file, so it is slower than %rehash.

</t>
<t tx="davy.20141209134323.5">
 * Each config value in @data conf.py have to apper in **one single line**
 
 * **sources** have to be the parrent of all @rst node to build in order to perform make-all-rst</t>
<t tx="davy.20141209134323.50">Resets the namespace by removing all names defined by the user.
Input/Output history remain in case you need them.

</t>
<t tx="davy.20141209134323.51">Runs the named file inside IPython as a program. Options:

-n:
    Suppresses setting ``__name__`` to ``__main__``. Instead, sets
    ``__name__`` to the file's name without extension (as Python does
    under import).

    This allows running scripts and reloading the definitions in them
    without calling code protected by:

    .. code:: last

        if __name__ == __main__:

-i:
    Runs the file in JythonShell's namespace instead of an empty one.
    This is useful if you are experimenting with code written in a text
    editor which depends on variables defined interactively.
-t:
    Prints timing information at the end of the run.
-N n:
    If -t is given this option indicates how many times you want the
    script to run. ``n`` must be an integer. The final timing report
    will include total and per run results.

</t>
<t tx="davy.20141209134323.52">This command uses the same syntax as %macro for line extraction, but
instead of creating a macro it saves the resulting string to file whose
name is given. It ensures the filename ends with a .py extension, and it
asks for confirmation before overwriting existing files.

</t>
<t tx="davy.20141209134323.53">Runs the given command using ``command.getoutput()`` and updates the
user's interactive namespace with a variable called varname containing
the value of the call. Your command can contain shell wildcards, pipes,
etc. The ``=`` is mandatory, and the variable name must be a valid
Python identifier. Options:

-l:
    List output. Splits the output on newlines into a list before
    assigning it to the given variable. By default the output is stored
    as a single string.
-v:
    Verbose. Prints the contents of the variable.

</t>
<t tx="davy.20141209134323.54">%see n
    Shows any output JPID n has collected.
%see n aReference
    Places any output JPID n has collected in the reference.

</t>
<t tx="davy.20141209134323.55">Sends the reference as input to JPID n.

</t>
<t tx="davy.20141209134323.56">Saves the object referenced by reference as a serialized Object.

</t>
<t tx="davy.20141209134323.57">Places the reference into the editor if the reference is a JComponent
subclass. Useful for quick gazing of what a Swing component looks like.

</t>
<t tx="davy.20141209134323.58">Runs the given command using commands.getoutput(), and returns the
result formatted as a list (split on). The output is stored in ipython's
regular output cache Out[N] and in the N automatic variables.

</t>
<t tx="davy.20141209134323.59">Shows the threads running and the state they are in. Selecting a thread
shows the thread's stack.

</t>
<t tx="davy.20141209134323.60">Removes the given alias.

</t>
<t tx="davy.20141209134323.61">Loads data from a url into a reference. For example:

.. code:: literal-block

    %url a http://python.org

take the data at ``http://python.org`` and places it in ref.

</t>
<t tx="davy.20141209134323.62">Suspends the JythonShell until JPID n has finished.

</t>
<t tx="davy.20141209134323.63">Prints the list of identifiers that have been defined interactively.

</t>
<t tx="davy.20141209134323.64">Returns a sorted list of all interactive variables. If arguments are
given, only variables of types matching these arguments are returned.
Examples:

.. code:: literal-block

    %who_ls
    %who_ls str int  #this prints out variables whose type is str and int

</t>
<t tx="davy.20141209134323.65">Prints a table of identifiers that have been defined interactively.

</t>
<t tx="davy.20141209134323.66">Transforms reference ref2 with the stylesheet in ref1 putting the result
in ref3.

</t>
<t tx="davy.20141209134323.67">JPIDs are not PIDs of the OS. They are a system by which the JythonShell
can keep track of Processes created by it, and means by which the user
can manipulate those Processes.

The CWD does not indicate what the process is working in. It is intended
to function with the Magic Commands. This system does not interoperate
with java.io.File or Jython open. To achieve interoperability the user
should use the magic command of the form:

.. code:: literal-block

    %cwd reference

This will place a java.io.File in the reference. The File instance is a
copy of the CWD File and will allow the user to open, write, create,
close streams and such in the JythonShell's CWD
</t>
<t tx="davy.20141209134323.7" rst-import="7d710028550b756e6465726c696e657332710155007102550b756e6465726c696e657331710355022d3d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="davy.20141209134323.8"></t>
<t tx="davy.20141209134323.9">The find and change commands are tricky; there are many details that
must be handled properly. This documentation describes the leo.py code.
Previous versions of Leo used an inferior scheme. The following
principles govern the leoFind class:

#. Find and Change commands initialize themselves using only the state
   of the present Leo window. In particular, the Find class must not
   save internal state information from one invocation to the next. This
   means that when the user changes the nodes, or selects new text in
   headline or body text, those changes will affect the next invocation
   of any Find or Change command. Failure to follow this principle
   caused all kinds of problems in the Borland and Macintosh codes.
   There is one exception to this rule: we must remember where
   interactive wrapped searches start. This principle simplifies the
   code because most ivars do not persist. However, each command must
   ensure that the Leo window is left in a state suitable for restarting
   the incremental (interactive) Find and Change commands. Details of
   initialization are discussed below.
#. The Find and Change commands must not change the state of the outline
   or body pane during execution. That would cause severe flashing and
   slow down the commands a great deal. In particular, c.selectVnode and
   c.editPosition methods must not be called while looking for matches.
#. When incremental Find or Change commands succeed they must leave the
   Leo window in the proper state to execute another incremental
   command. We restore the Leo window as it was on entry whenever an
   incremental search fails and after any Find All and Change All
   command.

Initialization involves setting the self.c, self.p, self.in\_headline,
self.wrapping and self.s\_ctrl ivars. Setting self.in\_headline is
tricky; we must be sure to retain the state of the outline pane until
initialization is complete. Initializing the Find All and Change All
commands is much easier because such initialization does not depend on
the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge
simplification of the code. Indeed, the searching code does not know
whether it is searching headline or body text. The search code knows
only that self.s\_ctrl is a Tk.Text widget that contains the text to be
searched or changed and the insert and sel Tk attributes of
self.search\_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The
selectNextPosition() method handles the many details involved by setting
self.s\_ctrl and its insert and sel attributes.

</t>
<t tx="davy.20141209154025.10">Summary:

- Leo's tutorials have been rewritten and simplified.
- Greatly improved abbreviations, including templates.
- Clones are now valid anywhere in @file nodes.
- Leo now warns if a .leo file is open elsewhere.
- Leo's IPython bridge now works with IPython 1.x.
- Added support for @testsetup and @testclass.
- Added support for sessions.
- Added colorizing themes.
- A colored border highlights the pane with focus.
- Added support for the clojure, markdown and TypeScript languages.
- Added importers for .ipynb, .otl and vimoutliner files.
- Many new and improved commands, plugins and scripts.
- Dozens of bug fixes and code-level improvements.
</t>
<t tx="davy.20141209154025.100">https://bugs.launchpad.net/leo-editor/+bug/1251252

F11 (help-for-command) now works for @button &amp; @command nodes.
</t>
<t tx="davy.20141209154025.101">https://bugs.launchpad.net/leo-editor/+bug/1254861
</t>
<t tx="davy.20141209154025.102">https://bugs.launchpad.net/leo-editor/+bug/1258373
</t>
<t tx="davy.20141209154025.103">https://bugs.launchpad.net/leo-editor/+bug/1260415
Added more informative error messages
</t>
<t tx="davy.20141209154025.104">https://bugs.launchpad.net/leo-editor/+bug/1264350
</t>
<t tx="davy.20141209154025.105">https://bugs.launchpad.net/leo-editor/+bug/1267921
</t>
<t tx="davy.20141209154025.106">https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
</t>
<t tx="davy.20141209154025.107">https://bugs.launchpad.net/leo-editor/+bug/613153

Use the %~dp0 syntax. Example::

  %~dp0\Python27\python.exe %~dp0\Leo-editor\launchLeo.py

http://ss64.com/nt/syntax-args.html
http://stackoverflow.com/questions/5034076/what-does-dp0-mean-and-how-does-it-work

I have just created a FAQ entry for this, so at last this issue is closed.
</t>
<t tx="davy.20141209154025.108">https://bugs.launchpad.net/leo-editor/+bug/735938
</t>
<t tx="davy.20141209154025.109">https://bugs.launchpad.net/leo-editor/+bug/969391
</t>
<t tx="davy.20141209154025.11">New commands:

- go-anywhere (quicksearch plugin).
- help-for-abbreviations
- help-for-dynamic-abbreviations
- help-for-find-commands
- help-for-regular-expressions
- insert-node-before
- normalize-whitespace
- parse-body
- print-buttons
- vr-expand &amp; vr-contract
- zoom-in/out commands

Improved commands:

- All viewrendered commands now start with vr.
- Alt-Home &amp; Alt-End collapse all possible nodes.
- Ensure selected @test node is run.
- Fixed dabbrev commands.
- Help commands now use &lt;pre&gt; formatting if docutils is not available
- Improved incremental search commands
- Refresh from disk menu command now refreshes all selected nodes
- Show all commands after &lt;alt-x&gt;&lt;tab&gt;
- help-for-command executes helpFor commands
- help-for-python now uses vr window
- leoscreen-jump-to-error command
</t>
<t tx="davy.20141209154025.110"></t>
<t tx="davy.20141209154025.111">Removed the odious "'Can not execute commands from headlines" message.

Leo now ends editing, replaces the event.widget and event.w fields with
c.frame.body.wrapper.widget and carries on.
</t>
<t tx="davy.20141209154025.112"></t>
<t tx="davy.20141209154025.113">Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
</t>
<t tx="davy.20141209154025.114">- pd.update_before_write_foreign_file tells when an @data node has been
  changed. This explains why the .leo file is now dirty.
- at.saveOutlineIfPossible automatically saves the .leo file if only
  unchanged persistence nodes remain.
  
at.saveOutlineIfPossible makes the following hacks unnecessary:
    
- at.writeAllHelper writes an unchanged @auto file only if it is
  selected explicitly.
- Changed at.writeAll so that the no @&lt;file&gt; node written message now says
  that you must selected an unchanged @auto node directly in order to write
  it with the write-at-files-nodes command.
</t>
<t tx="davy.20141209154025.115">https://groups.google.com/d/msg/leo-editor/NGbogCgVmx4/nsJGngrS8BgJ
</t>
<t tx="davy.20141209154025.116">Fixed the entry in g.app.language_extension_dict
</t>
<t tx="davy.20141209154025.117">Previously, Ctrl-F Alt-tab Alt-tab would put focus in an inactive minibuffer.

The fix involved rewriting onActivate/DeactivateEvent.
</t>
<t tx="davy.20141209154025.118">https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ

This only affected searches that were initiated using the buttons in the Find tab.

What I did:
    
- Init buttonFlag ivar in setup_button &amp; setup_command.
- showSuccess sets was_in_headline ivar.
- focusInTree returns was_in_headline when buttonFlag is True.
- editLabelHelper now properly sets selection range for backward searches.
- Removed a selection hack in initNextText.
</t>
<t tx="davy.20141209154025.119">Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
</t>
<t tx="davy.20141209154025.12">New features:

- Added importers for .otl, .ipnyb, TypeScript and vimoutliner.
- Added support for @testsetup and @testclass.
- Added syntax coloring for clojure language.
- Added yes-to-all button when prompting for dangerous writes.
- Allow periods before section names in headlines.
- Border color changes depending on input state.
- Clones are now valid anywhere in @file nodes.
- Leo issues a warning if the same .leo file is open in another Leo instance.

Improved features:

- Leo's IPython bridge now works with IPython 1.x.
- @wrap now suppresses horizontal scrolling.
- Added docstrings for all commands.
- Added help text to the find panel.
- Added sublime Text 2, a dark colorizing theme.
- All @button nodes now show call tips.
- Major additions to abbreviations, including templates.
</t>
<t tx="davy.20141209154025.120"># Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
</t>
<t tx="davy.20141209154025.121">https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4

Another example of the wretched newline problem. @edit nodes preserve '\r'
characters, and that messes up the counts in the find command.

The fix was a hack to find.search: it removes '\r' characters.

</t>
<t tx="davy.20141209154025.122">The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
</t>
<t tx="davy.20141209154025.123">@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

    aList = [x for x in globalDirectiveList if z != 'others']
    aList.sort(lambda a,b: len(b)-len(a))
        # Sort by length, longest first
    pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
</t>
<t tx="davy.20141209154025.124">@language python

import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') &gt; -1:
        g.es(sfn)

@language text

Possible automatic computation of First sets:
http://stackoverflow.com/questions/787134/can-i-determine-the-set-of-first-chars-matched-by-regex-pattern
http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf

found: Rules indicated are dubious or broken

md.py:
    disabled: 6,7,
    changed: 8,12,20,21,23,24,25,47
    [ \t]   leadins: 8,20,24,25,50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    other   leadins: 12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed
</t>
<t tx="davy.20141209154025.125">The problem was an off-by-one test in regexHelper.
</t>
<t tx="davy.20141209154025.126">Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.
</t>
<t tx="davy.20141209154025.127">http://i.imgur.com/1ZV45oB.png

There was a problem with hitting tab, and possibly with using the mouse in the QListWidget.

The fix was to define w as follows in lqlw.select_callback and lqlw.tab_callback:
    
    w = c.k.autoCompleter.w or c.frame.body.wrapper

In addition, I changed assert in lqlw.set_position to calls to g.trace.
</t>
<t tx="davy.20141209154025.128">The change pattern doesn't always get set properly.

The fix was in find.addChangeStringToLabel. It must never protect the
change string!
</t>
<t tx="davy.20141209154025.129">https://github.com/leo-editor/leo-editor/issues/49

The file import code as found in scripts fails on reaching
Word backup files (file names prefixed with a ~)

The problem was that g.os_path_join automatically called
os.path.expanduser, which converts ~ to the users home directory.

The fix was to disable the call to os.pathexpanduser in g.os_path_join &amp;
g.os_path_finalize if the new expanduser keyword argument is False.
</t>
<t tx="davy.20141209154025.13" str_atime="1376412280.0">New plugins:

- leomylyn.py
- markup_inline.py
- printing.py
- richtext.py
- rss.py
- screen_capture.py
- screencast.py
- timestamp.py

Improved plugins:

- bookmarks.py
- ipython.py
- valuespace.py
- viewrendered.py

.. _`contrib branch`: https://code.launchpad.net/~leo-editor-team/leo-editor/contrib

Recent additions to the `contrib branch`_:

- Dumping leo docs to excel.
- Full text searches.
- LeoReader: a prototype of Leo as web app.
- QML notebook.
- Templates with macro expansions.
</t>
<t tx="davy.20141209154025.130">https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw
</t>
<t tx="davy.20141209154025.131">The present code just exists Leo, which imo is the reasonable thing to do. 
</t>
<t tx="davy.20141209154025.132">https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

qtree.onItemClicked now calls c.findCommands.reset_state_ivars()
</t>
<t tx="davy.20141209154025.133">Tab cycling now works as expected in all my tests.

- Reset tab cycling if the user types backspace or any plain character.
- Start cycling *only* if len(label) == len(common_prefix)

These restriction appear to be essential.
</t>
<t tx="davy.20141209154025.134">It sometimes picked a shorter completion that is not a prefix of the present label!

Examples:
    print-se **sometimes** shows print-uas or print-bindings or...
    print-stat&lt;tab&gt;-h&lt;tab&gt; shows print-statusbar-hide
    print-st&lt;tab&gt; shows print-style-sheet.
    print-pr&lt;tab&gt; show print-plugin-handlers.
    
The fix was a single extra check in ga.do_tab.
</t>
<t tx="davy.20141209154025.135">Saved and restored the y-scroll position in find_place_holder.
</t>
<t tx="davy.20141209154025.136">dw.createGrid now honors the margin argument.
</t>
<t tx="davy.20141209154025.137">- Non-plain keys are now ignored.
- Backspace and other characters now do something fairly reasonable when text is selected.
  This is an edge case, unless everything to the end of the text is selected.
</t>
<t tx="davy.20141209154025.138">This was probably fixed earlier by the addition of progress guards
in ec.fillRegion and c.reformatBody.

Added one line for fillRegion.
</t>
<t tx="davy.20141209154025.139">http://legacy.python.org/dev/peps/pep-0008/

https://github.com/leo-editor/leo-editor/issues/68

    (fixed) puts whitespace between function name and opening '('
    (fixed) puts whitespace between dictionary name and '['
    (fixed) removes whitespace between function arguments after ','
    (partially fixed) removes whitespace around operator inside parentheses
        (this is not so clear, depends on situation, can be correct or can be wrong)
    (fixed) puts whitespace between print and opening '('

print(obj) is correct and PEP8 style in Python 3, in Python 2.7 runs
correctly but print(obj) is not correct traditionally
</t>
<t tx="davy.20141209154025.14">The following scripts have been added to scripts.leo:

By Terry Brown::

    Add @script node
    Cross-outline node editing
    Export full contents
    Full tree view (See the discussion in the child)
    Indexing files for full text search
    Persistent state with json as a leo abbreviation
    Tool for diffing Leo files
    
By Edward K. Ream::

    Cleanup imported nodes
    Create global data structures from in modes/*.py files
    Get all comments from modes (slow)
    Import org mode
    jinja2 templating
    Recursive import script (with cleanups)
    
By Brian Theado::

    Display function call hierarchy in Leo
</t>
<t tx="davy.20141209154025.140">This had been disabled when completion for vim : commands was added.

Changed ga.get_command and ga.is_command.
</t>
<t tx="davy.20141209154025.141">https://bugreports.qt-project.org/browse/QTBUG-41153
</t>
<t tx="davy.20141209154025.142">This is required so that, for example, python coloring is correct after
selecting a node that sets another color for operators.
</t>
<t tx="davy.20141209154025.143">g.es does nothing when g.app.gui.consoleOnly is True
</t>
<t tx="davy.20141209154025.144">For some strange reason, the PyQt5 version of LeoQtGui.runSaveFileDialog
returns a tuple instead of a string!
</t>
<t tx="davy.20141209154025.145"></t>
<t tx="davy.20141209154025.146"></t>
<t tx="davy.20141209154025.147">https://bugs.launchpad.net/leo-editor/+bug/1286909
Settings in file A propagate to file B when editing A and B is opened

</t>
<t tx="davy.20141209154025.148">https://bugs.launchpad.net/leo-editor/+bug/1240786
Corner case bug in tab-cycle-next and tab-cycle-previous

This bug appears to have been fixed.

Open any already existing Leo-Editor file. Call this File 1. Ctrl-O and
open any already existing Leo-Editor file. We will refer to this file as
"File 2." At this point the File 2 tab has focus.

Now execute tab-cycle-next or tab-cycle-previous. I do this using shortcuts
Ctrl+Next and Ctrl+Prior respectively, but your shortcuts may be different.
Now the File 1 tab has the focus. Now type any printable key.

Note that the printable key character is put into File 2 and File 2 is now
dirty, but the focus is still on File 1.

In every other case that I've tried tab-cycle-next and tab-cycle-previous
perform correctly and the tab with the focus is the tab into which
characters are inserted.
</t>
<t tx="davy.20141209154025.149">https://bugs.launchpad.net/leo-editor/+bug/1249684
"add body editor" adds editor pane in wrong tab

This seems to have been fixed.
</t>
<t tx="davy.20141209154025.15">- Added @color minibuffer-foreground-color setting.
- Added @color log_warning_color setting.
- Fully supported `:`: convention in @mode nodes.
- Added --no-plugins command-line option.
- Bound Alt-Ctrl-M for macro-call-last.
- Added @bool enable-tree-dragging setting.</t>
<t tx="davy.20141209154025.150">https://bugs.launchpad.net/leo-editor/+bug/1258302
Window, Toggle Split Direction Error

This works for me.  Don't know when it was fixed.
</t>
<t tx="davy.20141209154025.151">https://bugs.launchpad.net/leo-editor/+bug/1269540
File importing problems: Path doesn't properly appear as node header

This bug was fixed by #60 or at some earlier time.

I am aware of no problems with drag and drop at present.
Please create a github bug report if any new issues appear.

</t>
<t tx="davy.20141209154025.152">https://bugs.launchpad.net/leo-editor/+bug/1286914
A custom menu that seems correct, but does nothing

This problem is demonstrated by the file settingsCreep01.leo attached to bug 1286909.

The fix is to remove the amperstand from the @item headlines.
</t>
<t tx="davy.20141209154025.153">https://bugs.launchpad.net/leo-editor/+bug/1286913
After the "menu already exists: ampersand menu name" warning,
the menu entries are added to the existing menu.

This is a minor wishlist item.
</t>
<t tx="davy.20141209154025.154">https://bugs.launchpad.net/leo-editor/+bug/1292207
Disabling Plugins disables menu actions

This bug is invalid.

Disabling plugins disable the mod_scripting plugin, so the @command nodes
given in the example do nothing.
</t>
<t tx="davy.20141209154025.155">https://bugs.launchpad.net/leo-editor/+bug/815564
Plugin Menu - Keystroke binding can prevent plugin help display

Obvious workaround: avoid name clashes.
</t>
<t tx="davy.20141209154025.156"></t>
<t tx="davy.20141209154025.157">https://bugs.launchpad.net/leo-editor/+bug/1228457

This appears to have been fixed.
</t>
<t tx="davy.20141209154025.158">https://bugs.launchpad.net/leo-editor/+bug/1228713

This appears to have been fixed at some time in the past, possibly as the result of fixing another bug.
</t>
<t tx="davy.20141209154025.159">https://bugs.launchpad.net/leo-editor/+bug/1254864
</t>
<t tx="davy.20141209154025.16">@language rest

Summary:

* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
* Important new plugins for tagging, display and node evaluation.
* For beginners:
    - Leo's default workbook files contains Leo's quickstart guide.
* Hundreds of new/improved features and bug fixes.
</t>
<t tx="davy.20141209154025.160">https://bugs.launchpad.net/leo-editor/+bug/524890
Incomplete derived file

This bug was fixed by the allow_cloned_sibs logic in leoAtFile.py 2013/01/20.
</t>
<t tx="davy.20141209154025.161">https://bugs.launchpad.net/leo-editor/+bug/1177355
node-only wrapped search does not work in long nodes

This works for me.
</t>
<t tx="davy.20141209154025.162">From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1193820
Focus change on tree pane after saving current Leo file
    
Using Qt. First reported here:
https://groups.google.com/forum/#!topic/leo-editor/hPwPG9OTC3U

This no longer seems to be a problem.
</t>
<t tx="davy.20141209154025.163">https://bugs.launchpad.net/leo-editor/+bug/1266269
Mac: alt-x does not work in body pane

No problem with a clean homebrew install on MacOS 10.9 Mavericks.
</t>
<t tx="davy.20141209154025.164">https://bugs.launchpad.net/leo-editor/+bug/1268970

This works for me (Windows 7 and Ubuntu) with Python 2.7.8, PyQt version 4.8.6.
</t>
<t tx="davy.20141209154025.165">[Fixed?] https://bugs.launchpad.net/leo-editor/+bug/1282362
shadow file name collisions cause spontaneous clone creation

Works for me. Furthermore, the scenario is bizarre enough not to be important.

- Create a new leo file.
- Create @shadow foo.txt
- Set body to @others, add two children, with different body texts.
- Copy / paste the @shadow node, change the path to x/foo.txt

(In shell, create x folder, saving shadow doesn't create path, which is
maybe another bug) save and close file

open file again, children of shadow nodes are clones of each other. I think
it's the name collision, not the copy pasting etc.

</t>
<t tx="davy.20141209154025.166">https://bugs.launchpad.net/leo-editor/+bug/869098
Context menu settings lost if save as used

This report appears invalid.

The renamed file uses the @data contextmenu_commands node in that files.

Note that @data contextmenu_commands node in the file *replaces* any other
@data contextmenu_commands node in leoSettings.leo or myLeoSettings.leo.

</t>
<t tx="davy.20141209154025.167"></t>
<t tx="davy.20141209154025.168">In an earlier post I said:

QQQ

Strictly speaking, tab cycling doesn't have to be disabled for all colon
commands. One could imaging a list of commands that use tab to complete
file names. Otoh, maintaining that list would be clumsy, and it would add
still more special cases to ga.do_tab.

QQQ

This post describes a much better way, done at rev 3994eca.

The new code is gorgeous, if I do say so myself. Even better, the solution
is a design pattern with many applications.

The trick is to replace functions implementing commands by classes having
`__call__` methods. See the P.P.S for details.

Yes, this has all been done before. Several of Leo's commands are
implemented this way. But read on...

What's new is that classes can "advertise" their ability to do various
things. Here, the classes implementing vim commands advertise, by having a
tab_callback method, that they want to handle a tab that follows their
name. ga.do_tab then defers to the vim command.

There are several really cool things about this code.

1. ga.do_tab, and its helper, ga.do_tab_callback, no longer know *anything*
    about colon commands, or what any command intends to do with the
    tab(!!). If the command handler has a tab_callback attribute,
    ga.do_tab_callback just does::

     ga.reset_tab_cycling()
     k.functionTail = tail # For k.getFileName.
     handler.tab_callback()

Nothing could be simpler, or more general.

2. The code in the command classes is simplified as well. No need for a
   kludgy test event.get_arg_value. See the P.S. for the full
   implementation of the :tabnew command.

The overall result is a spectacular collapse in complexity, which the
attendant increase in power and generality.

Edward

P.S. Here is the flattened form of the class that handles the :tabnew
command (does not require vim-mode). In particular, note that the __call__
and tab_callback methods are trivial. This is the way it is written in The
Book.

class Tabnew:
    '''
    A class to handle Vim's :tabnew command.
    This class supports the do_tab callback.
    '''
    def __init__(self,vc):
        '''Ctor for VimCommands.tabnew class.'''
        self.vc = vc
    __name__ = ':tabnew'
        # Required.

    def __call__(self,event=None):
        '''Prompt for a file name, the open a new Leo tab.'''
        self.vc.c.k.getFileName(event,callback=self.open_file_by_name)
       
    def tab_callback(self):
        '''Called when the user types :tabnew&lt;tab&gt;'''
        self.vc.c.k.getFileName(event=None,callback=self.open_file_by_name)
       
    def open_file_by_name(self,fn):
        c = self.vc.c
        if fn and not g.os_path_isdir(fn):
            c2 = g.openWithFileName(fn,old_c=c)
            try:
                g.app.gui.runAtIdle(c2.treeWantsFocusNow)
            except Exception:
                pass
        else:
            c.new()

P.P.S. This pattern is particularly well suited to Leo, because the various
getPublicCommands methods reference those functions when create command
dictionaries. Here, we replace just two entries in the dict::

    ':r':   vc.LoadFileAtCursor(vc),
    ':tabnew': vc.Tabnew(vc),

This creates instances of the LoadFileAtCursor and Tabnew classes. In other
words, we replace a function by an instance of a class. All such classes
must have __call__ methods, so that Leo can "call" the instance as if it
were a function.
</t>
<t tx="davy.20141209154025.169">One change is required to all plugins and scripts:

    body.bodyCtrl.x -&gt; body.wrapper.x
    
There is a script that does this automatically.

What I did
- Created "@test interfaces using API classes" based on the checking script.
- The various isTextWidget methods now check for the existence of a supportsHighLevelInterface ivar.
- StringTextWrapper is now a stand-alone class.
- Removed BaseTextWrapper.
- LeoLog is no longer a subclass of the HighLevelInterface class.
  This required a hack to handle keystrokes in the log pane:
  k.masterKeyHandler sends strokes to c.frame.log.logWidget (a QTextEditWrapper)
  by changing event.widget.
  QTextMixin sets supportsHighLevelInterface = True as a signal to k.handleDefaultChar.
- Eliminated redirection code from LeoQtBody class.
- LeoBody is no longer a subclass of the HighLevelInterface class.
    - The only changes, one or two new guards.
- Create WrapperAPI class whose text indicates expected type of the result.
- Removed wrapper.getFocus method.
- Removed all references to HighLevelInterface class in the core.
- Removed the evil set_focus synonym in the HighLevelInterface class.
</t>
<t tx="davy.20141209154025.17">- Regularized .wrapper and .widget ivars.
- Added the IdleTime class.
- Added p.nosentinels
- Converted all class names to pep8 styleCapitalized, no underscores.
- Removed g.choose from Leo's core &amp; plugins.
- Improved handling of gnx's.
- Improved p.isAncestorOf and c.positionExists
- Improved speed of selection logic.
- Rewrote &amp; simplified k.getArg.
- Simplified gnx scan logic
- Split qtGui.py into separate files.
- Generalized importers.
- The @auto write code now uses writer plugins.
- Leo imports importers &amp; writers from home/.leo.
- Leo now uses the following namespace in .leo files::

    &lt;leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" &gt;
    
- c.executeScript adds '.' to sys.path.
</t>
<t tx="davy.20141209154025.170">It is not possible to use both the PyQt4 and PyQt5 installers at the same
time. But this is no big deal on Windows: just install PyQt5 for Python 3.4
only.
</t>
<t tx="davy.20141209154025.171">@language rest

Rev 060c33a contains a spectacular collapse in complexity in idle-time
handling.

Instantly, registering idle-time event handlers can be considered
deprecated, though I have no plans to remove the horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy::

@language python

    def IdleTime(c,handler,delay=500):
        '''A proxy for the g.app.gui.IdleTime class.'''
        if g.app and g.app.gui and hasattr(g.app.gui,'idleTimeClass'):
            return g.app.gui.idleTimeClass(c,handler,delay)
        else:
            return None
            
@language rest

g.IdleTime ensures that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

@language python

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()
    
@language rest

The code creates an instance of the IdleTime class that calls the given
handler at idle time, and no more than once every 500 msec. Here is the
output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

@language python

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()
        
@language rest

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.172">Fixed an important bug in addNode, a helper of createOutline: There was a
confusion about commanders: p is in the old commander. p2 must be in the
new commander.

Disabled a few unit tests when run externally:
This was due to missing nodes or copies of clones not being cloned.
</t>
<t tx="davy.20141209154025.173">- Converted all class names to pep8 style
- Removed g.choose from Leo's core &amp; plugins
  This function is deprecated: use Python's ternary operator instead.
</t>
<t tx="davy.20141209154025.174">Leo's core now calls k.setStatusLabel, not k.setLael, to report the status
of a Leo command. This allows an option (does not exist yet) to use g.es
instead of the minibuffer to report status.
</t>
<t tx="davy.20141209154025.175">Changed k.inverseCommandsDict to c.inverseCommandsDict.
Called vc.define commands from c.finishCreate.
Changed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
The new c.createCommandNames copies entries in g.app.global_commands_dict to commander c.
    Note: @g.command makes entries in g.app.global_commands_dict.
</t>
<t tx="davy.20141209154025.176">@language rest

This post will summarize what has already been done and what will be done in the next few days.  Let's start with the basics...

===== About wrappers and widgets

Wrapper and widget classes are at the heart of Leo's design. Clarifying the
relationships between wrappers and widgets started the present avalanche.

Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly. Instead...

2. A **wrapper class** defines a standard api that hides the details of the
   underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code
treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All
wrapper classes define an official "widget" ivar, so core or plugin code
can gain access to the real Qt widget using wrapper.widget. Searching for
wrapper.widget will (or soon will) find all gui-dependent snippets of code
in Leo's core.

3. Wrappers are crucial, even if Leo *always* uses the Qt gui.

This has just become crystal clear to me. Indeed:

- Wrappers allow users to choose different Qt widgets for the body pane,
  without changing *any* of Leo's core code (except the startup code).

- Wrappers allow Leo's text-handling code to remain unchanged regardless of
  whether the body or log panes are a QTextBrowser or a QsciScintilla
  widget.

- Without wrappers, all of Leo's text-editing commands would have to know
  the details of the api of the actual Qt text widget!

==== Summary of the avalanche

Here is what is happening now in Leo's code base, and in my thinking!

1. A collapse in the complexity of relationships between Leo's most
   important classes and between the files containing those classes.

qt_text.py was supposedly a minor reorg. Wrong! It has become the road map
to the reorganization of all of Leo's fundamental classes:

- qt_text.py is *self contained*: it doesn't depend on any other classes!

- qt_text.py defines a QTextMixin class. This is a new kind of class for
  me. As its name suggest, it is not so much a base class as a helper
  class. It provides helper code for all of Leo's Qt wrapper widgets.

- All the classes that use QTextMixin implement the HighLevelInterface
  class in leoFrame.py.

The HighLevelInterface class will soon morph into the WrapperInterface
class. Th WrapperInterface class will contain only the definition of
methods and their docstrings. Unlike the HighLevelInterface class, the
WrapperInterface will contain *no* redirection code!

- If we were (heaven forbid) going to change Leo's gui, we would simply use
  a copy of qt_text.py, say new_gui.text.py, as a starting point.

2. All "redirection" code will soon be gone.

Ville, Terry and I will be much happier. Eliminating this cruft makes Leo's
code both lighter and thicker, to use the go terminology. It's lighter
because there is far less blah, blah, blah. It's thicker because there is
less to check and to fail.

It's easy to eliminate redirection. For example, the LeoBody methods that
just call the corresponding wrapper methods will soon be gone. We'll
change::

    c.frame.body.wrapperMethod

to::

    c.frame.body.wrapper.wrapperMethod

Doh! This should have been done years ago. Yes, it's more verbose, but it's
also more explicit. Furthermore, few such calls actually exist!

3. widget.widget and other type-checking horrors will soon be a thing of
   the past.

New coding conventions will remove all confusion between wrappers and
widgets. Wrappers will *always* be called wrappers, never widgets.

There is/was something both fundamentally wrong and confusing about
widget.widget. The first widget must have a different type than the second,
but there is *no* indication of this fundamental fact. The reorg changes
widget.widget to wrapper.widget everywhere.

4. I have a new approach toward type checking.

It is obvious now, in retrospect, that clarity of design is something much
more important than type checking! Leo's code will soon make the types of
objects *explicit* and this far more important in practice than even
"perfect" static type checking. This is a revolution in my thinking.

pylint, while supremely important for day-to-day programming, is *totally
inadequate* to have produced the design changes I have been discussing.

Now that widgets are always clearly distinct from wrappers, we could
imaging type-checking assertions to verify their apparent types. Imo, such
assertions are seldom pythonic, but in this case assertions might be good
documentation, if nothing else. The assertions would be based on the
following functions:

- g.isWrapper(obj): calls g.app.gui.isWrapper(obj)
- g.isWidget(obj): calls g.app.gui.isWidget(obj)

5. A dead-easy script shows how to enforce the relationships between types
   that really matter.

This is a big Aha. The script merely compares dir(o1) with dir(o2), where
o1 is the "template" HighLevelInterface class in leoFrame.py and o2 is one
of QTextEditWrapper or QScintillaWrapper. You could call this the "back
door" approach to type checking. It's sooo easy! No more messing with
ast's!

As a result of running this script, (given in the P.P.S.) I was able to
removed cruft from both the HighLevelInterface class, and other parts of
Leo's code.

===== Summary

None of these massive changes adds anything directly to Leo :-)

However, they make understanding and changing Leo's code far easier and
more pleasant. Leo's code is now more beautiful.

Imo, these changes are long overdue. They fundamentally improve Leo's code
base.

That's all for now. I'll keep you posted as I change code, but this post
covers all the essentials.

Edward

P.S. git and easier access to pylint contributed to the present avalanche
of energy and ideas.

Git has allowed me to revise Leo's source code radically, with complete
safety. I would never have done what I have done lately with bzr.

Leo's new pylint command allows me to run pylint *easily* on one or more
"recent" files, *without* having to change any list. As a result, I run
pylint much more often.

P.P.S. Here is the script that checks that all text wrapper classes
implement all required methods. This is, to the first approximation, the
only type checking that Leo really needs. It will probably become a unit
test.

@language python

    import leo.core.leoFrame as leoFrame
    import leo.plugins.qt_text as qt_text
    from leo.core.leoQt import Qsci,QtWidgets
    
    h = leoFrame.HighLevelInterface(c)
    w = Qsci.QsciScintilla()
    tw = QtWidgets.QTextBrowser()
    q = qt_text.QScintillaWrapper(widget=w,c=c,name='test')
    t = qt_text.QTextEditWrapper(widget=tw,name='test2')
    
    h_list = [z for z in sorted(dir(h)) if not z.startswith('__')]
    t_list = [z for z in sorted(dir(t)) if not z.startswith('__')]
    q_list = [z for z in sorted(dir(q)) if not z.startswith('__')]
    ignore = [
        'set_focus', # synonym for setFocus
        'mutable_methods', # To be removed.
    ]
    for z in h_list:
        if z not in t_list and z not in ignore:
            print('QTextEditWrapper: not in HighLevelInterface: %s' % z)
    for z in h_list:
        if z not in q_list and z not in ignore:
            print('QScintillaWrapper: not in HighLevelInterface: %s' % z)
    print('done')

@language rest

=====

This project appears to be a complete success. No further work is planned.
I have encountered no problems at all during this reorg, and don't expect
any, but we shall see...

Here are the highlights:

1. *All* of the odious redirection code in Leo is gone.
 
The redirection code appeared in various places, especially in the
HighLevelInterface class.

2. The HighLevelInterface class is gone: the LeoBody and LeoLog classes are
   now subclasses of object.

3. The logCtrl property is gone: the LeoLog class now defines a .logCtrl
   ivar.

This ivar is inherently tricky: depending on which log *tab* is selected,
LeoLog.logCtrl may be either a wrapper or a widget!

Because LeoLog no longer contains redirection code a hack was needed.
k.masterKeyHandler redirects text-related events originally sent to the
c.frame.log to c.frame.log.logWidget, which, confusingly enough, is
actually a text wrapper.

4. leoFrame.py contains several new API classes: ColorizerAPI, IconBarAPI,
   StatusLineAPI and WrapperAPI.

No class is a subclass of these classes: they are for unit testing only.

The new unit test, "@test interfaces using API classes", checks that
classes implement all the methods in the corresponding API class. This is
not a perfect solution and it is no substitute for pylint. Nevertheless,
these API classes are good documentation, and they did result in a few new
methods being added to each tested "Null" class.

That's all! You may not believe it, but I think of all this work as being
related to fixing bugs. I'll now return more directly to bug fixes.
</t>
<t tx="davy.20141209154025.177">- ic.createOutline and its helper, ic.dispatch, now use tables
  created by ic.createImporterData and its helper.

- Eliminated odious special cases involving self.treeType in
  ic.create_top_node and ic.init_import.
  
- self.treeType is used only in a limited way in the scanner classes:
  The only tests are against '@root' and '@file'.
  
- For now, the unit-tests wrappers are hard-coded.
</t>
<t tx="davy.20141209154025.178">Rev 060c33a...Leo build: 20140825070951 contains a spectacular collapse in
complexity in idle-time handling. Instantly, registering idle-time event
handlers can be considered deprecated, though I have no plans to remove the
horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy:: g.IdleTime ensures
that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()
    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()

The code creates an instance of the IdleTime class that calls the given handler at idle time, and no more than once every 500 msec.  Here is the output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.179">- fc.getLeoFile now calls ni.begin/end_holding
- Added gnx keyword arg to VNode ctor.
- Added traces to pd.restore_gnx

What I did:
    
- checked all calls to VNode ctor.
- checked all calls to getNewIndex.
- checked all calls to fileIndex =
</t>
<t tx="davy.20141209154025.18">- clone-find-parents
- clone-to-last-node
- flatten-outline-to-node
- focus-to-find
- focus-to-spell
- help-for-drag-and-drop
- insert-file-name
- pylint command
- style-reload

- spell as you type commands::

    spell-as-you-type-toggle
    spell-as-you-type-next
    spell-as-you-type-undo
    
- idle-time commands::

    disable-idle-time-events
    disable-idle-time-tracing
    enable-idle-time-events
    enable-idle-time-tracing
    toggle-idle-time-events
    toggle-idle-time-tracing
</t>
<t tx="davy.20141209154025.180">https://groups.google.com/d/msg/leo-editor/JWhlmJBiesk/RsC64VZ1gxQJ
</t>
<t tx="davy.20141209154025.181">@language rest

Simplified and generalized idle-time handling as follows:
    
- Removed g.app.afterHandler: g.app.idleTimeHook does the same thing now.
- The timer callback now calls g.app.idleTimeHook() if it exists.
- g.enableIdleTimeHook now has the following signature::
    
    def enableIdleTimeHook(idleTimeDelay=500,idleTimeHandler=None):
        
  The two args set g.app.idleTimeDelay and g.app.idleTimeHandler respectively.
  g.idleTimeHookHandler is used if idleTimeHandler is None.

The new code has these properties:
    
1. g.app.idleTimeHook() actually gets called only at idle-time,
2. There is no busy waiting, and
3. There is at least g.app.idleTimeDelay msec. between calls to g.app.idleTimeHook()

Here is an script illustrating the possibilities::

@language python

'''
A script illustrating interacting idle-time handlers.
Do Alt-x enable-idle-time-tracing before executing this script
'''
class Handlers:
    def h1(self):
        g.trace()
        g.enableIdleTimeHook(1000,self.h2)
    def h2(self):
        g.trace()
        g.enableIdleTimeHook(500,self.h1)
h = Handlers()
if g.app.idleTimeHook:
    g.disableIdleTimeHook()
else:
    g.enableIdleTimeHook(1000,h.h1)
</t>
<t tx="davy.20141209154025.182">- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
</t>
<t tx="davy.20141209154025.183">0. Added details timing traces throughout the selectHelper logic.
   These traces showed precisely where the performance bugs were.

1. updateSyntaxColorer now does nothing if the body text starts with @killcolor.

2. w.setSelectionRangeHelper and v.restoreCursorAndScroll had performance bugs
because they called code that computed the length of text slowly.

3. The solution: w.setSelectionRangeHelper and all setInsertPoint methods
now take an 's' keyword arg. In the selection logic, s is set to p.b.
If s is not None, the desired length is simply len(s)

As a result, w.setSelectionRangeHelper no longer calls lengthHelper.
lengthHelper used QTextCursor, which is *much* slower than getAllText.

4. Even though all w.setInsertPoint methods have an s keyword arg,
   v.restoreCursorAndScroll uses the following defensive code::
       
    try:
        w.widget.setInsertPoint(ins,s=v._bodyString)
    except TypeError:
        w.setInsertPoint(ins)
</t>
<t tx="davy.20141209154025.184">Leo now imports from ~/.leo/plugins before importing from leo/plugins.

The new code is in at.createWritersData &amp; helper and ic.at.createImportersData &amp; their helpers.
</t>
<t tx="davy.20141209154025.185">'''Load each plugins ~/.leo/plugins if possible, then from leo/plugins.'''
import glob
def report(message,kind,folder,name):
    g.trace('%7s: %5s %9s %s' % (message,kind,folder,name))
g.cls()
plugins1 = g.os_path_finalize_join(g.app.homeDir,'.leo','plugins')
plugins2 = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
seen = set() # set of (folder,sfn)
for kind,plugins in (('home',plugins1),('leo',plugins2)):
    if g.os_path_exists(plugins):
        for folder in ('importers','writers'):
            path = g.os_path_finalize_join(plugins,folder)
            pattern = g.os_path_finalize_join(plugins,folder,'*.py')
            for fn in glob.glob(pattern):
                sfn = g.shortFileName(fn)
                if g.os_path_exists(fn) and sfn != '__init__.py':
                    moduleName = sfn[:-3]
                    if moduleName:
                        data = (folder,sfn)
                        if data in seen:
                            report('seen',kind,folder,sfn)
                        else:
                            m = g.importFromPath(moduleName,path) # Uses imp.
                            if m:
                                seen.add(data)
                                report('loaded',kind,folder,m.__name__)
                            else:
                                report('error',kind,folder,sfn)
                # else: report('skipped',kind,folder,sfn)
@language python
</t>
<t tx="davy.20141209154025.186">For several years the xml namespace line at the start of .leo files has been::

    &lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;

The new line is::

    &lt;leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" &gt;
</t>
<t tx="davy.20141209154025.187">What I did:
- Removed prefix arg to all calls to k.getArg.
  Not needed now that there is better convention for k.setLabelBlue.
- Removed protect argument from k.setLabelBlue.
  Some code now uses k.extendLabel to mix protect and unprotected parts of the label.
  
- k.fnc and k.getArgInstance now created by finishCreate.
  This guarantees that the c,k and log ivars are inited properly.
- Allow &lt;tab&gt; to escape to :r and :tabname code.
  This required several kludges.

</t>
<t tx="davy.20141209154025.188">1. createSaxVnode now does::
    
    v.fileIndex = ni.tupleToString(x.scanGnx(sax_node.tnx))
    
ni.tupleToString is substantially simpler than ni.toString.

This is the only call to tupleToString in Leo.

2. Removed ni.toString.

3. ni.scanGnx no longer converts n to an int.  It's going to become a string again anyway.

4. The new fc.setMaxNodeIndex *does* convert the n field to an int, but
   this very rarely happens.
</t>
<t tx="davy.20141209154025.189">- qt_big_text.py contains support for the "big text" warning buttons.

- qt_commands.py contains several commands created by @g.commands.
  qt_gui.py now imports this file so the commands are actually defined.

- qt_events.py contains the LeoQtEventFilter class. The LeoKeyEvent class
  remains in leoGui.py: it is independent of gui.

- qt_frame.py contains most of the Qt-related code that creates the Leo
  window and frames.
  
- qt_idle_time.py contains the IdleTime class.

- qt_gui.py contains Qt-specific code that defines g.app.gui. leoGui.py is
  the gui-independent code and was essentially unchanged.

- qt_quickheadlines.py contains the QuickHeadlines class.

- qt_text.py contains most the code for Leo's Leo's text widgets.
  leoFrame.py contains a few gui-independent classes.

- qt_tree.py contains all the Qt tree code. It replaces baseNativeTree.py.

No longer used: baseNativeTree.py, qtGui.py. qtGui.py still exists, but
just prints a warning message when imported.
</t>
<t tx="davy.20141209154025.19">- Improved find/replace-all commands.
- The beautify command now optionally uses PythonTidy.
- check outline now tests that all gnx's exist and are unique.
- Added Yes To All and No To All buttons to dialogs.
- Added warning buttons when selecting large text.
- Added some support for scintilla.
- Added support for delegate languages.
- Added support for the dart language.
- The clean-all-lines command now strips trailing whitespace.</t>
<t tx="davy.20141209154025.190">What I did:
- at.createWritersData inits tables using the writers_dict in each plugin.
- at.writeOnAtAutoNode calls at.dispatch to find writers.
  An important escape hatch: at.writeOnAtAutoNode calls the *existing* rst.writer
  if the user deletes plugins/writers/rst.py.

Won't do:
- at.writeAllHelper has lots of special-case code, but that probably can't be helped.
- It would be way too dangerous to refactor the write code for @file, @shadow, etc.
</t>
<t tx="davy.20141209154025.191">A head-slapping moment: the so-called high-level interfaced throughout
Leo's core to interact with Leo's text panes lacks a way of getting the
length of text *without* making a copy of the text.

This is more than a slight oversight: I imagine there are several place
were the code does s = w.getAllText() merely so it can use len(s)! This is
a huge strain on the GC for large p.b.

Worse, the absence of w.getTextLength() has lead to the most unfortunate
LeoQTextEditWidget.lengthHelper, which calculated the length of the text
using QTextCursor methods! This is catastrophically slow for large text.
This method was doubling node load times for large nodes.

@language rest

In other words, w.getTextLength() is an essential part of fixing git bug 28:
https://github.com/leo-editor/leo-editor/issues/28

But nooooooo... w.getTextLength() is far from easy to do. There is no
QTextEdit or QTextDocument method that delivers the length of the text!
This is a *huge* hole in the QTextEdit and QTextDocument api's, but there
is nothing we can do about that.

The simplest thing that could possibly work would be::

@language python

    def getTextLength(self):
        w = self.widget
        return len(w.getAllText())
        
@language rest

But this would be a step backwards because it hides the fact that it is
expensive.

It might be possible to cache the value of w.getAllText in an "text
changed" event handler in LeoQTextBrowser:(QTextBrowser). But I would like
to avoid this approach--any bug would lead to data loss or corruption. I
may play around with this, but for now it's not likely to happen. See below
for a workaround.

By analogy with w.getTextLength(), we can imagine a p.b_length method that
would simply return len(p.v._bodyString). This, at least, is worth doing.

===== Summary

w.getTextLength() isn't trivial.

Caching the value returned by w.getAllText() seems too dangerous.

As a work-around, the crucial node-selection logic will attempt to minimize
calls to w.getAllText. There, and *only* there, it should be possible to
create a *single* copy of the text and pass that copy around to all code
that needs it. It would be a complication, but a completely safe one.

Otoh, p/v.b_length are trivial and useful. They will be added asap.

-------------

Two parts to this reply:

===== Part 1: defining w.getTextLength

&gt; w.getTextLength() isn't trivial...Caching the value returned by
w.getAllText() seems too dangerous.

Actually, defining w.getTextLength using a textChanged event handler in
LeoQTextBrowser is straightforward::

@language python

    def onTextChanged(self):
        '''The textChanged event handler.  Cached the text in self.leo_s.'''
        self.leo_s = s = g.u(self.toPlainText())

    def getTextLength(self):
        '''Return the length of all the text.'''
        if 1: # safe.
            s = g.u(self.toPlainText())
            if s != self.leo_s:
                g.trace('can not happen: text mismatch.')
                self.leo_s = s
            return len(self.leo_s)
        else: # fast
            return len(self.leo_s)
            
@language rest

We can use the "safe" version of getTextLength until we are *sure* the can
not happen message never happens ;-)

Otoh, we must be careful: onTextChanged will be called in the middle of the
node-switching logic.

===== Part 2: doing without w.getTextLength

Imo, the simplest thing that could possibly work is to avoid the extra call
to w.getAllText in the node switching logic in selectHelper.

Here are the relevant parts of selectHelper. (w is a LeoQTextEditWidget).

1. setBodyTextAfterSelect *already* calls w.getAllText() to get the
   "before" text. This is unavoidable.

The "after" text will be p.b, where p is the *new* position.

2. restoreCursorAndScroll calls w.setInsertPoint, which just calls
   w.setSelectionRangeHelper.

3. w.setSelectionRangeHelper is the problem It used to call the horribly
   slow lengthHelper. Now it calls w.getAllText()

But w.getAllText must be the new p.b! So the selectHelper logic could
simply pass an optional s argument to w.setInsertPoint and
w.setSelectionRangeHelper. If present, setSelectionRangeHelper will use s
rather than calling w.getAllText.

Imo, this is the safe, if not exactly elegant way.
</t>
<t tx="davy.20141209154025.192">https://groups.google.com/forum/#!topic/leo-editor/cYWigOYtjUM

c.executeScript places '.' as the *second* element of
sys.path, following c.frame.openDirectory as before.
</t>
<t tx="davy.20141209154025.193"></t>
<t tx="davy.20141209154025.194"></t>
<t tx="davy.20141209154025.195">The focus-to-spell command just makes the spell tab visible.

It would not be a good idea actually to transfer focus.
</t>
<t tx="davy.20141209154025.196">As of rev 1d882d3. Leo supports an undoable clone-find-parents command.
Select a cloned node, then do:

    &lt;alt-x&gt;clone-find-parents&lt;return&gt;

This works somewhat like the clone-find-all command: it creates a node containing
clones of all the parents of the selected node.
</t>
<t tx="davy.20141209154025.197">This does *not* change the selected node so it's easy to
clone several nodes.

Added c.cloneToLastNode.  
</t>
<t tx="davy.20141209154025.198">Very useful when summarizing documentation nodes.
</t>
<t tx="davy.20141209154025.199"></t>
<t tx="davy.20141209154025.20">- Added livecode.py plugin.
- Added nodetags.py plugin.
- Added viewrendered2.py plugin.
- Added wikiview.py plugin.
- Most plugins now work with PyQt5.
- Added leo/external/leoftsindex.py.
- Rewrote at_produce.py plugin.
</t>
<t tx="davy.20141209154025.200">Added the following commands:
    
disable-idle-time-tracing
enable-idle-time-tracing
toggle-idle-time-tracing
disable-idle-time-events
enable-idle-time-events
toggle-idle-time-events
</t>
<t tx="davy.20141209154025.201"># The code is in leoEditCommands.py::insertFileName.
</t>
<t tx="davy.20141209154025.202">When pylint is available on your machine, Leo's pylint
command will execute run pylint on all @&lt;file&gt; nodes in the
selected tree. This command is now available from the popup
menus created by the contextmenu plugin.

This command is a dynamic way of selecting files to check
with pylint. It is *much* easier to use than the old pylint
-r option in pylint-leo.py. There is no longer any need to
update a list of "recent" files. Hooray.

The command has significantly changed my work flow. I use
pylint much more often.

The details of the search process are as follows:

1. The command looks down the tree of the selected node,
   looking for @&lt;file&gt; nodes.
2. If now @&lt;file&gt; nodes are found, it looks up the tree,
   looking for @&lt;file&gt; nodes.
3. If the selected node is a clone, and no @&lt;file&gt; nodes
   have yet been found, it expands the search to all
   ancestors of all positions cloned to the selected node.

This means that you can check a file by selecting any
(possibly clone) node of the file.

**Important**: running pylint-leo.py is still often very
useful. In particular, I often run python pylint-leo.py -a
to check all files. Here is the recently improved docstring
for pylint-leo.py::

    '''
    This file runs pylint on predefined lists of files.
    
    The -r option no longer exists. Instead, use Leo's pylint command to run
    pylint on all Python @&lt;file&gt; nodes in a given tree.
    
    On windows, the following .bat file runs this file::
        python27 pylint-leo.py %*
    
    On Ubuntu, the following alias runs this file::
        pylint="python27 pylint-leo.py"
    '''
</t>
<t tx="davy.20141209154025.203">Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
</t>
<t tx="davy.20141209154025.204"></t>
<t tx="davy.20141209154025.205">These commands now get their arguments from the Find Panel.

Changed the following methods:

generalChangeHelper,
minibufferFind/ReplaceAll,
searchWithPresentOptions,
setReplaceString,

Also fixed the bindings in create_find_buttons so buttons
are bound to the proper button-related methods. As a result,
the find-all and change-all buttons now work as expected.
</t>
<t tx="davy.20141209154025.206">This is a major upgrade to the beautify command.

PythonTidy (tidy for short) does a full parse of the Python sources:
https://pypi.python.org/pypi/PythonTidy/

What I did today.  See the &lt; &lt; version info &gt; &gt; section for all the details::

1. Leonized tidy's sources: @file ../external/PythonTidy.py in in LeoPyRef.leo.

- Removed all pylint complaints and made other minor mods.
 
2. Suppressed features not appropriate for Leo:

- Adds shebang and encoding lines only for @&lt;file&gt; nodes.
- Suppress extra spacing between classes &amp; functions.

3. Added settings to leoSettings.leo that control tidy operation:

    @bool tidy_add_blank_lines_around_comments =True
    @bool tidy_double_quoted_strings = False
    @bool tidy_keep_blank_lines = True
    @bool tidy_left_adjust_docstrings = False
    @int  tidy_lines_before_split_lit = 2
    @int  tidy_seps_before_split_line = 8

3. Fixed several important bugs:

- The original code deleted all comments because of a botch in Comments__init__.
- Tidy now properly handles the tidy_add_blank_lines_around_comments and
  tidy_double_quoted_strings settings.
</t>
<t tx="davy.20141209154025.207">It now tests that all gnx's exist and are unique.
</t>
<t tx="davy.20141209154025.208">Added YesToAll and NoToAll capability to g.app.gui.runAskYesNoDialog
and uses this in the open file again? questions when opening Leo after a
crash.
</t>
<t tx="davy.20141209154025.209">Used glob to discover files, not static lists.
</t>
<t tx="davy.20141209154025.21">- Added --no-persist command-line option.
- Added --trace-plugins command-line option.
- Added settings that control PythonTidy-based beautify command::

    @bool tidy_add_blank_lines_around_comments =True
    @bool tidy_double_quoted_strings = False
    @bool tidy_keep_blank_lines = True
    @bool tidy_left_adjust_docstrings = False
    @int  tidy_lines_before_split_lit = 2
    @int  tidy_seps_before_split_line = 8

- Added @bool auto-scroll-find-tab
- Added support for html handlebar syntax coloring.
- Leo's main style sheet is fully parameterized.
- The style-reload command reloads visual settings.
- Leo stylesheets now support all color names in leoColor.py.
</t>
<t tx="davy.20141209154025.210"></t>
<t tx="davy.20141209154025.211"></t>
<t tx="davy.20141209154025.212">I have been using a Scintilla widget in Leo's body pane today. It has been
the best incentive to improve it.

To enable it, set @bool qt-use-scintilla = True.

Almost everything works. It is certainly seems possible to do real work
safely and pleasantly.

The Scintilla code now honors the settings in @data qt-scintilla-styles,
but *only in leoSettings.leo, not myLeoSettings.leo. This is likely a bug
in the settings system, and I'll fix it soon.

Leo now switches between the native Scintilla colorizer and a custom,
do-nothing, colorizer depending on @language, @killcolor, etc. Creating a
custom Scintilla colorizer was unexpectedly easy. There is no native
Scintilla colorizer for @language rest. That will be the next custom
colorizer that I write.

Scintilla thinks Leo directives are decorators, so Leo directives are, in
effect, colorized.

No section references are ever colored. It *might* be possible to define a
custom colorizer that defers to a native colorizer in everything but
section references.

Most unit tests pass with @bool qt-use-scintilla = True. Something strange
is going on in the failing cases, but it doesn't seem strange enough to
cause real problems ;-) I'll be fixing these tests asap.

No other colorizing is available, but everything is in place to support
Scintilla's other native colorizers. They are:

AVS, Bash, Batch, CMake, CoffeeScript, CPP, CSS, D, Diff, Fortran77, HTML,
Lua, Makefile, Matlab, Pascal, Perl, PO, PostScript, POV, Properties,
Python, Ruby, Spice, SQL, TCL, TeX, Verilog, VHDL, YAML.
</t>
<t tx="davy.20141209154025.213"></t>
<t tx="davy.20141209154025.214">Allow colorizing for languages to be delegated to another language.

- Added g.app.delegate_language_dict, with three entries for David McNab.

- jEditColorizer.nameToRuleSetName now replaces the original language name
  with the delegated name.
  
There are two other changes you must make if you don't want
to use @language, as in your example with @nosent trees.

1. To write the proper delims for .hbs files, add the
   following entry in define_language_delims_dict in
   leoApp.py::

    "hbs" : "&lt;!-- --&gt;", # McNab: delegate to html.

2. To automatically use @language hbs in .hbs files, add the
   following entry in define_extension_dict in leoApp.py:
</t>
<t tx="davy.20141209154025.215"></t>
<t tx="davy.20141209154025.216">Replaced by new focus-to-find and focus-to-spell commands.
</t>
<t tx="davy.20141209154025.217"></t>
<t tx="davy.20141209154025.218"></t>
<t tx="davy.20141209154025.219">Then livecode-show command shows the live code evaluation pane. Hover on
the buttons for helpful tool-tips.

It currently has a dependency on https://pypi.python.org/pypi/meta
which you can install with

    pip install meta

The dependency on `meta` is for recursively turning AST node trees back
into printable identifiers like "m[m[5]]"

i.e.

   a = 7

is easy,

   m[m[5]] = 7

is not.
</t>
<t tx="davy.20141209154025.22">* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - Leo available via github repository.
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
    - The style-reload command changes Leo's appearance instantly.
* Important new plugins for tagging, display and node evaluation.
</t>
<t tx="davy.20141209154025.220">This is only an API for tags, but I feel like it should simplify the
process and allow someone to focus on the important bits, i.e. UI hooks,
rather than low-level details. Also, it's usable now for scripts.

Here is the docstring:

Provides node tagging capabilities to Leo

By Jacob M. Peck

API
----

This plugin registers a controller object to c.theTagController, which
provides the following API::

    tc = c.theTagController
    tc.get_all_tags() # return a list of all tags used in the current
outline, automatically updated to be consistent
    tc.get_tagged_nodes('foo') # return a list of positions tagged 'foo'
    tc.get_tags(p) # return a list of tags applied to the node at
position p; returns [] if node has no tags
    tc.add_tag(p, 'bar') # add the tag 'bar' to the node at position p
    tc.remove_tag(p, 'baz') # remove the tag 'baz' from p if it is in
the tag list

Internally, tags are stored in `p.v.unknownAttributes['__node_tags']` as
a set.

UI
----

The "Tags" tab in the Log pane is the UI for this plugin.  The bar at
the top is a search bar, editable to allow complex search queries.  It
is pre-populated with all existing tags in the outline, and remembers
your custom searches within the given session.  It also acts double duty
as an input box for the add (+) button, which adds the contents of the
search bar as a tag to the currently selected node.

The list box in the middle is a list of headlines of nodes which contain
the tag(s) defined by the current search string.  These are clickable,
and doing so will center the focus in the outline pane on the selected node.

Below the list box is a dynamic display of tags on the currently
selected node.  Left-clicking on any of these will populate the search
bar with that tag, allowing you to explore similarly tagged nodes.
Right-clicking on a tag will remove it from the currently selected node.

The status line at the bottom is purely informational.

The tag browser has set-algebra querying possible.  Users may search for
strings like 'foo&amp;bar', to get nodes with both tags foo and bar, or
'foo|bar' to get nodes with either or both.  Set difference (-) and
symmetric set difference (^) are supported as well.  These queries are
left-associative, meaning they are read from left to right, with no
other precedence.  Parentheses are not supported. See below for more
details.

Searching
---------

Searching on tags in the UI is based on set algebra.  The following
syntax is used::

    &lt;tag&gt;&amp;&lt;tag&gt; - return nodes tagged with both the given tags
    &lt;tag&gt;|&lt;tag&gt; - return nodes tagged with either of the given tags (or
both)
    &lt;tag&gt;-&lt;tag&gt; - return nodes tagged with the first tag, but not the
second tag
    &lt;tag&gt;^&lt;tag&gt; - return nodes tagged with either of the given tags
(but *not* both)

These may be combined, and are applied left-associatively, building the
set from the left, such that the query `foo&amp;bar^baz` will return only
nodes tagged both 'foo' and 'bar', or nodes tagged with 'baz', but *not*
tagged with all three.

Tag Limitations
---------------

The API is unlimited in tagging abilities.  If you do not wish to use
the UI, then the API may be used to tag nodes with any arbitrary
strings.  The UI, however, due to searching capabilities, may *not* be
used to tag (or search for) nodes with tags containing the special
search characters, `&amp;|-^`.  The UI also cannot search for tags of
zero-length, and it automatically removes surrounding whitespace
(calling .strip()).
</t>
<t tx="davy.20141209154025.221">https://groups.google.com/d/msg/leo-editor/3dH_NSQ4TsQ/ueVewAn50ZcJ

https://groups.google.com/d/msg/leo-editor/BDzmytlSegw/C0IbSz0US54J

As mentioned in my previous post I'll attempt to elaborate on the plugin
I've used to make Leo more useful to me, in case it is useful for others
also. Apologies for the very long post, but I wanted get get all its
features and warts exposed here to get some feedback on whether others see
this as useful or that this is only valuable to me. If it's useful to
others then it may be worth polishing up quite a bit.

Why a better viewrendered plugin?
---------------------------------

I like to use reStructuredText (reST) for all of my note-taking, idea
development, project and task management and automation of desktop
activities (e.g. initiating a backup). You could say it is the control
center of my daily activities, including calculating and showing dashboards
of where I am and where I'm going.

This means I need a tool which seamlessly shows me the full-fidelity
browser-rendered version of what I am writing and be able to print my notes
for meetings, cut and paste nicely formatted output to my office e-mails
and documents, as well as show some of the material as a slideshow.

The existing *viewrendered* plugin couldn't seem to do what I needed
(especially math) and I was almost ready to abandon Leo again. This time I
bit the bullet and created a more capable renderer in viewrendered2 (VR2).
Initially I made a plugin that rendered, on demand, to my normal web
browser. This worked well, but I really thought live rendering like
"viewrendered" would be better, and for that I needed close control over
scroll positions etc. that I couldn't get with an external browser. So the
plugin became much more complex as I merged it with the existing
viewrendered plugin, but was ultimately more powerful and useful to me.

Objectives
-----------

* Show a "full" html representation of any reST node or tree, without an
  @rst root node, including more features than the existing viewrendered
  plugin:

  - proper html layout
  - math (mathjax, etc.)
  - clickable URLs
  - clickable hyperlinks within the page (e.g. TOC)
  - good quality zoom
  - cut and paste html with ctl-C
  - s5 slideshows
  - javascript
  - svg images
  - configurable css

* Allow showing of node tree rather than just the current node. This can
  give a better overview perspective of the tree contents.

* Be able to lock the rendering on the root node of a tree, to view the
  effect editing a sub-node within the larger html document.

* Provide proper rendering of any combination of node types in a tree, so long as
  they have been properly designated by @language directives (i.e. reST, text,
  code, css, ...).

* Allow viewing (and printing) of an entire source file from an @file type
root node.

* Be able to *export* any of these renderings to a full web-browser to take advantage
  of the large rendering window (especially for slideshows, as well as printing, saving output.
  
* Be able to integrate automatically executed code nodes intermingled with
  reST nodes to provide an automatic calculation-based "Notebook" or "Report"
  type output.

* Don't increase the dependencies of Leo.

Implementation
--------------

VR2 is implemented mostly as an ~600 line expansion of the update_rst
method in the viewrendered.py plugin. The text-oriented class used for
rendering in VR1 has been replaced by the QWebView class which provides the
full rendering functionality of a real web-browser. To make this flexible,
a toolbar has been attached to the top with a few controls.

Because I wanted to retain compatibility with VR1, I created the
viewrendered2.py plugin, but retained all the class naming which occurred
within VR1. This means that it remains compatible with the existing
mechanisms (like free_layout) of showing and creating panes for VR1. I
tried this with an expectation that it would fail, but it appears to work
without any unintended side-effects.

Tooltips have been added where Qt allows, with the philosophy that a user
shouldn't need a manual to use this pane.

VR2 has been used a lot under Windows 7 and a little under Ubuntu 13.10.

Issues / Limitations
--------------------

I use VR2 every few minutes every working day. However, VR2 is likely to
still have a lot of rough edges and, in particular, bugs that show up with
different work flows or css folder layouts etc. In fact, VR2 is still a
work in progress and therefore still being fiddled with, so bugs creep in
regularly.

But overall, my perception of its deficiencies are:

* Does not handle reST headings within the node bodies well (sometimes very
  slow render, blocking Leo).

  - VR2 attempts to reconcile reST headings that originate from explicit
    headings within the nodes against reST headings that are automatically
    generated by the node hierarchy. In many cases, this is impossible,
    resulting in many errors which drastically slows down rendering. -
    Recommend not using headings within the nodes themselves, leaving the
    node hierarchy to do this automatically.

* If the node triggers one of the special viewrendered node header types
  (@md, @image, @movie, @html) VR2 simply defaults to the old handlers for
  those types. This means it jumps back to whatever pane type VR1 uses, so
  the features of VR2 disappear. I suspect that VR2 could incorporate these
  types into the new version and retain these new features. I should look
  at that.
    
* Doesn't integrate with rst3 plugin, especially honouring @others etc.
  There are some conflicts in objectives, so this may never be fully
  resolved. It would probably make sense for rst3 settings to get used for
  VR2 as well, along with additional VR2 specific settings. Currently, VR2
  has its own @settings-style settings. The rst3 code is not used.
  
* For slideshow purposes, a patch to docutils s5_writer is required to be
  able to handle an arbitrary hierarchy of nodes (forces all headings to
  start a new slide). Otherwise, only the 2nd level nodes (from the root)
  force a new slide.
  
* The integration of VR2 code into the existing viewrendered plugin code is
  rudimentary. I took the shortcut of not trying to understand this code
  well and confining my integration to the rst rendering only. Better
  integration would be a good future step.

With the plugin being able to execute javascript etc. there may be some
form of security issue, but I can't see it myself (given that Leo can
execute arbitrary python code anyway). Any thoughts?

Future?
-------

* Expand the export button if pandoc is installed, adding optional output
  formats such as docx, odt, plus additional slideshow formats. * Use new
  reST functionality to replace other media viewrendered methods for
  images, svg, movies, etc. * Integrate better with rst3?

Conclusion
----------

* I've attached the source as well as a bunch of screenshots. Feel free to
try out the source by putting viewrendered2 into your @enabled-plugins
instead of the usual viewrendered. I'd be interested in whether it works or
not - expect bugs to show up!

* I'm looking for feedback on whether this appears useful to others and not
just me. If so, it should probably be polished a bit more before being used
widely. Perhaps greater understanding of the existing viewrendered plugin
operation would help me here.
</t>
<t tx="davy.20141209154025.222">Hides text in the body editor, each time a new node is selected. Makes::

  file://#some--&gt;headlines--&gt;mynode     appear as mynode,
  http://www.google.com/search          appear as search, and
  `Python &lt;https://www.python.org/&gt;`_   appear as Python
  
There is a tiny dot to the left or right of the visible
text. Clicking that area, or clicking and dragging, or
clicking and using shift arrows *through* that area exposes
the hidden text.

full docs:
https://raw.githubusercontent.com/leo-editor/leo-editor/master/leo/plugins/wikiview.py

This plugin only addresses the visual aspects of wiki links.  Leo
already supports internal wikilinks as
file://#headline--&gt;other%20headline--&gt;Setup, which will now appear as
just 'Setup' with this pluing active.

</t>
<t tx="davy.20141209154025.223">active_path.py, attrib_edit.py, contextmenu.py, graphcanvas.py,
notebook.py, projectwizard.py, stickynotes.py
</t>
<t tx="davy.20141209154025.224">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Indexing files for full text search

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"
</t>
<t tx="davy.20141209154025.225">This plugin used ancient coding technology, created menu items instead of
minibuffer commands, did not report progress and was probably not thread
safe.

All these defects have now been remedied. It could be quite useful in some
situations. For example, suppose node P has this body text::

    @produce echo pylint commands
    @produce pylint -v
    @produce pylint -f core\leoAtFile.py
    @produce pylint -g

Selecting node P and running the at-produce-selected command produces these
messages in the log pane::

    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    at-produce done

And produces a node whose headline is::

    produce.log from Sun Sep 21 06:35:37 2014

And whose body text is::

    produce: echo pylint commands
    pylint commands
    ===============
    produce: pylint -v
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -v
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -v
    pylint-leo.py 1.1.0,
    astroid 1.0.1, common 0.61.0
    Python 2.7.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)]
    ===============
    produce: pylint -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -f core\leoAtFile.py
    pylint-leo.py: core\leoAtFile.py
    time:  5.000 sec.
    ===============
    produce: pylint -g
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -g
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -g
    pylint-leo.py: plugins\free_layout.py
    pylint-leo.py: plugins\nested_splitter.py
    pylint-leo.py: plugins\qt_commands.py
    pylint-leo.py: plugins\qt_events.py
    pylint-leo.py: plugins\qt_frame.py
    pylint-leo.py: plugins\qt_idle_time.py
    pylint-leo.py: plugins\qt_gui.py
    pylint-leo.py: plugins\qt_text.py
    pylint-leo.py: plugins\qt_tree.py
    time: 40.073 sec.
    ===============
</t>
<t tx="davy.20141209154025.226"></t>
<t tx="davy.20141209154025.227">removed new_auto switch in leoAtFile.py

added g.app.at_auto_persist

c.persistenceController exists only if g.app.auto_persist is True
</t>
<t tx="davy.20141209154025.228"></t>
<t tx="davy.20141209154025.229"></t>
<t tx="davy.20141209154025.23">Leo 5.0 final                       November 24, 2014

Leo 5.0-final is now available at:
http://sourceforge.net/projects/leo/files/Leo/

Leo is a PIM, an IDE and an outliner.
Video tutorials: http://leoeditor.com/screencasts.html
Text tutorials: http://leoeditor.com/tutorial.html

The highlights of Leo 5.0
--------------------------

* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Full support for Vim .otl outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Smoother installation:
    - Support for brew install leo on MacOS.
    - 'python setup.py install' now works.
    - pip install leo now works.
    - Leo is now a debian package.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - Command history for minibuffer commands.
    - Leo available via github repository.
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
    - The style-reload command changes Leo's appearance instantly.
* Important new plugins for tagging, display and node evaluation.
* For beginners:
    - Leo's default workbook files contains Leo's quickstart guide.
* Hundreds of new/improved features and bug fixes.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Videos:    http://leoeditor.com/screencasts.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Github:    https://github.com/leo-editor/leo-editor
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="davy.20141209154025.230">The default is True, so as to enable the "fix" to bug
1254861: find - ctrl-f doesn't ensure find input field
visible https://bugs.launchpad.net/leo-editor/+bug/1254861

I found the new behavior extremely unpleasant. For me, it
was the worst fit-and-finish issues with Leo.
</t>
<t tx="davy.20141209154025.231">These are colored with the previously unused literal3 tag,
so you specify the color with:

    @color html_literal3_color = pink
</t>
<t tx="davy.20141209154025.232">Almost all settings in @data qt-gui-plugin-style-sheet in leoSettings.leo
are now defined in terms of @values. Traditional Leo settings nodes
(@strings, @color, @font, etc.) define these @values.

Most users, and certainly all newbies, will never have to touch, or even
look at, @data qt-gui-plugin-style-sheet. This is a really good thing,
because the slightest syntax error silently messes up everything that
follows.

Notes:

1. There is now a node called "Basic Fonts (change these first)"
   This node contains the basic font definitions. Changing only the
   settings in this tree (in myLeoSettings.leo, of course) should be enough
   to get Leo looking pretty much as it was.

2. Don't even *think* about changing @data qt-gui-plugin-style-sheet.
   Really, the whole point of this exercise is to be able to change all
   aspects of Leo's appearance without touching this stylesheet. As Terry
   points out, there will always be a place for @data qt-gui-user-style-sheet

3. In an emergency, there is at present a node called "OLD
   qt-gui-plugin-style-sheet" that you could use to revert to the old
   settings. Just rename it and copy it to your myLeoSettings.leo.

4. The new settings scheme will moot the need for leo10pt.leo, leo12pt.leo
   and all the rest. Instead, all font sizes are now defined in terms of
   three intermediate settings: @string font-size, @string medium-font-size
   and @string small-font-size. Changing just these three settings will
   suffice to change *all* the font sizes used in Leo.

5. When things don't look right, I execute this script::

    c.styleSheetManager.print_style_sheet()

This prints the complete stylesheet to the console. What I mainly look for
are lines like::

    background-color: @some-setting

An @value as the value of a setting indicates that no substitution took
place, that is, that there is no node::

    @string some-setting = aValue

Any user that wants to roll their own @data node will want to be aware of
this technique.

5. The @data qt-gui-**user**-style-sheet setting is deprecated. Indeed,
   @data qt-gui-**plugin**-style-sheet now takes care to define almost
   everything that any user would want to define. myLeoSettings.leo should
   contain overrides of only the @color and @string nodes in
   leoSettings.leo.
</t>
<t tx="davy.20141209154025.233">For example, this setting works without any explicit definition of mistyrose2.
    
    @color head-bg = @mistyrose2
</t>
<t tx="davy.20141209154025.234">Leo 5.0 beta 2                  November 17, 2014

Leo 5.0b2 is now available at:
http://sourceforge.net/projects/leo/files/Leo/

This release fixes several installation issues
and updates installation instructions for Linux/Ubuntu.

Leo is a PIM, an IDE and an outliner.
Video tutorials: http://leoeditor.com/screencasts.html
Text tutorials: http://leoeditor.com/tutorial.html

The highlights of Leo 5.0
--------------------------

* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Full support for Vim .otl outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - Command history for minibuffer commands.
    - Leo available via github repository.
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
    - The style-reload command changes Leo's appearance instantly.
* Important new plugins for tagging, display and node evaluation.
* For beginners:
    - Leo's default workbook files contains Leo's quickstart guide.
* Hundreds of new/improved features and bug fixes.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Videos:    http://leoeditor.com/screencasts.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Github:    https://github.com/leo-editor/leo-editor
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="davy.20141209154025.235"></t>
<t tx="davy.20141209154025.236"></t>
<t tx="davy.20141209154025.237">See: http://leoeditor.com/vimBindings.html#using-leo-s-native-vim-mode

do_visual_mode will extend the selection if visual_line_mode is True.

Affected methods: vc.vim_V and vc&gt;do_visual_mode.

It would be good if LeoQTextEditWidget.setSelectionRangeHelper could handle
insert points in the middle of a text selection, but at present it can't.
</t>
<t tx="davy.20141209154025.238">Created g.run_pylint so pylint can run unmodified. This runs pylint (with
optional Sherlock tracing) in a separate process, thereby allowing Leo to
run pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    &lt;python&gt; -c "import leo.core.leoGlobals as g; g.run_pylint(&lt;args&gt;)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
</t>
<t tx="davy.20141209154025.239">Note: persistence applies to @auto-vimoutline-mode and @auto-org-mode

- Supported @auto-org-mode and @auto-vimoutline-mode
- Created importers and writers for .org and .otl files.
</t>
<t tx="davy.20141209154025.24"></t>
<t tx="davy.20141209154025.240"></t>
<t tx="davy.20141209154025.241">After Alt-x puts you in the minibuffer, you can now use UpArrow and
DownArrow keys to cycle through previous "complex" commands, that is,
commands entered via Alt-x&lt;command-name&gt;&lt;return&gt;.

For example, Alt-x UpArrow is roughly equivalent to Ctrl-p.

This completes one of the top four wishlist items at:
https://github.com/leo-editor/leo-editor/issues/93
</t>
<t tx="davy.20141209154025.242">How did we ever live without this?

@data nodes, like @data qt-gui-plugin-style-sheet may now be composed of
the body text of the @data node itself, concatenated to the body text of
all its descendants, in outline order.

For example, @data qt-gui-plugin-style-sheet node consists of some general
comments, with descendant nodes for the body pane, tree pane, etc. etc.
There is no limit of nesting: the Plugins node has a child for each plugin
that uses style sheets.

Not only does this new arrangement make it far easier to find the style
sheet of interest, it makes debugging style sheets easier. Typically, an
error in any part of the style sheet invalidates the whole style sheet.
With the new organization, one can swap nodes into or out of the @data node
to find the invalid node or nodes.

Two fine points about the concatenation of data:

1. Descendant nodes whose headlines start with '@' do not become part of
   the data. At present, no @data nodes have descendants, but this
   convention does something reasonable if nodes like @int or @string were
   descendants of an @data node.

2. The @data parser adds a newline to every "fragment" if necessary. This
   doesn't seem to matter for style sheets, but it could matter for other
   kinds of @data data.
</t>
<t tx="davy.20141209154025.243">https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

Leo now stores "ephemeral" or position-related data **in vnodes*. This is a
completely new idea in Leo's history!
</t>
<t tx="davy.20141209154025.244">The :r, :tabnew, insert-file-name and  file-open-by-name commands now have file-name completion

I bind Ctrl-O to file-open-by-name to bypass the Windows open file dialog.
</t>
<t tx="davy.20141209154025.245">The user can lose text if they start typing before the body text completely loads!

- Added c.max_pre_loaded_body_chars = c.config.getInt('max-pre-loaded-body-chars')

- The "dummy" body text now contains a warning to wait until the text fully loads.
</t>
<t tx="davy.20141209154025.246">Leo now uses an all-Python replacement for the QSyntaxHighlighter class.

This fixes git bug 28: https://github.com/leo-editor/leo-editor/issues/28
Leo hangs when a node with too large body is selected

To see the effect of the new code:

1  Create a node with *lots* of colored text.
2. Move the cursor to the last line of the text.
3. Select another node, and then move back to the "big" node.

You should see the end of the text all in black at first, and then become
colored later.

In the meantime, Leo is responsive to all commands, mouse clicks, etc.
</t>
<t tx="davy.20141209154025.248">The style-reload reloads all visual settings.

Suppose you have the following @button node:

    @button reload-styles
    c.k.simulateCommand('style-reload')

And suppose you have the following setting in your local @setting tree::

    @string font-size = 12pt

Change the setting to 10pt (or 14pt), click the button, and see what happens :-)

The present code doesn't deal with themes, although there is some commented
out that hints about what might be done.
</t>
<t tx="davy.20141209154025.249">The leo/plugins/importers folders now contains importer plugins.

The leo/plugins/writers folders now contain writer plugins.

Both importer and writer plugins can defined new kinds of @auto nodes.

Importers and writers can register either @auto-names or file extensions.
For example, @auto x.xyzzy will use both the importer and the writer for
the .xyzzy extension, that is, importers/test.py and writers/test.py. So,
for *unique* extensions, there is no need to use a separate @auto name, you
can just use @auto.
</t>
<t tx="davy.20141209154025.25"></t>
<t tx="davy.20141209154025.250">The default workbook contains both the cheat sheet and an example from the
rst3 tutorial.

</t>
<t tx="davy.20141209154025.251">Over 70 bugs have been fixed.
</t>
<t tx="davy.20141209154025.252"></t>
<t tx="davy.20141209154025.253">https://github.com/leo-editor/leo-editor/issues/38

Fixed by Terry Brown at e8c0e27.
</t>
<t tx="davy.20141209154025.254">https://github.com/leo-editor/leo-editor/issues/78

It's hard to know whether the change did anything.  It does not appear to have hurt.

find.showSuccess now sets p.v.scrollBarSpot = None, which prevents v.restoreCursorAndScroll
from altering the vertical scrollbars.
</t>
<t tx="davy.20141209154025.255">https://github.com/leo-editor/leo-editor/issues/80

Fixed at 614817a, October 26, 2014.
</t>
<t tx="davy.20141209154025.256">https://github.com/leo-editor/leo-editor/issues/101

https://bugs.launchpad.net/leo-editor/+bug/1228099
Cancelling save of dirty untitled commander doesn't work with --ipython
Works for me.

https://bugs.launchpad.net/leo-editor/+bug/1258512
_leo.c not working from IPython
Improved the documentation of the "c" property.
</t>
<t tx="davy.20141209154025.257">https://github.com/leo-editor/leo-editor/issues/102

The fix was to call c.os_path_finalize/_join instead of
g.os_path_finalize_join in two places in the read logic.
</t>
<t tx="davy.20141209154025.258">https://github.com/leo-editor/leo-editor/issues/103

Where are we?
</t>
<t tx="davy.20141209154025.259"></t>
<t tx="davy.20141209154025.26">See: http://leoeditor.com/vimBindings.html#using-leo-s-native-vim-mode

do_visual_mode will extend the selection if visual_line_mode is True.

Affected methods: vc.vim_V and vc&gt;do_visual_mode.

It would be good if LeoQTextEditWidget.setSelectionRangeHelper could handle
insert points in the middle of a text selection, but at present it can't.
</t>
<t tx="davy.20141209154025.260">https://github.com/leo-editor/leo-editor/issues/66

Works for me.
</t>
<t tx="davy.20141209154025.261">https://github.com/leo-editor/leo-editor/issues/104
https://github.com/leo-editor/leo-editor/issues/103
</t>
<t tx="davy.20141209154025.262"></t>
<t tx="davy.20141209154025.263"></t>
<t tx="davy.20141209154025.264">Previously, when checking "didn't" the spell checker would complain that
"didn" wasn't in the dictionary. Now it checks (and accepts) "didn't".

We have all been putting up with this annoyance for *far* to long. Changing
just two lines of code was all that was required.
</t>
<t tx="davy.20141209154025.265">https://bugs.launchpad.net/leo-editor/+bug/1159490

The solution is to change the following setting in leoSettings.leo::
    
    @bool open_with_save_on_update = True
</t>
<t tx="davy.20141209154025.266">https://bugs.launchpad.net/leo-editor/+bug/1338773
Autocompleter error

Added the following defensive code::

    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="davy.20141209154025.267">https://bugs.launchpad.net/leo-editor/+bug/1338172
ReplaceAll will not replace newlines indicated as \n in target string

Using regX , I can search on a pattern and replace it with a string that
includes "\n" as a newline in the transformed string.

If I do a simple search and replace-search from the Find pane that works
(I'm searching within the body of a single node).

However, if I do a Replace All, the "\n" is not translated into a newline;
it remains as is and appears as "\n" in the transformed string.

Also, I can't seem to get the replace-all command to work from the
minibuffer line; it only does a single replace.
</t>
<t tx="davy.20141209154025.268">https://github.com/leo-editor/leo-editor/issues/92
</t>
<t tx="davy.20141209154025.269">https://github.com/leo-editor/leo-editor/issues/66
errors inhibited read @auto foo.md

The markdown code is now similar to the @auto-rst code.

Added some kludgey code to handle underlining.
</t>
<t tx="davy.20141209154025.27">Created g.run_pylint so pylint can run unmodified. This runs pylint (with
optional Sherlock tracing) in a separate process, thereby allowing Leo to
run pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    &lt;python&gt; -c "import leo.core.leoGlobals as g; g.run_pylint(&lt;args&gt;)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
</t>
<t tx="davy.20141209154025.270">LeoQtGui.onActivate/DeactiveEvent

This fixed several focus problems.
</t>
<t tx="davy.20141209154025.271">The fix was to define out in the ctor of SaxContentHandler.
</t>
<t tx="davy.20141209154025.272">- Leo's desktop button now works properly with Python 3.x.
  The underlying cause was that Leo did not work with python34\pythonw.exe.

- Fixed name of a Qt class in richtext.py plugin.
</t>
<t tx="davy.20141209154025.273"></t>
<t tx="davy.20141209154025.274"></t>
<t tx="davy.20141209154025.275">https://github.com/leo-editor/leo-editor/issues/12

The fix was to p.isVisible.
</t>
<t tx="davy.20141209154025.276">https://github.com/leo-editor/leo-editor/issues/28

Summary post:
https://groups.google.com/d/msg/leo-editor/b6TszFS_6NQ/gJrlRkqH9_oJ
</t>
<t tx="davy.20141209154025.277">https://github.com/leo-editor/leo-editor/issues/31
'undo' on a freshly-loaded outline containing chapters removes chapters

Chapter.afterCreateChapter does not push undo data when cc.initing is True.
</t>
<t tx="davy.20141209154025.278">https://github.com/leo-editor/leo-editor/issues/35
leoBridge sometimes assigns the same GNX to two distinct vnodes

c.initObjects sets c.hiddenRootNode.fileIndex to 'hidden-root-vnode-gnx'

fc.getLeoFile calls the new fc.setMaxNodeIndex after reading all nodes.
</t>
<t tx="davy.20141209154025.279">https://github.com/leo-editor/leo-editor/issues/36

The report seems misleading: it says this happens when Leo tries to load an
@auto file that is in the outline but which was erased outside Leo,
but it worked for me.

I did add a guard in g.recureiveUNLFind to ensure that the IndexError shown
in the bug report can never happen.
</t>
<t tx="davy.20141209154025.28">Note: persistence applies to @auto-vimoutline-mode and @auto-org-mode

- Supported @auto-org-mode and @auto-vimoutline-mode
- Created importers and writers for .org and .otl files.
</t>
<t tx="davy.20141209154025.280">https://github.com/leo-editor/leo-editor/issues/50
Important: body text lost switching @file to @auto-rst

This case is so dangerous that Leo refuses to create the file and instead
reverts to the previous @file node.

Changes:
    
- v.at_read is now a dict: keys are full file names; values are lists of headlines.
- at.shouldPromptForDangerousWrite returns True if p.h is not in v.at_read.
- at.promptForDangerousWrite issues a warning and reverts the headline
</t>
<t tx="davy.20141209154025.281">https://github.com/leo-editor/leo-editor/issues/59

When a file is dropped into any part of the Leo window, if the cursor is
not on a node it goes to the top or bottom of the tree as a root node.
</t>
<t tx="davy.20141209154025.282">https://github.com/leo-editor/leo-editor/issues/60

It would be nice for Drag and drop files to have relative paths,taking into
account the @path settings of the part of the tree they're dropped into
(currently it is relative to the .leo file).
</t>
<t tx="davy.20141209154025.283">https://github.com/leo-editor/leo-editor/issues/63
</t>
<t tx="davy.20141209154025.284">https://github.com/leo-editor/leo-editor/issues/64
</t>
<t tx="davy.20141209154025.285">https://github.com/leo-editor/leo-editor/issues/74

What I did:

- ScriptingController now uses *gnxs* (not vnodes!) to detect duplicate buttons.
- Use AtButtonCallback for *all* buttons.
- QtIconBarClass.setCommandForButton always calls
  ScriptingController.build_rclick_tree.
- build_rclick_tree no longer assumes that command_p exists.

Rev 8413e2d fixes an important bug in the new code: "remote"
buttons (buttons defined in settings files) now work if the
settings file is not open.

There are some tricky details that must be handled. As an
example, consider a button defined as follows in
myLeoSettings.leo:

    @button print p.h
    print(p.h)

Detail 1: Leo must open myLeoSettings.leo to find the
@button node. Unlike the Goto Script rclick item, the search
does *not* leave myLeoSettings.leo open. That would be too
great a side effect of clicking the @button node!

Detail 2: We don't want to open myLeoSettings.leo every time
the user clicks the buttons, so the first time the user does
so the script is saved (cached). If the user clicks the
button later the cached value is used.

Detail 3: Caching is used "forever" (while Leo remains
open), even if the user opens myLeoSettings.leo and changes
the script. Sorry, this can't be helped. Don't ask me to
change this.

Detail 4: The new code is careful to execute the script in
the commander in which the button is *located*, not in the
commander in which the button is defined.

Report:

Putting @button definitions in myLeoSettings.leo (in an @buttons tree)
makes them available in all Leo files, a nice feature. Two problems:

- The buttons lack the 'Goto Script' rclick feature in all .leo files.
- There are duplicate buttons in myLeoSettings.leo

</t>
<t tx="davy.20141209154025.286">https://github.com/leo-editor/leo-editor/issues/75
write-opml-file always produces an empty file

leoOPML.py's docstring needs updating.

Improved the packaging as follows:

- The leoOPML plugin no longer monkey patches any part of the FileCommands
  class. Instead the plugin sets the c.opmlController ivar.

- fc.writeToFileHelper calls c.opmlController.putToOPML(owner=self).
    
- OpmlController.putToOPML is just PutToOPML(owner) where PutToOPML is a
  class that creates the opml using the owner's put method.
</t>
<t tx="davy.20141209154025.287">https://github.com/leo-editor/leo-editor/issues/76
erroneous clone markers in @auto trees

The fixes were to several methods of the PersistenceDataController class.
</t>
<t tx="davy.20141209154025.288">https://github.com/leo-editor/leo-editor/issues/78

This is a scrolling problem, not a failure to select text.

Changed the call to w.see in find.showSuccess.
</t>
<t tx="davy.20141209154025.289"></t>
<t tx="davy.20141209154025.29"></t>
<t tx="davy.20141209154025.290">https://bugs.launchpad.net/leo-editor/+bug/1028986
create relative urls when dragging binary files to Leo

This bug was fixed by #60: 
https://github.com/leo-editor/leo-editor/issues/60
create relative paths &amp; urls when dragging files to Leo

Modified dropEvent and its helpers.

Added createLeoFileTree and isLeoFile.

Regular drag of .leo files from a file folder works like the open-outline
command.

Ctrl-drag of .leo files from a file folder copies all nodes of the .leo
file to the receiving outline.

</t>
<t tx="davy.20141209154025.291">https://bugs.launchpad.net/leo-editor/+bug/1041906

Changed LeoQtTree.closeEditorHelper as follows:
    
- Call w.setItemWidget(item,0,None) to make sure e is never referenced again.
    
- Catch RuntimeError exceptions.
</t>
<t tx="davy.20141209154025.292">Fixed bug 1090950: refresh from disk - cut node resurrection.
https://bugs.launchpad.net/leo-editor/+bug/1090950

refresh_rclick_cb in contextmenu.py now just calls c.refreshFromDisk,
which calls c.recreateGnxDict() before reading any file.

Also created the new refresh-from-disk command and the corresponding item in the File menu.
</t>
<t tx="davy.20141209154025.293">https://bugs.launchpad.net/leo-editor/+bug/1185933

Note: the insert-headline-time command must be bound to a shortcut in order for this to work.
</t>
<t tx="davy.20141209154025.294">https://bugs.launchpad.net/leo-editor/+bug/1228312

This was the so-called "greedy checkbox bug".
</t>
<t tx="davy.20141209154025.295">https://bugs.launchpad.net/leo-editor/+bug/1228452

</t>
<t tx="davy.20141209154025.296">https://bugs.launchpad.net/leo-editor/+bug/1228458
</t>
<t tx="davy.20141209154025.297">https://bugs.launchpad.net/leo-editor/+bug/1231656

This bug may already have been fixed, but just to make sure compareLeoFiles
now calls g.app.forgetOpenFile
</t>
<t tx="davy.20141209154025.298">https://bugs.launchpad.net/leo-editor/+bug/1244461

LeoQtEventFilter.qtKey now changes a toString value of 'Enter' to 'Return'
</t>
<t tx="davy.20141209154025.299">https://bugs.launchpad.net/leo-editor/+bug/1245535
</t>
<t tx="davy.20141209154025.3">@language rest

.. What's new.
</t>
<t tx="davy.20141209154025.30">After Alt-x puts you in the minibuffer, you can now use UpArrow and
DownArrow keys to cycle through previous "complex" commands, that is,
commands entered via Alt-x&lt;command-name&gt;&lt;return&gt;.

For example, Alt-x UpArrow is roughly equivalent to Ctrl-p.

This completes one of the top four wishlist items at:
https://github.com/leo-editor/leo-editor/issues/93
</t>
<t tx="davy.20141209154025.300">https://bugs.launchpad.net/leo-editor/+bug/1245616
</t>
<t tx="davy.20141209154025.301">https://bugs.launchpad.net/leo-editor/+bug/1251252

F11 (help-for-command) now works for @button &amp; @command nodes.
</t>
<t tx="davy.20141209154025.302">https://bugs.launchpad.net/leo-editor/+bug/1254861
</t>
<t tx="davy.20141209154025.303">https://bugs.launchpad.net/leo-editor/+bug/1258373
</t>
<t tx="davy.20141209154025.304">https://bugs.launchpad.net/leo-editor/+bug/1260415
Added more informative error messages
</t>
<t tx="davy.20141209154025.305">https://bugs.launchpad.net/leo-editor/+bug/1264350
</t>
<t tx="davy.20141209154025.306">https://bugs.launchpad.net/leo-editor/+bug/1267921
</t>
<t tx="davy.20141209154025.307">https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
</t>
<t tx="davy.20141209154025.308">https://bugs.launchpad.net/leo-editor/+bug/613153

Use the %~dp0 syntax. Example::

  %~dp0\Python27\python.exe %~dp0\Leo-editor\launchLeo.py

http://ss64.com/nt/syntax-args.html
http://stackoverflow.com/questions/5034076/what-does-dp0-mean-and-how-does-it-work

I have just created a FAQ entry for this, so at last this issue is closed.
</t>
<t tx="davy.20141209154025.309">https://bugs.launchpad.net/leo-editor/+bug/735938
</t>
<t tx="davy.20141209154025.31">How did we ever live without this?

@data nodes, like @data qt-gui-plugin-style-sheet may now be composed of
the body text of the @data node itself, concatenated to the body text of
all its descendants, in outline order.

For example, @data qt-gui-plugin-style-sheet node consists of some general
comments, with descendant nodes for the body pane, tree pane, etc. etc.
There is no limit of nesting: the Plugins node has a child for each plugin
that uses style sheets.

Not only does this new arrangement make it far easier to find the style
sheet of interest, it makes debugging style sheets easier. Typically, an
error in any part of the style sheet invalidates the whole style sheet.
With the new organization, one can swap nodes into or out of the @data node
to find the invalid node or nodes.

Two fine points about the concatenation of data:

1. Descendant nodes whose headlines start with '@' do not become part of
   the data. At present, no @data nodes have descendants, but this
   convention does something reasonable if nodes like @int or @string were
   descendants of an @data node.

2. The @data parser adds a newline to every "fragment" if necessary. This
   doesn't seem to matter for style sheets, but it could matter for other
   kinds of @data data.
</t>
<t tx="davy.20141209154025.310">https://bugs.launchpad.net/leo-editor/+bug/969391
</t>
<t tx="davy.20141209154025.311"></t>
<t tx="davy.20141209154025.312">Removed the odious "'Can not execute commands from headlines" message.

Leo now ends editing, replaces the event.widget and event.w fields with
c.frame.body.wrapper.widget and carries on.
</t>
<t tx="davy.20141209154025.313"></t>
<t tx="davy.20141209154025.314">Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
</t>
<t tx="davy.20141209154025.315">- pd.update_before_write_foreign_file tells when an @data node has been
  changed. This explains why the .leo file is now dirty.
- at.saveOutlineIfPossible automatically saves the .leo file if only
  unchanged persistence nodes remain.
  
at.saveOutlineIfPossible makes the following hacks unnecessary:
    
- at.writeAllHelper writes an unchanged @auto file only if it is
  selected explicitly.
- Changed at.writeAll so that the no @&lt;file&gt; node written message now says
  that you must selected an unchanged @auto node directly in order to write
  it with the write-at-files-nodes command.
</t>
<t tx="davy.20141209154025.316">https://groups.google.com/d/msg/leo-editor/NGbogCgVmx4/nsJGngrS8BgJ
</t>
<t tx="davy.20141209154025.317">Fixed the entry in g.app.language_extension_dict
</t>
<t tx="davy.20141209154025.318">Previously, Ctrl-F Alt-tab Alt-tab would put focus in an inactive minibuffer.

The fix involved rewriting onActivate/DeactivateEvent.
</t>
<t tx="davy.20141209154025.319">https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ

This only affected searches that were initiated using the buttons in the Find tab.

What I did:
    
- Init buttonFlag ivar in setup_button &amp; setup_command.
- showSuccess sets was_in_headline ivar.
- focusInTree returns was_in_headline when buttonFlag is True.
- editLabelHelper now properly sets selection range for backward searches.
- Removed a selection hack in initNextText.
</t>
<t tx="davy.20141209154025.32">https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

Leo now stores "ephemeral" or position-related data **in vnodes*. This is a
completely new idea in Leo's history!
</t>
<t tx="davy.20141209154025.320">Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
</t>
<t tx="davy.20141209154025.321"># Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
</t>
<t tx="davy.20141209154025.322">https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4

Another example of the wretched newline problem. @edit nodes preserve '\r'
characters, and that messes up the counts in the find command.

The fix was a hack to find.search: it removes '\r' characters.

</t>
<t tx="davy.20141209154025.323">The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
</t>
<t tx="davy.20141209154025.324">@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

    aList = [x for x in globalDirectiveList if z != 'others']
    aList.sort(lambda a,b: len(b)-len(a))
        # Sort by length, longest first
    pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
</t>
<t tx="davy.20141209154025.325">@language python

import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') &gt; -1:
        g.es(sfn)

@language text

Possible automatic computation of First sets:
http://stackoverflow.com/questions/787134/can-i-determine-the-set-of-first-chars-matched-by-regex-pattern
http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf

found: Rules indicated are dubious or broken

md.py:
    disabled: 6,7,
    changed: 8,12,20,21,23,24,25,47
    [ \t]   leadins: 8,20,24,25,50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    other   leadins: 12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed
</t>
<t tx="davy.20141209154025.326">The problem was an off-by-one test in regexHelper.
</t>
<t tx="davy.20141209154025.327">Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.
</t>
<t tx="davy.20141209154025.328">http://i.imgur.com/1ZV45oB.png

There was a problem with hitting tab, and possibly with using the mouse in the QListWidget.

The fix was to define w as follows in lqlw.select_callback and lqlw.tab_callback:
    
    w = c.k.autoCompleter.w or c.frame.body.wrapper

In addition, I changed assert in lqlw.set_position to calls to g.trace.
</t>
<t tx="davy.20141209154025.329">The change pattern doesn't always get set properly.

The fix was in find.addChangeStringToLabel. It must never protect the
change string!
</t>
<t tx="davy.20141209154025.33">The :r, :tabnew, insert-file-name and  file-open-by-name commands now have file-name completion

I bind Ctrl-O to file-open-by-name to bypass the Windows open file dialog.
</t>
<t tx="davy.20141209154025.330">https://github.com/leo-editor/leo-editor/issues/49

The file import code as found in scripts fails on reaching
Word backup files (file names prefixed with a ~)

The problem was that g.os_path_join automatically called
os.path.expanduser, which converts ~ to the users home directory.

The fix was to disable the call to os.pathexpanduser in g.os_path_join &amp;
g.os_path_finalize if the new expanduser keyword argument is False.
</t>
<t tx="davy.20141209154025.331">https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw
</t>
<t tx="davy.20141209154025.332">The present code just exists Leo, which imo is the reasonable thing to do. 
</t>
<t tx="davy.20141209154025.333">https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

qtree.onItemClicked now calls c.findCommands.reset_state_ivars()
</t>
<t tx="davy.20141209154025.334">Tab cycling now works as expected in all my tests.

- Reset tab cycling if the user types backspace or any plain character.
- Start cycling *only* if len(label) == len(common_prefix)

These restriction appear to be essential.
</t>
<t tx="davy.20141209154025.335">It sometimes picked a shorter completion that is not a prefix of the present label!

Examples:
    print-se **sometimes** shows print-uas or print-bindings or...
    print-stat&lt;tab&gt;-h&lt;tab&gt; shows print-statusbar-hide
    print-st&lt;tab&gt; shows print-style-sheet.
    print-pr&lt;tab&gt; show print-plugin-handlers.
    
The fix was a single extra check in ga.do_tab.
</t>
<t tx="davy.20141209154025.336">Saved and restored the y-scroll position in find_place_holder.
</t>
<t tx="davy.20141209154025.337">dw.createGrid now honors the margin argument.
</t>
<t tx="davy.20141209154025.338">- Non-plain keys are now ignored.
- Backspace and other characters now do something fairly reasonable when text is selected.
  This is an edge case, unless everything to the end of the text is selected.
</t>
<t tx="davy.20141209154025.339">This was probably fixed earlier by the addition of progress guards
in ec.fillRegion and c.reformatBody.

Added one line for fillRegion.
</t>
<t tx="davy.20141209154025.34">The user can lose text if they start typing before the body text completely loads!

- Added c.max_pre_loaded_body_chars = c.config.getInt('max-pre-loaded-body-chars')

- The "dummy" body text now contains a warning to wait until the text fully loads.
</t>
<t tx="davy.20141209154025.340">http://legacy.python.org/dev/peps/pep-0008/

https://github.com/leo-editor/leo-editor/issues/68

    (fixed) puts whitespace between function name and opening '('
    (fixed) puts whitespace between dictionary name and '['
    (fixed) removes whitespace between function arguments after ','
    (partially fixed) removes whitespace around operator inside parentheses
        (this is not so clear, depends on situation, can be correct or can be wrong)
    (fixed) puts whitespace between print and opening '('

print(obj) is correct and PEP8 style in Python 3, in Python 2.7 runs
correctly but print(obj) is not correct traditionally
</t>
<t tx="davy.20141209154025.341">This had been disabled when completion for vim : commands was added.

Changed ga.get_command and ga.is_command.
</t>
<t tx="davy.20141209154025.342">https://bugreports.qt-project.org/browse/QTBUG-41153
</t>
<t tx="davy.20141209154025.343">This is required so that, for example, python coloring is correct after
selecting a node that sets another color for operators.
</t>
<t tx="davy.20141209154025.344">g.es does nothing when g.app.gui.consoleOnly is True
</t>
<t tx="davy.20141209154025.345">For some strange reason, the PyQt5 version of LeoQtGui.runSaveFileDialog
returns a tuple instead of a string!
</t>
<t tx="davy.20141209154025.346"></t>
<t tx="davy.20141209154025.347"></t>
<t tx="davy.20141209154025.348">https://bugs.launchpad.net/leo-editor/+bug/1286909
Settings in file A propagate to file B when editing A and B is opened

</t>
<t tx="davy.20141209154025.349">https://bugs.launchpad.net/leo-editor/+bug/1240786
Corner case bug in tab-cycle-next and tab-cycle-previous

This bug appears to have been fixed.

Open any already existing Leo-Editor file. Call this File 1. Ctrl-O and
open any already existing Leo-Editor file. We will refer to this file as
"File 2." At this point the File 2 tab has focus.

Now execute tab-cycle-next or tab-cycle-previous. I do this using shortcuts
Ctrl+Next and Ctrl+Prior respectively, but your shortcuts may be different.
Now the File 1 tab has the focus. Now type any printable key.

Note that the printable key character is put into File 2 and File 2 is now
dirty, but the focus is still on File 1.

In every other case that I've tried tab-cycle-next and tab-cycle-previous
perform correctly and the tab with the focus is the tab into which
characters are inserted.
</t>
<t tx="davy.20141209154025.35">Leo now uses an all-Python replacement for the QSyntaxHighlighter class.

This fixes git bug 28: https://github.com/leo-editor/leo-editor/issues/28
Leo hangs when a node with too large body is selected

To see the effect of the new code:

1  Create a node with *lots* of colored text.
2. Move the cursor to the last line of the text.
3. Select another node, and then move back to the "big" node.

You should see the end of the text all in black at first, and then become
colored later.

In the meantime, Leo is responsive to all commands, mouse clicks, etc.
</t>
<t tx="davy.20141209154025.350">https://bugs.launchpad.net/leo-editor/+bug/1249684
"add body editor" adds editor pane in wrong tab

This seems to have been fixed.
</t>
<t tx="davy.20141209154025.351">https://bugs.launchpad.net/leo-editor/+bug/1258302
Window, Toggle Split Direction Error

This works for me.  Don't know when it was fixed.
</t>
<t tx="davy.20141209154025.352">https://bugs.launchpad.net/leo-editor/+bug/1269540
File importing problems: Path doesn't properly appear as node header

This bug was fixed by #60 or at some earlier time.

I am aware of no problems with drag and drop at present.
Please create a github bug report if any new issues appear.

</t>
<t tx="davy.20141209154025.353">https://bugs.launchpad.net/leo-editor/+bug/1286914
A custom menu that seems correct, but does nothing

This problem is demonstrated by the file settingsCreep01.leo attached to bug 1286909.

The fix is to remove the amperstand from the @item headlines.
</t>
<t tx="davy.20141209154025.354">https://bugs.launchpad.net/leo-editor/+bug/1286913
After the "menu already exists: ampersand menu name" warning,
the menu entries are added to the existing menu.

This is a minor wishlist item.
</t>
<t tx="davy.20141209154025.355">https://bugs.launchpad.net/leo-editor/+bug/1292207
Disabling Plugins disables menu actions

This bug is invalid.

Disabling plugins disable the mod_scripting plugin, so the @command nodes
given in the example do nothing.
</t>
<t tx="davy.20141209154025.356">https://bugs.launchpad.net/leo-editor/+bug/815564
Plugin Menu - Keystroke binding can prevent plugin help display

Obvious workaround: avoid name clashes.
</t>
<t tx="davy.20141209154025.357"></t>
<t tx="davy.20141209154025.358">https://bugs.launchpad.net/leo-editor/+bug/1228457

This appears to have been fixed.
</t>
<t tx="davy.20141209154025.359">https://bugs.launchpad.net/leo-editor/+bug/1228713

This appears to have been fixed at some time in the past, possibly as the result of fixing another bug.
</t>
<t tx="davy.20141209154025.360">https://bugs.launchpad.net/leo-editor/+bug/1254864
</t>
<t tx="davy.20141209154025.361">https://bugs.launchpad.net/leo-editor/+bug/524890
Incomplete derived file

This bug was fixed by the allow_cloned_sibs logic in leoAtFile.py 2013/01/20.
</t>
<t tx="davy.20141209154025.362">https://bugs.launchpad.net/leo-editor/+bug/1177355
node-only wrapped search does not work in long nodes

This works for me.
</t>
<t tx="davy.20141209154025.363">From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1193820
Focus change on tree pane after saving current Leo file
    
Using Qt. First reported here:
https://groups.google.com/forum/#!topic/leo-editor/hPwPG9OTC3U

This no longer seems to be a problem.
</t>
<t tx="davy.20141209154025.364">https://bugs.launchpad.net/leo-editor/+bug/1266269
Mac: alt-x does not work in body pane

No problem with a clean homebrew install on MacOS 10.9 Mavericks.
</t>
<t tx="davy.20141209154025.365">https://bugs.launchpad.net/leo-editor/+bug/1268970

This works for me (Windows 7 and Ubuntu) with Python 2.7.8, PyQt version 4.8.6.
</t>
<t tx="davy.20141209154025.366">[Fixed?] https://bugs.launchpad.net/leo-editor/+bug/1282362
shadow file name collisions cause spontaneous clone creation

Works for me. Furthermore, the scenario is bizarre enough not to be important.

- Create a new leo file.
- Create @shadow foo.txt
- Set body to @others, add two children, with different body texts.
- Copy / paste the @shadow node, change the path to x/foo.txt

(In shell, create x folder, saving shadow doesn't create path, which is
maybe another bug) save and close file

open file again, children of shadow nodes are clones of each other. I think
it's the name collision, not the copy pasting etc.

</t>
<t tx="davy.20141209154025.367">https://bugs.launchpad.net/leo-editor/+bug/869098
Context menu settings lost if save as used

This report appears invalid.

The renamed file uses the @data contextmenu_commands node in that files.

Note that @data contextmenu_commands node in the file *replaces* any other
@data contextmenu_commands node in leoSettings.leo or myLeoSettings.leo.

</t>
<t tx="davy.20141209154025.368"></t>
<t tx="davy.20141209154025.369">In an earlier post I said:

QQQ

Strictly speaking, tab cycling doesn't have to be disabled for all colon
commands. One could imaging a list of commands that use tab to complete
file names. Otoh, maintaining that list would be clumsy, and it would add
still more special cases to ga.do_tab.

QQQ

This post describes a much better way, done at rev 3994eca.

The new code is gorgeous, if I do say so myself. Even better, the solution
is a design pattern with many applications.

The trick is to replace functions implementing commands by classes having
`__call__` methods. See the P.P.S for details.

Yes, this has all been done before. Several of Leo's commands are
implemented this way. But read on...

What's new is that classes can "advertise" their ability to do various
things. Here, the classes implementing vim commands advertise, by having a
tab_callback method, that they want to handle a tab that follows their
name. ga.do_tab then defers to the vim command.

There are several really cool things about this code.

1. ga.do_tab, and its helper, ga.do_tab_callback, no longer know *anything*
    about colon commands, or what any command intends to do with the
    tab(!!). If the command handler has a tab_callback attribute,
    ga.do_tab_callback just does::

     ga.reset_tab_cycling()
     k.functionTail = tail # For k.getFileName.
     handler.tab_callback()

Nothing could be simpler, or more general.

2. The code in the command classes is simplified as well. No need for a
   kludgy test event.get_arg_value. See the P.S. for the full
   implementation of the :tabnew command.

The overall result is a spectacular collapse in complexity, which the
attendant increase in power and generality.

Edward

P.S. Here is the flattened form of the class that handles the :tabnew
command (does not require vim-mode). In particular, note that the __call__
and tab_callback methods are trivial. This is the way it is written in The
Book.

class Tabnew:
    '''
    A class to handle Vim's :tabnew command.
    This class supports the do_tab callback.
    '''
    def __init__(self,vc):
        '''Ctor for VimCommands.tabnew class.'''
        self.vc = vc
    __name__ = ':tabnew'
        # Required.

    def __call__(self,event=None):
        '''Prompt for a file name, the open a new Leo tab.'''
        self.vc.c.k.getFileName(event,callback=self.open_file_by_name)
       
    def tab_callback(self):
        '''Called when the user types :tabnew&lt;tab&gt;'''
        self.vc.c.k.getFileName(event=None,callback=self.open_file_by_name)
       
    def open_file_by_name(self,fn):
        c = self.vc.c
        if fn and not g.os_path_isdir(fn):
            c2 = g.openWithFileName(fn,old_c=c)
            try:
                g.app.gui.runAtIdle(c2.treeWantsFocusNow)
            except Exception:
                pass
        else:
            c.new()

P.P.S. This pattern is particularly well suited to Leo, because the various
getPublicCommands methods reference those functions when create command
dictionaries. Here, we replace just two entries in the dict::

    ':r':   vc.LoadFileAtCursor(vc),
    ':tabnew': vc.Tabnew(vc),

This creates instances of the LoadFileAtCursor and Tabnew classes. In other
words, we replace a function by an instance of a class. All such classes
must have __call__ methods, so that Leo can "call" the instance as if it
were a function.
</t>
<t tx="davy.20141209154025.37">The style-reload reloads all visual settings.

Suppose you have the following @button node:

    @button reload-styles
    c.k.simulateCommand('style-reload')

And suppose you have the following setting in your local @setting tree::

    @string font-size = 12pt

Change the setting to 10pt (or 14pt), click the button, and see what happens :-)

The present code doesn't deal with themes, although there is some commented
out that hints about what might be done.
</t>
<t tx="davy.20141209154025.370">One change is required to all plugins and scripts:

    body.bodyCtrl.x -&gt; body.wrapper.x
    
There is a script that does this automatically.

What I did
- Created "@test interfaces using API classes" based on the checking script.
- The various isTextWidget methods now check for the existence of a supportsHighLevelInterface ivar.
- StringTextWrapper is now a stand-alone class.
- Removed BaseTextWrapper.
- LeoLog is no longer a subclass of the HighLevelInterface class.
  This required a hack to handle keystrokes in the log pane:
  k.masterKeyHandler sends strokes to c.frame.log.logWidget (a QTextEditWrapper)
  by changing event.widget.
  QTextMixin sets supportsHighLevelInterface = True as a signal to k.handleDefaultChar.
- Eliminated redirection code from LeoQtBody class.
- LeoBody is no longer a subclass of the HighLevelInterface class.
    - The only changes, one or two new guards.
- Create WrapperAPI class whose text indicates expected type of the result.
- Removed wrapper.getFocus method.
- Removed all references to HighLevelInterface class in the core.
- Removed the evil set_focus synonym in the HighLevelInterface class.
</t>
<t tx="davy.20141209154025.371">It is not possible to use both the PyQt4 and PyQt5 installers at the same
time. But this is no big deal on Windows: just install PyQt5 for Python 3.4
only.
</t>
<t tx="davy.20141209154025.372">@language rest

Rev 060c33a contains a spectacular collapse in complexity in idle-time
handling.

Instantly, registering idle-time event handlers can be considered
deprecated, though I have no plans to remove the horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy::

@language python

    def IdleTime(c,handler,delay=500):
        '''A proxy for the g.app.gui.IdleTime class.'''
        if g.app and g.app.gui and hasattr(g.app.gui,'idleTimeClass'):
            return g.app.gui.idleTimeClass(c,handler,delay)
        else:
            return None
            
@language rest

g.IdleTime ensures that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

@language python

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()
    
@language rest

The code creates an instance of the IdleTime class that calls the given
handler at idle time, and no more than once every 500 msec. Here is the
output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

@language python

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()
        
@language rest

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.373">Fixed an important bug in addNode, a helper of createOutline: There was a
confusion about commanders: p is in the old commander. p2 must be in the
new commander.

Disabled a few unit tests when run externally:
This was due to missing nodes or copies of clones not being cloned.
</t>
<t tx="davy.20141209154025.374">- Converted all class names to pep8 style
- Removed g.choose from Leo's core &amp; plugins
  This function is deprecated: use Python's ternary operator instead.
</t>
<t tx="davy.20141209154025.375">Leo's core now calls k.setStatusLabel, not k.setLael, to report the status
of a Leo command. This allows an option (does not exist yet) to use g.es
instead of the minibuffer to report status.
</t>
<t tx="davy.20141209154025.376">Changed k.inverseCommandsDict to c.inverseCommandsDict.
Called vc.define commands from c.finishCreate.
Changed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
The new c.createCommandNames copies entries in g.app.global_commands_dict to commander c.
    Note: @g.command makes entries in g.app.global_commands_dict.
</t>
<t tx="davy.20141209154025.377">@language rest

This post will summarize what has already been done and what will be done in the next few days.  Let's start with the basics...

===== About wrappers and widgets

Wrapper and widget classes are at the heart of Leo's design. Clarifying the
relationships between wrappers and widgets started the present avalanche.

Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly. Instead...

2. A **wrapper class** defines a standard api that hides the details of the
   underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code
treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All
wrapper classes define an official "widget" ivar, so core or plugin code
can gain access to the real Qt widget using wrapper.widget. Searching for
wrapper.widget will (or soon will) find all gui-dependent snippets of code
in Leo's core.

3. Wrappers are crucial, even if Leo *always* uses the Qt gui.

This has just become crystal clear to me. Indeed:

- Wrappers allow users to choose different Qt widgets for the body pane,
  without changing *any* of Leo's core code (except the startup code).

- Wrappers allow Leo's text-handling code to remain unchanged regardless of
  whether the body or log panes are a QTextBrowser or a QsciScintilla
  widget.

- Without wrappers, all of Leo's text-editing commands would have to know
  the details of the api of the actual Qt text widget!

==== Summary of the avalanche

Here is what is happening now in Leo's code base, and in my thinking!

1. A collapse in the complexity of relationships between Leo's most
   important classes and between the files containing those classes.

qt_text.py was supposedly a minor reorg. Wrong! It has become the road map
to the reorganization of all of Leo's fundamental classes:

- qt_text.py is *self contained*: it doesn't depend on any other classes!

- qt_text.py defines a QTextMixin class. This is a new kind of class for
  me. As its name suggest, it is not so much a base class as a helper
  class. It provides helper code for all of Leo's Qt wrapper widgets.

- All the classes that use QTextMixin implement the HighLevelInterface
  class in leoFrame.py.

The HighLevelInterface class will soon morph into the WrapperInterface
class. Th WrapperInterface class will contain only the definition of
methods and their docstrings. Unlike the HighLevelInterface class, the
WrapperInterface will contain *no* redirection code!

- If we were (heaven forbid) going to change Leo's gui, we would simply use
  a copy of qt_text.py, say new_gui.text.py, as a starting point.

2. All "redirection" code will soon be gone.

Ville, Terry and I will be much happier. Eliminating this cruft makes Leo's
code both lighter and thicker, to use the go terminology. It's lighter
because there is far less blah, blah, blah. It's thicker because there is
less to check and to fail.

It's easy to eliminate redirection. For example, the LeoBody methods that
just call the corresponding wrapper methods will soon be gone. We'll
change::

    c.frame.body.wrapperMethod

to::

    c.frame.body.wrapper.wrapperMethod

Doh! This should have been done years ago. Yes, it's more verbose, but it's
also more explicit. Furthermore, few such calls actually exist!

3. widget.widget and other type-checking horrors will soon be a thing of
   the past.

New coding conventions will remove all confusion between wrappers and
widgets. Wrappers will *always* be called wrappers, never widgets.

There is/was something both fundamentally wrong and confusing about
widget.widget. The first widget must have a different type than the second,
but there is *no* indication of this fundamental fact. The reorg changes
widget.widget to wrapper.widget everywhere.

4. I have a new approach toward type checking.

It is obvious now, in retrospect, that clarity of design is something much
more important than type checking! Leo's code will soon make the types of
objects *explicit* and this far more important in practice than even
"perfect" static type checking. This is a revolution in my thinking.

pylint, while supremely important for day-to-day programming, is *totally
inadequate* to have produced the design changes I have been discussing.

Now that widgets are always clearly distinct from wrappers, we could
imaging type-checking assertions to verify their apparent types. Imo, such
assertions are seldom pythonic, but in this case assertions might be good
documentation, if nothing else. The assertions would be based on the
following functions:

- g.isWrapper(obj): calls g.app.gui.isWrapper(obj)
- g.isWidget(obj): calls g.app.gui.isWidget(obj)

5. A dead-easy script shows how to enforce the relationships between types
   that really matter.

This is a big Aha. The script merely compares dir(o1) with dir(o2), where
o1 is the "template" HighLevelInterface class in leoFrame.py and o2 is one
of QTextEditWrapper or QScintillaWrapper. You could call this the "back
door" approach to type checking. It's sooo easy! No more messing with
ast's!

As a result of running this script, (given in the P.P.S.) I was able to
removed cruft from both the HighLevelInterface class, and other parts of
Leo's code.

===== Summary

None of these massive changes adds anything directly to Leo :-)

However, they make understanding and changing Leo's code far easier and
more pleasant. Leo's code is now more beautiful.

Imo, these changes are long overdue. They fundamentally improve Leo's code
base.

That's all for now. I'll keep you posted as I change code, but this post
covers all the essentials.

Edward

P.S. git and easier access to pylint contributed to the present avalanche
of energy and ideas.

Git has allowed me to revise Leo's source code radically, with complete
safety. I would never have done what I have done lately with bzr.

Leo's new pylint command allows me to run pylint *easily* on one or more
"recent" files, *without* having to change any list. As a result, I run
pylint much more often.

P.P.S. Here is the script that checks that all text wrapper classes
implement all required methods. This is, to the first approximation, the
only type checking that Leo really needs. It will probably become a unit
test.

@language python

    import leo.core.leoFrame as leoFrame
    import leo.plugins.qt_text as qt_text
    from leo.core.leoQt import Qsci,QtWidgets
    
    h = leoFrame.HighLevelInterface(c)
    w = Qsci.QsciScintilla()
    tw = QtWidgets.QTextBrowser()
    q = qt_text.QScintillaWrapper(widget=w,c=c,name='test')
    t = qt_text.QTextEditWrapper(widget=tw,name='test2')
    
    h_list = [z for z in sorted(dir(h)) if not z.startswith('__')]
    t_list = [z for z in sorted(dir(t)) if not z.startswith('__')]
    q_list = [z for z in sorted(dir(q)) if not z.startswith('__')]
    ignore = [
        'set_focus', # synonym for setFocus
        'mutable_methods', # To be removed.
    ]
    for z in h_list:
        if z not in t_list and z not in ignore:
            print('QTextEditWrapper: not in HighLevelInterface: %s' % z)
    for z in h_list:
        if z not in q_list and z not in ignore:
            print('QScintillaWrapper: not in HighLevelInterface: %s' % z)
    print('done')

@language rest

=====

This project appears to be a complete success. No further work is planned.
I have encountered no problems at all during this reorg, and don't expect
any, but we shall see...

Here are the highlights:

1. *All* of the odious redirection code in Leo is gone.
 
The redirection code appeared in various places, especially in the
HighLevelInterface class.

2. The HighLevelInterface class is gone: the LeoBody and LeoLog classes are
   now subclasses of object.

3. The logCtrl property is gone: the LeoLog class now defines a .logCtrl
   ivar.

This ivar is inherently tricky: depending on which log *tab* is selected,
LeoLog.logCtrl may be either a wrapper or a widget!

Because LeoLog no longer contains redirection code a hack was needed.
k.masterKeyHandler redirects text-related events originally sent to the
c.frame.log to c.frame.log.logWidget, which, confusingly enough, is
actually a text wrapper.

4. leoFrame.py contains several new API classes: ColorizerAPI, IconBarAPI,
   StatusLineAPI and WrapperAPI.

No class is a subclass of these classes: they are for unit testing only.

The new unit test, "@test interfaces using API classes", checks that
classes implement all the methods in the corresponding API class. This is
not a perfect solution and it is no substitute for pylint. Nevertheless,
these API classes are good documentation, and they did result in a few new
methods being added to each tested "Null" class.

That's all! You may not believe it, but I think of all this work as being
related to fixing bugs. I'll now return more directly to bug fixes.
</t>
<t tx="davy.20141209154025.378">- ic.createOutline and its helper, ic.dispatch, now use tables
  created by ic.createImporterData and its helper.

- Eliminated odious special cases involving self.treeType in
  ic.create_top_node and ic.init_import.
  
- self.treeType is used only in a limited way in the scanner classes:
  The only tests are against '@root' and '@file'.
  
- For now, the unit-tests wrappers are hard-coded.
</t>
<t tx="davy.20141209154025.379">Rev 060c33a...Leo build: 20140825070951 contains a spectacular collapse in
complexity in idle-time handling. Instantly, registering idle-time event
handlers can be considered deprecated, though I have no plans to remove the
horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy:: g.IdleTime ensures
that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()
    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()

The code creates an instance of the IdleTime class that calls the given handler at idle time, and no more than once every 500 msec.  Here is the output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.38">The leo/plugins/importers folders now contains importer plugins.

The leo/plugins/writers folders now contain writer plugins.

Both importer and writer plugins can defined new kinds of @auto nodes.

Importers and writers can register either @auto-names or file extensions.
For example, @auto x.xyzzy will use both the importer and the writer for
the .xyzzy extension, that is, importers/test.py and writers/test.py. So,
for *unique* extensions, there is no need to use a separate @auto name, you
can just use @auto.
</t>
<t tx="davy.20141209154025.380">- fc.getLeoFile now calls ni.begin/end_holding
- Added gnx keyword arg to VNode ctor.
- Added traces to pd.restore_gnx

What I did:
    
- checked all calls to VNode ctor.
- checked all calls to getNewIndex.
- checked all calls to fileIndex =
</t>
<t tx="davy.20141209154025.381">https://groups.google.com/d/msg/leo-editor/JWhlmJBiesk/RsC64VZ1gxQJ
</t>
<t tx="davy.20141209154025.382">@language rest

Simplified and generalized idle-time handling as follows:
    
- Removed g.app.afterHandler: g.app.idleTimeHook does the same thing now.
- The timer callback now calls g.app.idleTimeHook() if it exists.
- g.enableIdleTimeHook now has the following signature::
    
    def enableIdleTimeHook(idleTimeDelay=500,idleTimeHandler=None):
        
  The two args set g.app.idleTimeDelay and g.app.idleTimeHandler respectively.
  g.idleTimeHookHandler is used if idleTimeHandler is None.

The new code has these properties:
    
1. g.app.idleTimeHook() actually gets called only at idle-time,
2. There is no busy waiting, and
3. There is at least g.app.idleTimeDelay msec. between calls to g.app.idleTimeHook()

Here is an script illustrating the possibilities::

@language python

'''
A script illustrating interacting idle-time handlers.
Do Alt-x enable-idle-time-tracing before executing this script
'''
class Handlers:
    def h1(self):
        g.trace()
        g.enableIdleTimeHook(1000,self.h2)
    def h2(self):
        g.trace()
        g.enableIdleTimeHook(500,self.h1)
h = Handlers()
if g.app.idleTimeHook:
    g.disableIdleTimeHook()
else:
    g.enableIdleTimeHook(1000,h.h1)
</t>
<t tx="davy.20141209154025.383">- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
</t>
<t tx="davy.20141209154025.384">0. Added details timing traces throughout the selectHelper logic.
   These traces showed precisely where the performance bugs were.

1. updateSyntaxColorer now does nothing if the body text starts with @killcolor.

2. w.setSelectionRangeHelper and v.restoreCursorAndScroll had performance bugs
because they called code that computed the length of text slowly.

3. The solution: w.setSelectionRangeHelper and all setInsertPoint methods
now take an 's' keyword arg. In the selection logic, s is set to p.b.
If s is not None, the desired length is simply len(s)

As a result, w.setSelectionRangeHelper no longer calls lengthHelper.
lengthHelper used QTextCursor, which is *much* slower than getAllText.

4. Even though all w.setInsertPoint methods have an s keyword arg,
   v.restoreCursorAndScroll uses the following defensive code::
       
    try:
        w.widget.setInsertPoint(ins,s=v._bodyString)
    except TypeError:
        w.setInsertPoint(ins)
</t>
<t tx="davy.20141209154025.385">Leo now imports from ~/.leo/plugins before importing from leo/plugins.

The new code is in at.createWritersData &amp; helper and ic.at.createImportersData &amp; their helpers.
</t>
<t tx="davy.20141209154025.386">'''Load each plugins ~/.leo/plugins if possible, then from leo/plugins.'''
import glob
def report(message,kind,folder,name):
    g.trace('%7s: %5s %9s %s' % (message,kind,folder,name))
g.cls()
plugins1 = g.os_path_finalize_join(g.app.homeDir,'.leo','plugins')
plugins2 = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
seen = set() # set of (folder,sfn)
for kind,plugins in (('home',plugins1),('leo',plugins2)):
    if g.os_path_exists(plugins):
        for folder in ('importers','writers'):
            path = g.os_path_finalize_join(plugins,folder)
            pattern = g.os_path_finalize_join(plugins,folder,'*.py')
            for fn in glob.glob(pattern):
                sfn = g.shortFileName(fn)
                if g.os_path_exists(fn) and sfn != '__init__.py':
                    moduleName = sfn[:-3]
                    if moduleName:
                        data = (folder,sfn)
                        if data in seen:
                            report('seen',kind,folder,sfn)
                        else:
                            m = g.importFromPath(moduleName,path) # Uses imp.
                            if m:
                                seen.add(data)
                                report('loaded',kind,folder,m.__name__)
                            else:
                                report('error',kind,folder,sfn)
                # else: report('skipped',kind,folder,sfn)
@language python
</t>
<t tx="davy.20141209154025.387">For several years the xml namespace line at the start of .leo files has been::

    &lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;

The new line is::

    &lt;leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" &gt;
</t>
<t tx="davy.20141209154025.388">What I did:
- Removed prefix arg to all calls to k.getArg.
  Not needed now that there is better convention for k.setLabelBlue.
- Removed protect argument from k.setLabelBlue.
  Some code now uses k.extendLabel to mix protect and unprotected parts of the label.
  
- k.fnc and k.getArgInstance now created by finishCreate.
  This guarantees that the c,k and log ivars are inited properly.
- Allow &lt;tab&gt; to escape to :r and :tabname code.
  This required several kludges.

</t>
<t tx="davy.20141209154025.389">1. createSaxVnode now does::
    
    v.fileIndex = ni.tupleToString(x.scanGnx(sax_node.tnx))
    
ni.tupleToString is substantially simpler than ni.toString.

This is the only call to tupleToString in Leo.

2. Removed ni.toString.

3. ni.scanGnx no longer converts n to an int.  It's going to become a string again anyway.

4. The new fc.setMaxNodeIndex *does* convert the n field to an int, but
   this very rarely happens.
</t>
<t tx="davy.20141209154025.39">The default workbook contains both the cheat sheet and an example from the
rst3 tutorial.

</t>
<t tx="davy.20141209154025.390">- qt_big_text.py contains support for the "big text" warning buttons.

- qt_commands.py contains several commands created by @g.commands.
  qt_gui.py now imports this file so the commands are actually defined.

- qt_events.py contains the LeoQtEventFilter class. The LeoKeyEvent class
  remains in leoGui.py: it is independent of gui.

- qt_frame.py contains most of the Qt-related code that creates the Leo
  window and frames.
  
- qt_idle_time.py contains the IdleTime class.

- qt_gui.py contains Qt-specific code that defines g.app.gui. leoGui.py is
  the gui-independent code and was essentially unchanged.

- qt_quickheadlines.py contains the QuickHeadlines class.

- qt_text.py contains most the code for Leo's Leo's text widgets.
  leoFrame.py contains a few gui-independent classes.

- qt_tree.py contains all the Qt tree code. It replaces baseNativeTree.py.

No longer used: baseNativeTree.py, qtGui.py. qtGui.py still exists, but
just prints a warning message when imported.
</t>
<t tx="davy.20141209154025.391">What I did:
- at.createWritersData inits tables using the writers_dict in each plugin.
- at.writeOnAtAutoNode calls at.dispatch to find writers.
  An important escape hatch: at.writeOnAtAutoNode calls the *existing* rst.writer
  if the user deletes plugins/writers/rst.py.

Won't do:
- at.writeAllHelper has lots of special-case code, but that probably can't be helped.
- It would be way too dangerous to refactor the write code for @file, @shadow, etc.
</t>
<t tx="davy.20141209154025.392">A head-slapping moment: the so-called high-level interfaced throughout
Leo's core to interact with Leo's text panes lacks a way of getting the
length of text *without* making a copy of the text.

This is more than a slight oversight: I imagine there are several place
were the code does s = w.getAllText() merely so it can use len(s)! This is
a huge strain on the GC for large p.b.

Worse, the absence of w.getTextLength() has lead to the most unfortunate
LeoQTextEditWidget.lengthHelper, which calculated the length of the text
using QTextCursor methods! This is catastrophically slow for large text.
This method was doubling node load times for large nodes.

@language rest

In other words, w.getTextLength() is an essential part of fixing git bug 28:
https://github.com/leo-editor/leo-editor/issues/28

But nooooooo... w.getTextLength() is far from easy to do. There is no
QTextEdit or QTextDocument method that delivers the length of the text!
This is a *huge* hole in the QTextEdit and QTextDocument api's, but there
is nothing we can do about that.

The simplest thing that could possibly work would be::

@language python

    def getTextLength(self):
        w = self.widget
        return len(w.getAllText())
        
@language rest

But this would be a step backwards because it hides the fact that it is
expensive.

It might be possible to cache the value of w.getAllText in an "text
changed" event handler in LeoQTextBrowser:(QTextBrowser). But I would like
to avoid this approach--any bug would lead to data loss or corruption. I
may play around with this, but for now it's not likely to happen. See below
for a workaround.

By analogy with w.getTextLength(), we can imagine a p.b_length method that
would simply return len(p.v._bodyString). This, at least, is worth doing.

===== Summary

w.getTextLength() isn't trivial.

Caching the value returned by w.getAllText() seems too dangerous.

As a work-around, the crucial node-selection logic will attempt to minimize
calls to w.getAllText. There, and *only* there, it should be possible to
create a *single* copy of the text and pass that copy around to all code
that needs it. It would be a complication, but a completely safe one.

Otoh, p/v.b_length are trivial and useful. They will be added asap.

-------------

Two parts to this reply:

===== Part 1: defining w.getTextLength

&gt; w.getTextLength() isn't trivial...Caching the value returned by
w.getAllText() seems too dangerous.

Actually, defining w.getTextLength using a textChanged event handler in
LeoQTextBrowser is straightforward::

@language python

    def onTextChanged(self):
        '''The textChanged event handler.  Cached the text in self.leo_s.'''
        self.leo_s = s = g.u(self.toPlainText())

    def getTextLength(self):
        '''Return the length of all the text.'''
        if 1: # safe.
            s = g.u(self.toPlainText())
            if s != self.leo_s:
                g.trace('can not happen: text mismatch.')
                self.leo_s = s
            return len(self.leo_s)
        else: # fast
            return len(self.leo_s)
            
@language rest

We can use the "safe" version of getTextLength until we are *sure* the can
not happen message never happens ;-)

Otoh, we must be careful: onTextChanged will be called in the middle of the
node-switching logic.

===== Part 2: doing without w.getTextLength

Imo, the simplest thing that could possibly work is to avoid the extra call
to w.getAllText in the node switching logic in selectHelper.

Here are the relevant parts of selectHelper. (w is a LeoQTextEditWidget).

1. setBodyTextAfterSelect *already* calls w.getAllText() to get the
   "before" text. This is unavoidable.

The "after" text will be p.b, where p is the *new* position.

2. restoreCursorAndScroll calls w.setInsertPoint, which just calls
   w.setSelectionRangeHelper.

3. w.setSelectionRangeHelper is the problem It used to call the horribly
   slow lengthHelper. Now it calls w.getAllText()

But w.getAllText must be the new p.b! So the selectHelper logic could
simply pass an optional s argument to w.setInsertPoint and
w.setSelectionRangeHelper. If present, setSelectionRangeHelper will use s
rather than calling w.getAllText.

Imo, this is the safe, if not exactly elegant way.
</t>
<t tx="davy.20141209154025.393">https://groups.google.com/forum/#!topic/leo-editor/cYWigOYtjUM

c.executeScript places '.' as the *second* element of
sys.path, following c.frame.openDirectory as before.
</t>
<t tx="davy.20141209154025.394"></t>
<t tx="davy.20141209154025.395"></t>
<t tx="davy.20141209154025.396">The focus-to-spell command just makes the spell tab visible.

It would not be a good idea actually to transfer focus.
</t>
<t tx="davy.20141209154025.397">As of rev 1d882d3. Leo supports an undoable clone-find-parents command.
Select a cloned node, then do:

    &lt;alt-x&gt;clone-find-parents&lt;return&gt;

This works somewhat like the clone-find-all command: it creates a node containing
clones of all the parents of the selected node.
</t>
<t tx="davy.20141209154025.398">This does *not* change the selected node so it's easy to
clone several nodes.

Added c.cloneToLastNode.  
</t>
<t tx="davy.20141209154025.399">Very useful when summarizing documentation nodes.
</t>
<t tx="davy.20141209154025.4">- Weightless unit testing.

- Added the following commands::

    beautify-c
    c-to-python
    clone-find-all-flattened
    clone-marked-nodes
    delete-marked-nodes
    move-marked-nodes
    run-marked-unit-tests-externally
    run-marked-unit-tests-locally
    select-to-matching-bracket
    split-defs
    
- Improved the following commands::
    
    add-comments
    delete-comments
    open
    page-up
    page-down
    print-bindings
    print-commands
    rst3
    shell-command
    shell-command-on-region
    
.. _`The leoInspect Module`: http://leoeditor.com/leoInspect.html
    
- The leoInspect module allows scripts to interrogate static code.
  For full details, see `The leoInspect Module`_ chapter.
    
- Improved existing features:

    - Leo's File:Open With command now works with Qt
    - The new quick edit/save mode allows Leo to be a drop-in replacement for SciTe.
    - Detached windows.
    - A major improvements to Leo's abbreviation code.
    - Improved presentation of autocompletion list.
    - Applied patch for bug 800399: smart word jumps/deletes.

- Code improvements:

    - Most of Leo's core files now import just leo.core.leoGlobals.
    - Global switches are now all in leoGlobals.py.
    - version.py now uses bzr_version.py. Leo now reports bzr version numbers and dates automatically.
    - Unified the high-level interface &amp; eliminated the low-level interface.
    - Create properties for logCtrl &amp; bodyCtrl.
    - Added event filters to top-level frames.
    - Added g.app.isExternalUnitTest.
    - Added c.config.set.

- Created new classes::

    EditCommandsManager
    KeyStroke &amp; ShortcutInfo
    LoadManager
    TestManager
    
- Dozens of other new commands and features.

For details, see the release notes.
</t>
<t tx="davy.20141209154025.40">Over 70 bugs have been fixed.
</t>
<t tx="davy.20141209154025.400"></t>
<t tx="davy.20141209154025.401">Added the following commands:
    
disable-idle-time-tracing
enable-idle-time-tracing
toggle-idle-time-tracing
disable-idle-time-events
enable-idle-time-events
toggle-idle-time-events
</t>
<t tx="davy.20141209154025.402"># The code is in leoEditCommands.py::insertFileName.
</t>
<t tx="davy.20141209154025.403">When pylint is available on your machine, Leo's pylint
command will execute run pylint on all @&lt;file&gt; nodes in the
selected tree. This command is now available from the popup
menus created by the contextmenu plugin.

This command is a dynamic way of selecting files to check
with pylint. It is *much* easier to use than the old pylint
-r option in pylint-leo.py. There is no longer any need to
update a list of "recent" files. Hooray.

The command has significantly changed my work flow. I use
pylint much more often.

The details of the search process are as follows:

1. The command looks down the tree of the selected node,
   looking for @&lt;file&gt; nodes.
2. If now @&lt;file&gt; nodes are found, it looks up the tree,
   looking for @&lt;file&gt; nodes.
3. If the selected node is a clone, and no @&lt;file&gt; nodes
   have yet been found, it expands the search to all
   ancestors of all positions cloned to the selected node.

This means that you can check a file by selecting any
(possibly clone) node of the file.

**Important**: running pylint-leo.py is still often very
useful. In particular, I often run python pylint-leo.py -a
to check all files. Here is the recently improved docstring
for pylint-leo.py::

    '''
    This file runs pylint on predefined lists of files.
    
    The -r option no longer exists. Instead, use Leo's pylint command to run
    pylint on all Python @&lt;file&gt; nodes in a given tree.
    
    On windows, the following .bat file runs this file::
        python27 pylint-leo.py %*
    
    On Ubuntu, the following alias runs this file::
        pylint="python27 pylint-leo.py"
    '''
</t>
<t tx="davy.20141209154025.404">Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
</t>
<t tx="davy.20141209154025.405"></t>
<t tx="davy.20141209154025.406">These commands now get their arguments from the Find Panel.

Changed the following methods:

generalChangeHelper,
minibufferFind/ReplaceAll,
searchWithPresentOptions,
setReplaceString,

Also fixed the bindings in create_find_buttons so buttons
are bound to the proper button-related methods. As a result,
the find-all and change-all buttons now work as expected.
</t>
<t tx="davy.20141209154025.407">This is a major upgrade to the beautify command.

PythonTidy (tidy for short) does a full parse of the Python sources:
https://pypi.python.org/pypi/PythonTidy/

What I did today.  See the &lt; &lt; version info &gt; &gt; section for all the details::

1. Leonized tidy's sources: @file ../external/PythonTidy.py in in LeoPyRef.leo.

- Removed all pylint complaints and made other minor mods.
 
2. Suppressed features not appropriate for Leo:

- Adds shebang and encoding lines only for @&lt;file&gt; nodes.
- Suppress extra spacing between classes &amp; functions.

3. Added settings to leoSettings.leo that control tidy operation:

    @bool tidy_add_blank_lines_around_comments =True
    @bool tidy_double_quoted_strings = False
    @bool tidy_keep_blank_lines = True
    @bool tidy_left_adjust_docstrings = False
    @int  tidy_lines_before_split_lit = 2
    @int  tidy_seps_before_split_line = 8

3. Fixed several important bugs:

- The original code deleted all comments because of a botch in Comments__init__.
- Tidy now properly handles the tidy_add_blank_lines_around_comments and
  tidy_double_quoted_strings settings.
</t>
<t tx="davy.20141209154025.408">It now tests that all gnx's exist and are unique.
</t>
<t tx="davy.20141209154025.409">Added YesToAll and NoToAll capability to g.app.gui.runAskYesNoDialog
and uses this in the open file again? questions when opening Leo after a
crash.
</t>
<t tx="davy.20141209154025.41"></t>
<t tx="davy.20141209154025.410">Used glob to discover files, not static lists.
</t>
<t tx="davy.20141209154025.411"></t>
<t tx="davy.20141209154025.412"></t>
<t tx="davy.20141209154025.413">I have been using a Scintilla widget in Leo's body pane today. It has been
the best incentive to improve it.

To enable it, set @bool qt-use-scintilla = True.

Almost everything works. It is certainly seems possible to do real work
safely and pleasantly.

The Scintilla code now honors the settings in @data qt-scintilla-styles,
but *only in leoSettings.leo, not myLeoSettings.leo. This is likely a bug
in the settings system, and I'll fix it soon.

Leo now switches between the native Scintilla colorizer and a custom,
do-nothing, colorizer depending on @language, @killcolor, etc. Creating a
custom Scintilla colorizer was unexpectedly easy. There is no native
Scintilla colorizer for @language rest. That will be the next custom
colorizer that I write.

Scintilla thinks Leo directives are decorators, so Leo directives are, in
effect, colorized.

No section references are ever colored. It *might* be possible to define a
custom colorizer that defers to a native colorizer in everything but
section references.

Most unit tests pass with @bool qt-use-scintilla = True. Something strange
is going on in the failing cases, but it doesn't seem strange enough to
cause real problems ;-) I'll be fixing these tests asap.

No other colorizing is available, but everything is in place to support
Scintilla's other native colorizers. They are:

AVS, Bash, Batch, CMake, CoffeeScript, CPP, CSS, D, Diff, Fortran77, HTML,
Lua, Makefile, Matlab, Pascal, Perl, PO, PostScript, POV, Properties,
Python, Ruby, Spice, SQL, TCL, TeX, Verilog, VHDL, YAML.
</t>
<t tx="davy.20141209154025.414"></t>
<t tx="davy.20141209154025.415">Allow colorizing for languages to be delegated to another language.

- Added g.app.delegate_language_dict, with three entries for David McNab.

- jEditColorizer.nameToRuleSetName now replaces the original language name
  with the delegated name.
  
There are two other changes you must make if you don't want
to use @language, as in your example with @nosent trees.

1. To write the proper delims for .hbs files, add the
   following entry in define_language_delims_dict in
   leoApp.py::

    "hbs" : "&lt;!-- --&gt;", # McNab: delegate to html.

2. To automatically use @language hbs in .hbs files, add the
   following entry in define_extension_dict in leoApp.py:
</t>
<t tx="davy.20141209154025.416"></t>
<t tx="davy.20141209154025.417">Replaced by new focus-to-find and focus-to-spell commands.
</t>
<t tx="davy.20141209154025.418"></t>
<t tx="davy.20141209154025.419"></t>
<t tx="davy.20141209154025.42"></t>
<t tx="davy.20141209154025.420">Then livecode-show command shows the live code evaluation pane. Hover on
the buttons for helpful tool-tips.

It currently has a dependency on https://pypi.python.org/pypi/meta
which you can install with

    pip install meta

The dependency on `meta` is for recursively turning AST node trees back
into printable identifiers like "m[m[5]]"

i.e.

   a = 7

is easy,

   m[m[5]] = 7

is not.
</t>
<t tx="davy.20141209154025.421">This is only an API for tags, but I feel like it should simplify the
process and allow someone to focus on the important bits, i.e. UI hooks,
rather than low-level details. Also, it's usable now for scripts.

Here is the docstring:

Provides node tagging capabilities to Leo

By Jacob M. Peck

API
----

This plugin registers a controller object to c.theTagController, which
provides the following API::

    tc = c.theTagController
    tc.get_all_tags() # return a list of all tags used in the current
outline, automatically updated to be consistent
    tc.get_tagged_nodes('foo') # return a list of positions tagged 'foo'
    tc.get_tags(p) # return a list of tags applied to the node at
position p; returns [] if node has no tags
    tc.add_tag(p, 'bar') # add the tag 'bar' to the node at position p
    tc.remove_tag(p, 'baz') # remove the tag 'baz' from p if it is in
the tag list

Internally, tags are stored in `p.v.unknownAttributes['__node_tags']` as
a set.

UI
----

The "Tags" tab in the Log pane is the UI for this plugin.  The bar at
the top is a search bar, editable to allow complex search queries.  It
is pre-populated with all existing tags in the outline, and remembers
your custom searches within the given session.  It also acts double duty
as an input box for the add (+) button, which adds the contents of the
search bar as a tag to the currently selected node.

The list box in the middle is a list of headlines of nodes which contain
the tag(s) defined by the current search string.  These are clickable,
and doing so will center the focus in the outline pane on the selected node.

Below the list box is a dynamic display of tags on the currently
selected node.  Left-clicking on any of these will populate the search
bar with that tag, allowing you to explore similarly tagged nodes.
Right-clicking on a tag will remove it from the currently selected node.

The status line at the bottom is purely informational.

The tag browser has set-algebra querying possible.  Users may search for
strings like 'foo&amp;bar', to get nodes with both tags foo and bar, or
'foo|bar' to get nodes with either or both.  Set difference (-) and
symmetric set difference (^) are supported as well.  These queries are
left-associative, meaning they are read from left to right, with no
other precedence.  Parentheses are not supported. See below for more
details.

Searching
---------

Searching on tags in the UI is based on set algebra.  The following
syntax is used::

    &lt;tag&gt;&amp;&lt;tag&gt; - return nodes tagged with both the given tags
    &lt;tag&gt;|&lt;tag&gt; - return nodes tagged with either of the given tags (or
both)
    &lt;tag&gt;-&lt;tag&gt; - return nodes tagged with the first tag, but not the
second tag
    &lt;tag&gt;^&lt;tag&gt; - return nodes tagged with either of the given tags
(but *not* both)

These may be combined, and are applied left-associatively, building the
set from the left, such that the query `foo&amp;bar^baz` will return only
nodes tagged both 'foo' and 'bar', or nodes tagged with 'baz', but *not*
tagged with all three.

Tag Limitations
---------------

The API is unlimited in tagging abilities.  If you do not wish to use
the UI, then the API may be used to tag nodes with any arbitrary
strings.  The UI, however, due to searching capabilities, may *not* be
used to tag (or search for) nodes with tags containing the special
search characters, `&amp;|-^`.  The UI also cannot search for tags of
zero-length, and it automatically removes surrounding whitespace
(calling .strip()).
</t>
<t tx="davy.20141209154025.422">https://groups.google.com/d/msg/leo-editor/3dH_NSQ4TsQ/ueVewAn50ZcJ

https://groups.google.com/d/msg/leo-editor/BDzmytlSegw/C0IbSz0US54J

As mentioned in my previous post I'll attempt to elaborate on the plugin
I've used to make Leo more useful to me, in case it is useful for others
also. Apologies for the very long post, but I wanted get get all its
features and warts exposed here to get some feedback on whether others see
this as useful or that this is only valuable to me. If it's useful to
others then it may be worth polishing up quite a bit.

Why a better viewrendered plugin?
---------------------------------

I like to use reStructuredText (reST) for all of my note-taking, idea
development, project and task management and automation of desktop
activities (e.g. initiating a backup). You could say it is the control
center of my daily activities, including calculating and showing dashboards
of where I am and where I'm going.

This means I need a tool which seamlessly shows me the full-fidelity
browser-rendered version of what I am writing and be able to print my notes
for meetings, cut and paste nicely formatted output to my office e-mails
and documents, as well as show some of the material as a slideshow.

The existing *viewrendered* plugin couldn't seem to do what I needed
(especially math) and I was almost ready to abandon Leo again. This time I
bit the bullet and created a more capable renderer in viewrendered2 (VR2).
Initially I made a plugin that rendered, on demand, to my normal web
browser. This worked well, but I really thought live rendering like
"viewrendered" would be better, and for that I needed close control over
scroll positions etc. that I couldn't get with an external browser. So the
plugin became much more complex as I merged it with the existing
viewrendered plugin, but was ultimately more powerful and useful to me.

Objectives
-----------

* Show a "full" html representation of any reST node or tree, without an
  @rst root node, including more features than the existing viewrendered
  plugin:

  - proper html layout
  - math (mathjax, etc.)
  - clickable URLs
  - clickable hyperlinks within the page (e.g. TOC)
  - good quality zoom
  - cut and paste html with ctl-C
  - s5 slideshows
  - javascript
  - svg images
  - configurable css

* Allow showing of node tree rather than just the current node. This can
  give a better overview perspective of the tree contents.

* Be able to lock the rendering on the root node of a tree, to view the
  effect editing a sub-node within the larger html document.

* Provide proper rendering of any combination of node types in a tree, so long as
  they have been properly designated by @language directives (i.e. reST, text,
  code, css, ...).

* Allow viewing (and printing) of an entire source file from an @file type
root node.

* Be able to *export* any of these renderings to a full web-browser to take advantage
  of the large rendering window (especially for slideshows, as well as printing, saving output.
  
* Be able to integrate automatically executed code nodes intermingled with
  reST nodes to provide an automatic calculation-based "Notebook" or "Report"
  type output.

* Don't increase the dependencies of Leo.

Implementation
--------------

VR2 is implemented mostly as an ~600 line expansion of the update_rst
method in the viewrendered.py plugin. The text-oriented class used for
rendering in VR1 has been replaced by the QWebView class which provides the
full rendering functionality of a real web-browser. To make this flexible,
a toolbar has been attached to the top with a few controls.

Because I wanted to retain compatibility with VR1, I created the
viewrendered2.py plugin, but retained all the class naming which occurred
within VR1. This means that it remains compatible with the existing
mechanisms (like free_layout) of showing and creating panes for VR1. I
tried this with an expectation that it would fail, but it appears to work
without any unintended side-effects.

Tooltips have been added where Qt allows, with the philosophy that a user
shouldn't need a manual to use this pane.

VR2 has been used a lot under Windows 7 and a little under Ubuntu 13.10.

Issues / Limitations
--------------------

I use VR2 every few minutes every working day. However, VR2 is likely to
still have a lot of rough edges and, in particular, bugs that show up with
different work flows or css folder layouts etc. In fact, VR2 is still a
work in progress and therefore still being fiddled with, so bugs creep in
regularly.

But overall, my perception of its deficiencies are:

* Does not handle reST headings within the node bodies well (sometimes very
  slow render, blocking Leo).

  - VR2 attempts to reconcile reST headings that originate from explicit
    headings within the nodes against reST headings that are automatically
    generated by the node hierarchy. In many cases, this is impossible,
    resulting in many errors which drastically slows down rendering. -
    Recommend not using headings within the nodes themselves, leaving the
    node hierarchy to do this automatically.

* If the node triggers one of the special viewrendered node header types
  (@md, @image, @movie, @html) VR2 simply defaults to the old handlers for
  those types. This means it jumps back to whatever pane type VR1 uses, so
  the features of VR2 disappear. I suspect that VR2 could incorporate these
  types into the new version and retain these new features. I should look
  at that.
    
* Doesn't integrate with rst3 plugin, especially honouring @others etc.
  There are some conflicts in objectives, so this may never be fully
  resolved. It would probably make sense for rst3 settings to get used for
  VR2 as well, along with additional VR2 specific settings. Currently, VR2
  has its own @settings-style settings. The rst3 code is not used.
  
* For slideshow purposes, a patch to docutils s5_writer is required to be
  able to handle an arbitrary hierarchy of nodes (forces all headings to
  start a new slide). Otherwise, only the 2nd level nodes (from the root)
  force a new slide.
  
* The integration of VR2 code into the existing viewrendered plugin code is
  rudimentary. I took the shortcut of not trying to understand this code
  well and confining my integration to the rst rendering only. Better
  integration would be a good future step.

With the plugin being able to execute javascript etc. there may be some
form of security issue, but I can't see it myself (given that Leo can
execute arbitrary python code anyway). Any thoughts?

Future?
-------

* Expand the export button if pandoc is installed, adding optional output
  formats such as docx, odt, plus additional slideshow formats. * Use new
  reST functionality to replace other media viewrendered methods for
  images, svg, movies, etc. * Integrate better with rst3?

Conclusion
----------

* I've attached the source as well as a bunch of screenshots. Feel free to
try out the source by putting viewrendered2 into your @enabled-plugins
instead of the usual viewrendered. I'd be interested in whether it works or
not - expect bugs to show up!

* I'm looking for feedback on whether this appears useful to others and not
just me. If so, it should probably be polished a bit more before being used
widely. Perhaps greater understanding of the existing viewrendered plugin
operation would help me here.
</t>
<t tx="davy.20141209154025.423">Hides text in the body editor, each time a new node is selected. Makes::

  file://#some--&gt;headlines--&gt;mynode     appear as mynode,
  http://www.google.com/search          appear as search, and
  `Python &lt;https://www.python.org/&gt;`_   appear as Python
  
There is a tiny dot to the left or right of the visible
text. Clicking that area, or clicking and dragging, or
clicking and using shift arrows *through* that area exposes
the hidden text.

full docs:
https://raw.githubusercontent.com/leo-editor/leo-editor/master/leo/plugins/wikiview.py

This plugin only addresses the visual aspects of wiki links.  Leo
already supports internal wikilinks as
file://#headline--&gt;other%20headline--&gt;Setup, which will now appear as
just 'Setup' with this pluing active.

</t>
<t tx="davy.20141209154025.424">active_path.py, attrib_edit.py, contextmenu.py, graphcanvas.py,
notebook.py, projectwizard.py, stickynotes.py
</t>
<t tx="davy.20141209154025.425">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Indexing files for full text search

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"
</t>
<t tx="davy.20141209154025.426">This plugin used ancient coding technology, created menu items instead of
minibuffer commands, did not report progress and was probably not thread
safe.

All these defects have now been remedied. It could be quite useful in some
situations. For example, suppose node P has this body text::

    @produce echo pylint commands
    @produce pylint -v
    @produce pylint -f core\leoAtFile.py
    @produce pylint -g

Selecting node P and running the at-produce-selected command produces these
messages in the log pane::

    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    at-produce done

And produces a node whose headline is::

    produce.log from Sun Sep 21 06:35:37 2014

And whose body text is::

    produce: echo pylint commands
    pylint commands
    ===============
    produce: pylint -v
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -v
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -v
    pylint-leo.py 1.1.0,
    astroid 1.0.1, common 0.61.0
    Python 2.7.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)]
    ===============
    produce: pylint -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -f core\leoAtFile.py
    pylint-leo.py: core\leoAtFile.py
    time:  5.000 sec.
    ===============
    produce: pylint -g
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -g
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -g
    pylint-leo.py: plugins\free_layout.py
    pylint-leo.py: plugins\nested_splitter.py
    pylint-leo.py: plugins\qt_commands.py
    pylint-leo.py: plugins\qt_events.py
    pylint-leo.py: plugins\qt_frame.py
    pylint-leo.py: plugins\qt_idle_time.py
    pylint-leo.py: plugins\qt_gui.py
    pylint-leo.py: plugins\qt_text.py
    pylint-leo.py: plugins\qt_tree.py
    time: 40.073 sec.
    ===============
</t>
<t tx="davy.20141209154025.427"></t>
<t tx="davy.20141209154025.428">removed new_auto switch in leoAtFile.py

added g.app.at_auto_persist

c.persistenceController exists only if g.app.auto_persist is True
</t>
<t tx="davy.20141209154025.429"></t>
<t tx="davy.20141209154025.43"></t>
<t tx="davy.20141209154025.430"></t>
<t tx="davy.20141209154025.431">The default is True, so as to enable the "fix" to bug
1254861: find - ctrl-f doesn't ensure find input field
visible https://bugs.launchpad.net/leo-editor/+bug/1254861

I found the new behavior extremely unpleasant. For me, it
was the worst fit-and-finish issues with Leo.
</t>
<t tx="davy.20141209154025.432">These are colored with the previously unused literal3 tag,
so you specify the color with:

    @color html_literal3_color = pink
</t>
<t tx="davy.20141209154025.433">Almost all settings in @data qt-gui-plugin-style-sheet in leoSettings.leo
are now defined in terms of @values. Traditional Leo settings nodes
(@strings, @color, @font, etc.) define these @values.

Most users, and certainly all newbies, will never have to touch, or even
look at, @data qt-gui-plugin-style-sheet. This is a really good thing,
because the slightest syntax error silently messes up everything that
follows.

Notes:

1. There is now a node called "Basic Fonts (change these first)"
   This node contains the basic font definitions. Changing only the
   settings in this tree (in myLeoSettings.leo, of course) should be enough
   to get Leo looking pretty much as it was.

2. Don't even *think* about changing @data qt-gui-plugin-style-sheet.
   Really, the whole point of this exercise is to be able to change all
   aspects of Leo's appearance without touching this stylesheet. As Terry
   points out, there will always be a place for @data qt-gui-user-style-sheet

3. In an emergency, there is at present a node called "OLD
   qt-gui-plugin-style-sheet" that you could use to revert to the old
   settings. Just rename it and copy it to your myLeoSettings.leo.

4. The new settings scheme will moot the need for leo10pt.leo, leo12pt.leo
   and all the rest. Instead, all font sizes are now defined in terms of
   three intermediate settings: @string font-size, @string medium-font-size
   and @string small-font-size. Changing just these three settings will
   suffice to change *all* the font sizes used in Leo.

5. When things don't look right, I execute this script::

    c.styleSheetManager.print_style_sheet()

This prints the complete stylesheet to the console. What I mainly look for
are lines like::

    background-color: @some-setting

An @value as the value of a setting indicates that no substitution took
place, that is, that there is no node::

    @string some-setting = aValue

Any user that wants to roll their own @data node will want to be aware of
this technique.

5. The @data qt-gui-**user**-style-sheet setting is deprecated. Indeed,
   @data qt-gui-**plugin**-style-sheet now takes care to define almost
   everything that any user would want to define. myLeoSettings.leo should
   contain overrides of only the @color and @string nodes in
   leoSettings.leo.
</t>
<t tx="davy.20141209154025.434">For example, this setting works without any explicit definition of mistyrose2.
    
    @color head-bg = @mistyrose2
</t>
<t tx="davy.20141209154025.435">Leo 5.0 alpha 2                     November 8, 2014

Leo 5.0a2 is now available at:
http://sourceforge.net/projects/leo/files/Leo/

Leo is a PIM, an IDE and an outliner.
Video tutorials: http://leoeditor.com/screencasts.html
Text tutorials: http://leoeditor.com/tutorial.html

The highlights of Leo 5.0
--------------------------

* Better compatibility with vim, Emacs, pylint and PyQt:
    - Optional native emulation of vim commands.
    - Full support for Emacs org-mode outlines.
    - Better support for pylint.
    - Support for both PyQt4 and PyQt5.
* Better handling of nodes containing large text:
    - Idle time syntax coloring eliminates delay.
    - Optional delayed loading of large text.
* Power features:
    - Leo available via github repository.
    - File name completion.
    - Cloned nodes expand and contract independently.
    - @data nodes can be composed from descendant nodes.
    - No need to change Leo's main style sheet:
      it can be customized with @color and @font settings.
    - @persistence nodes save data in @auto trees.
    - A pluggable architecture for @auto nodes.
    - The style-reload command changes Leo's appearance instantly.
* Important new plugins for tagging, display and node evaluation.
* For beginners:
    - Leo's default workbook files contains Leo's quickstart guide.
* Hundreds of new/improved features and bug fixes.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Videos:    http://leoeditor.com/screencasts.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Github:    https://github.com/leo-editor/leo-editor
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="davy.20141209154025.436"></t>
<t tx="davy.20141209154025.437"></t>
<t tx="davy.20141209154025.438">See: http://leoeditor.com/vimBindings.html#using-leo-s-native-vim-mode

do_visual_mode will extend the selection if visual_line_mode is True.

Affected methods: vc.vim_V and vc&gt;do_visual_mode.

It would be good if LeoQTextEditWidget.setSelectionRangeHelper could handle
insert points in the middle of a text selection, but at present it can't.
</t>
<t tx="davy.20141209154025.439">Created g.run_pylint so pylint can run unmodified. This runs pylint (with
optional Sherlock tracing) in a separate process, thereby allowing Leo to
run pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    &lt;python&gt; -c "import leo.core.leoGlobals as g; g.run_pylint(&lt;args&gt;)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
</t>
<t tx="davy.20141209154025.44"></t>
<t tx="davy.20141209154025.440">Note: persistence applies to @auto-vimoutline-mode and @auto-org-mode

Done:
- Added @auto-org-mode to list of valid @auto nodes.
- Created org-mode importer.
- Create at.writeOneOrgModeNode, called from at.writeOneAtAutoNode
</t>
<t tx="davy.20141209154025.441"></t>
<t tx="davy.20141209154025.442">How did we ever live without this?

@data nodes, like @data qt-gui-plugin-style-sheet may now be composed of
the body text of the @data node itself, concatenated to the body text of
all its descendants, in outline order.

For example, @data qt-gui-plugin-style-sheet node consists of some general
comments, with descendant nodes for the body pane, tree pane, etc. etc.
There is no limit of nesting: the Plugins node has a child for each plugin
that uses style sheets.

Not only does this new arrangement make it far easier to find the style
sheet of interest, it makes debugging style sheets easier. Typically, an
error in any part of the style sheet invalidates the whole style sheet.
With the new organization, one can swap nodes into or out of the @data node
to find the invalid node or nodes.

Two fine points about the concatenation of data:

1. Descendant nodes whose headlines start with '@' do not become part of
   the data. At present, no @data nodes have descendants, but this
   convention does something reasonable if nodes like @int or @string were
   descendants of an @data node.

2. The @data parser adds a newline to every "fragment" if necessary. This
   doesn't seem to matter for style sheets, but it could matter for other
   kinds of @data data.
</t>
<t tx="davy.20141209154025.443">https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

Leo now stores "ephemeral" or position-related data **in vnodes*. This is a
completely new idea in Leo's history!
</t>
<t tx="davy.20141209154025.444">The :r, :tabnew, insert-file-name and  file-open-by-name commands now have file-name completion

I bind Ctrl-O to file-open-by-name to bypass the Windows open file dialog.
</t>
<t tx="davy.20141209154025.445">The user can lose text if they start typing before the body text completely loads!

- Added c.max_pre_loaded_body_chars = c.config.getInt('max-pre-loaded-body-chars')

- The "dummy" body text now contains a warning to wait until the text fully loads.
</t>
<t tx="davy.20141209154025.446">Leo now uses an all-Python replacement for the QSyntaxHighlighter class.

This fixes git bug 28: https://github.com/leo-editor/leo-editor/issues/28
Leo hangs when a node with too large body is selected

To see the effect of the new code:

1  Create a node with *lots* of colored text.
2. Move the cursor to the last line of the text.
3. Select another node, and then move back to the "big" node.

You should see the end of the text all in black at first, and then become
colored later.

In the meantime, Leo is responsive to all commands, mouse clicks, etc.
</t>
<t tx="davy.20141209154025.448">The style-reload reloads all visual settings.

Suppose you have the following @button node:

    @button reload-styles
    c.k.simulateCommand('style-reload')

And suppose you have the following setting in your local @setting tree::

    @string font-size = 12pt

Change the setting to 10pt (or 14pt), click the button, and see what happens :-)

The present code doesn't deal with themes, although there is some commented
out that hints about what might be done.
</t>
<t tx="davy.20141209154025.449">The leo/plugins/importers folders now contains importer plugins.

The leo/plugins/writers folders now contain writer plugins.

Both importer and writer plugins can defined new kinds of @auto nodes.

Importers and writers can register either @auto-names or file extensions.
For example, @auto x.xyzzy will use both the importer and the writer for
the .xyzzy extension, that is, importers/test.py and writers/test.py. So,
for *unique* extensions, there is no need to use a separate @auto name, you
can just use @auto.
</t>
<t tx="davy.20141209154025.45">https://bugs.launchpad.net/leo-editor/+bug/1158269
viewrendered pane goes blank when url clicked.

Clicking on a url link in a viewrendered pane causes the viewrendered pane
to completely blank. The action successfully launches a browser. Then if I
clear the viewrendered pane (right-click, Remove 1 Right) and repeat the
alt-x vr command, a detached blank python window is launched. The only way
to get the viewrendered panel to be embedded in leo is to restart.
</t>
<t tx="davy.20141209154025.450">The default workbook contains both the cheat sheet and an example from the
rst3 tutorial.

</t>
<t tx="davy.20141209154025.451">Over 70 bugs have been fixed.
</t>
<t tx="davy.20141209154025.452">- Leo's desktop button now works properly with Python 3.x.
  The underlying cause was that Leo did not work with python34\pythonw.exe.

- Fixed name of a Qt class in richtext.py plugin.
</t>
<t tx="davy.20141209154025.453"></t>
<t tx="davy.20141209154025.454"></t>
<t tx="davy.20141209154025.455">https://github.com/leo-editor/leo-editor/issues/12

The fix was to p.isVisible.
</t>
<t tx="davy.20141209154025.456">https://github.com/leo-editor/leo-editor/issues/28

Summary post:
https://groups.google.com/d/msg/leo-editor/b6TszFS_6NQ/gJrlRkqH9_oJ
</t>
<t tx="davy.20141209154025.457">https://github.com/leo-editor/leo-editor/issues/31
'undo' on a freshly-loaded outline containing chapters removes chapters

Chapter.afterCreateChapter does not push undo data when cc.initing is True.
</t>
<t tx="davy.20141209154025.458">https://github.com/leo-editor/leo-editor/issues/35
leoBridge sometimes assigns the same GNX to two distinct vnodes

c.initObjects sets c.hiddenRootNode.fileIndex to 'hidden-root-vnode-gnx'

fc.getLeoFile calls the new fc.setMaxNodeIndex after reading all nodes.
</t>
<t tx="davy.20141209154025.459">https://github.com/leo-editor/leo-editor/issues/36

The report seems misleading: it says this happens when Leo tries to load an
@auto file that is in the outline but which's file was erased outside Leo,
but it worked for me.

I did add a guard in g.recureiveUNLFind to ensure that the IndexError shown
in the bug report can never happen.
</t>
<t tx="davy.20141209154025.46"></t>
<t tx="davy.20141209154025.460">https://github.com/leo-editor/leo-editor/issues/50
Important: body text lost switching @file to @auto-rst

This case is so dangerous that Leo refuses to create the file and instead
reverts to the previous @file node.

Changes:
    
- v.at_read is now a dict: keys are full file names; values are lists of headlines.
- at.shouldPromptForDangerousWrite returns True if p.h is not in v.at_read.
- at.promptForDangerousWrite issues a warning and reverts the headline
</t>
<t tx="davy.20141209154025.461">https://github.com/leo-editor/leo-editor/issues/59

When a file is dropped into any part of the Leo window, if the cursor is
not on a node it goes to the top or bottom of the tree as a root node.
</t>
<t tx="davy.20141209154025.462">https://github.com/leo-editor/leo-editor/issues/60

It would be nice for Drag and drop files to have relative paths,taking into
account the @path settings of the part of the tree they're dropped into
(currently it is relative to the .leo file).
</t>
<t tx="davy.20141209154025.463">https://github.com/leo-editor/leo-editor/issues/63
</t>
<t tx="davy.20141209154025.464">https://github.com/leo-editor/leo-editor/issues/64
</t>
<t tx="davy.20141209154025.465">https://github.com/leo-editor/leo-editor/issues/74

What I did:

- ScriptingController now uses *gnxs* (not vnodes!) to detect duplicate buttons.
- Use AtButtonCallback for *all* buttons.
- QtIconBarClass.setCommandForButton always calls
  ScriptingController.build_rclick_tree.
- build_rclick_tree no longer assumes that command_p exists.

Rev 8413e2d fixes an important bug in the new code: "remote"
buttons (buttons defined in settings files) now work if the
settings file is not open.

There are some tricky details that must be handled. As an
example, consider a button defined as follows in
myLeoSettings.leo:

    @button print p.h
    print(p.h)

Detail 1: Leo must open myLeoSettings.leo to find the
@button node. Unlike the Goto Script rclick item, the search
does *not* leave myLeoSettings.leo open. That would be too
great a side effect of clicking the @button node!

Detail 2: We don't want to open myLeoSettings.leo every time
the user clicks the buttons, so the first time the user does
so the script is saved (cached). If the user clicks the
button later the cached value is used.

Detail 3: Caching is used "forever" (while Leo remains
open), even if the user opens myLeoSettings.leo and changes
the script. Sorry, this can't be helped. Don't ask me to
change this.

Detail 4: The new code is careful to execute the script in
the commander in which the button is *located*, not in the
commander in which the button is defined.

Report:

Putting @button definitions in myLeoSettings.leo (in an @buttons tree)
makes them available in all Leo files, a nice feature. Two problems:

- The buttons lack the 'Goto Script' rclick feature in all .leo files.
- There are duplicate buttons in myLeoSettings.leo

</t>
<t tx="davy.20141209154025.466">https://github.com/leo-editor/leo-editor/issues/75
write-opml-file always produces an empty file

leoOPML.py's docstring needs updating.

Improved the packaging as follows:

- The leoOPML plugin no longer monkey patches any part of the FileCommands
  class. Instead the plugin sets the c.opmlController ivar.

- fc.writeToFileHelper calls c.opmlController.putToOPML(owner=self).
    
- OpmlController.putToOPML is just PutToOPML(owner) where PutToOPML is a
  class that creates the opml using the owner's put method.
</t>
<t tx="davy.20141209154025.467">https://github.com/leo-editor/leo-editor/issues/76
erroneous clone markers in @auto trees

The fixes were to several methods of the PersistenceDataController class.
</t>
<t tx="davy.20141209154025.468">https://github.com/leo-editor/leo-editor/issues/78

This is a scrolling problem, not a failure to select text.

Changed the call to w.see in find.showSuccess.
</t>
<t tx="davy.20141209154025.469"></t>
<t tx="davy.20141209154025.47">The unit test created an unwanted @auto node.
The fix was to ic.create_top_node.
The fix also affected other importer tests.
</t>
<t tx="davy.20141209154025.470"></t>
<t tx="davy.20141209154025.471">https://bugs.launchpad.net/leo-editor/+bug/1228457

This appears to have been fixed.
</t>
<t tx="davy.20141209154025.472">https://bugs.launchpad.net/leo-editor/+bug/1228713

This appears to have been fixed at some time in the past, possibly as the result of fixing another bug.
</t>
<t tx="davy.20141209154025.473">https://bugs.launchpad.net/leo-editor/+bug/1254864
</t>
<t tx="davy.20141209154025.474">https://bugs.launchpad.net/leo-editor/+bug/524890
Incomplete derived file

This bug was fixed by the allow_cloned_sibs logic in leoAtFile.py 2013/01/20.
</t>
<t tx="davy.20141209154025.475">https://bugs.launchpad.net/leo-editor/+bug/1177355
node-only wrapped search does not work in long nodes

This works for me.
</t>
<t tx="davy.20141209154025.476">From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1193820
Focus change on tree pane after saving current Leo file
    
Using Qt. First reported here:
https://groups.google.com/forum/#!topic/leo-editor/hPwPG9OTC3U

This no longer seems to be a problem.
</t>
<t tx="davy.20141209154025.477">https://bugs.launchpad.net/leo-editor/+bug/1266269
Mac: alt-x does not work in body pane

No problem with a clean homebrew install on MacOS 10.9 Mavericks.
</t>
<t tx="davy.20141209154025.478">https://bugs.launchpad.net/leo-editor/+bug/1268970

This works for me (Windows 7 and Ubuntu) with Python 2.7.8, PyQt version 4.8.6.
</t>
<t tx="davy.20141209154025.479">[Fixed?] https://bugs.launchpad.net/leo-editor/+bug/1282362
shadow file name collisions cause spontaneous clone creation

Works for me. Furthermore, the scenario is bizarre enough not to be important.

- Create a new leo file.
- Create @shadow foo.txt
- Set body to @others, add two children, with different body texts.
- Copy / paste the @shadow node, change the path to x/foo.txt

(In shell, create x folder, saving shadow doesn't create path, which is
maybe another bug) save and close file

open file again, children of shadow nodes are clones of each other. I think
it's the name collision, not the copy pasting etc.

</t>
<t tx="davy.20141209154025.48"></t>
<t tx="davy.20141209154025.480">https://bugs.launchpad.net/leo-editor/+bug/869098
Context menu settings lost if save as used

This report appears invalid.

The renamed file uses the @data contextmenu_commands node in that files.

Note that @data contextmenu_commands node in the file *replaces* any other
@data contextmenu_commands node in leoSettings.leo or myLeoSettings.leo.

</t>
<t tx="davy.20141209154025.481">https://bugs.launchpad.net/leo-editor/+bug/1028986
create relative urls when dragging binary files to Leo

This bug was fixed by #60: 
https://github.com/leo-editor/leo-editor/issues/60
create relative paths &amp; urls when dragging files to Leo

Modified dropEvent and its helpers.

Added createLeoFileTree and isLeoFile.

Regular drag of .leo files from a file folder works like the open-outline
command.

Ctrl-drag of .leo files from a file folder copies all nodes of the .leo
file to the receiving outline.

</t>
<t tx="davy.20141209154025.482">https://bugs.launchpad.net/leo-editor/+bug/1041906

Changed LeoQtTree.closeEditorHelper as follows:
    
- Call w.setItemWidget(item,0,None) to make sure e is never referenced again.
    
- Catch RuntimeError exceptions.
</t>
<t tx="davy.20141209154025.483">Fixed bug 1090950: refresh from disk - cut node resurrection.
https://bugs.launchpad.net/leo-editor/+bug/1090950

refresh_rclick_cb in contextmenu.py now just calls c.refreshFromDisk,
which calls c.recreateGnxDict() before reading any file.

Also created the new refresh-from-disk command and the corresponding item in the File menu.
</t>
<t tx="davy.20141209154025.484">https://bugs.launchpad.net/leo-editor/+bug/1185933

Note: the insert-headline-time command must be bound to a shortcut in order for this to work.
</t>
<t tx="davy.20141209154025.485">https://bugs.launchpad.net/leo-editor/+bug/1228312

This was the so-called "greedy checkbox bug".
</t>
<t tx="davy.20141209154025.486">https://bugs.launchpad.net/leo-editor/+bug/1228452

</t>
<t tx="davy.20141209154025.487">https://bugs.launchpad.net/leo-editor/+bug/1228458
</t>
<t tx="davy.20141209154025.488">https://bugs.launchpad.net/leo-editor/+bug/1231656

This bug may already have been fixed, but just to make sure compareLeoFiles
now calls g.app.forgetOpenFile
</t>
<t tx="davy.20141209154025.489">https://bugs.launchpad.net/leo-editor/+bug/1244461

LeoQtEventFilter.qtKey now changes a toString value of 'Enter' to 'Return'
</t>
<t tx="davy.20141209154025.49"></t>
<t tx="davy.20141209154025.490">https://bugs.launchpad.net/leo-editor/+bug/1245535
</t>
<t tx="davy.20141209154025.491">https://bugs.launchpad.net/leo-editor/+bug/1245616
</t>
<t tx="davy.20141209154025.492">https://bugs.launchpad.net/leo-editor/+bug/1251252

F11 (help-for-command) now works for @button &amp; @command nodes.
</t>
<t tx="davy.20141209154025.493">https://bugs.launchpad.net/leo-editor/+bug/1254861
</t>
<t tx="davy.20141209154025.494">https://bugs.launchpad.net/leo-editor/+bug/1258373
</t>
<t tx="davy.20141209154025.495">https://bugs.launchpad.net/leo-editor/+bug/1260415
Added more informative error messages
</t>
<t tx="davy.20141209154025.496">https://bugs.launchpad.net/leo-editor/+bug/1264350
</t>
<t tx="davy.20141209154025.497">https://bugs.launchpad.net/leo-editor/+bug/1267921
</t>
<t tx="davy.20141209154025.498">https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
</t>
<t tx="davy.20141209154025.499">https://bugs.launchpad.net/leo-editor/+bug/613153

Use the %~dp0 syntax. Example::

  %~dp0\Python27\python.exe %~dp0\Leo-editor\launchLeo.py

http://ss64.com/nt/syntax-args.html
http://stackoverflow.com/questions/5034076/what-does-dp0-mean-and-how-does-it-work

I have just created a FAQ entry for this, so at last this issue is closed.
</t>
<t tx="davy.20141209154025.5">Small improvements the unit testing framework created big results. They
completely eliminate the overhead in running unit tests:

    - The run-marked-unit-tests-externally (Alt-4) command runs all marked
      @test nodes. To choose tests, just mark them.
    - Alt-4 now saves the .leo file first.
    - Almost all unit tests may now be run externally:
        - External unit tests always read config settings.
        - The nullGui now uses a fully capable string-based body widget.
        - The nullGui now uses the regular undoer.
    - Unit tests now always have the sources available.
    - Disabled messages on external unit tests.
    - The unit test commands always run a selected @test node.

These improvements mean that almost all unit tests may be run externally.
In turn, this creates a remarkable work flow::

    Edit
    Alt-4
    Edit
    Alt-4
    ...

The energy difference between weightless and heavy is astounding. Try the
new way: you will surely like it.

**Notes**:

Experience shows that being able to run the desired unit tests *without*
selecting any particular node makes an amazingly large difference. Being
able to run all and only marked unit tests is a big step forward.

If a marked node is neither an @test node nor an @suite node, all nodes in
the tree are considered to be marked.
</t>
<t tx="davy.20141209154025.50">When editing at the end of a large block of text where all of the body text
does not fit in the edit window, if I enter an abbreviation, the scroll
position resets to the top of the page even though the text cursor position
remains with the replaced text.
</t>
<t tx="davy.20141209154025.500">https://bugs.launchpad.net/leo-editor/+bug/735938
</t>
<t tx="davy.20141209154025.501">https://bugs.launchpad.net/leo-editor/+bug/969391
</t>
<t tx="davy.20141209154025.502"></t>
<t tx="davy.20141209154025.503">Removed the odious "'Can not execute commands from headlines" message.

Leo now ends editing, replaces the event.widget and event.w fields with
c.frame.body.wrapper.widget and carries on.
</t>
<t tx="davy.20141209154025.504"></t>
<t tx="davy.20141209154025.505">Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
</t>
<t tx="davy.20141209154025.506">- pd.update_before_write_foreign_file tells when an @data node has been
  changed. This explains why the .leo file is now dirty.
- at.saveOutlineIfPossible automatically saves the .leo file if only
  unchanged persistence nodes remain.
  
at.saveOutlineIfPossible makes the following hacks unnecessary:
    
- at.writeAllHelper writes an unchanged @auto file only if it is
  selected explicitly.
- Changed at.writeAll so that the no @&lt;file&gt; node written message now says
  that you must selected an unchanged @auto node directly in order to write
  it with the write-at-files-nodes command.
</t>
<t tx="davy.20141209154025.507">https://groups.google.com/d/msg/leo-editor/NGbogCgVmx4/nsJGngrS8BgJ
</t>
<t tx="davy.20141209154025.508">Fixed the entry in g.app.language_extension_dict
</t>
<t tx="davy.20141209154025.509">Previously, Ctrl-F Alt-tab Alt-tab would put focus in an inactive minibuffer.

The fix involved rewriting onActivate/DeactivateEvent.
</t>
<t tx="davy.20141209154025.51"></t>
<t tx="davy.20141209154025.510">https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ

This only affected searches that were initiated using the buttons in the Find tab.

What I did:
    
- Init buttonFlag ivar in setup_button &amp; setup_command.
- showSuccess sets was_in_headline ivar.
- focusInTree returns was_in_headline when buttonFlag is True.
- editLabelHelper now properly sets selection range for backward searches.
- Removed a selection hack in initNextText.
</t>
<t tx="davy.20141209154025.511">Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
</t>
<t tx="davy.20141209154025.512"># Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
</t>
<t tx="davy.20141209154025.513">https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4

Another example of the wretched newline problem. @edit nodes preserve '\r'
characters, and that messes up the counts in the find command.

The fix was a hack to find.search: it removes '\r' characters.

</t>
<t tx="davy.20141209154025.514">The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
</t>
<t tx="davy.20141209154025.515">@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

    aList = [x for x in globalDirectiveList if z != 'others']
    aList.sort(lambda a,b: len(b)-len(a))
        # Sort by length, longest first
    pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
</t>
<t tx="davy.20141209154025.516">@language python

import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') &gt; -1:
        g.es(sfn)

@language text

Possible automatic computation of First sets:
http://stackoverflow.com/questions/787134/can-i-determine-the-set-of-first-chars-matched-by-regex-pattern
http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf

found: Rules indicated are dubious or broken

md.py:
    disabled: 6,7,
    changed: 8,12,20,21,23,24,25,47
    [ \t]   leadins: 8,20,24,25,50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    other   leadins: 12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed
</t>
<t tx="davy.20141209154025.517">The problem was an off-by-one test in regexHelper.
</t>
<t tx="davy.20141209154025.518">Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.
</t>
<t tx="davy.20141209154025.519">http://i.imgur.com/1ZV45oB.png

There was a problem with hitting tab, and possibly with using the mouse in the QListWidget.

The fix was to define w as follows in lqlw.select_callback and lqlw.tab_callback:
    
    w = c.k.autoCompleter.w or c.frame.body.wrapper

In addition, I changed assert in lqlw.set_position to calls to g.trace.
</t>
<t tx="davy.20141209154025.52">https://github.com/leo-editor/leo-editor/issues/38

Fixed by Terry Brown at e8c0e27.
</t>
<t tx="davy.20141209154025.520">The change pattern doesn't always get set properly.

The fix was in find.addChangeStringToLabel. It must never protect the
change string!
</t>
<t tx="davy.20141209154025.521">https://github.com/leo-editor/leo-editor/issues/49

The file import code as found in scripts fails on reaching
Word backup files (file names prefixed with a ~)

The problem was that g.os_path_join automatically called
os.path.expanduser, which converts ~ to the users home directory.

The fix was to disable the call to os.pathexpanduser in g.os_path_join &amp;
g.os_path_finalize if the new expanduser keyword argument is False.
</t>
<t tx="davy.20141209154025.522">https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw
</t>
<t tx="davy.20141209154025.523">The present code just exists Leo, which imo is the reasonable thing to do. 
</t>
<t tx="davy.20141209154025.524">https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

qtree.onItemClicked now calls c.findCommands.reset_state_ivars()
</t>
<t tx="davy.20141209154025.525">Tab cycling now works as expected in all my tests.

- Reset tab cycling if the user types backspace or any plain character.
- Start cycling *only* if len(label) == len(common_prefix)

These restriction appear to be essential.
</t>
<t tx="davy.20141209154025.526">It sometimes picked a shorter completion that is not a prefix of the present label!

Examples:
    print-se **sometimes** shows print-uas or print-bindings or...
    print-stat&lt;tab&gt;-h&lt;tab&gt; shows print-statusbar-hide
    print-st&lt;tab&gt; shows print-style-sheet.
    print-pr&lt;tab&gt; show print-plugin-handlers.
    
The fix was a single extra check in ga.do_tab.
</t>
<t tx="davy.20141209154025.527">Saved and restored the y-scroll position in find_place_holder.
</t>
<t tx="davy.20141209154025.528">dw.createGrid now honors the margin argument.
</t>
<t tx="davy.20141209154025.529">- Non-plain keys are now ignored.
- Backspace and other characters now do something fairly reasonable when text is selected.
  This is an edge case, unless everything to the end of the text is selected.
</t>
<t tx="davy.20141209154025.53">https://github.com/leo-editor/leo-editor/issues/78

It's hard to know whether the change did anything.  It does not appear to have hurt.

find.showSuccess now sets p.v.scrollBarSpot = None, which prevents v.restoreCursorAndScroll
from altering the vertical scrollbars.
</t>
<t tx="davy.20141209154025.530">This was probably fixed earlier by the addition of progress guards
in ec.fillRegion and c.reformatBody.

Added one line for fillRegion.
</t>
<t tx="davy.20141209154025.531">http://legacy.python.org/dev/peps/pep-0008/

https://github.com/leo-editor/leo-editor/issues/68

    (fixed) puts whitespace between function name and opening '('
    (fixed) puts whitespace between dictionary name and '['
    (fixed) removes whitespace between function arguments after ','
    (partially fixed) removes whitespace around operator inside parentheses
        (this is not so clear, depends on situation, can be correct or can be wrong)
    (fixed) puts whitespace between print and opening '('

print(obj) is correct and PEP8 style in Python 3, in Python 2.7 runs
correctly but print(obj) is not correct traditionally
</t>
<t tx="davy.20141209154025.532">This had been disabled when completion for vim : commands was added.

Changed ga.get_command and ga.is_command.
</t>
<t tx="davy.20141209154025.533">https://bugreports.qt-project.org/browse/QTBUG-41153
</t>
<t tx="davy.20141209154025.534">This is required so that, for example, python coloring is correct after
selecting a node that sets another color for operators.
</t>
<t tx="davy.20141209154025.535">g.es does nothing when g.app.gui.consoleOnly is True
</t>
<t tx="davy.20141209154025.536">For some strange reason, the PyQt5 version of LeoQtGui.runSaveFileDialog
returns a tuple instead of a string!
</t>
<t tx="davy.20141209154025.537"></t>
<t tx="davy.20141209154025.538">In an earlier post I said:

QQQ

Strictly speaking, tab cycling doesn't have to be disabled for all colon
commands. One could imaging a list of commands that use tab to complete
file names. Otoh, maintaining that list would be clumsy, and it would add
still more special cases to ga.do_tab.

QQQ

This post describes a much better way, done at rev 3994eca.

The new code is gorgeous, if I do say so myself. Even better, the solution
is a design pattern with many applications.

The trick is to replace functions implementing commands by classes having
`__call__` methods. See the P.P.S for details.

Yes, this has all been done before. Several of Leo's commands are
implemented this way. But read on...

What's new is that classes can "advertise" their ability to do various
things. Here, the classes implementing vim commands advertise, by having a
tab_callback method, that they want to handle a tab that follows their
name. ga.do_tab then defers to the vim command.

There are several really cool things about this code.

1. ga.do_tab, and its helper, ga.do_tab_callback, no longer know *anything*
    about colon commands, or what any command intends to do with the
    tab(!!). If the command handler has a tab_callback attribute,
    ga.do_tab_callback just does::

     ga.reset_tab_cycling()
     k.functionTail = tail # For k.getFileName.
     handler.tab_callback()

Nothing could be simpler, or more general.

2. The code in the command classes is simplified as well. No need for a
   kludgy test event.get_arg_value. See the P.S. for the full
   implementation of the :tabnew command.

The overall result is a spectacular collapse in complexity, which the
attendant increase in power and generality.

Edward

P.S. Here is the flattened form of the class that handles the :tabnew
command (does not require vim-mode). In particular, note that the __call__
and tab_callback methods are trivial. This is the way it is written in The
Book.

class Tabnew:
    '''
    A class to handle Vim's :tabnew command.
    This class supports the do_tab callback.
    '''
    def __init__(self,vc):
        '''Ctor for VimCommands.tabnew class.'''
        self.vc = vc
    __name__ = ':tabnew'
        # Required.

    def __call__(self,event=None):
        '''Prompt for a file name, the open a new Leo tab.'''
        self.vc.c.k.getFileName(event,callback=self.open_file_by_name)
       
    def tab_callback(self):
        '''Called when the user types :tabnew&lt;tab&gt;'''
        self.vc.c.k.getFileName(event=None,callback=self.open_file_by_name)
       
    def open_file_by_name(self,fn):
        c = self.vc.c
        if fn and not g.os_path_isdir(fn):
            c2 = g.openWithFileName(fn,old_c=c)
            try:
                g.app.gui.runAtIdle(c2.treeWantsFocusNow)
            except Exception:
                pass
        else:
            c.new()

P.P.S. This pattern is particularly well suited to Leo, because the various
getPublicCommands methods reference those functions when create command
dictionaries. Here, we replace just two entries in the dict::

    ':r':   vc.LoadFileAtCursor(vc),
    ':tabnew': vc.Tabnew(vc),

This creates instances of the LoadFileAtCursor and Tabnew classes. In other
words, we replace a function by an instance of a class. All such classes
must have __call__ methods, so that Leo can "call" the instance as if it
were a function.
</t>
<t tx="davy.20141209154025.539">One change is required to all plugins and scripts:

    body.bodyCtrl.x -&gt; body.wrapper.x
    
There is a script that does this automatically.

What I did
- Created "@test interfaces using API classes" based on the checking script.
- The various isTextWidget methods now check for the existence of a supportsHighLevelInterface ivar.
- StringTextWrapper is now a stand-alone class.
- Removed BaseTextWrapper.
- LeoLog is no longer a subclass of the HighLevelInterface class.
  This required a hack to handle keystrokes in the log pane:
  k.masterKeyHandler sends strokes to c.frame.log.logWidget (a QTextEditWrapper)
  by changing event.widget.
  QTextMixin sets supportsHighLevelInterface = True as a signal to k.handleDefaultChar.
- Eliminated redirection code from LeoQtBody class.
- LeoBody is no longer a subclass of the HighLevelInterface class.
    - The only changes, one or two new guards.
- Create WrapperAPI class whose text indicates expected type of the result.
- Removed wrapper.getFocus method.
- Removed all references to HighLevelInterface class in the core.
- Removed the evil set_focus synonym in the HighLevelInterface class.
</t>
<t tx="davy.20141209154025.54">https://github.com/leo-editor/leo-editor/issues/80

Fixed at 614817a, October 26, 2014.
</t>
<t tx="davy.20141209154025.540">It is not possible to use both the PyQt4 and PyQt5 installers at the same
time. But this is no big deal on Windows: just install PyQt5 for Python 3.4
only.
</t>
<t tx="davy.20141209154025.541">@language rest

Rev 060c33a contains a spectacular collapse in complexity in idle-time
handling.

Instantly, registering idle-time event handlers can be considered
deprecated, though I have no plans to remove the horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy::

@language python

    def IdleTime(c,handler,delay=500):
        '''A proxy for the g.app.gui.IdleTime class.'''
        if g.app and g.app.gui and hasattr(g.app.gui,'idleTimeClass'):
            return g.app.gui.idleTimeClass(c,handler,delay)
        else:
            return None
            
@language rest

g.IdleTime ensures that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

@language python

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()
    
@language rest

The code creates an instance of the IdleTime class that calls the given
handler at idle time, and no more than once every 500 msec. Here is the
output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

@language python

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()
        
@language rest

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.542">Fixed an important bug in addNode, a helper of createOutline: There was a
confusion about commanders: p is in the old commander. p2 must be in the
new commander.

Disabled a few unit tests when run externally:
This was due to missing nodes or copies of clones not being cloned.
</t>
<t tx="davy.20141209154025.543">- Converted all class names to pep8 style
- Removed g.choose from Leo's core &amp; plugins
  This function is deprecated: use Python's ternary operator instead.
</t>
<t tx="davy.20141209154025.544">Leo's core now calls k.setStatusLabel, not k.setLael, to report the status
of a Leo command. This allows an option (does not exist yet) to use g.es
instead of the minibuffer to report status.
</t>
<t tx="davy.20141209154025.545">Changed k.inverseCommandsDict to c.inverseCommandsDict.
Called vc.define commands from c.finishCreate.
Changed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
The new c.createCommandNames copies entries in g.app.global_commands_dict to commander c.
    Note: @g.command makes entries in g.app.global_commands_dict.
</t>
<t tx="davy.20141209154025.546">@language rest

This post will summarize what has already been done and what will be done in the next few days.  Let's start with the basics...

===== About wrappers and widgets

Wrapper and widget classes are at the heart of Leo's design. Clarifying the
relationships between wrappers and widgets started the present avalanche.

Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly. Instead...

2. A **wrapper class** defines a standard api that hides the details of the
   underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code
treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All
wrapper classes define an official "widget" ivar, so core or plugin code
can gain access to the real Qt widget using wrapper.widget. Searching for
wrapper.widget will (or soon will) find all gui-dependent snippets of code
in Leo's core.

3. Wrappers are crucial, even if Leo *always* uses the Qt gui.

This has just become crystal clear to me. Indeed:

- Wrappers allow users to choose different Qt widgets for the body pane,
  without changing *any* of Leo's core code (except the startup code).

- Wrappers allow Leo's text-handling code to remain unchanged regardless of
  whether the body or log panes are a QTextBrowser or a QsciScintilla
  widget.

- Without wrappers, all of Leo's text-editing commands would have to know
  the details of the api of the actual Qt text widget!

==== Summary of the avalanche

Here is what is happening now in Leo's code base, and in my thinking!

1. A collapse in the complexity of relationships between Leo's most
   important classes and between the files containing those classes.

qt_text.py was supposedly a minor reorg. Wrong! It has become the road map
to the reorganization of all of Leo's fundamental classes:

- qt_text.py is *self contained*: it doesn't depend on any other classes!

- qt_text.py defines a QTextMixin class. This is a new kind of class for
  me. As its name suggest, it is not so much a base class as a helper
  class. It provides helper code for all of Leo's Qt wrapper widgets.

- All the classes that use QTextMixin implement the HighLevelInterface
  class in leoFrame.py.

The HighLevelInterface class will soon morph into the WrapperInterface
class. Th WrapperInterface class will contain only the definition of
methods and their docstrings. Unlike the HighLevelInterface class, the
WrapperInterface will contain *no* redirection code!

- If we were (heaven forbid) going to change Leo's gui, we would simply use
  a copy of qt_text.py, say new_gui.text.py, as a starting point.

2. All "redirection" code will soon be gone.

Ville, Terry and I will be much happier. Eliminating this cruft makes Leo's
code both lighter and thicker, to use the go terminology. It's lighter
because there is far less blah, blah, blah. It's thicker because there is
less to check and to fail.

It's easy to eliminate redirection. For example, the LeoBody methods that
just call the corresponding wrapper methods will soon be gone. We'll
change::

    c.frame.body.wrapperMethod

to::

    c.frame.body.wrapper.wrapperMethod

Doh! This should have been done years ago. Yes, it's more verbose, but it's
also more explicit. Furthermore, few such calls actually exist!

3. widget.widget and other type-checking horrors will soon be a thing of
   the past.

New coding conventions will remove all confusion between wrappers and
widgets. Wrappers will *always* be called wrappers, never widgets.

There is/was something both fundamentally wrong and confusing about
widget.widget. The first widget must have a different type than the second,
but there is *no* indication of this fundamental fact. The reorg changes
widget.widget to wrapper.widget everywhere.

4. I have a new approach toward type checking.

It is obvious now, in retrospect, that clarity of design is something much
more important than type checking! Leo's code will soon make the types of
objects *explicit* and this far more important in practice than even
"perfect" static type checking. This is a revolution in my thinking.

pylint, while supremely important for day-to-day programming, is *totally
inadequate* to have produced the design changes I have been discussing.

Now that widgets are always clearly distinct from wrappers, we could
imaging type-checking assertions to verify their apparent types. Imo, such
assertions are seldom pythonic, but in this case assertions might be good
documentation, if nothing else. The assertions would be based on the
following functions:

- g.isWrapper(obj): calls g.app.gui.isWrapper(obj)
- g.isWidget(obj): calls g.app.gui.isWidget(obj)

5. A dead-easy script shows how to enforce the relationships between types
   that really matter.

This is a big Aha. The script merely compares dir(o1) with dir(o2), where
o1 is the "template" HighLevelInterface class in leoFrame.py and o2 is one
of QTextEditWrapper or QScintillaWrapper. You could call this the "back
door" approach to type checking. It's sooo easy! No more messing with
ast's!

As a result of running this script, (given in the P.P.S.) I was able to
removed cruft from both the HighLevelInterface class, and other parts of
Leo's code.

===== Summary

None of these massive changes adds anything directly to Leo :-)

However, they make understanding and changing Leo's code far easier and
more pleasant. Leo's code is now more beautiful.

Imo, these changes are long overdue. They fundamentally improve Leo's code
base.

That's all for now. I'll keep you posted as I change code, but this post
covers all the essentials.

Edward

P.S. git and easier access to pylint contributed to the present avalanche
of energy and ideas.

Git has allowed me to revise Leo's source code radically, with complete
safety. I would never have done what I have done lately with bzr.

Leo's new pylint command allows me to run pylint *easily* on one or more
"recent" files, *without* having to change any list. As a result, I run
pylint much more often.

P.P.S. Here is the script that checks that all text wrapper classes
implement all required methods. This is, to the first approximation, the
only type checking that Leo really needs. It will probably become a unit
test.

@language python

    import leo.core.leoFrame as leoFrame
    import leo.plugins.qt_text as qt_text
    from leo.core.leoQt import Qsci,QtWidgets
    
    h = leoFrame.HighLevelInterface(c)
    w = Qsci.QsciScintilla()
    tw = QtWidgets.QTextBrowser()
    q = qt_text.QScintillaWrapper(widget=w,c=c,name='test')
    t = qt_text.QTextEditWrapper(widget=tw,name='test2')
    
    h_list = [z for z in sorted(dir(h)) if not z.startswith('__')]
    t_list = [z for z in sorted(dir(t)) if not z.startswith('__')]
    q_list = [z for z in sorted(dir(q)) if not z.startswith('__')]
    ignore = [
        'set_focus', # synonym for setFocus
        'mutable_methods', # To be removed.
    ]
    for z in h_list:
        if z not in t_list and z not in ignore:
            print('QTextEditWrapper: not in HighLevelInterface: %s' % z)
    for z in h_list:
        if z not in q_list and z not in ignore:
            print('QScintillaWrapper: not in HighLevelInterface: %s' % z)
    print('done')

@language rest

=====

This project appears to be a complete success. No further work is planned.
I have encountered no problems at all during this reorg, and don't expect
any, but we shall see...

Here are the highlights:

1. *All* of the odious redirection code in Leo is gone.
 
The redirection code appeared in various places, especially in the
HighLevelInterface class.

2. The HighLevelInterface class is gone: the LeoBody and LeoLog classes are
   now subclasses of object.

3. The logCtrl property is gone: the LeoLog class now defines a .logCtrl
   ivar.

This ivar is inherently tricky: depending on which log *tab* is selected,
LeoLog.logCtrl may be either a wrapper or a widget!

Because LeoLog no longer contains redirection code a hack was needed.
k.masterKeyHandler redirects text-related events originally sent to the
c.frame.log to c.frame.log.logWidget, which, confusingly enough, is
actually a text wrapper.

4. leoFrame.py contains several new API classes: ColorizerAPI, IconBarAPI,
   StatusLineAPI and WrapperAPI.

No class is a subclass of these classes: they are for unit testing only.

The new unit test, "@test interfaces using API classes", checks that
classes implement all the methods in the corresponding API class. This is
not a perfect solution and it is no substitute for pylint. Nevertheless,
these API classes are good documentation, and they did result in a few new
methods being added to each tested "Null" class.

That's all! You may not believe it, but I think of all this work as being
related to fixing bugs. I'll now return more directly to bug fixes.
</t>
<t tx="davy.20141209154025.547">- ic.createOutline and its helper, ic.dispatch, now use tables
  created by ic.createImporterData and its helper.

- Eliminated odious special cases involving self.treeType in
  ic.create_top_node and ic.init_import.
  
- self.treeType is used only in a limited way in the scanner classes:
  The only tests are against '@root' and '@file'.
  
- For now, the unit-tests wrappers are hard-coded.
</t>
<t tx="davy.20141209154025.548">Rev 060c33a...Leo build: 20140825070951 contains a spectacular collapse in
complexity in idle-time handling. Instantly, registering idle-time event
handlers can be considered deprecated, though I have no plans to remove the
horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy:: g.IdleTime ensures
that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()
    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()

The code creates an instance of the IdleTime class that calls the given handler at idle time, and no more than once every 500 msec.  Here is the output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count &gt;= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
</t>
<t tx="davy.20141209154025.549">- fc.getLeoFile now calls ni.begin/end_holding
- Added gnx keyword arg to VNode ctor.
- Added traces to pd.restore_gnx

What I did:
    
- checked all calls to VNode ctor.
- checked all calls to getNewIndex.
- checked all calls to fileIndex =
</t>
<t tx="davy.20141209154025.55">https://github.com/leo-editor/leo-editor/issues/101

https://bugs.launchpad.net/leo-editor/+bug/1228099
Canceling save of dirty untitled commander doesn't work with --ipython
Works for me.

https://bugs.launchpad.net/leo-editor/+bug/1258512
_leo.c not working from IPython
Improved the documentation of the "c" property.
</t>
<t tx="davy.20141209154025.550">https://groups.google.com/d/msg/leo-editor/JWhlmJBiesk/RsC64VZ1gxQJ
</t>
<t tx="davy.20141209154025.551">@language rest



Simplified and generalized idle-time handling as follows:
    
- Removed g.app.afterHandler: g.app.idleTimeHook does the same thing now.
- The timer callback now calls g.app.idleTimeHook() if it exists.
- g.enableIdleTimeHook now has the following signature::
    
    def enableIdleTimeHook(idleTimeDelay=500,idleTimeHandler=None):
        
  The two args set g.app.idleTimeDelay and g.app.idleTimeHandler respectively.
  g.idleTimeHookHandler is used if idleTimeHandler is None.

The new code has these properties:
    
1. g.app.idleTimeHook() actually gets called only at idle-time,
2. There is no busy waiting, and
3. There is at least g.app.idleTimeDelay msec. between calls to g.app.idleTimeHook()

Here is an script illustrating the possibilities::

@language python

'''
A script illustrating interacting idle-time handlers.
Do Alt-x enable-idle-time-tracing before executing this script
'''
class Handlers:
    def h1(self):
        g.trace()
        g.enableIdleTimeHook(1000,self.h2)
    def h2(self):
        g.trace()
        g.enableIdleTimeHook(500,self.h1)
h = Handlers()
if g.app.idleTimeHook:
    g.disableIdleTimeHook()
else:
    g.enableIdleTimeHook(1000,h.h1)
</t>
<t tx="davy.20141209154025.552">- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
</t>
<t tx="davy.20141209154025.553">0. Added details timing traces throughout the selectHelper logic.
   These traces showed precisely where the performance bugs were.

1. updateSyntaxColorer now does nothing if the body text starts with @killcolor.

2. w.setSelectionRangeHelper and v.restoreCursorAndScroll had performance bugs
because they called code that computed the length of text slowly.

3. The solution: w.setSelectionRangeHelper and all setInsertPoint methods
now take an 's' keyword arg. In the selection logic, s is set to p.b.
If s is not None, the desired length is simply len(s)

As a result, w.setSelectionRangeHelper no longer calls lengthHelper.
lengthHelper used QTextCursor, which is *much* slower than getAllText.

4. Even though all w.setInsertPoint methods have an s keyword arg,
   v.restoreCursorAndScroll uses the following defensive code::
       
    try:
        w.widget.setInsertPoint(ins,s=v._bodyString)
    except TypeError:
        w.setInsertPoint(ins)
</t>
<t tx="davy.20141209154025.554">Leo now imports from ~/.leo/plugins before importing from leo/plugins.

The new code is in at.createWritersData &amp; helper and ic.at.createImportersData &amp; their helpers.
</t>
<t tx="davy.20141209154025.555">'''Load each plugins ~/.leo/plugins if possible, then from leo/plugins.'''
import glob
def report(message,kind,folder,name):
    g.trace('%7s: %5s %9s %s' % (message,kind,folder,name))
g.cls()
plugins1 = g.os_path_finalize_join(g.app.homeDir,'.leo','plugins')
plugins2 = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
seen = set() # set of (folder,sfn)
for kind,plugins in (('home',plugins1),('leo',plugins2)):
    if g.os_path_exists(plugins):
        for folder in ('importers','writers'):
            path = g.os_path_finalize_join(plugins,folder)
            pattern = g.os_path_finalize_join(plugins,folder,'*.py')
            for fn in glob.glob(pattern):
                sfn = g.shortFileName(fn)
                if g.os_path_exists(fn) and sfn != '__init__.py':
                    moduleName = sfn[:-3]
                    if moduleName:
                        data = (folder,sfn)
                        if data in seen:
                            report('seen',kind,folder,sfn)
                        else:
                            m = g.importFromPath(moduleName,path) # Uses imp.
                            if m:
                                seen.add(data)
                                report('loaded',kind,folder,m.__name__)
                            else:
                                report('error',kind,folder,sfn)
                # else: report('skipped',kind,folder,sfn)
@language python
</t>
<t tx="davy.20141209154025.556">For several years the xml namespace line at the start of .leo files has been::

    &lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;

The new line is::

    &lt;leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" &gt;
</t>
<t tx="davy.20141209154025.557">What I did:
- Removed prefix arg to all calls to k.getArg.
  Not needed now that there is better convention for k.setLabelBlue.
- Removed protect argument from k.setLabelBlue.
  Some code now uses k.extendLabel to mix protect and unprotected parts of the label.
  
- k.fnc and k.getArgInstance now created by finishCreate.
  This guarantees that the c,k and log ivars are inited properly.
- Allow &lt;tab&gt; to escape to :r and :tabname code.
  This required several kludges.

</t>
<t tx="davy.20141209154025.558">1. createSaxVnode now does::
    
    v.fileIndex = ni.tupleToString(x.scanGnx(sax_node.tnx))
    
ni.tupleToString is substantially simpler than ni.toString.

This is the only call to tupleToString in Leo.

2. Removed ni.toString.

3. ni.scanGnx no longer converts n to an int.  It's going to become a string again anyway.

4. The new fc.setMaxNodeIndex *does* convert the n field to an int, but
   this very rarely happens.
</t>
<t tx="davy.20141209154025.559">- qt_big_text.py contains support for the "big text" warning buttons.

- qt_commands.py contains several commands created by @g.commands.
  qt_gui.py now imports this file so the commands are actually defined.

- qt_events.py contains the LeoQtEventFilter class. The LeoKeyEvent class
  remains in leoGui.py: it is independent of gui.

- qt_frame.py contains most of the Qt-related code that creates the Leo
  window and frames.
  
- qt_idle_time.py contains the IdleTime class.

- qt_gui.py contains Qt-specific code that defines g.app.gui. leoGui.py is
  the gui-independent code and was essentially unchanged.

- qt_quickheadlines.py contains the QuickHeadlines class.

- qt_text.py contains most the code for Leo's Leo's text widgets.
  leoFrame.py contains a few gui-independent classes.

- qt_tree.py contains all the Qt tree code. It replaces baseNativeTree.py.

No longer used: baseNativeTree.py, qtGui.py. qtGui.py still exists, but
just prints a warning message when imported.
</t>
<t tx="davy.20141209154025.56">https://github.com/leo-editor/leo-editor/issues/102

The fix was to call c.os_path_finalize/_join instead of
g.os_path_finalize_join in two places in the read logic.
</t>
<t tx="davy.20141209154025.560">What I did:
- at.createWritersData inits tables using the writers_dict in each plugin.
- at.writeOnAtAutoNode calls at.dispatch to find writers.
  An important escape hatch: at.writeOnAtAutoNode calls the *existing* rst.writer
  if the user deletes plugins/writers/rst.py.

Won't do:
- at.writeAllHelper has lots of special-case code, but that probably can't be helped.
- It would be way too dangerous to refactor the write code for @file, @shadow, etc.
</t>
<t tx="davy.20141209154025.561">A head-slapping moment: the so-called high-level interfaced throughout
Leo's core to interact with Leo's text panes lacks a way of getting the
length of text *without* making a copy of the text.

This is more than a slight oversight: I imagine there are several place
were the code does s = w.getAllText() merely so it can use len(s)! This is
a huge strain on the GC for large p.b.

Worse, the absence of w.getTextLength() has lead to the most unfortunate
LeoQTextEditWidget.lengthHelper, which calculated the length of the text
using QTextCursor methods! This is catastrophically slow for large text.
This method was doubling node load times for large nodes.

@language rest

In other words, w.getTextLength() is an essential part of fixing git bug 28:
https://github.com/leo-editor/leo-editor/issues/28

But nooooooo... w.getTextLength() is far from easy to do. There is no
QTextEdit or QTextDocument method that delivers the length of the text!
This is a *huge* hole in the QTextEdit and QTextDocument api's, but there
is nothing we can do about that.

The simplest thing that could possibly work would be::

@language python


    def getTextLength(self):
        w = self.widget
        return len(w.getAllText())
        
@language rest

But this would be a step backwards because it hides the fact that it is
expensive.

It might be possible to cache the value of w.getAllText in an "text
changed" event handler in LeoQTextBrowser:(QTextBrowser). But I would like
to avoid this approach--any bug would lead to data loss or corruption. I
may play around with this, but for now it's not likely to happen. See below
for a workaround.

By analogy with w.getTextLength(), we can imagine a p.b_length method that
would simply return len(p.v._bodyString). This, at least, is worth doing.

===== Summary

w.getTextLength() isn't trivial.

Caching the value returned by w.getAllText() seems too dangerous.

As a work-around, the crucial node-selection logic will attempt to minimize
calls to w.getAllText. There, and *only* there, it should be possible to
create a *single* copy of the text and pass that copy around to all code
that needs it. It would be a complication, but a completely safe one.

Otoh, p/v.b_length are trivial and useful. They will be added asap.

-------------

Two parts to this reply:

===== Part 1: defining w.getTextLength

&gt; w.getTextLength() isn't trivial...Caching the value returned by
w.getAllText() seems too dangerous.

Actually, defining w.getTextLength using a textChanged event handler in
LeoQTextBrowser is straightforward::

@language python

    def onTextChanged(self):
        '''The textChanged event handler.  Cached the text in self.leo_s.'''
        self.leo_s = s = g.u(self.toPlainText())

    def getTextLength(self):
        '''Return the length of all the text.'''
        if 1: # safe.
            s = g.u(self.toPlainText())
            if s != self.leo_s:
                g.trace('can not happen: text mismatch.')
                self.leo_s = s
            return len(self.leo_s)
        else: # fast
            return len(self.leo_s)
            
@language rest

We can use the "safe" version of getTextLength until we are *sure* the can
not happen message never happens ;-)

Otoh, we must be careful: onTextChanged will be called in the middle of the
node-switching logic.

===== Part 2: doing without w.getTextLength

Imo, the simplest thing that could possibly work is to avoid the extra call
to w.getAllText in the node switching logic in selectHelper.

Here are the relevant parts of selectHelper. (w is a LeoQTextEditWidget).

1. setBodyTextAfterSelect *already* calls w.getAllText() to get the
   "before" text. This is unavoidable.

The "after" text will be p.b, where p is the *new* position.

2. restoreCursorAndScroll calls w.setInsertPoint, which just calls
   w.setSelectionRangeHelper.

3. w.setSelectionRangeHelper is the problem It used to call the horribly
   slow lengthHelper. Now it calls w.getAllText()

But w.getAllText must be the new p.b! So the selectHelper logic could
simply pass an optional s argument to w.setInsertPoint and
w.setSelectionRangeHelper. If present, setSelectionRangeHelper will use s
rather than calling w.getAllText.

Imo, this is the safe, if not exactly elegant way.
</t>
<t tx="davy.20141209154025.562"></t>
<t tx="davy.20141209154025.563"></t>
<t tx="davy.20141209154025.564">As of rev 1d882d3. Leo supports an undoable clone-find-parents command.
Select a cloned node, then do:

    &lt;alt-x&gt;clone-find-parents&lt;return&gt;

This works somewhat like the clone-find-all command: it creates a node containing
clones of all the parents of the selected node.
</t>
<t tx="davy.20141209154025.565">This does *not* change the selected node so it's easy to
clone several nodes.

Added c.cloneToLastNode.  
</t>
<t tx="davy.20141209154025.566">Very useful when summarizing documentation nodes.
</t>
<t tx="davy.20141209154025.567"></t>
<t tx="davy.20141209154025.568">Added the following commands:
    
disable-idle-time-tracing
enable-idle-time-tracing
toggle-idle-time-tracing
disable-idle-time-events
enable-idle-time-events
toggle-idle-time-events
</t>
<t tx="davy.20141209154025.569"># The code is in leoEditCommands.py::insertFileName.
</t>
<t tx="davy.20141209154025.57">https://github.com/leo-editor/leo-editor/issues/103

Where are we?
</t>
<t tx="davy.20141209154025.570">When pylint is available on your machine, Leo's pylint
command will execute run pylint on all @&lt;file&gt; nodes in the
selected tree. This command is now available from the popup
menus created by the contextmenu plugin.

This command is a dynamic way of selecting files to check
with pylint. It is *much* easier to use than the old pylint
-r option in pylint-leo.py. There is no longer any need to
update a list of "recent" files. Hooray.

The command has significantly changed my work flow. I use
pylint much more often.

The details of the search process are as follows:

1. The command looks down the tree of the selected node,
   looking for @&lt;file&gt; nodes.
2. If now @&lt;file&gt; nodes are found, it looks up the tree,
   looking for @&lt;file&gt; nodes.
3. If the selected node is a clone, and no @&lt;file&gt; nodes
   have yet been found, it expands the search to all
   ancestors of all positions cloned to the selected node.

This means that you can check a file by selecting any
(possibly clone) node of the file.

**Important**: running pylint-leo.py is still often very
useful. In particular, I often run python pylint-leo.py -a
to check all files. Here is the recently improved docstring
for pylint-leo.py::

    '''
    This file runs pylint on predefined lists of files.
    
    The -r option no longer exists. Instead, use Leo's pylint command to run
    pylint on all Python @&lt;file&gt; nodes in a given tree.
    
    On windows, the following .bat file runs this file::
        python27 pylint-leo.py %*
    
    On Ubuntu, the following alias runs this file::
        pylint="python27 pylint-leo.py"
    '''
</t>
<t tx="davy.20141209154025.571">Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
</t>
<t tx="davy.20141209154025.572"></t>
<t tx="davy.20141209154025.573">These commands now get their arguments from the Find Panel.

Changed the following methods:

generalChangeHelper,
minibufferFind/ReplaceAll,
searchWithPresentOptions,
setReplaceString,

Also fixed the bindings in create_find_buttons so buttons
are bound to the proper button-related methods. As a result,
the find-all and change-all buttons now work as expected.
</t>
<t tx="davy.20141209154025.574">This is a major upgrade to the beautify command.

PythonTidy (tidy for short) does a full parse of the Python sources:
https://pypi.python.org/pypi/PythonTidy/

What I did today.  See the &lt; &lt; version info &gt; &gt; section for all the details::

1. Leonized tidy's sources: @file ../external/PythonTidy.py in in LeoPyRef.leo.

- Removed all pylint complaints and made other minor mods.
 
2. Suppressed features not appropriate for Leo:

- Adds shebang and encoding lines only for @&lt;file&gt; nodes.
- Suppress extra spacing between classes &amp; functions.

3. Added settings to leoSettings.leo that control tidy operation:

    @bool tidy_add_blank_lines_around_comments =True
    @bool tidy_double_quoted_strings = False
    @bool tidy_keep_blank_lines = True
    @bool tidy_left_adjust_docstrings = False
    @int  tidy_lines_before_split_lit = 2
    @int  tidy_seps_before_split_line = 8

3. Fixed several important bugs:

- The original code deleted all comments because of a botch in Comments__init__.
- Tidy now properly handles the tidy_add_blank_lines_around_comments and
  tidy_double_quoted_strings settings.
</t>
<t tx="davy.20141209154025.575">It now tests that all gnx's exist and are unique.
</t>
<t tx="davy.20141209154025.576">Added YesToAll and NoToAll capability to g.app.gui.runAskYesNoDialog
and uses this in the open file again? questions when opening Leo after a
crash.
</t>
<t tx="davy.20141209154025.577"></t>
<t tx="davy.20141209154025.578"></t>
<t tx="davy.20141209154025.579">I have been using a Scintilla widget in Leo's body pane today. It has been
the best incentive to improve it.

To enable it, set @bool qt-use-scintilla = True.

Almost everything works. It is certainly seems possible to do real work
safely and pleasantly.

The Scintilla code now honors the settings in @data qt-scintilla-styles,
but *only in leoSettings.leo, not myLeoSettings.leo. This is likely a bug
in the settings system, and I'll fix it soon.

Leo now switches between the native Scintilla colorizer and a custom,
do-nothing, colorizer depending on @language, @killcolor, etc. Creating a
custom Scintilla colorizer was unexpectedly easy. There is no native
Scintilla colorizer for @language rest. That will be the next custom
colorizer that I write.

Scintilla thinks Leo directives are decorators, so Leo directives are, in
effect, colorized.

No section references are ever colored. It *might* be possible to define a
custom colorizer that defers to a native colorizer in everything but
section references.

Most unit tests pass with @bool qt-use-scintilla = True. Something strange
is going on in the failing cases, but it doesn't seem strange enough to
cause real problems ;-) I'll be fixing these tests asap.

No other colorizing is available, but everything is in place to support
Scintilla's other native colorizers. They are:

AVS, Bash, Batch, CMake, CoffeeScript, CPP, CSS, D, Diff, Fortran77, HTML,
Lua, Makefile, Matlab, Pascal, Perl, PO, PostScript, POV, Properties,
Python, Ruby, Spice, SQL, TCL, TeX, Verilog, VHDL, YAML.
</t>
<t tx="davy.20141209154025.58"></t>
<t tx="davy.20141209154025.580">Allow colorizing for languages to be delegated to another language.

- Added g.app.delegate_language_dict, with three entries for David McNab.

- jEditColorizer.nameToRuleSetName now replaces the original language name
  with the delegated name.
  
There are two other changes you must make if you don't want
to use @language, as in your example with @nosent trees.

1. To write the proper delims for .hbs files, add the
   following entry in define_language_delims_dict in
   leoApp.py::

    "hbs" : "&lt;!-- --&gt;", # McNab: delegate to html.

2. To automatically use @language hbs in .hbs files, add the
   following entry in define_extension_dict in leoApp.py:
</t>
<t tx="davy.20141209154025.581"></t>
<t tx="davy.20141209154025.582">Then livecode-show command shows the live code evaluation pane. Hover on
the buttons for helpful tool-tips.

It currently has a dependency on https://pypi.python.org/pypi/meta
which you can install with

    pip install meta

The dependency on `meta` is for recursively turning AST node trees back
into printable identifiers like "m[m[5]]"

i.e.

   a = 7

is easy,

   m[m[5]] = 7

is not.
</t>
<t tx="davy.20141209154025.583">This is only an API for tags, but I feel like it should simplify the
process and allow someone to focus on the important bits, i.e. UI hooks,
rather than low-level details. Also, it's usable now for scripts.

Here is the docstring:

Provides node tagging capabilities to Leo

By Jacob M. Peck

API
----

This plugin registers a controller object to c.theTagController, which
provides the following API::

    tc = c.theTagController
    tc.get_all_tags() # return a list of all tags used in the current
outline, automatically updated to be consistent
    tc.get_tagged_nodes('foo') # return a list of positions tagged 'foo'
    tc.get_tags(p) # return a list of tags applied to the node at
position p; returns [] if node has no tags
    tc.add_tag(p, 'bar') # add the tag 'bar' to the node at position p
    tc.remove_tag(p, 'baz') # remove the tag 'baz' from p if it is in
the tag list

Internally, tags are stored in `p.v.unknownAttributes['__node_tags']` as
a set.

UI
----

The "Tags" tab in the Log pane is the UI for this plugin.  The bar at
the top is a search bar, editable to allow complex search queries.  It
is pre-populated with all existing tags in the outline, and remembers
your custom searches within the given session.  It also acts double duty
as an input box for the add (+) button, which adds the contents of the
search bar as a tag to the currently selected node.

The list box in the middle is a list of headlines of nodes which contain
the tag(s) defined by the current search string.  These are clickable,
and doing so will center the focus in the outline pane on the selected node.

Below the list box is a dynamic display of tags on the currently
selected node.  Left-clicking on any of these will populate the search
bar with that tag, allowing you to explore similarly tagged nodes.
Right-clicking on a tag will remove it from the currently selected node.

The status line at the bottom is purely informational.

The tag browser has set-algebra querying possible.  Users may search for
strings like 'foo&amp;bar', to get nodes with both tags foo and bar, or
'foo|bar' to get nodes with either or both.  Set difference (-) and
symmetric set difference (^) are supported as well.  These queries are
left-associative, meaning they are read from left to right, with no
other precedence.  Parentheses are not supported. See below for more
details.

Searching
---------

Searching on tags in the UI is based on set algebra.  The following
syntax is used::

    &lt;tag&gt;&amp;&lt;tag&gt; - return nodes tagged with both the given tags
    &lt;tag&gt;|&lt;tag&gt; - return nodes tagged with either of the given tags (or
both)
    &lt;tag&gt;-&lt;tag&gt; - return nodes tagged with the first tag, but not the
second tag
    &lt;tag&gt;^&lt;tag&gt; - return nodes tagged with either of the given tags
(but *not* both)

These may be combined, and are applied left-associatively, building the
set from the left, such that the query `foo&amp;bar^baz` will return only
nodes tagged both 'foo' and 'bar', or nodes tagged with 'baz', but *not*
tagged with all three.

Tag Limitations
---------------

The API is unlimited in tagging abilities.  If you do not wish to use
the UI, then the API may be used to tag nodes with any arbitrary
strings.  The UI, however, due to searching capabilities, may *not* be
used to tag (or search for) nodes with tags containing the special
search characters, `&amp;|-^`.  The UI also cannot search for tags of
zero-length, and it automatically removes surrounding whitespace
(calling .strip()).
</t>
<t tx="davy.20141209154025.584">https://groups.google.com/d/msg/leo-editor/3dH_NSQ4TsQ/ueVewAn50ZcJ

https://groups.google.com/d/msg/leo-editor/BDzmytlSegw/C0IbSz0US54J

As mentioned in my previous post I'll attempt to elaborate on the plugin
I've used to make Leo more useful to me, in case it is useful for others
also. Apologies for the very long post, but I wanted get get all its
features and warts exposed here to get some feedback on whether others see
this as useful or that this is only valuable to me. If it's useful to
others then it may be worth polishing up quite a bit.

Why a better viewrendered plugin?
---------------------------------

I like to use reStructuredText (reST) for all of my note-taking, idea
development, project and task management and automation of desktop
activities (e.g. initiating a backup). You could say it is the control
center of my daily activities, including calculating and showing dashboards
of where I am and where I'm going.

This means I need a tool which seamlessly shows me the full-fidelity
browser-rendered version of what I am writing and be able to print my notes
for meetings, cut and paste nicely formatted output to my office e-mails
and documents, as well as show some of the material as a slideshow.

The existing *viewrendered* plugin couldn't seem to do what I needed
(especially math) and I was almost ready to abandon Leo again. This time I
bit the bullet and created a more capable renderer in viewrendered2 (VR2).
Initially I made a plugin that rendered, on demand, to my normal web
browser. This worked well, but I really thought live rendering like
"viewrendered" would be better, and for that I needed close control over
scroll positions etc. that I couldn't get with an external browser. So the
plugin became much more complex as I merged it with the existing
viewrendered plugin, but was ultimately more powerful and useful to me.

Objectives
-----------

* Show a "full" html representation of any reST node or tree, without an
  @rst root node, including more features than the existing viewrendered
  plugin:

  - proper html layout
  - math (mathjax, etc.)
  - clickable URLs
  - clickable hyperlinks within the page (e.g. TOC)
  - good quality zoom
  - cut and paste html with ctl-C
  - s5 slideshows
  - javascript
  - svg images
  - configurable css

* Allow showing of node tree rather than just the current node. This can
  give a better overview perspective of the tree contents.

* Be able to lock the rendering on the root node of a tree, to view the
  effect editing a sub-node within the larger html document.

* Provide proper rendering of any combination of node types in a tree, so long as
  they have been properly designated by @language directives (i.e. reST, text,
  code, css, ...).

* Allow viewing (and printing) of an entire source file from an @file type
root node.

* Be able to *export* any of these renderings to a full web-browser to take advantage
  of the large rendering window (especially for slideshows, as well as printing, saving output.
  
* Be able to integrate automatically executed code nodes intermingled with
  reST nodes to provide an automatic calculation-based "Notebook" or "Report"
  type output.

* Don't increase the dependencies of Leo.

Implementation
--------------

VR2 is implemented mostly as an ~600 line expansion of the update_rst
method in the viewrendered.py plugin. The text-oriented class used for
rendering in VR1 has been replaced by the QWebView class which provides the
full rendering functionality of a real web-browser. To make this flexible,
a toolbar has been attached to the top with a few controls.

Because I wanted to retain compatibility with VR1, I created the
viewrendered2.py plugin, but retained all the class naming which occurred
within VR1. This means that it remains compatible with the existing
mechanisms (like free_layout) of showing and creating panes for VR1. I
tried this with an expectation that it would fail, but it appears to work
without any unintended side-effects.

Tooltips have been added where Qt allows, with the philosophy that a user
shouldn't need a manual to use this pane.

VR2 has been used a lot under Windows 7 and a little under Ubuntu 13.10.

Issues / Limitations
--------------------

I use VR2 every few minutes every working day. However, VR2 is likely to
still have a lot of rough edges and, in particular, bugs that show up with
different work flows or css folder layouts etc. In fact, VR2 is still a
work in progress and therefore still being fiddled with, so bugs creep in
regularly.

But overall, my perception of its deficiencies are:

* Does not handle reST headings within the node bodies well (sometimes very
  slow render, blocking Leo).

  - VR2 attempts to reconcile reST headings that originate from explicit
    headings within the nodes against reST headings that are automatically
    generated by the node hierarchy. In many cases, this is impossible,
    resulting in many errors which drastically slows down rendering. -
    Recommend not using headings within the nodes themselves, leaving the
    node hierarchy to do this automatically.

* If the node triggers one of the special viewrendered node header types
  (@md, @image, @movie, @html) VR2 simply defaults to the old handlers for
  those types. This means it jumps back to whatever pane type VR1 uses, so
  the features of VR2 disappear. I suspect that VR2 could incorporate these
  types into the new version and retain these new features. I should look
  at that.
    
* Doesn't integrate with rst3 plugin, especially honouring @others etc.
  There are some conflicts in objectives, so this may never be fully
  resolved. It would probably make sense for rst3 settings to get used for
  VR2 as well, along with additional VR2 specific settings. Currently, VR2
  has its own @settings-style settings. The rst3 code is not used.
  
* For slideshow purposes, a patch to docutils s5_writer is required to be
  able to handle an arbitrary hierarchy of nodes (forces all headings to
  start a new slide). Otherwise, only the 2nd level nodes (from the root)
  force a new slide.
  
* The integration of VR2 code into the existing viewrendered plugin code is
  rudimentary. I took the shortcut of not trying to understand this code
  well and confining my integration to the rst rendering only. Better
  integration would be a good future step.

With the plugin being able to execute javascript etc. there may be some
form of security issue, but I can't see it myself (given that Leo can
execute arbitrary python code anyway). Any thoughts?

Future?
-------

* Expand the export button if pandoc is installed, adding optional output
  formats such as docx, odt, plus additional slideshow formats. * Use new
  reST functionality to replace other media viewrendered methods for
  images, svg, movies, etc. * Integrate better with rst3?

Conclusion
----------

* I've attached the source as well as a bunch of screenshots. Feel free to
try out the source by putting viewrendered2 into your @enabled-plugins
instead of the usual viewrendered. I'd be interested in whether it works or
not - expect bugs to show up!

* I'm looking for feedback on whether this appears useful to others and not
just me. If so, it should probably be polished a bit more before being used
widely. Perhaps greater understanding of the existing viewrendered plugin
operation would help me here.
</t>
<t tx="davy.20141209154025.585">Hides text in the body editor, each time a new node is selected. Makes::

  file://#some--&gt;headlines--&gt;mynode     appear as mynode,
  http://www.google.com/search          appear as search, and
  `Python &lt;https://www.python.org/&gt;`_   appear as Python
  
There is a tiny dot to the left or right of the visible
text. Clicking that area, or clicking and dragging, or
clicking and using shift arrows *through* that area exposes
the hidden text.

full docs:
https://raw.githubusercontent.com/leo-editor/leo-editor/master/leo/plugins/wikiview.py

This plugin only addresses the visual aspects of wiki links.  Leo
already supports internal wikilinks as
file://#headline--&gt;other%20headline--&gt;Setup, which will now appear as
just 'Setup' with this pluing active.

</t>
<t tx="davy.20141209154025.586">active_path.py, attrib_edit.py, contextmenu.py, graphcanvas.py,
notebook.py, projectwizard.py, stickynotes.py
</t>
<t tx="davy.20141209154025.587">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Indexing files for full text search

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"
</t>
<t tx="davy.20141209154025.588">This plugin used ancient coding technology, created menu items instead of
minibuffer commands, did not report progress and was probably not thread
safe.

All these defects have now been remedied. It could be quite useful in some
situations. For example, suppose node P has this body text::

    @produce echo pylint commands
    @produce pylint -v
    @produce pylint -f core\leoAtFile.py
    @produce pylint -g

Selecting node P and running the at-produce-selected command produces these
messages in the log pane::

    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    at-produce done

And produces a node whose headline is::

    produce.log from Sun Sep 21 06:35:37 2014

And whose body text is::

    produce: echo pylint commands
    pylint commands
    ===============
    produce: pylint -v
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -v
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -v
    pylint-leo.py 1.1.0,
    astroid 1.0.1, common 0.61.0
    Python 2.7.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)]
    ===============
    produce: pylint -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -f core\leoAtFile.py
    pylint-leo.py: core\leoAtFile.py
    time:  5.000 sec.
    ===============
    produce: pylint -g
   
    c:\leo.repo\leo-editor&gt;python27 pylint-leo.py -g
   
    c:\leo.repo\leo-editor&gt;c:\python27\python.exe pylint-leo.py -g
    pylint-leo.py: plugins\free_layout.py
    pylint-leo.py: plugins\nested_splitter.py
    pylint-leo.py: plugins\qt_commands.py
    pylint-leo.py: plugins\qt_events.py
    pylint-leo.py: plugins\qt_frame.py
    pylint-leo.py: plugins\qt_idle_time.py
    pylint-leo.py: plugins\qt_gui.py
    pylint-leo.py: plugins\qt_text.py
    pylint-leo.py: plugins\qt_tree.py
    time: 40.073 sec.
    ===============
</t>
<t tx="davy.20141209154025.589"></t>
<t tx="davy.20141209154025.59">https://github.com/leo-editor/leo-editor/issues/66

Works for me.
</t>
<t tx="davy.20141209154025.590">removed new_auto switch in leoAtFile.py

added g.app.at_auto_persist

c.persistenceController exists only if g.app.auto_persist is True
</t>
<t tx="davy.20141209154025.591"></t>
<t tx="davy.20141209154025.592"></t>
<t tx="davy.20141209154025.593">The default is True, so as to enable the "fix" to bug
1254861: find - ctrl-f doesn't ensure find input field
visible https://bugs.launchpad.net/leo-editor/+bug/1254861

I found the new behavior extremely unpleasant. For me, it
was the worst fit-and-finish issues with Leo.
</t>
<t tx="davy.20141209154025.594">These are colored with the previously unused literal3 tag,
so you specify the color with:

    @color html_literal3_color = pink
</t>
<t tx="davy.20141209154025.595">Almost all settings in @data qt-gui-plugin-style-sheet in leoSettings.leo
are now defined in terms of @values. Traditional Leo settings nodes
(@strings, @color, @font, etc.) define these @values.

Most users, and certainly all newbies, will never have to touch, or even
look at, @data qt-gui-plugin-style-sheet. This is a really good thing,
because the slightest syntax error silently messes up everything that
follows.

Notes:

1. There is now a node called "Basic Fonts (change these first)"
   This node contains the basic font definitions. Changing only the
   settings in this tree (in myLeoSettings.leo, of course) should be enough
   to get Leo looking pretty much as it was.

2. Don't even *think* about changing @data qt-gui-plugin-style-sheet.
   Really, the whole point of this exercise is to be able to change all
   aspects of Leo's appearance without touching this stylesheet. As Terry
   points out, there will always be a place for @data qt-gui-user-style-sheet

3. In an emergency, there is at present a node called "OLD
   qt-gui-plugin-style-sheet" that you could use to revert to the old
   settings. Just rename it and copy it to your myLeoSettings.leo.

4. The new settings scheme will moot the need for leo10pt.leo, leo12pt.leo
   and all the rest. Instead, all font sizes are now defined in terms of
   three intermediate settings: @string font-size, @string medium-font-size
   and @string small-font-size. Changing just these three settings will
   suffice to change *all* the font sizes used in Leo.

5. When things don't look right, I execute this script::

    c.styleSheetManager.print_style_sheet()

This prints the complete stylesheet to the console. What I mainly look for
are lines like::

    background-color: @some-setting

An @value as the value of a setting indicates that no substitution took
place, that is, that there is no node::

    @string some-setting = aValue

Any user that wants to roll their own @data node will want to be aware of
this technique.

5. The @data qt-gui-**user**-style-sheet setting is deprecated. Indeed,
   @data qt-gui-**plugin**-style-sheet now takes care to define almost
   everything that any user would want to define. myLeoSettings.leo should
   contain overrides of only the @color and @string nodes in
   leoSettings.leo.
</t>
<t tx="davy.20141209154025.596">For example, this setting works without any explicit definition of mistyrose2.
    
    @color head-bg = @mistyrose2
</t>
<t tx="davy.20141209154025.6">.. _`quicksearch plugin`:  http://groups.google.com/group/leo-editor/browse_thread/thread/e0ad60ae319359df/e932052a1ef6e9f5
.. _`bigdash plugin`: http://groups.google.com/group/leo-editor/browse_thread/thread/f7eaf4dd4e84a535

- Improved the `quicksearch plugin`_.

- A new `bigdash plugin`_.

- Removed scrolledmessage plugin.

- The vim and xemacs plugins now work smoothly with contextmenu plugin.

- Supported auto-hide in viewrendered plugin.
</t>
<t tx="davy.20141209154025.60">https://github.com/leo-editor/leo-editor/issues/104
https://github.com/leo-editor/leo-editor/issues/103
</t>
<t tx="davy.20141209154025.61"></t>
<t tx="davy.20141209154025.62"></t>
<t tx="davy.20141209154025.63">Previously, when checking "didn't" the spell checker would complain that
"didn" wasn't in the dictionary. Now it checks (and accepts) "didn't".

We have all been putting up with this annoyance for *far* to long. Changing
just two lines of code was all that was required.
</t>
<t tx="davy.20141209154025.64">https://bugs.launchpad.net/leo-editor/+bug/1159490

The solution is to change the following setting in leoSettings.leo::
    
    @bool open_with_save_on_update = True
</t>
<t tx="davy.20141209154025.65">https://bugs.launchpad.net/leo-editor/+bug/1338773
Autocompleter error

Added the following defensive code::

    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="davy.20141209154025.66">https://bugs.launchpad.net/leo-editor/+bug/1338172
ReplaceAll will not replace newlines indicated as \n in target string

Using regX , I can search on a pattern and replace it with a string that
includes "\n" as a newline in the transformed string.

If I do a simple search and replace-search from the Find pane that works
(I'm searching within the body of a single node).

However, if I do a Replace All, the "\n" is not translated into a newline;
it remains as is and appears as "\n" in the transformed string.

Also, I can't seem to get the replace-all command to work from the
minibuffer line; it only does a single replace.
</t>
<t tx="davy.20141209154025.67">https://github.com/leo-editor/leo-editor/issues/92
</t>
<t tx="davy.20141209154025.68">https://github.com/leo-editor/leo-editor/issues/66
errors inhibited read @auto foo.md

The markdown code is now similar to the @auto-rst code.

Added some kludgey code to handle underlining.
</t>
<t tx="davy.20141209154025.69">LeoQtGui.onActivate/DeactiveEvent

This fixed several focus problems.
</t>
<t tx="davy.20141209154025.7">- Improved the create @auto nodes script.

- Added import-org-mode script.

- Added a script for displaying a function call hierarchy in Leo.

- Improved recursive import script.

- Created a script for replacing Qt stylesheets on the fly.

- Scripts to add bookmarks automatically.

- A new "magic refactor" button.

- Changed calling signatures of g.openWithFileName and g.app.newCommander.

- The open-with event now uses a "d" arg.

For full details, see the release notes.
</t>
<t tx="davy.20141209154025.70">The fix was to define out in the ctor of SaxContentHandler.
</t>
<t tx="davy.20141209154025.71">- Leo's desktop button now works properly with Python 3.x.
  The underlying cause was that Leo did not work with python34\pythonw.exe.

- Fixed name of a Qt class in richtext.py plugin.
</t>
<t tx="davy.20141209154025.72"></t>
<t tx="davy.20141209154025.73"></t>
<t tx="davy.20141209154025.74">https://github.com/leo-editor/leo-editor/issues/12

The fix was to p.isVisible.
</t>
<t tx="davy.20141209154025.75">https://github.com/leo-editor/leo-editor/issues/28

Summary post:
https://groups.google.com/d/msg/leo-editor/b6TszFS_6NQ/gJrlRkqH9_oJ
</t>
<t tx="davy.20141209154025.76">https://github.com/leo-editor/leo-editor/issues/31
'undo' on a freshly-loaded outline containing chapters removes chapters

Chapter.afterCreateChapter does not push undo data when cc.initing is True.
</t>
<t tx="davy.20141209154025.77">https://github.com/leo-editor/leo-editor/issues/35
leoBridge sometimes assigns the same GNX to two distinct vnodes

c.initObjects sets c.hiddenRootNode.fileIndex to 'hidden-root-vnode-gnx'

fc.getLeoFile calls the new fc.setMaxNodeIndex after reading all nodes.
</t>
<t tx="davy.20141209154025.78">https://github.com/leo-editor/leo-editor/issues/36

The report seems misleading: it says this happens when Leo tries to load an
@auto file that is in the outline but which was erased outside Leo,
but it worked for me.

I did add a guard in g.recureiveUNLFind to ensure that the IndexError shown
in the bug report can never happen.
</t>
<t tx="davy.20141209154025.79">https://github.com/leo-editor/leo-editor/issues/50
Important: body text lost switching @file to @auto-rst

This case is so dangerous that Leo refuses to create the file and instead
reverts to the previous @file node.

Changes:
    
- v.at_read is now a dict: keys are full file names; values are lists of headlines.
- at.shouldPromptForDangerousWrite returns True if p.h is not in v.at_read.
- at.promptForDangerousWrite issues a warning and reverts the headline
</t>
<t tx="davy.20141209154025.8">- New settings:

    - @bool indent_added_comments
    - @color focus_border_color = red
    - @int focus_border_width = 1
    - @bool use_body_focus_border  = True
    - @bool use_focus_border = True
    
- Other changes:
    
    - Added show-decoration-selected: 1 to QTreeWidget stylesheet. This causes
      the entire headline row to be shown when selected.
    - Added stylesheets for Log &amp; Find tabs.
    - Eliminated the -c option.
    - New format for @openwith settings nodes. See leoSettings.leo for details.

- New search order for leoSettings.leo::

    1. leoSettings.leo in the home directories.
    2. &lt;machine-name&gt;leoSettings.leo in the home directories.
    3. leoSettings.leo in leo/config directory.

- New search order for myLeoSettings.leo::

    1. myLeoSettings.leo in the local directory.
    2. myLeoSettings.leo in the home directories.
    3. &lt;machine-name&gt;myLeoSettings.leo in the home directories.
    4. myLeoSettings.leo in leo/config directory.

- New default settings for run unit tests commands::

    run-marked-unit-tests-externally    = Alt-4
    run-selected-unit-tests-externally  = Alt-5
    
</t>
<t tx="davy.20141209154025.80">https://github.com/leo-editor/leo-editor/issues/59

When a file is dropped into any part of the Leo window, if the cursor is
not on a node it goes to the top or bottom of the tree as a root node.
</t>
<t tx="davy.20141209154025.81">https://github.com/leo-editor/leo-editor/issues/60

It would be nice for Drag and drop files to have relative paths,taking into
account the @path settings of the part of the tree they're dropped into
(currently it is relative to the .leo file).
</t>
<t tx="davy.20141209154025.82">https://github.com/leo-editor/leo-editor/issues/63
</t>
<t tx="davy.20141209154025.83">https://github.com/leo-editor/leo-editor/issues/64
</t>
<t tx="davy.20141209154025.84">https://github.com/leo-editor/leo-editor/issues/74

What I did:

- ScriptingController now uses *gnxs* (not vnodes!) to detect duplicate buttons.
- Use AtButtonCallback for *all* buttons.
- QtIconBarClass.setCommandForButton always calls
  ScriptingController.build_rclick_tree.
- build_rclick_tree no longer assumes that command_p exists.

Rev 8413e2d fixes an important bug in the new code: "remote"
buttons (buttons defined in settings files) now work if the
settings file is not open.

There are some tricky details that must be handled. As an
example, consider a button defined as follows in
myLeoSettings.leo:

    @button print p.h
    print(p.h)

Detail 1: Leo must open myLeoSettings.leo to find the
@button node. Unlike the Goto Script rclick item, the search
does *not* leave myLeoSettings.leo open. That would be too
great a side effect of clicking the @button node!

Detail 2: We don't want to open myLeoSettings.leo every time
the user clicks the buttons, so the first time the user does
so the script is saved (cached). If the user clicks the
button later the cached value is used.

Detail 3: Caching is used "forever" (while Leo remains
open), even if the user opens myLeoSettings.leo and changes
the script. Sorry, this can't be helped. Don't ask me to
change this.

Detail 4: The new code is careful to execute the script in
the commander in which the button is *located*, not in the
commander in which the button is defined.

Report:

Putting @button definitions in myLeoSettings.leo (in an @buttons tree)
makes them available in all Leo files, a nice feature. Two problems:

- The buttons lack the 'Goto Script' rclick feature in all .leo files.
- There are duplicate buttons in myLeoSettings.leo

</t>
<t tx="davy.20141209154025.85">https://github.com/leo-editor/leo-editor/issues/75
write-opml-file always produces an empty file

leoOPML.py's docstring needs updating.

Improved the packaging as follows:

- The leoOPML plugin no longer monkey patches any part of the FileCommands
  class. Instead the plugin sets the c.opmlController ivar.

- fc.writeToFileHelper calls c.opmlController.putToOPML(owner=self).
    
- OpmlController.putToOPML is just PutToOPML(owner) where PutToOPML is a
  class that creates the opml using the owner's put method.
</t>
<t tx="davy.20141209154025.86">https://github.com/leo-editor/leo-editor/issues/76
erroneous clone markers in @auto trees

The fixes were to several methods of the PersistenceDataController class.
</t>
<t tx="davy.20141209154025.87">https://github.com/leo-editor/leo-editor/issues/78

This is a scrolling problem, not a failure to select text.

Changed the call to w.see in find.showSuccess.
</t>
<t tx="davy.20141209154025.88"></t>
<t tx="davy.20141209154025.89">https://bugs.launchpad.net/leo-editor/+bug/1028986
create relative urls when dragging binary files to Leo

This bug was fixed by #60: 
https://github.com/leo-editor/leo-editor/issues/60
create relative paths &amp; urls when dragging files to Leo

Modified dropEvent and its helpers.

Added createLeoFileTree and isLeoFile.

Regular drag of .leo files from a file folder works like the open-outline
command.

Ctrl-drag of .leo files from a file folder copies all nodes of the .leo
file to the receiving outline.

</t>
<t tx="davy.20141209154025.9">.. _`bug 800157`: https://bugs.launchpad.net/leo-editor/+bug/800157
.. _`bug 823267`: https://bugs.launchpad.net/leo-editor/+bug/823267
.. _`bug 875327`: https://bugs.launchpad.net/leo-editor/+bug/875327
.. _`bug 917814`: https://bugs.launchpad.net/leo-editor/+bug/917814
.. _`bug 875323`: https://bugs.launchpad.net/leo-editor/+bug/875323
.. _`bug 831658`: https://bugs.launchpad.net/leo-editor/+bug/831658

- Fixed several bugs related to selection following hoists &amp; chapters:

    - `bug 823267`_: When a tab is closed focus may go to a tab other than the visible one.
    - `bug 875327`_: Positioning outside of hoisted outline" usually causes problems.
    - `bug 917814`_: Switching Log Pane tabs is done incompletely.
    - `bug 875323`_: Hoist an @chapter node leaves a non-visible node selected.
    - `bug 831658`_: @url doesn't leave Chapter.

.. _`bug 951739`: https://bugs.launchpad.net/leo-editor/+bug/951739
.. _`bug 951721`: https://bugs.launchpad.net/leo-editor/+bug/951721
.. _`bug 944555`: https://bugs.launchpad.net/leo-editor/+bug/944555
.. _`bug 944551`: https://bugs.launchpad.net/leo-editor/+bug/944551
.. _`bug 893230`: https://bugs.launchpad.net/leo-editor/+bug/893230
    
- Fixed several bugs related to URL's:

    - `bug 951739`_: xdg-open of a file-scheme URL containing blanks.
    - `bug 951721`_: @url with URL in headline.
    - `bug 944555`_: Ctrl-left-click URL handling not as sophisticated as @url URL handling.
    - `bug 944551`_: @url URL Open Hangs Leo.
    - `bug 893230`_: URL coloring does not work for many Internet protocols.
    - Removed "significant" calls to os.system.
    - Added support for colorizing the following schemes:
      gopher,mailto,news,nntp,prospero,telnet,wais.
      
- Fixed several other serious bugs:
      
    - `bug 800157`_, an ancient hanger in paste-retaining-clones.
    - Fixed at serious read bug. Changed at.readEndOthers and at.readEndRef.
    - Fixed bug: @button @key=x does not override x.
    - Fixed the wretched scrolling bug.
    
- Fixed almost 70 minor bugs. For details, see the release notes.
</t>
<t tx="davy.20141209154025.90">https://bugs.launchpad.net/leo-editor/+bug/1041906

Changed LeoQtTree.closeEditorHelper as follows:
    
- Call w.setItemWidget(item,0,None) to make sure e is never referenced again.
    
- Catch RuntimeError exceptions.
</t>
<t tx="davy.20141209154025.91">Fixed bug 1090950: refresh from disk - cut node resurrection.
https://bugs.launchpad.net/leo-editor/+bug/1090950

refresh_rclick_cb in contextmenu.py now just calls c.refreshFromDisk,
which calls c.recreateGnxDict() before reading any file.

Also created the new refresh-from-disk command and the corresponding item in the File menu.
</t>
<t tx="davy.20141209154025.92">https://bugs.launchpad.net/leo-editor/+bug/1185933

Note: the insert-headline-time command must be bound to a shortcut in order for this to work.
</t>
<t tx="davy.20141209154025.93">https://bugs.launchpad.net/leo-editor/+bug/1228312

This was the so-called "greedy checkbox bug".
</t>
<t tx="davy.20141209154025.94">https://bugs.launchpad.net/leo-editor/+bug/1228452

</t>
<t tx="davy.20141209154025.95">https://bugs.launchpad.net/leo-editor/+bug/1228458
</t>
<t tx="davy.20141209154025.96">https://bugs.launchpad.net/leo-editor/+bug/1231656

This bug may already have been fixed, but just to make sure compareLeoFiles
now calls g.app.forgetOpenFile
</t>
<t tx="davy.20141209154025.97">https://bugs.launchpad.net/leo-editor/+bug/1244461

LeoQtEventFilter.qtKey now changes a toString value of 'Enter' to 'Return'
</t>
<t tx="davy.20141209154025.98">https://bugs.launchpad.net/leo-editor/+bug/1245535
</t>
<t tx="davy.20141209154025.99">https://bugs.launchpad.net/leo-editor/+bug/1245616
</t>
<t tx="edream.110203163054.100">The Synchronization Principle simplifies everything and at long last puts Leo on
a firm theoretical foundation. This principle states that the "smallest unit of
meaning" of any Leo outline is the entire outline itself. In particular,
individual external files have meaning only in the context of a particular
outline.

The Synchronization Principle has the following happy consequences:

1. We may assume that all external files are in synch with the outline that wrote
them. This assumption allows Leo to use "hidden machinery" in the outline to
associate nodes in the external file with nodes in the outline. This "hidden"
machinery consists of a list of tnodes associated with @file vnodes in the
outline. When writing a external file Leo creates a list of tnodes in the order
they were written to the external file. When reading the external file, Leo uses
this list to associate nodes in the external file with nodes in the outline.

2. external files must get their structure from the .leo file that wrote them. As
we have seen, this is done using the hidden machinery in the .leo file.
Consequently, there is no further need to represent outline structure in derived
files. There is no need any longer either for child indices or for sentinels to
represent outline structure. As a result, we can eliminate @+body and @-body
nodes entirely because all @+node sentinels are followed by body text.

3. All .leo files must contain full outline structure. Even "thin" outline will
contain the full representation of the outline as vnodes.

4. Reading _never_ alters outline structure in the outline. No vnodes are ever
created or destroyed and reading never alters clone links. This is true whether
or not read errors occur. The read code sets a temporary attribute of tnodes
while reading. These attributes are copied to the permanent t.bodyString
attribute only if no read errors were encountered.

4. Error recovery is now trivial: Read errors indicate that the .leo files and
one or more external files are out-of-synch. No error recovery is attempted: the
@file tree in which the error occurred reverts back to its original state.

5. The new Import External File command is the _only_ way to recover data from
mismatched external file.
</t>
<t tx="edream.110203163054.101"></t>
<t tx="edream.110203163054.102">The write_old_format_derived_files option in leoConfig.leo and leoConfig.txt
determines which format of external file Leo's Write and Save commands write by
default. If this option is 0 (recommended) Leo writes 4.x format external files.
Otherwise Leo writes 3.x external files.

Note that you can use the Write 3.x/4.x external files commands in the
File:Read/Write menu to write external files in an explicitly specified format.
</t>
<t tx="edream.110203163054.103">This command deletes all entries in the Recent Files submenu except the most
recent file. The files themselves are not affected, just the menu entries.
</t>
<t tx="edream.110203163054.104">The Import External File command imports all the nodes in a external file into the
outline. Unlike the read commands, no outline structure is preserved. This
command can import either 3.x or 4.x external files.

This command is necessary in version 4.0 because there is no other way to read
external files that are out-of-synch with a .leo file.
</t>
<t tx="edream.110203163054.105">The Write 4.x External Files command and Write 3.x External Files command work
just like the Write @file Nodes command, except that they write the indicated
format off external file. In contrast, the Write @file Nodes command writes 3.x
format external files if and only if the write_old_format_derived_files = 1 in
leoConfig.txt.

All three of these commands automatically save the outline (the .leo file) if
any external file was actually written. This is necessary so that information in
the .leo file always remains in synch with all external files.
</t>
<t tx="edream.110203163054.106">Paul Paterson contributed the following new plugins:

mod_autosave.py

Autosaves the Leo document every so often.

mod_timestamp.py

Timestamps all save operations to show when they occur.

word_export.py

Exports an outline to a word document. Clicking "plugins ... word export ...
export" exports the selected outline to Word. Word should be running with an
open (empty) document before executing this command.
</t>
<t tx="edream.110203163054.107"></t>
<t tx="edream.110203163054.108">Leo's read code now warns if any non-empty node is unvisited. This check, and
the check that headlines match pretty much guarantees that out-of-synch outlines
will generate errors. Thus, there is no need a gnx timestamp in @+leo sentinels!
</t>
<t tx="edream.110203163054.109">Version 4.0 is a major advance in Leo's error handling. Using 4.0 is much safer
than all previous versions. This new error handling applies to all derived
files, both 3.x and 4.x format.

Leo's read code never alters the structure of an outline, regardless of whether
read errors are encountered. This means that clone links, marks, and all other
information in the outline except body text remains completely unchanged during
reads. Broken clone links (the dreaded read errors) are gone forever. Also, the
new read code makes no changes to any body text until it is known that no read
errors have occurred. This ensures that absolutely no changes at all are made to
the outline if there are read errors.

Leo's read code now writes a message to the log pane whenever it sees that the
body text in the external file does not match the body text in the outline. These
messages do not indicate errors, only that the body text has been changed
outside of Leo, say in an external editor or by cvs.
</t>
<t tx="edream.110203163054.110"></t>
<t tx="edream.110203163054.111"></t>
<t tx="edream.110203163054.112">Added encoding comments to leoGlobals.py and French plugins

This removes a warning new in Python 2.3.
</t>
<t tx="edream.110203163054.113">There is no need to recycle Python objects when the last outline window is being closed.
</t>
<t tx="edream.110203163054.114">This is too annoying during testing.  The Read @file Nodes command will in fact be made undoable for the 4.0 final release.
</t>
<t tx="edream.110203163054.115">This has been changed in Python 2.3 and it probably wasn't ever a good idea...
</t>
<t tx="edream.110203163054.116">The read code has much simplified using look-behind rather than look-ahead.  Both the read and write code write the file line-by-line without recursion.
</t>
<t tx="edream.110203163054.117"></t>
<t tx="edream.110203163054.63"></t>
<t tx="edream.110203163054.64">Leo 4.1 alpha 1                   November 3, 2003

*** Alpha quality code:  Please make full backups before playing with this code!

This release marks another significant milestone in Leo's history:

- Leo's 4.x file code is complete. At present I have no plans to change the
format of .leo files or external files. I am eating my own dog food: I do all my
editing with the 4.1 code base.

- Leo uses immutable gnx's (id:timestamp:n) by default to associate tnodes with
vnodes in .leo files. This makes Leo as cvs friendly as possible. From now on
.leo files will be checked in to cvs with the -ko (text/keywords off) option.

- The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs
friendly) or ints. No version of Leo before 4.1 can read .leo files containing
gnx. Only gnx's are immutable. Leo recomputes all non-gnx indices from scratch
whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file
formats by changing the use_gnx setting.

- The 4.1 code base has been reorganized to support gui's other than tkinter.
Leo's src directory contains several new source files.

- The file test.leo in the test directory contains real regression tests for
syntax coloring. Regression testing scripts create regression tests dynamically
from data in Leo's outline. Very cool, very easy, very general. In particular,
regression tests may use temporary nodes in test.leo rather than creating
separate Tk windows for testing.

Known bugs:

- The Extract commands eat one character too much.

- The __wx_gui.py plugin is only partly functional.
</t>
<t tx="edream.110203163054.66">Leo 4.0.4                         October 29, 2003

- Fixed a problem with the titles in Font and Color panels.
- Worked around a Unicode assert failure in the colorizer.
- Fixed crasher in OnEndEditHeadline.
- Fixed import problems in leoPlugins.leo.
- @first and @last sentinels no longer contain corresponding text.
  This fixes a problem that affected PHP comment delimiters.

Leo 4.0.3                         October 25, 2003

- Fixes several problems with the auto_save and plugin menu plugins.
- Fixes a problem with the Go To Line Number command.

Note: This version does _not_ support Unicode file names or directory names.

Leo 4.0.2                         October 23, 2003

- Fixes a crasher in reportBadChars when a .leo file contains a character that
  can not be represented in the encoding specified in the first line of the
  .leo file.
- Leo now sends full tracebacks to the log window when Leo takes an unexpected
 exception.

Leo 4.0.1                         October 22, 2003

- Fixes several crashers, one of which may prevent Leo from starting.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.
</t>
<t tx="edream.110203163054.67">Leo 4.0 final                     October 17, 2003

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------

** Improved and simplified format of external files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading external files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all external files properly, regardless of version.
	- Leo writes new-format external files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of external files.

* New commands:
	- Write 3.x external file and Write 4.x external file.
	- Import External File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

See the notes for the various beta releases for full details.
</t>
<t tx="edream.110203163054.68">Leo 4.0 beta 4                      October 13, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.  This will be the last beta release before 4.0 final.

Changes made in 4.0 beta 4
--------------------------

- Changed all instances of string.letters to string.ascii_letters.
  string.letters can cause crashes in some locales (Unicode environments).
- Fixed several bugs that caused clone marks not to be set properly.
</t>
<t tx="edream.110203163054.69">Leo 4.0 beta 3                      October 9, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.

Highlights of 4.0 beta 3
------------------------

- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

See the children of this node for full details.
</t>
<t tx="edream.110203163054.70"></t>
<t tx="edream.110203163054.71">This was a long-standing bug.  It's effect was cosmetic, and it was important to fix.
</t>
<t tx="edream.110203163054.72"></t>
<t tx="edream.110203163054.73">This could happen when the external file was corrupted.
</t>
<t tx="edream.110203163054.74"></t>
<t tx="edream.110203163054.75"></t>
<t tx="edream.110203163054.76">Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo
files:

- When reading a .leo file, Leo will create t.unknownAttributes or
v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt;
or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute
names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if a vnode or tnode
contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute
in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt;
elements. Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing
the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching
unknownAttributes ivars to a vnode or tnode. For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would
be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}
</t>
<t tx="edream.110203163054.77"></t>
<t tx="edream.110203163054.78">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.
</t>
<t tx="edream.110203163054.79">Leo 4.0 beta 2                      October 3, 2003

This is the second public release of Leo 4.0. There are no known serious bugs
in this version of Leo. Version 4.0 is the culmination of over a year of
collaborative design work and several months of actual implementation.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed several problems with reading and writing 4.0 external files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting.  N.B. Allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

See the children of this node for full details.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of external files.
* Greatly improved error handling.
* Full compatibility will previous versions of Leo.
</t>
<t tx="edream.110203163054.80">- Fix undo/redo bug for all commands that change body text in multiple nodes without changing outline structure.
	- This is a long-standing bug that came to light when trying to make Read @file Nodes undoable.

- Make Read @file Nodes command undoable.

- Fix small bugs in the Go To Line Number command.
</t>
<t tx="edream.110203163054.81"></t>
<t tx="edream.110203163054.82">The new code prints a warning if Leo's key internal strings are not Unicode.
</t>
<t tx="edream.110203163054.83"></t>
<t tx="edream.110203163054.833">The Execute Script command executes body text as a Python script. Leo execute
the selected text, or the entire body text if no text is selected.

Scripts are executed in a "pristine" environment, that is, with __builtins__ as
both the local and global environments.

New in version 4.1: Body text may now contain @directives and section
references. This is a major step forward: you can now use all of Leo's features
to organize scripts that you execute interactively.

Section definitions must appear in the node containing the script or in
descendant nodes. Leo "preprocesses" all scripts by simulating the writing of a
external file to a string.

The Execute Script command sets app.scriptDict["script1"] to the value of the
script before preprocessing, and sets app.scriptDict["script2"] to the value of
the script after preprocessing. Scripts may examine and change app.scriptDict as
they please.
</t>
<t tx="edream.110203163054.84">There were bugs involving saving the "Pattern Match" and "Subroutine Only" find settings.
</t>
<t tx="edream.110203163054.85">@nocolor

Class level-code after the method definitions was dropped.
</t>
<t tx="edream.110203163054.86">The new code ensures that Leo creates and uses only Unicode strings internally.
</t>
<t tx="edream.110203163054.87">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed.
</t>
<t tx="edream.110203163054.88">Under certain conditions the no sentinels at all were written when writing @rawfile trees.
</t>
<t tx="edream.110203163054.89"></t>
<t tx="edream.110203163054.90"></t>
<t tx="edream.110203163054.91">This is much more natural and less cluttered.
</t>
<t tx="edream.110203163054.92"></t>
<t tx="edream.110203163054.93"></t>
<t tx="edream.110203163054.94">Leo will create the Leo icon in Leo windows automatically when using Python 2.3.
The Python Imaging Library and the tkIcon package are only used when using
previous versions of Python.
</t>
<t tx="edream.110203163054.95">This is the foundation for "foreign" guis.
</t>
<t tx="edream.110203163054.96"></t>
<t tx="edream.110203163054.97">allow_clone_drags

This is a workaround so that Leo may be used on Aqua. When this setting is zero
Leo always moves nodes when dragging. The default is to enable clone-drags.

enable_drag_messages

Allows the user to suppress the message telling whether dragging nodes will move
them or clone them. The default is to enable those messages.
</t>
<t tx="edream.110203163054.98">After the 4.0 beta 1 release I changed the default so that _new_ format derived
files are written if leoConfig.txt does not exist.
</t>
<t tx="edream.110203163054.99">leo.py 4.0 beta 1                      September 26, 2003

This is the first public release of Leo 4.0.  Version 4.0 is the culmination of over a year of collaborative design work and several months of actual implementation.

Please use caution when using this beta version of Leo.  It appears very solid and it has been tested by only a few people.

Highlights of 4.0:

** Improved and simplified format of external files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading external files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, using 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo reads all external files properly, regardless of version.
	- Leo writes new-format external files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of external files.

* New commands:
	- Write 3.x external file.
	- Write 4.x external file.
	- Import external file.
	- Clear Recent Files.

- Several new plugins.
- Several minor bug fixes.

See the children of this node for full details.
</t>
<t tx="edream.110303182253.3">Leo does an auto-save only if something has actually been changed.
</t>
<t tx="edream.110303182253.39"></t>
<t tx="edream.110303182719">The config_encoding setting controls the encoding of non-ascii characters in leoConfig.txt.

The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.
</t>
<t tx="edream.110603185805">Leo 4.1 beta 5                   December 5, 2003

This is the fifth release of the reorganized 4.1 code base.

For the first time in months there are no serious bugs outstanding.

Warning: By default Leo 4.1 creates .leo files that can not be read by older versions of Leo.

Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
bugs in this plugin could cause body text to be cleared improperly when changing nodes.

Beta 5:
  * Leo runs in batch mode when invoked with --script aScriptFile.py
    - Created "null gui" classes that do not use any gui code.
  * Leo supports Unicode characters (e.g. Chinese) in path and file names.
  * Fixed several long-standing bugs:
    - Fixed several minor problems with the Extract Section and Import commands.
    - Fixed problem that prevent the Find panel from working on the Mac.
    - Improved @url handling so that @url file:\\path\x.leo works properly.
    - Improved support for @lineending platform.
    - Leo honors outline/body pane ratio when opening .leo files.
    - Leo now ensures that newly-opened windows fit entirely on the screen.
    - Fixed a crasher when Undoing a Change All command when searching headlines.
  - Fixed other bugs resulting from the 4.1 reorg:
    - Fixed problem loading plugins on Linux.
    - Fixed crashers in the Extract Section and Extract commands.
    - Fixed a crasher when writing a file containing an undefined section.
    - Removed duplicate bindings in popup menus.
    - Made sure to show Leo's windows in wx gui plugin.

Beta 4:
  - Fixed several "reorg" bugs, some of which affected plugins.
  - Allow @directives and section references when executing scripts!
  - More than one section reference may now appear on the same line.
  - Use "utf-8" encoding for filenames under MacOS (Darwin)
  - Allow command or cmnd prefix for menu shortcuts under Darwin.

Beta 3:
  - Completed the reorg, making many changes to the code base.
  - Fixed a LaTeX coloring bug

Beta 2:
  - Fixed a startup problem on Linux: the "mbcs" text encoding is not valid on Linux.

Beta 1:
  * Script-based find/change commands.
  - Hoist &amp; DeHoist commands for viewing parts of an outline.
  - Check Outline command finds user clone mistakes.
  * New configuration settings:
    - use_gnx specifies whether .leo files use integers as indices:
      use_gnx = 0 makes .leo files compatible with previous versions of Leo.
      use_gnx = 1 makes .leo files cvs-friendly
    - config_encoding specifies the encoding of leoConfig.txt.
  * Several significant code-level changes:
    - The 4.1 code base has been reorganized to support gui plugins.
    - An example wx_gui plugin is partly functional.
    - Created a flexible framework for creating &amp; running regression tests.
    - app.forceShutdown now works when called from plugins.
</t>
<t tx="edream.110603190125.1">Leo 4.1 uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.
</t>
<t tx="edream.110603190125.3">The file test.leo in the test directory contains real regression tests for
syntax coloring.  Regression testing scripts create regression tests dynamically
from data in Leo's outline.  Very cool, very easy, very general.  In particular,
regression tests may use temporary nodes in test.leo rather than creating
separate Tk windows for testing. 
</t>
<t tx="edream.110603190125.4">The 4.1 code base has been reorganized to support gui's other than tkinter.
Leo's src directory contains several new source files.

This reorg affects almost all plugins. Considerably more work and testing will
be done before 4.1 final.

The __wx_gui.py plugin is uses the newly reorganized code.  It is functional
except for gui-dependent commands like Toggle-Split Direction.  WARNING: treat
the this plugin with extreme caution until further notice.  The possibility
exists that bugs in the code could cause body text to be cleared improperly when
changing nodes. 
</t>
<t tx="edream.110603190234.1"></t>
<t tx="edream.110603190322.10"></t>
<t tx="edream.110603190322.11">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.
</t>
<t tx="edream.110603190322.13">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.
</t>
<t tx="edream.110603190322.14">This command checks for unused tnodeLists and checks the topology of all clones.
</t>
<t tx="edream.110603190322.15">The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.  Leo prevents the you from moving nodes outside the hoisted outline.  The De-hoist command restores the outline.  Hoist commands may be nested.
</t>
<t tx="edream.110603190322.3">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.
</t>
<t tx="edream.110603190322.6">@nocolor

New in 4.1: Leo now supports scripts in Leo's Find/Change dialog.

Leo's find panel now contains the Script Search radio button and the Script
Change checkbox. When the Script Search radio button is selected Leo treats the
contents of the Search Text as a script to execute whenever any kind of Find
command is executed. Similarly, when the Script Change checkbox is selected Leo
treats the context of the Change Text as a script to execute whenever any kind
of Change command is executed. See below for just how this works.

Script-based find-change is extremely powerful. In effect, Leo's Find/Change
panel becomes a new platform for running scripts interactively. Leo now has all
the find/change capability of pattern matching languages like Snobol and Icon,
just by using the capabilities of the plain Python language. Moreover, Leo can
deliver these capabilities interactively or not depending which buttons you push
in Leo's Find/Change panel.

Script-based find/change frees the user from having to control script-based
searches interactively. Rather than forcing find/change scripts to implement
their own interactive controls, it is much easier to use what Leo already has.
</t>
<t tx="edream.110603190322.8">Undoing Change All cleared the body pane or the headline pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.
</t>
<t tx="edream.110603190322.9"></t>
<t tx="edream.110603190404"></t>
<t tx="edream.110603192009"></t>
<t tx="edream.110603192009.1"></t>
<t tx="edream.111803060152"></t>
<t tx="edream.111803060152.1">Leo dedicates a Python dictionary called app.searchDict for communication
between Leo and the search and change scripts. The search and change scripts may
also use app.searchDict for communication between themselves. Leo sets
app.searchDict["type"] to "find", "change", "findAll" or "changeAll" to indicate
the kind of command being executed. Scripts may use all other entries in
app.searchDict as they please.

Leo executes the find script once when you press the Find button (or the Change
then Find button) in Leo's Find/Change dialog. Typically, the find script would
traversing the tree and highlight the found text or otherwise indicate to the
user that the find operation has succeeded. However, the script can do anything
it pleases.

Leo executes the the find script repeatedly when you press the Find All button.
Leo keeps executing the find script until app.searchDict["continue"] evaluates
to false. Initially there is no entry for app.searchDict["continue"], so the
find script must set app.searchDict["continue"] = true if it wants Leo to keep
executing it.

Leo executes the change script once when you press the Change button. Typically,
the change script would change the selected text. Usually the change script will
compute the new value of body text and call c.setBodyString(p,newText) to
make that change permanent. 

The change script also may handle undo, typically by calling
c.frame.onBodyChanged(v,"Change",oldText=oldText). Leo does not handle undo
automatically. Indeed, Leo makes no assumptions whatever about what the change
script really does.

Leo executes the the change script repeatedly when you press the Replace All
button. Just as with the Find All command, Leo keeps executing the change script
until app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as c.whole_word_flag, etc. if desired.
</t>
<t tx="edream.111803060152.2">@nocolor

Some ideas for using scripts:

Either the find and change scripts may use Python's re module.  For
example, the find script could set app.searchDict["m"] to the match object
returned by re's match method.  The change script would then compute the
result, change the text and set the undo info as usual.

There is no reason to confine find/change scripts to operate on data only
within a Leo outline. These scripts could as easily traverse your file system
as the Leo outline. But notice: scripts could pull data from the file system
into the outline so that you can see the effects of changes as the scripts
operate. Again, this can all happen interactively if you like.
</t>
<t tx="edream.111803060643"></t>
<t tx="edream.111803062437"></t>
<t tx="edream.112303173638">@color
@  New in version 4.1: On startup, Leo looks for two arguments of the form --script scriptFile.  If found, Leo enters batch mode.

In batch mode Leo does not show any windows.  Leo assumes the scriptFile contains a Python script and executes the contents of that file using Leo's Execute Script command.  By default, Leo sends all output to Leo's log pane to the console window.  Scripts in the scriptFile may disable or enable this output by calling app.log.disable() or app.log.enable()

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body and Edit Headline commands.  Those commands require interaction with the user.

For example, the following batch script reads a Leo file and prints all the headlines in that file.
@c

import leoGlobals as g

path = r"c:\prog\leoCVS\leo\test\test.leo"

g.app.log.disable() # disable reading messages while opening the file
flag,newFrame = g.openWithFileName(path,None)
g.app.log.enable() # re-enable the log.

for p in newFrame.c.all_positions():
	g.es(g.toEncodedString(p.headString(),"utf-8"))
</t>
<t tx="edream.120403174147"></t>
<t tx="edream.120403174147.102">Another 4.1 reorg bug.
</t>
<t tx="edream.120403174147.105">This bug has been around for a long time.
</t>
<t tx="edream.120403174147.109">The new code attempts to use bitmap files only on Windows.
</t>
<t tx="edream.120403174147.112">Leo makes sure that opened files or newly-created outlines fit entirely on the screen.  The Cascade commands leaves the sizes of windows unchanged: it merely ensures that the top left corner of a window is visible on the screen.
</t>
<t tx="edream.120403174147.119"></t>
<t tx="edream.120403174147.128">@

A problem: the new window gets put behind the old.  This is probably because Tk
thinks that the mouse-down event should select then new window... 
</t>
<t tx="edream.120403174147.30">Another 4.1 reorg bug.
</t>
<t tx="edream.120403174147.33">This was due to a missing activate event.
</t>
<t tx="edream.120403174147.36">Continuation lines caused the import command to terminate functions, methods and classes prematurely.
</t>
<t tx="edream.120403174147.56"></t>
<t tx="edream.120403174147.61">This was causing Leo not to load plugins properly on Linux.  The problem was that the imp module does not handle Unicode file names properly.
</t>
<t tx="edream.120403174147.63">This was a reorg bug.
</t>
<t tx="edream.120403174147.65">Another bug caused by the 4.1 reorg.
</t>
<t tx="edream.120403174147.94">- Leo now properly enables and disables the Extract Section menu item.
- Leo no longer removes leading forward slashes in section names in headlines.
- Corrected the documentation for the Extract Section command.
</t>
<t tx="edream.120403174241"></t>
<t tx="edream.120403180443"></t>
<t tx="edream.120403180443.1"></t>
<t tx="edream.121403160546">Leo 4.1 Release Candidate 3              December 19, 2003

This release fixes a serious bug in the logic that reads old-style external files.

There are no known bugs in this version of Leo.

The highlights of this release:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- A host of bug fixes.
</t>
<t tx="edream.121403161017">See previous release notes for more details:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="edream.121403161017.1">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="edream.121403161017.2">- use_gnx specifies whether .leo files use integers as indices:

	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.
</t>
<t tx="edream.121403161340">- Import External File command now uses a file dialog.

	This is much more natural than using @file nodes.
</t>
<t tx="edream.121403165221">- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.
</t>
<t tx="ekr.20031218072017.1999">if 0:
    def toString (self,index):
        '''
        Convert a tuple, string or None to its string representation.
        *Important* the present sax code and earlier versions of Leo
        use various kinds of tuples.  Do *not* change the tuple-related code!
        '''
        if g.isString(index): # new gnxs:
            return g.toUnicode(index)
        elif index is None: # new gnxs:
            return self.getNewIndex() 
        try:
            theId,t,n = index
            if n in (None,0,'',):
                s = "%s.%s" % (theId,t)
            else:
                s = "%s.%s.%s" % (theId,t,n)
        except Exception:
            if not g.app.unitTesting:
                g.trace('unusual gnx',repr(index),g.callers()) 
            try:
                theId,t,n = self.getNewIndex()
                if n in (None,0,'',):
                    s = "%s.%s" % (theId,t)
                else:
                    s = "%s.%s.%d" % (theId,t,n)
            except Exception:
                s = repr(index)
                g.trace('double exception: returning repr(index)',s)
        return g.toUnicode(s)
</t>
<t tx="ekr.20031218072017.365"></t>
<t tx="ekr.20031218072017.366">use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
    cvs add leoConfig.txt
    cvs add leoConfig.py
    (then do commit)

remove readme*.doc
    remove files from working area (done)
    cvs remove readme1.doc
    cvs remove readme2.doc
    ...
    (then do commit)
</t>
<t tx="ekr.20031218072017.3660">mustBeDefinedInSubclasses = (
    # Birth, death &amp; config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
)
</t>
<t tx="ekr.20031218072017.367">- Add new entries in the following Python dictionariues in leoApp.py:
  self.language_delims_dict, self.language_extension_dict and self.extension_dict

- Add an entry to the languages list in &lt;&lt;configure language-specific settings&gt;&gt;

- Add a list of the keywords of the language to &lt;&lt; define colorizer keywords &gt;&gt;

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done.

- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  &lt;&lt; define global colorizer data &gt;&gt;

- Create the files theLanguage.xml and theLanguage.py file was added to the leo\modes directory.
  See Chapter 15 of Leo's users guide for full details.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

@color
</t>
<t tx="ekr.20031218072017.384">Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
</t>
<t tx="ekr.20031218072017.385">To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
</t>
<t tx="ekr.20031218072017.386">teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
&gt; I am plowing through old bug reports, and I found the following, from whom 
&gt; I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

&gt;&gt; - Source files still have the dreaded \r in them. Why don't you switch 
&gt;&gt; to \n only, once and for all, and live happily ever after? ;^) 

&gt; I sure whould like to do that, and I'm not sure how to do this. All 
&gt; versions of the read code attempt to remove '\r' characters, and all 
&gt; versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 

</t>
<t tx="ekr.20031218072017.387">Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

&gt; Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
</t>
<t tx="ekr.20031218072017.388">In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; f = open("crlf.txt")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
&gt;&gt;&gt; f = open("crlf.txt", "rU")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline" problem,\n'

</t>
<t tx="ekr.20031218072017.389">&gt; You can open the file in 'binary' mode (adding 'b' to the mode string) and
&gt; the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
</t>
<t tx="ekr.20031218072017.391">I have a fair bit of expertise on CVS branches. It's late at night, so I
don't have time for a long soapbox spiel at the moment. I will try to post
something tomorrow.

The brief picture is: 

* Check out code from CVS at the point you want to create the branch.

* Make sure none of the files in your sandbox is modified.

* Create the branch (cvs tag -b branchname). The branch name must start
  with a letter (upper or lower case) and thereafter can have alphanumeric
  characters, hyphens, and underscores (no periods or spaces).

* The branch is created on the repository, but your sandbox is still
  checked out on the main branch. To check out on the new branch, do "cvs
  up -r branchname".

When you want to merge changes back into the main branch, you can use "cvs
up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to
merge changes, then "cvs commit" to commit the merged version to the main
branch AFTER YOU HAVE VERIFIED IT.

I would recommend caution with merging because as you have noted, leo files
are not well set up for CVS. They don't merge well because of inconsistent
sentinel values.

You may want to look at manually merging changes back into the main branch
until leo implements invariant unique (UUID) sentinel indices.

This will not hurt your ability to use branches, only your ability to
automatically merge changes from one branch onto another.
</t>
<t tx="ekr.20031218072017.392"></t>
<t tx="ekr.20031218072017.398">In general, everything you can do in Python is accessible through the C API.

    lines = block.split('\n');

&gt; That will be

    lines = PyObject_CallMethod(block, "split", "s", "\n");
</t>
<t tx="ekr.20031218072017.399"></t>
<t tx="ekr.20031218072017.400">It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\&gt;set PATH=%PATH%;c:\python22\tools\Scripts

C:\&gt;google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\&gt;google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\&gt;
</t>
<t tx="ekr.20031218072017.401">&gt;&gt; It has a header of just one line. All the ugly stuff is at the end.
&gt;&gt;
&gt;&gt; -------------------------------------------------------------------
&gt;&gt; goto ="python"
&gt;&gt;
&gt;&gt; # Python code goes here
&gt;&gt;
&gt;&gt; ''' hybrid python/batch footer:
&gt;&gt; @:="python"
&gt;&gt; @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
&gt;&gt; @if errorlevel 9009 echo Python may be downloaded from
&gt;www.python.org/download
&gt;&gt; @rem '''
&gt;&gt; -------------------------------------------------------------------
&gt;&gt;
&gt;&gt;         Oren
&gt;&gt;
&gt;

It's for running python scripts on windows, without having to type:

[&lt;path to python&gt;\]python[.exe] &lt;scriptname&gt; [&lt;arguments&gt;*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

</t>
<t tx="ekr.20031218072017.434">@ignore
@language python
@color
</t>
<t tx="ekr.20031218072017.670">(In Linux) The home page and online tutorial options in the menu only work
properly if Mozilla window is already open. If not, a Mozilla window opens, but
with empty page and url field.
</t>
<t tx="ekr.20031218072017.672">This has been and continues to be a known issue with Tk. Has been logged as a
bug; no response from the Tk folks.

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&amp;aid=605277&amp;group_id=12997&amp;atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
</t>
<t tx="ekr.20031218072017.673">The following bugs can not be fixed because they are Tk bugs.

These bugs are becoming moot: Tk will soon be deprecated.
</t>
<t tx="ekr.20031218072017.674">Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
</t>
<t tx="ekr.20031218072017.675">1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
</t>
<t tx="ekr.20031218072017.676"></t>
<t tx="ekr.20031218072017.677">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

</t>
<t tx="ekr.20031218072017.718"></t>
<t tx="ekr.20031218072017.719">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
</t>
<t tx="ekr.20031218072017.720">This is a test line.
</t>
<t tx="ekr.20031218072017.721">This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


</t>
<t tx="ekr.20031218072017.745">@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
@verbatim
@verbatim
@verbatim
#@+leo 
@verbatim
@verbatim
@verbatim
#@+node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@+body 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@+doc 
# 
# How many firsts do I get? 

@verbatim
@verbatim
@verbatim
#@-doc 
@verbatim
@verbatim
@verbatim
#@@c 
Start code. 
@verbatim
@verbatim
@verbatim
#@-body 
@verbatim
@verbatim
@verbatim
#@-node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first &lt;num&gt; 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
</t>
<t tx="ekr.20031218072017.748">Need a good yaml parser first: I don't want to write another parser by hand.
</t>
<t tx="ekr.20031218072017.753">@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
</t>
<t tx="ekr.20031218072017.790">@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
</t>
<t tx="ekr.20031218072017.795">@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list &amp; schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 

3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  

There are quite a few of these now.  It would be good to generalize:
- Register @node type.
</t>
<t tx="ekr.20031218072017.797">@nocolor

I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new"&gt;ftp://user:pass@ftp.sd.org/python/foo.py&gt; 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?

@color
</t>
<t tx="ekr.20031218072017.805">Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
</t>
<t tx="ekr.20031218072017.807">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
</t>
<t tx="ekr.20031218072017.810">I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
</t>
<t tx="ekr.20040104162835.13">Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


</t>
<t tx="ekr.20040104162835.14">&gt; 1. The python that FC installs is MacPython.  I think that because the
&gt; MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

&gt;
&gt;
&gt; I have the TkTclAquBI (Batteries included) installer.  Is installing 
&gt; this
&gt; enough to get Leo to work with Aqua?  Do I have to de-install the
&gt; present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

</t>
<t tx="ekr.20040104162835.15">Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
</t>
<t tx="ekr.20040104162835.8"></t>
<t tx="ekr.20040105070023.5">Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
</t>
<t tx="ekr.20040115165036">@language html
@ignore
@color
</t>
<t tx="ekr.20040115165036.1">@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
</t>
<t tx="ekr.20040115165036.3">@first
@language HTML
&lt;HiMom&gt;
@
This will produce, in the derived file, an XML comment with another XML comment
embedded. Or, if you prefer, it will produce an unclosed XML comment followed by
a well-formed one, followed by a string of text containing a comment-close
marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the
same line as the at-sign.
@c
&lt;/HiMom&gt;
</t>
<t tx="ekr.20040115165036.4">&lt;?xml version='1.0'?&gt;
&lt;!--@+leo-ver=4--&gt;
&lt;!--@+node:@file xmlcommentbug.xml--&gt;
&lt;!--@@first--&gt;
&lt;!--@@language HTML--&gt;
&lt;HiMom&gt;
&lt;!--@+at --&gt;
&lt;!--
&lt;!--@nonl--&gt;
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
--&gt;
&lt;!--@-at--&gt;
&lt;!--@@c--&gt;


&lt;!--@+at--&gt;
&lt;!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
--&gt;
&lt;!--@-at--&gt;
&lt;!--@@c--&gt;
&lt;/HiMom&gt;
&lt;!--@nonl--&gt;
&lt;!--@-node:@file xmlcommentbug.xml--&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20040117092727">By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
</t>
<t tx="ekr.20040118090055">https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&amp;aid=879073&amp;group_id=12997&amp;atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&amp;aid=879077&amp;group_id=12997&amp;atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
</t>
<t tx="ekr.20040123102724">@language rest
</t>
<t tx="ekr.20040131040356">Leo 4.1 Release Candidate 4              February 3, 2004

This release fixes numerous bugs reported since 4.1 rc3 and makes several other
minor improvements, including several nifty new plugins.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.
</t>
<t tx="ekr.20040131040356.1"></t>
<t tx="ekr.20040131040356.2">See previous release notes for more details:

4.1 rc3:

- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.

4.1 rc2, rc1, betas, alphas:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="ekr.20040131040356.3">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="ekr.20040131040356.4">- use_gnx specifies whether .leo files use integers as indices:

	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.
</t>
<t tx="ekr.20040131040356.5">- Import External File command now uses a file dialog.

	This is much more natural than using @file nodes.
</t>
<t tx="ekr.20040131040544.10">This allows plugins to draw the status area in the icon area.
</t>
<t tx="ekr.20040131040544.146">- Leo now does a better job of checking and reporting read-only violations.

- Leo now clears the file-dirty mark only if the file was successfully saved.

</t>
<t tx="ekr.20040131040544.169"></t>
<t tx="ekr.20040131040544.178">Leo sets only ancestor @file nodes dirty (not nodes themselves) when altering
outline structure, i.e., when moving, inserting, deleting, cloning and sorting
nodes.
</t>
<t tx="ekr.20040131040544.18">The old code was concatenating strings; the new code uses list.append.
</t>
<t tx="ekr.20040131040544.2"></t>
<t tx="ekr.20040131040544.21">- ESC closes the Find panel.

- Hitting the Return key is now equivalent to hitting the Find button.
</t>
<t tx="ekr.20040131040544.222">That is, when preprocessing the script (expanding section references, etc.) Leo
now ensures that child nodes effectively end in a newline. This prevents
unintended concatenation of lines.
</t>
<t tx="ekr.20040131040544.227">A contained a space before a tab in the leading whitespace of the line.
</t>
<t tx="ekr.20040131040544.228">- These commands did not properly count the number of changed nodes.
- These commands now mark only changed nodes as dirty.
</t>
<t tx="ekr.20040131040544.258"></t>
<t tx="ekr.20040131040544.32"></t>
<t tx="ekr.20040131040544.5"></t>
<t tx="ekr.20040131040544.55">Leo now reports the parent of the orphan node.
</t>
<t tx="ekr.20040131040544.73">This bug happened when a move up command would cause a node to become the
sibling of (a clone of) itself. In such cases, Leo simply selects the other
cloned copy of the moved node.
</t>
<t tx="ekr.20040131040544.81">The bug was causing Leo not to remember the comment delimiters in the @+leo
sentinel. As a result, Leo was recognizing no sentinels and the command
complained about missing @-leo sentinels.
</t>
<t tx="ekr.20040131040754">Fixed crashers in:

- Insert Headline Time/Date commands.
- Change headline command.
- Write Dirty/Missing @file Nodes commands.
- Batch mode.
</t>
<t tx="ekr.20040131041015"></t>
<t tx="ekr.20040131044136">- Fixed a bug that caused cut and paste operations in headlines to revert when those commands were chosen from the Edit menu.

- Extended control-v bug fix to "darwin","freebsd4","freebsd5"

- Cut and paste are now always enabled when not editing the body pane.  This isn't perfect, and is an improvement.
</t>
<t tx="ekr.20040131044727">1. Fixed a bug that caused improper indentation of sections.

The bug happened in some cases when a section reference occurred following non-whitespace.

2. Leo ensures that leading whitespace is not added when writing empty lines.

This might fix the "Zope Sprint" bug: "blank" lines in the expansion of @others got leading whitespace.
</t>
<t tx="ekr.20040131100557">Previously, if you hoist a node with no children and then insert a node (CTRL-I)
then the child is created as a sibling of the hoisted node and consequently is
not displayed.

Leo now creates the new node as the first child of the hoisted node. 

Also, Leo disables the Clone command when the presently selected node is the root of a hoist.
</t>
<t tx="ekr.20040201061329">This creates a status area at the bottom of the Leo Window. Plugins may write to
this area using the status area convenience routines in leoTkinterFrame.py.
</t>
<t tx="ekr.20040201113232">@nocolor

The Scripts node in LeoPy.leo contains a script called initScriptFind.  This script makes it easy to set up script based searches as follows:

1. Put the following code in the root of a tree that will contain your script search:

@color
# Initialize Leo's find panel using the named children of this node.
from leoGlobals import *
initScriptFind("Find script","Change script") # Second argument is optional.
# Start searching at the top.
top().selectVnode(c.rootVnode())
@nocolor

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto!  Leo is ready for a script search.
</t>
<t tx="ekr.20040201114855"></t>
<t tx="ekr.20040201114855.105"></t>
<t tx="ekr.20040201114855.106"></t>
<t tx="ekr.20040201114855.107">This bug happened when executing the initScriptFind script.  This bug could cause Leo not to be able to save files.
</t>
<t tx="ekr.20040201114855.13">Adds a quick search to the toolbar in Leo.

A search box which behaves like a web site search is added, along with a "GO"
button to do quick searches right from the main Leo window. All the current
search options are retained except that "search body text" is explicitly set -
mainly because this is by far the most common use case.

Pressing &lt;CR&gt; while editing the text automatically does a search. Repeated
searches can be done by clicking the "GO" button.

The combo box also stores a list of previous searches, which can be selected to
quickly repeat a search. When activating a previous search the original search
mode is used.

Still to do:

- incremental search
- reverse search
- persist recent searches across Leo sessions
- use INI file to set options for list size, etc.
</t>
<t tx="ekr.20040201114855.29">Adds a node navigator to the toolbar. The navigator allows quick access to
marked nodes. You can either go to the marked node or hoist the marked node.
</t>
<t tx="ekr.20040201114855.3">This plugin uses Leo and docutils to mix program code and reST documentation.

The Python docutils package must be installed.http://docutils.sourceforge.net

The basic approach is that any Leo node that contains program code that needs
documentation (in an ideal world it would be every node) has an associated child
node whose headline is simply '@rst', that contains reST-style documentation.
While this means that a typical program may have dozens (if not hundreds) of
these @rst nodes, it produces documentation that I think is as close as I have
ever seen to useful, easy-to-read documentation that is easy to create at the
same time as an application is being coded.

There are several interrelated aspects to this work:

- The reST plugin (renamed rst2) was hacked to manage Leo outlines that were a
combination of normal code nodes and reSt nodes.

- The plugin now recognizes a @rst directive (that has no associated file name)
in the headline of a node.

- When it encounters such a @rst Headline node, it writes the contents of the
body of the @rst node's *parent* (which generally contains program code) to the
reST output file (HTML) and then adds the reST content that is contained in the
body of the @rst documentation node to the output HTML file,

- These @rst nodes are used in @file-nosent trees and the @rst nodes have an 
@ignore directive (plus @nocolor directive and @wrap directives) so that 
when the @file is updated the application code does not contain the reST-style
documentation contained in the body of the @rst nodes. (This was the reason I
had asked you in the Leo Forum to allow @file-nosent trees to work appropriately
with @ignore nodes - Thank you for doing this right away.) There is no reason
that the reST content couldn't be written to the 
@file as documentation other than I personally believe in a volume of 
documentation (including musings, failed ideas, questions, etc.) that is 
probably best kept separate from the actual *.py files.

- When you double-click on a plain rst node (no associated filename) Leo opens
both the @rst documentation node and the parent node containing code in an
external editor *simultaneously*. I happen to use Textpad and so the code is
opened with python syntax coloring in one Textpad window and right next to it is
the reST documentation. This makes it much much easier to code and do
documentation at the same time. (Note that the plugin assumes that the python
extension is '.tp' since that is what I use with TextPad.)

So why is this a big deal?

For the first time in my experience the documentation process:

1) is completely in sync with the process of code development.

2) allows the programmer to write as much documentation as he/she wants without
the programming code becoming unreadable because of what would be considered
excessive or intrusive documentation. (This applies whether documentation is
intended for external consumption or just so a solo programmer can remember what
he/she was thinking...)

My conclusion is that Leo + reST/docutils provides the perfect platform for
optimal documentation.

Frankly, I think this is all a minor miracle but maybe I've lost perspective.

Steve Zatz
</t>
<t tx="ekr.20040201114855.36">Adds row/column indicators to the toolbar at the top of Leo Windows.
</t>
<t tx="ekr.20040201114855.42">A minimal http plugin for Leo, based on AsyncHttpServer.py.

Use this plugin is as follows:

1. Start Leo with the plugin enabled. You will see a purple message that says
something like: "http serving enabled on port 8080, version 0.9"

2. Start a web browser, and enter the following url: http://localhost:8080/
You will see a a "top" level page containing one link for every open .leo file.
Start clicking :-)

You can use the browser's refresh button to update the top-level view in the
browser after you have opened or closed files.
</t>
<t tx="ekr.20040201114855.91">Automatically add nodes for common tasks. This can be used to generate boiler
plate code to quickly build an outline.
</t>
<t tx="ekr.20040201120903">Adds a status line to the bottom of Leo windows.
</t>
<t tx="ekr.20040203084228">The Change All command was looping when the find pattern was '\n'.
</t>
<t tx="ekr.20040216054459">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now
and then, (hey, not a week passes that i dont think to myself : "why did'nt
anyone thought of that kind of tool that is LEO. It's so stupid to program such
a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a
feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in
the starting node body of the file and place in the file, as it's decendants
(children, grand-children &amp; so on) some clones of other stuff somewhere else
outside of this file (usualy, clones of parts of program regrouped as children
of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in
lower level languages, the order of components such as procs, declarations, etc
as an importance. It also has the implication that &lt;&lt; and &gt;&gt; brackets are
irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it
here in case no one had any need of this before) is that when used in the BODY
of a node part of an "@file" the @h and @endh would define a chunk of text in
the body, you've guessed it, to be added before _each_ children node and ONLY
children no grandchildren or any deeper. But It could also be used INSIDE the
body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it
clearly? maybe this would help:'

CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise : It's just really for adding something at end or beginning of a
direct children of a node part of an @file in the tangling process.

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not
be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but
instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it,
sourceforge "eated" leading spaces sorry a, b and c are children of their "+"
node just above them . -- k
</t>
<t tx="ekr.20040216151748">Leo 4.1 Final              February 20, 2004

Leo 4.1 Final is the culmination of four months of work. No significant bugs
have been reported since 4.1 rc4. Several people have contributed nifty plugins
recently. See leoPlugins.leo for full details.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.
</t>
<t tx="ekr.20040216152948"></t>
<t tx="ekr.20040216153725">Changed Undo/Redo messages:

- Insert Outline to Insert Node.
- Delete Outline to Delete Node.
- Clone to Clone Node.

This is a real code change: it affects the undo/redo logic.
</t>
<t tx="ekr.20040217075627">Clone bits could be improperly set in some cases.  This bug would not have caused serious long-term problems.

Steps to reproduce:

1. Create a parent node (named 'cloned').
2. Create two children nodes (one named 'dummy' and another named 'bottom') under the parent node 'cloned'.
3. Move the 'bottom' node below the 'dummy' node.
4. Clone node 'cloned'.
5. Copy node 'dummy'.
6. Paste node 'dummy' in between 'dummy' and 'bottom'.
7. After pasting you'll see that 'bottom' is now marked as a cloned node.
</t>
<t tx="ekr.20040217085036">See leoPlugins.leo for full details.
</t>
<t tx="ekr.20040217085036.1">Here is the bug report I submitted to Python:

The documentation for encoding lines at

C:\Python23\Doc\Python-Docs-2.3.1\whatsnew\section-encodings.html

states:

"Encodings are declared by including a specially formatted comment in the
first or second line of the source file."

In fact, contrary to the implication, the Python 2.3 parser does not look
for lines of the form:

# -*- coding: &lt;encoding&gt; -*-

For example, Python improperly scans the following line for an encoding

#@+leo-ver=4-encoding=iso-8859-1.

and reports that iso-8859-1. (note trailing dot) is an invalid encoding!

The workaround for my app is to precede this line with the following line:

# -*- coding: iso-8859-1 -*-

This makes Python 2.3 happy.

To make myself perfectly clear: Python has absolutely no right to complain
about comment lines that do not have the form:

# -*- coding: &lt;encoding&gt; -*-
</t>
<t tx="ekr.20040220110030">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
</t>
<t tx="ekr.20040403171740">@ @rst-options
.. A very cool option: doc parts will be rendered properly,
.. but will be ignored by the Execute script command.
..
show_doc_parts_as_paragraphs = True
@c

.. |---| unicode:: U+02015 .. for quotes
   :trim:

#########################
Scripting Leo with Python
#########################

.. _`Python Tutorial`: http://docs.python.org/2/tutorial/

    "Leo a way to make a "living" document. A document built out of
    discrete parts that can be re-organized on the fly to meet the needs of
    a varying audience... just the possibility of keeping system
    maintenance scripts in the IT manual is mind boggling."---David Nichols

This chapter tells how to write **Leo scripts**, Python scripts run from
any Leo node. This chapter also discusses several topics related to
scripting: autocompletion, @button and @test.

This chapter is intended for those fairly comfortable with Python
scripting. If you are not, please study the excellent `Python Tutorial`_.

.. _`informal scripting tutorial`: http://blog.suspended-chord.info/2014/01/28/intro-to-leo-scripting/

As an alternative to this chapter, Jacob Peck has written a more `informal scripting tutorial`_.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20040403173920.18" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e710158040000003c2f613e71025d710328582e0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583a0000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a711058760000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">Leo dispatches commands using c.doCommand,
which calls the "command1" and "command2" hook routines for the given label.
c.doCommand catches all exceptions thrown by the command::

    c.doCommand(c.markHeadline,label="markheadline")

You can also call command handlers directly so that hooks will not be called::

    c.markHeadline()

You can invoke minibuffer commands by name.  For example::

    c.executeMinibufferCommand('open-outline')

c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.
</t>
<t tx="ekr.20040403173920.19" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e710158040000003c2f613e71025d71032858390000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e710458060000003c2f6469763e71055d710628583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710758060000003c2f6469763e71085d71092858060000003c626f64793e710a58070000003c2f626f64793e710b5d710c2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d58070000003c2f68746d6c3e710e4e6565656558070000003c2f6469763e0a710f583b0000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a711058780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a7111652e">Each commander sets ivars corresponding to settings.

Scripts can get the following ivars of the Commands class::

    ivars = (
        'output_doc_flag',
        'page_width',
        'page_width',
        'tab_width',
        'target_language',
        'use_header_flag',
    )
    print("Prefs ivars...\n",color="purple")
    for ivar in ivars:
        print(getattr(c,ivar))

If your script sets c.tab_width it should call f.setTabWidth to redraw the
screen::

    c.tab_width = -4    # Change this and see what happens.
    c.frame.setTabWidth(c.tab_width)
</t>
<t tx="ekr.20040403173920.24" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710158040000003c2f613e71025d71032858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710458060000003c2f6469763e71055d710628584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258070000003c2f6469763e0a711358350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e">On startup, Leo looks for two arguments of the form::

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's Execute Script command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling app.log.disable or app.log.enable

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body
and Edit Headline commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file::

    path = g.os_path_finalize_join(g.app.loadDir,'..','test','test.leo')
    assert g.os_path_exists(path),path

    g.app.log.disable() # disable reading messages while opening the file
    c2 = g.openWithFileName(path)
    g.app.log.enable() # re-enable the log.

    for p in c2.all_positions():
        g.es(g.toEncodedString(p.h,"utf-8"))
</t>
<t tx="ekr.20040414161647" str_atime="1376411963.0">These are the sources for Leo's users guide.

They contain sphinx markup. See::

    http://sphinx.pocoo.org/
    http://docutils.sourceforge.net/docs/user/rst/quickstart.html
    </t>
<t tx="ekr.20040414172218.4">##################
Acknowledgements
##################

Leo owes much of its visual design to MORE, possibly the most elegant computer program ever written. Leo's clone nodes are inspired by MORE.

The following people have made generous donations to the Leo project: Robert Low, Nic Cave-Lynch.

The following people reported bugs, answered questions, and made suggestions for improving Leo:
Alex Abacus, Shakeeb Alireze, Steve Allen, Bruce Arnold,
Chris Barker, Dennis Benzinger, David Boddie, Jason Breti, Eric Brown, Terry Brown, Darius Clarke, Martin Clifford, Jason Cunliffe, Josef Dalcolmo, Gil Dev, Bill Drissel, Wenshan Du,
Allen Edwards, Chris Elliot, Dethe Elza, Mark Engleberg, Roger Erens, Stephen Ferg, Tom Fetherston, Tomaz Ficko, Niklas Frykholm, Fred Gansevles, Jonathan M. Gilligan, Zak Greant, Thomas Guettler, Romain Guy, Dave Hein, Tiago Castro Henriques, Gary Herron, Steve Holden, Klass Holwerda, Matthias Huening, Robert Hustead, John Jacob, Paul Jaros, Christopher P. Jobling, Eric S. Johansson, Garold Johnson, James Kerwin, Nicola Larosa, David LeBlanc, Chris Liechti, Steve Litt, Martin v. Löwis (Loewis), Robert Low, Fredrik Lundh, Michael Manti, Alex Martelli, Marcus A. Martin, Gidion May, David McNab, Frank Merenda, Martin Montcrieffe, Will Munslow, Chad Netzer, Derick van Niekerk, Jeff Nowland, Naud Olivier, Joe Orr, Marc-Antoine Parent, Paul Paterson, Sean Shaleh Perry, Tim Peters, David Priest, Gary Poster, Scott Powell, Bruce Rafnel, Walter H. Rauser, Olivier Ravard, David Speed Ream, Rich Ries, Aharon Robbins, Guido van Rossum, David Rowe, Davide Salomoni, Steven Schaefer,Johannes Schöön, Wolfram Schwenzer, Casey Wong Kam Shun, Gil Shwartz, Jim Sizelove, Paul Snively, Jurjen Stellingwerff, Phil Straus, David Szent-Györgyi, Kent Tenney, Jeffrey Thompson, Gabriel Valiente, Jim Vickroy, Tony Vignaux, Tom van Vleck, Kevin Walzer, Ying-Chao Wang, Cliff Wells, Dan Wharton, John Wiegley, Wim Wijnders, Dan Winkler, Vadim Zeitlin.

The following have contributed plugins to Leo:

Rodrigo Benenson, Pierre Bidon, Felix Breuer, Terry Brown,
Mike Crowe, Josef Dalcolmo, Michael Dawson, e, Roger Erens, 
Andrea Galimberti, Engelbert Gruber, Timo Honkasalo, Jaakko Kourula, Maxim Krikun, Zhang Le, LeoUser, Frédéric Momméja, Bernhard Mulder, Mark Ng, Alexis Gendron Paquette, Paul Paterson, Dan Rahmel, Davide Salomoni, Ed Taekema, Kent Tenney, Brian Theado, Ville M. Vainio, Steve Zatz.
</t>
<t tx="ekr.20040416080538">The following deserve special mention:
David Brock wrote TSyntaxMemo.
The late Bob Fitzwater kept me focused on design.
Donald Knuth invented the CWEB language.
Jonathan M. Gilligan showed how to put the Leo icon in Leo's windows.
Joe Orr created XSLT stylesheets for Leo; see http://www.jserv.com/jk_orr/xml/leo.htm.
Joe Orr also created an outstanding set of tutorials for Leo; see http://www.evisa.com/e/sb.htm.
LeoUser (B.H.) contributed numerous plugins and was the inspiration for Leo's minibuffer.
LeoUser also wrote jyLeo: Leo for Jython.
The late Bernhard Mulder proposed a new way of untangling external files.
John K. Ousterhout created tcl/Tk. Neal Norwitz wrote PyChecker.
Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it.
Paul Paterson suggested the plugin architecture,
suggested an approach to spell checking and has contributed many excellent plugins.
François Pinard wrote pymacs.
Norman Ramsey created noweb and gave permission to quote from the noweb web documentation.
Rich Ries has contributed a huge number of suggestions.
Steven P. Schaefer pointed out major security problems lurking in hooks.
Gil Shwartz helped with unicode support.
Phil Straus has been a great friend and constant support.
Guido van Rossum created Python, Tkinter and the Python License.
Dave Winer created MORE.
Ville M. Vainio created ILeo and has made many other valuable contributions to Leo.
Dan Winkler helped support Leo on the Mac.

Special thanks to my family.
My brother, David Speed Ream, tested Leo and made many useful suggestions.
Rebecca, James and Linda make it all worthwhile.
It was during a conversation with Rebecca that I realized that MORE could be used as a prototype for Leo.
That was a crucial first step.
</t>
<t tx="ekr.20040705111716"></t>
<t tx="ekr.20040705111716.1">Leo will write only t.unknownAttributes to the .leo file when writing the &lt;v&gt;
element corresponding to the root of an @thin tree. Leo will do this by writing
a new xml attribute, say descendentTnodeUnknownAttributes, in &lt;v&gt; element.

The reason that Leo will only write t.unknownAttributes and not
v.unknownAttributes is that only tnodes have gnx's in thin external files. In
effect, vnodes are anonymous. We could attempt to get around this by identifying
vnodes by their corresponding tnodes, but that's not a general solution and it
is, in effect, equivalent to writing only t.unknownAttributes. This being so, it
seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. As I've stated in the past, this won't do if,
for example, a plugin is trying create an arbitrary directed graph between
vnodes. In that case, the plugin should confine itself to @file trees, or just
vnodes in .leo files, for that matter.

7/1/04:

- Leo now writes "marks" and "expanded" attributes in the root &lt;v&gt; element for @thin trees.

- VERY IMPORTANT.  Leo now writes entire tree of @ignored @thin nodes.  This fixes a major bug.
</t>
<t tx="ekr.20040705111716.126"></t>
<t tx="ekr.20040705111716.45">Leo marks as dirty all @file nodes when they become "newly unignored".
</t>
<t tx="ekr.20040705112148"></t>
<t tx="ekr.20040705150130">Leo now generates no warnings with all significant tests enabled.  Some tests have been disabled in bases classes, and in a few cases pychecker gives erroneous warnings that have been suppressed directly in the source code using the __pychecker__ = arg syntax.
</t>
<t tx="ekr.20040713110718">Leo 4.2 beta 3           August 10, 2004

This version of Leo is feature complete.  Leo's core code has been stable for several months.

To do: most plugins work with the new code base, but other plugins need some more work.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.
</t>
<t tx="ekr.20040804164600.102">Spurious entries in a tnodeList for @thin trees wiped out all the headlines in
the @thin tree.
</t>
<t tx="ekr.20040804164600.16">Leo now vetoes the shutdown logic if saving a dirty file fails.

Leo prints in red the warning about not being able save the read-only file. The
user can use the Save To command to save the file. The Save To command does not
clear the file's dirty bit, so Leo will prompt again to save the file. The user
will have to ignore this prompt in order to exit. This is correct: the
_original_ file has not been saved.
</t>
<t tx="ekr.20040804164600.265"></t>
<t tx="ekr.20040804164600.275"># The new code only writes tnodes for the current tree when pasting to the clipboard.
</t>
<t tx="ekr.20040804164600.36">- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.
</t>
<t tx="ekr.20040804164600.377">There was a big performance bug in the nodenavigator plugin.
</t>
<t tx="ekr.20040804164600.394">@nocolor

As a result, the minimal .leo file is:

@color
@language html

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

@nocolor

The empty_leo_file plugin now uses this code. The minimal .leo file that Leo
might actually write is more like this:

@color

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;
</t>
<t tx="ekr.20040804164600.406"></t>
<t tx="ekr.20040804164600.419"></t>
<t tx="ekr.20040804164600.421">This is required to make @thin work properly.
</t>
<t tx="ekr.20040804164600.424">This makes the command more useful.
</t>
<t tx="ekr.20040804164600.470"></t>
<t tx="ekr.20040804164600.471">A major change: putVnode doesn't put tnodeLists for @thin nodes.

Instead it issues an informational message and deletes the tnodeList.
</t>
<t tx="ekr.20040804164600.515">Leo used to allocate more positions than necessary.  This unnecessarily stressed the garbage collector.
</t>
<t tx="ekr.20040804164600.56"></t>
<t tx="ekr.20040804164600.98"></t>
<t tx="ekr.20040804165258.1"></t>
<t tx="ekr.20040804165258.2"></t>
<t tx="ekr.20040804165258.3">Leo now allows you to select multiple files in the dialogs for all Import
commands. This fixes a major annoyance. However, you must be running Python 2.3
or above to get this feature.
</t>
<t tx="ekr.20040804165258.4">Added the Check submenu of the Outline menu. This contains the Check Outline and
Dump Outline commands, as well as four new commands:

The Check All Python Code and Check Python Code commands report any syntax
errors or tabnanny errors. These commands mark erroneous nodes. These commands
work on the selected Node and its descendants. These commands ignore any nodes
for which a) @ignore is in effect or b) @language python is in not effect.

The Check Python Code and Pretty Print Python Code commands replace nodes with
their pretty-printed alternative. No doubt everyone will have their own favorite
style. You could implement alternate pretty printers in a plugin merely by
overriding the following methods of class prettyPrinter in leoCommands.py:

---- putOperator:      puts whitespace around operators.
---- putNormalToken:   puts whitespace around everything else.
</t>
<t tx="ekr.20040804170531"></t>
<t tx="ekr.20040804170657">Leo now reuses all widgets used to draw the outline pane. This improves
performance and ends leaks of bindings and widgets.
</t>
<t tx="ekr.20040804170846">@thin bad-directory caused excessive and confusing tracebacks.
</t>
<t tx="ekr.20040804171818"></t>
<t tx="ekr.20040804172113"></t>
<t tx="ekr.20040804172113.1"></t>
<t tx="ekr.20040914103359">Leo 4.2 release candidate 1        September 14, 2004

This version fixes a number of minor bugs reported since the last release. See
the children of this node for details.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.
</t>
<t tx="ekr.20040914103359.110"></t>
<t tx="ekr.20040914103359.12">If only one file was specified Leo gave an error for every character of the file name!
</t>
<t tx="ekr.20040914103359.129">http://sourceforge.net/forum/message.php?msg_id=2742238
By: hinsen

The shortcut definitions in Leo are quite inconvenient on the Mac, as those
using the Alt key don't work. Alt is used for entry of additional characters.
On the other hand, ctrl is available for shortcuts but not used in Leo, since
the ctrl-based shortcuts are shifted to the command key (following standard
Mac practice).

The patch at the end of this message simply shifts all Alt-shortcuts to Ctrl
on the Mac.

That leaves one minor clash: Command-` is used for CloneNode in Leo, although
it canonical MacOS function (switching between the windows of an application)
would be very useful in Leo as well. Removing the CloneNode binding is easy
enough, but it seems that I must implement a window switching function myself.
Not today :-)

Konrad.
</t>
<t tx="ekr.20040914103359.137"></t>
<t tx="ekr.20040914103359.15"></t>
<t tx="ekr.20040914103359.19"></t>
<t tx="ekr.20040914103359.2"></t>
<t tx="ekr.20040914103359.20">@killcolor

From Dan Winkler:

On a couple of occasions, I tried to paste in a long @url node and got 
this message:

	Truncating headline to 250 characters

I wonder if the 250 character limit on headline length should be 
rethought in light of the @url directive and long web addresses.
</t>
<t tx="ekr.20040914103359.28"></t>
<t tx="ekr.20040914103359.31"></t>
<t tx="ekr.20040914103359.37"></t>
<t tx="ekr.20040914103359.4"></t>
<t tx="ekr.20040914103359.47">There were too many problems with this feature. In the future Leo will have a
Check Import command.
</t>
<t tx="ekr.20040914103359.7">With TclTkAqua on the Mac (but *not* with tcltk installed via Fink), the tab
problem doesn't exist there), the tab, return, and backspace keys did not generate
ASCII codes, i.e. event.char is an empty string. So when I press the tab key,
Tk inserts a tab character and Leo isn't even aware of it.
</t>
<t tx="ekr.20040914103743"></t>
<t tx="ekr.20040914103743.1"></t>
<t tx="ekr.20040922074200">Leo 4.2 Final       September 20, 2004

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
external files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.
</t>
<t tx="ekr.20041016134312.2">Use noweb and TeX, or maybe Pyx.
</t>
<t tx="ekr.20041022083005.2"></t>
<t tx="ekr.20041022083226"></t>
<t tx="ekr.20041130104552">@killcolor

By: Guenther Enthaler - genthaler
RE: Haskell support  
2004-11-18 22:55

There's a literate programming mode in Haskell (and in a number of other
functional programming languages such as Clean &amp; Curry), where the program is in
a comment, usually where the line starts with "&gt;" (bird track style, I think
it's called), and the comments/documentation are freeform. It would be difficult
but cool if Leo could support it, if only because the sentinels in the derived
files wouldn't make whole file look so busy.

Günther 
</t>
<t tx="ekr.20041130123243">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2859273
e

theres a config option to clear undo on save.
can that be a menu choice as well? 
clear undo now.
enable clear undo on save.
moot as it will be with the new config options
and any undo changes on the table.
maybe there is a single point to involke clear 
undo that could be run from a button?

with py2.3 after allot of small edits on an open leo after a few hours gc can
hit unexpectedly and last several minutes
and return at any time lasting several more minutes.
I think its gc related because the memory use and disk grinding demanding I
free up memory or kill python.

I have no idea if undo is the cause,
 just guessing.
using cvs of last week. I just updated, 
will let you know if it happens again.
(new error reporting jump to error is great)

usually I don't edit in the same process that long.
I have run scripts from leo that run 6, 12 
or 24 hours no problem. 
maybe I can turn on some internals reporting and
get some feedback on whats going on from python if it happens again. 
or run the gc script before and after.

 win98 128meg w/maxmem memory defrager that works well.
but I go from 50% free to 10% when this starts happening.
I haven't noticed this problem yet in py2.4, and it is peppier,
but don't use py2.4 enough. it doesn't happen every day.
I reboot at least once a day for various reasons.
so it isn't that either. 
you do need to reboot and or exit python once it starts.
this was never an issue with py2.2 and Leo 4.1 or less with only 64 megs.
I don't really have any other long running python processes to compare to Leo. 
can't say what it is.
Aha, progress. 
this started sometime early in 4.2 or late 4.1
but I can still be persuaded something in my 
local system is to blame, some install or dll update. or script, psyco or plugin
related.

nonwithstanding, I should be taking better advantage Moore's law in my CPU and
memory.
I only notice this when I'm running the same leo over a few hours of constant
editing and running scrips.
and when I exit python and restart leo everything returns to normal.
more a supporting anomaly report 
than a bug report or feature request.
</t>
<t tx="ekr.20041201071145">http://sourceforge.net/forum/message.php?msg_id=2876797
By: skal

By: Grossé Pascal - skal
RE: Leo freezing up  
2004-12-01 06:15

The freezing problem on debian sid (which is also my current OS) is caused by a bug in Tkinter: Tkinter does not work when libtk is compiled with thread support, which is the case on debian sid for tk8.4 
I compiled my own non-threaded libtk with the corresponding python/tkinter, and the freeze magically vanished.  

This is a known bug in debian bugtrack: 

http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=171353 

Skal
</t>
<t tx="ekr.20041219162724">http://sourceforge.net/forum/message.php?msg_id=2903742
By: nobody

In the multifile plugin there is an option to insert a directory string.  I
use it alot for the @path directive.  What happens is that when executed a FileDialog
opens up and the user selects the directory he wants to use as a directory string.
When chosen the directory string is inserted into the text editor.

The good of this:
1. It makes using path simpler, you dont have to type out the directory path
yourself, just use the tkFileDialog to select it and have Leo insert the string.
For long directories this saves a lot of typing.

simple, short and quite helpful.  Thoughts? :)

-----------

Time to create a directory class??

</t>
<t tx="ekr.20050122084954">Leo stores options in @settings trees, that is, parts of Leo outlines whose root node has the headline @settings.  When opening a .leo file, Leo looks for @settings trees in the following places:

- The file called leoSettings.leo in the leo/config directory.
- The file called leoSettings.leo in the users home directory.
- The file being loaded.

Settings that later in the above list override settings found earlier. For
example, any setting specified in an @settings tree in the file being loaded
overrides any setting seen in any leoSettings.leo file.

The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings dialog" pane. This settings dialog pane allows
you to change the settings selected in the outline pane using standard gui
widgets.

The format of nodes in @settings trees are as follows:

1. "Simple settings nodes" have headlines of the form:

@&lt;type&gt; name = val

set the value of name to val, with the indicated type.

&lt;type&gt; may be one of the following, with valid values shown:

&lt;type&gt;          Valid values
-----           ------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)

For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'

2. "Complex settings nodes" have headlines of the form:

\@&lt;type&gt; description

The actual settings are specified in the body text.  At present, there are two such kinds of complex settings nodes:

- @font

The body text contains a list of settings for a font.  For example:

body_text_font_family = Courier New
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None

- @recentFiles

The body text contains a list of paths of recently opened files, one path per line.

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.

3.  All other nodes are "Organizer" nodes.  Such nodes have no effect on the settings shown in the dialog.  You may use them as you please to organize settings.

Notes:

A.  At present, you can not change @settings trees while executing the Settings command.  You can, however, change any @settings tree normally when not executing the Settings command.

B. Other kinds of settings nodes are planned for future releases.
</t>
<t tx="ekr.20050122090311">Leo 4.3 alpha 1                 January 24, 2005

Leo 4.3 is the culmination of more than four months of work. 

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.
</t>
<t tx="ekr.20050122091036">The essential features of @settings trees and the settings dialog appear to be stable.  However, many improvements can be imagined, including the following:

- Allow searching for nodes while in the settings dialog.

- Allow adding, deleting, rearranging nodes while in the settings dialog.

- Allow adding, deleting, rearranging recent files while in the settings dialog.

These will be added as time permits and people request.
</t>
<t tx="ekr.20050123092834.1"></t>
<t tx="ekr.20050123092834.1004">Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",
</t>
<t tx="ekr.20050123092834.1005">Leo no loner has any global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.
</t>
<t tx="ekr.20050123092834.1011">computeHomeDir() now test the first retrieval of the %HOME% var and grab it's
results if it is in fact another environment variable.
</t>
<t tx="ekr.20050123092834.1013"></t>
<t tx="ekr.20050123092834.1018">Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.
</t>
<t tx="ekr.20050123092834.1043"></t>
<t tx="ekr.20050123092834.1044"></t>
<t tx="ekr.20050123092834.1047">- This plugin now handles both kinds of triple-quotes correctly so that both
kinds of docstrings are recognized.
</t>
<t tx="ekr.20050123092834.1052">Created callTagHandler. This checks 'idle' hooks to make sure that any commander
referenced by the 'c','new_c' or 'old_c' keywords still exists.
</t>
<t tx="ekr.20050123092834.1057">leoPlugins.registerOneHandler wasn't working properly at all. In effect, only
the last registered hook was ever being remembered!
</t>
<t tx="ekr.20050123092834.159"></t>
<t tx="ekr.20050123092834.160">p.moveToParent now just returns if p is a null position.
</t>
<t tx="ekr.20050123092834.163"># Leo looped after this assert failed.
</t>
<t tx="ekr.20050123092834.165"></t>
<t tx="ekr.20050123092834.166">he readDirective method was changing the comment delimiters as the result of
seeing the sentinels corresponding to @language or @comment directives. But in
general this makes no sense! Comment delimiters should be set once and for all
in the @+leo sentinel: there is no compiler in the world that tolerates mixed
comment delimiters.

BTW, the way to set javascript "inner" comments is to use @delims, not @comment.
N.B. The @language and @comment delimiters _will_ have an effect, and that
effect is in the _write_ logic, not the read logic. The effect is to set the
comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective.
</t>
<t tx="ekr.20050123092834.173"></t>
<t tx="ekr.20050123092834.176">The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.
</t>
<t tx="ekr.20050123092834.19">The old code wasn't handling single file selections properly. The new code works
around an apparent bug in Tk.askopenfilename.
</t>
<t tx="ekr.20050123092834.196">The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.
</t>
<t tx="ekr.20050123092834.2"></t>
<t tx="ekr.20050123092834.27">The new code forbids Paste Node As Clone if the paste would result in a node being a clone of itself.
</t>
<t tx="ekr.20050123092834.42">The '@' sign is an operator in Python 2.4, not an error token.
</t>
<t tx="ekr.20050123092834.422">This method now does nothing if at.toString is True.
</t>
<t tx="ekr.20050123092834.424"></t>
<t tx="ekr.20050123092834.431"></t>
<t tx="ekr.20050123092834.432">Leo did not correctly write adjacent @doc parts in @file trees.  Leo could not read the resulting external files!

The bug happened if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo failed to write the closing #@-at sentinel that would finish the first @doc part.
</t>
<t tx="ekr.20050123092834.434">The new code uses protocol=1 instead of the deprecated bin argument to Pickler.
</t>
<t tx="ekr.20050123092834.438"></t>
<t tx="ekr.20050123092834.439">The problem was that nullLog.write calls print, and if print is redirected the
code ends up calling nullLog.write again.

What I did:

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.
</t>
<t tx="ekr.20050123092834.474">It makes no sense to use only the selected text.
</t>
<t tx="ekr.20050123092834.480">The old code assumed that the error is always in the script itself. Not true!
The error could happen in methods called by the script.

This code works with Python 2.3.4 and Python 2.4.  It may be version dependent.
</t>
<t tx="ekr.20050123092834.486"></t>
<t tx="ekr.20050123092834.487">Leo now sets the name of the frame to the requested file name on the command line even if the file name does not exist.
</t>
<t tx="ekr.20050123092834.490">The code now clears previous shortcut, and tells what the previous entry was.
</t>
<t tx="ekr.20050123092834.491">Changed the open command associated with .leo files on Windows from:

pythonw.exe "&lt;leodir&gt;\src\leo.py" %1

to:

"pythonw.exe" "&lt;leodir&gt;\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.
</t>
<t tx="ekr.20050123092834.492">This is an important difference. imp.load_module is equivalent to a reload, so
we must not call this if the module already exists!
</t>
<t tx="ekr.20050123092834.497">Leo did not properly write external files that contained section references to grand-children.

For example:

&lt;&lt; current level&gt;&gt;
  reference to &lt;&lt; 3. level&gt;&gt;
    &lt;&lt; 1.level&gt;&gt;
        &lt;&lt; 2.level &gt;&gt;
            &lt;&lt; 3.level&gt;&gt;

The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.
</t>
<t tx="ekr.20050123092834.499">In some cases g.app.config.output_newline was None.  The new code sets the default to '', and then assigns a valid default to ''.
</t>
<t tx="ekr.20050123092834.502">This binds scroll-wheel events to Button-4 and Button-5
</t>
<t tx="ekr.20050123092834.506">chapters.py requires that the canvas have a name ivar.

Added treeCanvas.name = '1' in:

&lt;&lt; replace tree pane with settings tree &gt;&gt;
</t>
<t tx="ekr.20050123092834.510"></t>
<t tx="ekr.20050123092834.517">Leo can still read such files, but old-style file formats are now deprecated
</t>
<t tx="ekr.20050123092834.520">The new code greatly simplifies the class structure. The intention is to allow plugins to override methods of this file more easily.

The highlights:

- Plugins may now override methods in this file much more easily.
    - All code is now in a single class.
    - Resolved the few name conflicts by renaming x to x3 or x4.
    - The new code generally uses methods instead of sections.
    - Initialization is now simple and sane, and is done in dedicated methods.
    - All constants are class constants: no more module-level constants.

- All top-level methods support toString or fromString arguments.
</t>
<t tx="ekr.20050123092834.526">Fixed shadow warnings.  The following are all Python global functions:

cmp -&gt; compare
dict -&gt; theDict
dir -&gt; theDir
file -&gt; theFile
id -&gt; theId
type -&gt; theType
input  (suppressed the warning)
iter -&gt; theIter
</t>
<t tx="ekr.20050123092834.544">Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.
</t>
<t tx="ekr.20050123092834.565">Leo's code now contains an important simplification to Leo's gui code. This
arose because of a problem in the UNL plugin. The window that opened when double
clicking an @url UNL node wasn't staying on top.

It turns out that this was essentially impossible to fix with the old code. The
proximate cause of the original problem button-1 was bound to OnActivateTree,
which called g.app.gui.set_focus after the new window was visible, thereby
bringing the old tree to the front.

Further investigation revealed other problems. For example, the idle-time code
in the status line logic was also messing with the focus. It turns out that
repeatedly calling g.app.gui.set_focus is a very bad idea, for lots of reasons
which I won't go into in detail here.

The old code called g.app.gui.set_focus explicitly whenever it wanted focus to
change. But there is a much better way, namely to have routines that _indicate_
where they want the focus to be "after the dust settles", that is, when all gui
calls have been completed. I call this a "delayed focus" scheme.

So I rewrote all the code that sets the focus. The new code replaces direct
calls to g.app.gui.set_focus with calls to the following methods in
leoTkinterFrame class: bodyWantsFocus, statusLineWantsFocus, treeWantsFocus and
logWantsFocus. Actually, these xWantsFocus methods all do the same thing, but
using different methods improves traces.

This is an excellent pattern. Again, rather than setting the focus directly,
these xWantsFocus methods merely signal their intension to set the focus. This
allows very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours this
morning to get it just right. It queues up a 'one-shot' callback. That is, at
most one copy of the callback is ever waiting to be executed. Furthermore, the
callback is only queued for execution at the result of a call to xWantsFocus; it
is never run automatically at idle time. Finally, even when executed, the
callback does nothing if the last requested commander (in the new ivar,
g.app.wantedFocus) does not match the commander to which the callback was bound.

These checks allow the UNL plugin to open a window properly and keep it topmost.

This is a big step forward for Leo, for the following reasons:

- Delayed focus ensures that the body pane always has focus unless the code has
a specific, positive reason for the focus to be elsewhere. This was difficult
(or rather impossible) to do with the old code: there are _many_ Tk calls that
can affect the focus.

- Delayed focus minimizes calls to g.app.gui.set_focus. Unlike the old code,
many seconds may elapse between calls. The stress on Tk is much less, and I
believe this may cure some flakiness in how focus changes, especially in
headlines.

- There are some cases where focus must change immediately. The xWantsFocus
methods all support a 'later' keyword argument. By default it is True, but when
it is False leoTkinterFrame.set_focus calls g.app.gui.set_focus immediately.

- The xWantsFocus methods all support a 'tag' keyword argument that tells what
routine the method is called from. It is a big help in making sense of traces.
BTW, extensive traces are the _only_ possible way of tracking down
focus/selection problems.
</t>
<t tx="ekr.20050123092834.6">The Open With logic in createOpenWithMenuFromTable for the 'spawnv' case now
actually calls os.spawnv (rather than spawnl) and it allows a variable length
list of parameters.
</t>
<t tx="ekr.20050123092834.71">What I did:

- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.
</t>
<t tx="ekr.20050123092834.81">- Restored non Pmw code in resizePanesToRatio. This code got deleted by mistake.
The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.
It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo. This overrides the
default (Ctrl-E) and thereby prevents the default from overriding the entry for
ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been
redefined. Not sure if this is a wise idea, or indeed if it actually does
anything :-)

I am tempted to remove all the default entries entirely. This would simplify
error reporting, but then Leo would hardly work at all if leoSettings.leo were
not present.
</t>
<t tx="ekr.20050123092834.896"></t>
<t tx="ekr.20050123092834.897">These commands work as do the similar commands in Windows Explorer. How did we
ever live without them?
</t>
<t tx="ekr.20050123092834.901">This supports the fromString option in read commands.
</t>
<t tx="ekr.20050123092834.903">Thanks to Bernhard Mulder for the new code.
</t>
<t tx="ekr.20050123092834.908">- Tab toggles between the Search to the Replace areas.

- Control-Tab inserts a tab.

- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  The Enter key activates the Find button.

- As usual, Alt-F4 dismisses the Find panel.
</t>
<t tx="ekr.20050123092834.928">It's not clear that this support is so useful for debugging scripts.

If g.app.debugSwitch is True es_exception gives a full traceback.
</t>
<t tx="ekr.20050123092834.929">Thanks to David McNab &lt;david@freenet.org.nz&gt; for this work.
</t>
<t tx="ekr.20050123092834.961">- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without these features?
</t>
<t tx="ekr.20050123092834.984">Restored the following hooks:

"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event
</t>
<t tx="ekr.20050123093854.1">tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!
</t>
<t tx="ekr.20050123100706.1"></t>
<t tx="ekr.20050123100706.2"></t>
<t tx="ekr.20050123101208"></t>
<t tx="ekr.20050123103303"></t>
<t tx="ekr.20050123103303.1"></t>
<t tx="ekr.20050123103521"></t>
<t tx="ekr.20050123103753"></t>
<t tx="ekr.20050123105026">- Leo now ignores all find settings in .leo files.  Instead, Leo inits find settings from @settings entries.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, a helper of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.
</t>
<t tx="ekr.20050123110009">Leo now stores options in @settings trees, that is, outlines whose headline is
'@settings'. When opening a .leo file, Leo looks for @settings trees not only in
the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.

The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

For full details, see the children of this node.
</t>
<t tx="ekr.20050123111723"></t>
<t tx="ekr.20050123112151">- leoPlugins.doHandlersForTag now executes the list of hook handlers for a
particular tag (hook name) until one of the handlers returns a non-None result.
doHandersForTag no longer tries to "sort" handlers, so the order that the
handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks
interfering with each other. If two handlers try to return a non-None result
only one of them will ever execute. doHandlersForTag can't do much about this: a
better solution would require more conceptual framework. Not now...
</t>
<t tx="ekr.20050123112834"></t>
<t tx="ekr.20050123115804">Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables and
disables plugins automatically.This plugin also tells you everything you need to
know about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

Note. The Plugins Manager plugin requires Pmw. You can install Pmw in Leo's
extensions directory if you like.
</t>
<t tx="ekr.20050123115804.1">You can can import any extension to Leo by putting the extension in the 'extensions' directory and using g.importExtension to import it.

- created the 'extensions' directory and g.app.extensionsDir

- created g.importModule and g.importExtension
</t>
<t tx="ekr.20050123151338">Changed scanDirectives and atFile.scanDirectives so they work like
tangle.scanAllDirectives. Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 

So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... 
</t>
<t tx="ekr.20050126100405">Leo 4.3 alpha 2                 February 14, 2005

Leo 4.3 is the culmination of more than four months of work. This alpha 2
release corrects various bugs and distribution problems.

a2 also adds several new features:

- Adds 'word', 'line' and 'node' undo granularities.
- Predefines 'c','g', and 'p' in scripts and unit tests.
- Added support for top-level init functions in plugins.
- Buttons can remove themselves when their scripts fail.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.  Leo is distributed with Pmw (Python Mega Widgets) in this directory.
</t>
<t tx="ekr.20050126100405.1"></t>
<t tx="ekr.20050127110221">@killcolor
https://sourceforge.net/forum/message.php?msg_id=2962825
By: jasonic

-- pdf -- 
yes I know what you mean, PDF has it uses.  If nicely embedded into Leo via
'reportwriter'  and some export scripts {and clear useinterfance} would stillbe
a good thing.


As I start to think about how to print Leo, I become more aware of the differneces
between Leo structures and linear [print] layouts.

Different kinds of outlines obviously will need different kinds of printing.
I don't yet have enough experience or overview.

--xslt--
Seems a natural way to go for printing Leo, but yet another langauge and syntax
to wrassle with. Last time I looked I went from being horrified to very impressed
to be being exhausted.

--htmlize--
thanks I'll check into that

"print to web"  should definitely be on Leo's missing PRINT MENU.

--swf [flash]--
This printing topic pushes me harder to get FLC  [my FlashLeoClient project]
into the Leosphere.

Flash has*limited*  CSS handling, but enough to do some nice and useful typographic
formatting in a pretty clean object-oriented manner.

FLC parses .leo files into a Flash object. Flash Textformat instances are created
using CSS and can be applied then to rendering any parts of  the deserialized
Leo object.. The beauty is it can be very fast and ynamic so I can imagine a
real-time WYSIWYG laytou tool for printing Leo to web and at the same making
it suitable at the same time for print-to-paper.

Since FLC is in the very first instance a READ-ONLY client tool for Leo, it
makes it a natural Leo printing service.

To complete full service, it woudl be good if Leo could create SWF files directly
itself, just like using PDF reportwriter.
There are a couple of libraries to help this 
- Ming [with PHP, Perl, Python and Ruby wrappers]
http://ming.sourceforge.net/

- makeswf.r [interesting REBOL/Flash dialect by David Oldes]
http://sweb.cz/oliva.david/swf/

These could also be both configured as web-services.
So Leo print-to-web would include by default rendering a flash swf file versoin
of itself either using locally installed libraries or by passing a view of itself
to a chosen client or server-based tool.

But even without those extra 'services' and libraries a single flash file in
the form of FLC could become an effective Leo printing kit. Using a standalone
desktop  version [not embedded in the browser, out of the sandbox] much more
is possible - remote control, peer-peer editing, file writing etc.

-- flashpaper2--
btw, Lately I've been using Flashpaper2 a lot to print all kinds of stuff, Often
from web pages to my local adhoc home filebase. It's a very fast lighweight
alternative to PDF, saves paper, has excellent zooming and nice search features
built-in.
Flashpaper renders a very litteral snapshot, but as I am discovering that turns
out to be extremely useful.
For example you visit a page and click on some links. Flashpaper saves teh pages
exactly as it looks, viisted links disntinguished.  In the era of info-overload,
even that crude mnemonic is valuable.

Alas, Flashpaper2 is not free nor open in the way Leo is. But worth to play
with it if only for for the experience.
30 day trial downlaod from
http://www.macromedia.com/software/flashpaper/

And of course the flash _players_ is free, so can send people flashpaper documents
just like PDF.
Brilliant when you have a big Excel spreadsheet or CAD document which would
normally get all messy printing across pages, confusing people.
Instead adjust and print to a generous 'piece' of flashpaper - letting your
coleagues pan and zoom to their comfort.

I've not quite figured out the place where  Leo meets Flashpaper, because Leo
needs to preserve its full pane contents. Flashpaper works fine with long web
pages, automatically reading the full window contents and cutting into a paginated
sequence, ready for paper printing.
Leo's does not have aprint menu, so it's off the sytem's print-devices map,
which Flash paper appearing just  like any phtycial printer.

I imagine is possible to fix that in Leo, but I do not where to begin and woudl
not be surprised to learn its a major heachche to write adn debug for multiple
operating systems.

An immediate alternative are screencapture tools like vnc2swf or MDM Capture.

[vnc2swf uses Ming-0.2a]
http://www.unixuser.org/~euske/vnc2swf/

http://www.multidmedia.com/software/capture/index.php

But much is hidden or lost from view. 
Still very vauable for creating dynamic narrative tutorials [aka screencasting]

AS you know I am very excited about what flash can do for Leo, and vice versa.
But I am concerned that there is not yet a 100% Leo means which supports people's
standard print needs and habits.

-- PRINT MENU-- 
Leo deserves good friendly printing features which anyone can use. At the moment
we have a confusing patchwork of choices. Printing Leo seems to be both harder
and easier than  first meets the eye.

Having a little library of export scripts - well named, documented and intended
to aid printing woudl go a long way. Thesse scripts anyone coiuld be called
by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list.
Or they can just insert the appropriate script  into an outline giving finer
grained print control on the fly.
</t>
<t tx="ekr.20050130112336.1">Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.
</t>
<t tx="ekr.20050201175325.1"></t>
<t tx="ekr.20050201175325.2"></t>
<t tx="ekr.20050202073944"></t>
<t tx="ekr.20050209141626.101"></t>
<t tx="ekr.20050209141626.102">http://sourceforge.net/forum/message.php?msg_id=2958470

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.
</t>
<t tx="ekr.20050209141626.105">http://sourceforge.net/forum/message.php?msg_id=2958470

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
- Improved signon message.
- Better error handling and reporting. 
</t>
<t tx="ekr.20050209141626.113">This now works: g.es('ﺻﺱ',color='red')

g.es must send the original unicode string to the log pane widget, NOT an encoded string.
</t>
<t tx="ekr.20050209141626.114">http://sourceforge.net/forum/message.php?msg_id=2983923

- Replaced string.+ with string.% in numerous places.
- Simplified g.openWithFileName and corrected problems in error-reporting logic.
</t>
<t tx="ekr.20050209141626.12"></t>
<t tx="ekr.20050209141626.13"></t>
<t tx="ekr.20050209141626.150"></t>
<t tx="ekr.20050209141626.16">http://sourceforge.net/forum/message.php?msg_id=2966541

---- Report:

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

---- Added to @recentfile documentation: 

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.
</t>
<t tx="ekr.20050209141626.185">When loading plugins, the Leo checks to see if the plugin has an init function
at the top level (the module level). If so, Leo calls the init function. This
function should return True (or equivalent) if the module loaded correctly.

If the top-level init function does not exist, Leo assumes the module loaded
correctly.
</t>
<t tx="ekr.20050209141626.190"></t>
<t tx="ekr.20050209141626.193"></t>
<t tx="ekr.20050209141626.194">A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True. Leo checks this value after
executing the script in the button.
</t>
<t tx="ekr.20050209141626.195"></t>
<t tx="ekr.20050209141626.196">@nocolor

Added define_p keyword arg in executeScript. When True (the default), the script
or unit test is run in an environment in which c, p and g are all defined.
c is the commander for the outline in which the script appears.
p is the same as c.currentPosition and g is the leoGlobals module.

Therefore, the following lines need never appear in scripts or unit tests!

@color

import leoGlobals as g
p = c.currentPosition()
</t>
<t tx="ekr.20050209141626.198"></t>
<t tx="ekr.20050209141626.23">http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.
</t>
<t tx="ekr.20050209141626.3"></t>
<t tx="ekr.20050209141626.4">http://sourceforge.net/forum/message.php?msg_id=2795653

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc 
commands don't work until you click on something with the mouse

-----

http://sourceforge.net/forum/message.php?msg_id=2795656

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory lives on ...
</t>
<t tx="ekr.20050209141626.42"></t>
<t tx="ekr.20050209141626.43">The new code no longer requires that the present node have a tnodeList.

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)

AttributeError: 'tnode' object has no attribute 'tnodeList'
</t>
<t tx="ekr.20050209141626.46">The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.

Moreover, there were some extra print statements in the g.es logic for the Mac.
</t>
<t tx="ekr.20050209141626.53">This makes the test more robust in case of failure.
</t>
<t tx="ekr.20050209141626.54">Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass on the Mac as well as on XP.
</t>
<t tx="ekr.20050209141626.55">*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.
</t>
<t tx="ekr.20050209141626.8"></t>
<t tx="ekr.20050209141626.91">There were problems searching for whitespace.

Note: it just ran slowly &amp; silently.
</t>
<t tx="ekr.20050210101318">Typing return now correctly invokes the Find button, without adding a newline in the find string.
</t>
<t tx="ekr.20050210102150"></t>
<t tx="ekr.20050210102150.1"></t>
<t tx="ekr.20050210102358"></t>
<t tx="ekr.20050211095754">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2990951
Milan Melena

I think, I found two bugs:

1) leoAtFile.py:
&lt;&lt; read optional encoding param &gt;&gt;
changed first instance of i = j + 1 to i = j + 2

2) leoGlobals.py
g.getScript now returns with

if at.output_newline == 'crlf':
    return script.replace("\r\n","\n")
else:
    return script
</t>
<t tx="ekr.20050212054743">At present, such indented blocks may not contain Leo directives or section references.  This will be fixed in 4.3a3.
</t>
<t tx="ekr.20050212144116">1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.

2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found

    # Local --&gt; locale
    # Might cause getpreferredencoding to fail on *nix.

3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.

4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)

5. (removed code) from &lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;
    - last_p is None at first, so last_p.insertAfter does not make sense.
</t>
<t tx="ekr.20050214055018"></t>
<t tx="ekr.20050214055018.4"></t>
<t tx="ekr.20050214055018.5"></t>
<t tx="ekr.20050221054932"> @killcolor
http://sourceforge.net/forum/message.php?msg_id=3007062
By: jgleeson

Sorry to take so long to reply.  I've been buried in work and haven't kept up
with some email.

Here's the link to the site where I posted the folder you have:
&lt;http://homepage.mac.com/jdgleeson/&gt;  It's the small file named "Leo.zip" (23
KB), not the large file "Leo-4.3-alpha-2.dmg" (20 MB).

I agree that I did not write very clear instructions, beginnng with the first
step, where I should have also said:  "It is important to use version 1.1.8
of py2app, which is only available through svn.  The version on the py2app website
is 1.1.7, which creates buggy Tkinter apps. If you try to use version 1.1.7,
the Leo app it creates will give you a message saying that Tkinter is not properly
installed.  Your installation is fine; otherwise you could not have even built
Leo.app with py2app, because py2app copies the essential parts of Tcl/Tk into
the application bundle to make the app completely standalone."

I haven't tried intalling the Fink subversion -- I'm using DarwinPorts
&lt;http://darwinports.opendarwin.org/&gt;.  But there's a simpler alternative than
DarwinPorts. Metissian releases OS X packages of Subversion clients
&lt;http://metissian.com/projects/macosx/subversion/&gt;

AFAIK, the command "python setup.py bdist_mpkg --open" only applies to the py2app
1.1.8 distribution.  By the way, bdist_mpkg is distributed with py2app. It creates
a package around the setup.py script (more specialized than Platypus).  I don't
have any experience with bdist_mpkg yet.

'Copy the leo folder into this directory' is horrible. I'm glad you figured
it out -- I'm not sure I could have.

"python setup.py py2app -a" should be run in the folder with the readme file,
which also contains the setup.py file that the command refers to.  Most importantly,
the folder in which this command is run must contain the leo folder -- which
it does only if you are brilliant enough to decode my instructions.   ;) 

HTH

-John
</t>
<t tx="ekr.20050221104844">Leo 4.3 alpha 3                 February 24, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 3
release corrects various bugs in Leo's core and in plugins. This is the first
release that include an installer for MacOSX.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically.
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.
</t>
<t tx="ekr.20050221104844.12">http://sourceforge.net/forum/message.php?msg_id=2999651

I was pleasantly surprised to discover the reST2 plug-in working under 4.3a2
(this is one the first thing I try as I'd like to use Leo as an editor
for that).

As mentioned in early threads, it still needs @rst for each node to be included
in the reST rendering process. So I put @rst test.html and then a child with
@rst and some reST code and it worked !!

Then I tried to to get a simple rst file using @rst test but the plugin complained:

[snip]

  File "C:\dn_apps\Leo\plugins\rst2.py", line 164, in onIconDoubleClick
    writeTreeAsRst(rstFile,fname,p,c)
TypeError: writeTreeAsRst() takes exactly 5 arguments (4 given)

So I looked at the rst2.py and found a way to get it working but I would need
someone to verify it :

line 164, replaced   writeTreeAsRst(rstFile,fname,p,c)  by

syntax = False
writeTreeAsRst(rstFile,fname,p,c,syntax)

And it worked!
</t>
<t tx="ekr.20050221104844.14"></t>
<t tx="ekr.20050221104844.2"></t>
<t tx="ekr.20050221104844.27">http://sourceforge.net/forum/message.php?msg_id=3005140
By: ktenney

- perform a search which marks a number of nodes
- select "Outline -&gt; Mark/Unmark -&gt; Unmark All"
- Several marks are still listed in in the nodenavigator "Marks" list.
  (They are not marked in the outline.)

What I did:

- The p.set/clearMark methods now call the hook _after_ changing the marked status.
  This fixes the apparent bug in nodenavigator.py.
- Rewrote nav_buttons.py.  The old code was a mess; the new code is clean.
- Changed the vnodeList ivar in leoTkinterDialog to positionList.
- Rewrote c.unmarkAll to make clear that it is using positions.
    - Added test_c_unmark_all test routine.
</t>
<t tx="ekr.20050221104844.45">http://sourceforge.net/forum/message.php?msg_id=2958470
From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file &amp; tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!

What I did

All changes were to g.app.leoID():
    - Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
    - Improved signon message.
    - Better error handling and reporting. 
</t>
<t tx="ekr.20050221104844.54">g.pdb wasn't working because pdb wasn't imported inside the function.
</t>
<t tx="ekr.20050221104844.57"></t>
<t tx="ekr.20050221104844.58">This allows plugins such as plugin_manager.py to work on Python 2.2.x.
</t>
<t tx="ekr.20050221104844.59">g.es does nothing if color=='suppress'.  This can be useful in unit tests.
</t>
<t tx="ekr.20050222100936">http://sourceforge.net/forum/message.php?msg_id=3008045

Leo crashed when executing a script if the script was selected text in a new window.

What I did:

- g.getScript now calls g.getOutputNewline(c=c) rather than look at atFile.output_newline.

atFile.output_newline may not exist if a) the file is new and b) g.getScript
doesn't call atfile.write.

- Set scripting=scriptWrite in call to atFile.scanAllDirectives in atFile.write.

This suppresses the following irrelevant message when executing scripts:

    "No absolute directory specified anywhere."
</t>
<t tx="ekr.20050306070535">@killcolor
</t>
<t tx="ekr.20050306070535.3">http://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:

&gt;This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to &lt;Alt-KeyPress&gt;,
&lt;Shift-KeyPress&gt;, etc.  Tk chooses the most specific event it can find, so the
more general &lt;KeyPress&gt; handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

Brian Theado
</t>
<t tx="ekr.20050306090601">Leo's .leo file format is extensible.
The basis for extending .leo files are the v.unknownAttributes ivars of vnodes,
uA's for short.
Leo translates between uA's and xml attributes in the corresponding
&lt;v&gt; elements in .leo files.
Plugins may also use v.tempAttributes ivars to hold temporary information
that will *not* be written to the .leo file.
These two ivars are called **attribute ivars**.

Attribute ivars must be Python dictionaries, whose keys are names of plugins and
whose values are *other* dictionaries, called **inner dictionaries**, for
exclusive use of each plugin.

The v.u Python property allows plugins to get and set v.unknownAttributes easily::

    d = v.u # gets uA (the outer dict) for v
    v.u = d # sets uA (the outer dict) for v

For example::

    plugin_name = 'xyzzy'
    d = v.u # Get the outer dict.
    inner_d = d.get(plugin_name,{}) # Get the inner dict.
    inner_d ['duration']= 5
    inner_d ['notes'] "This is a note."
    d [plugin_name] = inner_d
    v.u = d

No corresponding Python properties exist for v.tempAttributes,
so the corresponding example would be::

    plugin_name = 'xyzzy'
    # Get the outer dict.
    if hasattr(p.v,'tempAttributes'): d = p.v.tempAttributes
    else: d = {}
    inner_d = d.get(plugin_name,{}) # Get the inner dict.
    inner_d ['duration'] = 5
    inner_d ['notes'] = "This is a note."
    d [plugin_name] = inner_d
    p.v.tempAttributes = d

**Important**: All members of inner dictionaries should be picklable: Leo
uses Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

**Note**: Leo does *not* pickle members of inner dictionaries whose name (key) starts with str\_.
The values of such members should be a Python string.
This convention allows strings to appear in .leo files in a more readable format.

Here is how Leo associates uA's with &lt;v&gt; elements in .leo files:

- **Native xml attributes** are the attributes of &lt;v&gt; elements that are
  known (treated specially) by Leo's read/write code. The native attributes of
  &lt;v&gt; elements are a, t, vtag, tnodeList, marks,
  expanded and descendentTnodeUnknownAttributes. All other attributes of
  &lt;v&gt; and &lt;t&gt; elements are **foreign xml attributes**.

- When reading a .leo file, Leo will create v.unknownAttributes ivars for
  any vnode whose corresponding &lt;v&gt; or &lt;t&gt; element contains a
  foreign xml attribute.

- When writing a file, Leo will write foreign xml attributes in &lt;v&gt; elements
  if the corresponding vnode contains an unknownAttributes ivar.

- Leo performs the usual xml escapes on these strings when reading or writing
  the unknownAttributes ivars.
</t>
<t tx="ekr.20050313101229">Leo 4.3 alpha 4                 March 15, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 4
focuses on plugins: all known plugins are now in leoPlugins.leo. Most plugins
now work with the 4.3 code base. Warning: not all plugins have been tested
thoroughly.

This alpha 4 release also adds the frequently-requested Add Comments and Delete
Comments commands to Leo's Edit Body menu.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.
</t>
<t tx="ekr.20050313101229.100">Fixed problems in the following plugins. See the &lt;&lt; version history &gt;&gt; section
in each plugin for details.

autocompleter.py
cleo.py
mod_scripting.py
mod_tempfname.py
templates.py
vim.py
xemacs.py

Replaced the 'new_c' key by the 'c' key in the following plugins:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py

Replaced the 'start2' hook by the 'new' hook in the following plugins: (This was
made possible now that 'new' is called when opening a new window if the
'open1/2' hooks are not called.

URLloader.py
UASearch.py
at_produce.py
autocompleter.py
color_markup.py
fastGotoNode.py
groupOperations.py
import_cisco_config.py
multifile.py
nodebar.py
open_with.py
read_only_nodes.py
scheduler.py
table.py
usetemacs.py
xsltWithNodes.py
</t>
<t tx="ekr.20050313101229.101">atFile.copyAllTempBodyStringsToTnodes calls:

    c.mod_label_controller.add_label(p,"before change:",old_body)
</t>
<t tx="ekr.20050313101229.2"></t>
<t tx="ekr.20050313101229.74">http://sourceforge.net/forum/message.php?msg_id=3035471

Leo was not inserting a visible horizontal scrollbar when @nowrap was in effect.
</t>
<t tx="ekr.20050313101229.77">http://sourceforge.net/forum/message.php?msg_id=3042593

Leo now properly redraws the screen after a Change All command.
</t>
<t tx="ekr.20050313101229.94">Several hooks use the 'new_c' key in the keywords dictionary. Plugin writers had
to remember whether to get the commander using keywords.get('c') or
keywords.get('new_c') or both. This was needlessly confusing.

All hooks that use the 'new_c' key now use also include the 'c' key. The 'new_c'
key is deprecated; plugins should use the 'c' key instead. 

None of the plugins presently in leoPlugins.leo use the 'new_c' key, but the
'new_c' key still exists for compatibility.

The following plugins were affected by this change:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py
</t>
<t tx="ekr.20050313101229.95">The Add Comments command puts comments around a block of code. This command uses
single-line comments if the language in effect for the node supports single-line
comments.

The Delete Comments command deletes the comments specified by the Add Comments command.
</t>
<t tx="ekr.20050313102319">The ``add-comments`` (Ctrl-)) command puts comments around a block of code.
This command uses single-line comments if possible. The ``delete-comments``
(Ctrl-() command deletes the comments.
</t>
<t tx="ekr.20050313103448"></t>
<t tx="ekr.20050313103448.1">Leo calls the 'before-create-leo-frame' hook just before calling frame.onCreate.
Similarly, Leo calls the 'after-create-leo-frame' just after calling
frame.onCreate.
</t>
<t tx="ekr.20050316092232">- Unpack the .zip file, placing the result somewhere, say in c:\prog\jyleo-Jan-11-06

- Edit jleo.bat so it refers to jyleo-Jan-11-06.  For example:

rem open jyLeo
set ARGS= 
:loop 
if [%1] == [] goto end 
set ARGS=%ARGS% %1 
shift 
goto loop 
:end 

cd c:\prog\jyleo-Jan-11-06
java -jar c:\jython-2.2a1\jython.jar src\leo.py
</t>
<t tx="ekr.20050317153447">http://sourceforge.net/forum/message.php?msg_id=3053534
By: paulpaterson

Very interesting indeed - great work! 

I didn't have Java/Jython installed so for others in the same boat here's
what I had to do to get it work on my platform (Win2k). Some of this is in
the README but I had to do some extra but I'm not sure why.

1. Install 1.5 JDK  
http://java.sun.com/j2se/1.5.0/download.jsp 

2. Install Jython 
http://www.jython.org/jython22a1.zip 

3. Edit Jython.bat file - the part that calls Java.exe to ... 
"C:\Program Files\Java\jdk1.5.0_02\jre\bin\java" -cp "C:\Program Files\Java\jdk1.5.0_02\jre\lib";"c:\Apps\Python23\Jython";"C:\Apps\jLeo\j-leo-MAR15\Icons";"C:\Apps\jLeo\j-leo-MAR15\skins";"C:\Apps\jLeo\j-leo-MAR15\src";"C:\Apps\jLeo\j-leo-MAR15\skinimages" -Dpython.home="c:\Apps\Python23\Jython" -jar jython.jar %ARGS% 

Where  
- Java installed at C:\Program Files\Java\jdk1.5.0_02 
- Jython at c:\Apps\Python23\Jython 
- jLeo at C:\Apps\jLeo\j-leo-MAR15 

Change your paths as appropriate! There must be a better way to do this - Java confuses me! 

4. Edit leo.py in jleo/src directory to fix failure to find HOME env variable. 

line 241 becomes ... 

....try:home = os.getenv('HOME' )#,default=dotDir) 
....except KeyError:home="" 


Then, from the Jython install directory ... 

Jython " 
C:\Apps\jLeo\j-leo-MAR15\src\leo.py" 

Works a treat!  

Paul
</t>
<t tx="ekr.20050407144417"></t>
<t tx="ekr.20050417072710.1">Plugins and scripts should call u.beforeX and u.afterX methods ato
describe the operation that is being performed. **Note**: u is shorthand for
c.undoer. Most u.beforeX methods return undoData that the client
code merely passes to the corresponding u.afterX method. This data contains
the 'before' snapshot. The u.afterX methods then create a bead containing
both the 'before' and 'after' snapshots.

u.beforeChangeGroup and u.afterChangeGroup allow multiple calls to
u.beforeX and u.afterX methods to be treated as a single undoable entry.
See the code for the Replace All, Sort, Promote and Demote
commands for examples. The u.beforeChangeGroup and u.afterChangeGroup
methods substantially reduce the number of u.beforeX and afterX methods
needed.

Plugins and scripts may define their own u.beforeX and afterX methods. Indeed,
u.afterX merely needs to set the bunch.undoHelper and
bunch.redoHelper ivars to the methods used to undo and redo the operation.
See the code for the various u.beforeX and afterX methods for guidance.

p.setDirty and p.setAllAncestorAtFileNodesDirty now return a
dirtyVnodeList that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern dirtyVnodeList.extend(dirtyVnodeList2)

See the section &lt;&lt; How Leo implements unlimited undo &gt;&gt; in leoUndo.py
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the u.beforeX and afterX methods.
</t>
<t tx="ekr.20050429094215">Leo 4.3 beta 1                 April 30, 2005

Leo 4.3 beta 1 completes all major features of Leo 4.3. There are no known
significant bugs remaining.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. 
This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.
</t>
<t tx="ekr.20050429094215.113">The status bits weren't being passed to v.initStatus!
</t>
<t tx="ekr.20050429094215.116">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 863, in importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 137, in importDerivedFiles
    isThin = at.scanHeaderForThin(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 570, in scanHeaderForThin
    junk,junk,isThin = at.scanHeader(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2616, in scanHeader
    at.error("Bad @+leo sentinel in: %s" % fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4500, in error
    self.printError(message)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4509, in printError
    if self.errors == 0:
AttributeError: atFile instance has no attribute 'errors'
</t>
<t tx="ekr.20050429094215.120">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1409, in idle_scrollTo
    h1 = self.yoffset(p)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1488, in yoffset
    h, flag = self.yoffsetTree(root,v1)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1506, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)

# Maximum recursion depth exceeded.

It is still not completely clear why this happened.
</t>
<t tx="ekr.20050429094215.130"></t>
<t tx="ekr.20050429094215.131">- Moved computeGlobalConfigDir, computeHomeDir, computeLoadDir and
startupEncoding from leo.py to leoGlobals.py.

- Created g.computeStandardDirectories and used it in leo.py.

- Created g.createStandAloneApp using the above functions. This function was
based on the 'Standalone Operation' classed in the plugin_manager plugin.
g.createStandAloneApp doesn't actually use any of these classes because the
nullGui class is basically a clumsier version of the BlackHole class.

- Added a do-nothing attachLeoIcon method to nullGui class to suppress a
warning. As I said, the nullGui class is not as elegant as Paul's BlackHole
class.

- Added &lt;&lt;importLeoGlobals&gt;&gt; button to newButtons plugin. This creates a node
  named &lt;&lt; define importLeoGlobals &gt;&gt; whose body text defines an
  importLeoGlobals function.

The idea is that importing leoGlobals from a stand-alone plugin is a bit tricky.
The importLeoGlobals handles these details. Note that we don't want to define
importLeoGlobals in a node included by @others, because this function must be
available to the code in the &lt;&lt; imports &gt;&gt; section. So we use a named section
and reference it in before referencing the &lt;&lt; imports &gt;&gt; section. See the
plugin_manager plugin for an example.

- Changed the plugin_manager plugin as follows: - Used the newButtons plugin to
    add an &lt;&lt; define importLeoGlobals &gt;&gt; section. - Simplified the import logic
    using importLeoGlobals function. - Commented out the Standalone Operation
    classes. - Called g.createStandAloneApp in the '__name__ == "__main__"'
    code.
</t>
<t tx="ekr.20050429094215.139">- config.openSettingsFile returns None if there is a read error.

- leoFileCommand.open gives no BadLeoFile message if silent is True.
</t>
<t tx="ekr.20050429094215.145">- Simplified write_Leo_file using new leoFileCommand.deleteFileWithMessage and g.utils_rename.

- Eliminated outputList var.
    - The code that writes to a clipboard sets self.outputFile to g.fileLikeObject.

- Sped up put routine: it always writes to self.outputFile.

- self.outputFile is now a cStringIo object.  However, the heart of the put routine is:

    s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
    self.outputFile.write(s)

and it appears that the call to g.toEncodedString is the limiting factor.
</t>
<t tx="ekr.20050429094215.173">- Use g.Bunch to simplify code.
- Added 'before' &amp; 'after' methods
- Added entries to optionalIvars dynamically in bead methods.
- Eliminated 'case-itis' by making it unnecessary ever to add more cases.
- Removed 'v' key in undoer:  replaced it with 'p'.
- Replaced u.v by u.p and v by p in find code (It's too confusing).
- p.setDirty and p.setAllAncestorAtFileNodesDirty  return list of nodes that were marked dirty.
- Create new top-level before/after methods &amp; helpers:
- Changed setUndoTypingParams to use new dispatch method.
- Removed makeBeadDict.
- Removed updateSetChangedFlag.
- Added new methods to nullUndoer class.
- Moved undo methods from leoNodes.py to leoUndo.py
- Added dirtyVnodeList param to afterChangeNodeContents.
</t>
<t tx="ekr.20050429094215.2"></t>
<t tx="ekr.20050429094215.22">Initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3053699

There were three similar bugs, all arising from the fact that g.os_path_abs and
g.os_path_join return the _working_ directory if the initial path is None!

I removed my HOME directory for testing. This was essential.

- Compute home directory must return None, rather than the working directory if
the HOME variable is None.

- app.setLeoId must be careful (in two sections) to do nothing if any of
(homeDir,globalConfigDir,loadDir) is None.
</t>
<t tx="ekr.20050429094215.286"></t>
<t tx="ekr.20050429094215.3">The initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3048149

The problem arose from a misguided attempt to eliminate non-useful information
from traces. Alas, the baby got thrown out with the bath water.

Here are the changes I made:

 - c.executeScript now calls g.es_exception(full=True) to ensure that a full
 stack trace always gets produced. This is especially important when the
 exception happens in a module (file) called by the script.

- c.executeScript now always executes the section &lt; &lt; dump the lines near the
error &gt; &gt;, regardless of context. The lines are printed (in black) in the log.
This is useful information in almost all cases.

- After much experimentation, g.es_exception is basically unchanged. Note: If
the error occurs in your script itself (as contrasted with an exception thrown
from a file called by your script) Leo always has properly put the cursor on the
offending line. I made no changes in this logic.

BTW, calling pdb.set_trace() in your scripts may cause more problems than it is
worth. Indeed.pdb.set_trace() uses only the information on the stack, and that
may not be enough information to be useful. I usually use g.trace to find out
what is happening. This works well.
</t>
<t tx="ekr.20050429094215.31">The problem is that newButtons must use @nosent, so any changes to newButtons
must be accompanied by a change to LeoPluginsRef.py. There is nothing more that
needs to be done.
</t>
<t tx="ekr.20050429094215.316">The only changes concern how Leo encodes and decodes items in
t.unknownAttributes and v.unknownAttributes.

Without changing the file format, the only way to tell Leo how to write
attributes is to use naming conventions. When writing attributes, Leo now does
the following:

- Do nothing except apply xml escapes if the attribute name (in
t.unknownAttributes or v.unknownAttributes) starts with str_ and the attribute
is, in fact, a string. If the string is a Unicode string Leo converts the
Unicode string to an encoded string.

- Use the present pickling/hexlifying scheming otherwise. In particular, issue a
warning and ignore the attribute if the attribute can not be pickled. BTW, there
is no need for separate base64 support: hexlifying guarantees that the result is
valid in any xml environment.

Leo now does the reverse when reading.

BTW, plugins could add their own naming conventions in an emergency. Indeed, the
conventions will be confined to code in atFile.putUa and atFile.getUa, so a
plugin would only need to override these two methods.
</t>
<t tx="ekr.20050429094215.347">Removed inAtOthers  param from putOpen/CloseNodeSentinel.
Removed inAtAll param from putCloseNodeSentinel.
Removed putCloseSentinel param from putAtAllBody
Removed putCloseSentinel param from putBody

Removed toString param from openFileForWritingHelper
Removed toString param from v.putUnknownAttributes

Note: most(all?) top-level atFile.write methods pass toString to initWriteIvars.
</t>
<t tx="ekr.20050429094215.353">Leo stores recent files information as follows.

1. Leo stores recent files info in files called .leoRecentFiles.txt. These will
be a plain text files with one line per recent files entry. An Easter egg: if
the file starts with read-only, read_only, readonly, etc. Leo will never update
the file and will not remember changes to the Recent Files menu.

2. On startup, Leo searches for the .leoRecentFiles.txt files in the user's home
directory, if it exists. Leo looks in Leo's config directory next, but only if
the home directory does not exist, or does not contain a .leoRecentFiles.txt
file. In other words, Leo will use at most one .leoRecentFiles.txt file on
startup.

3. When opening a .leo file, Leo looks for .leoRecentFiles.txt in the directory
containing the file.

4. At no time after installation does Leo create any .leoRecentFiles.txt file.
This will allow users (or their managers) to set policy regarding where to store
this information (if anywhere).

5. Leo writes at most one .leoRecentFiles.txt file when saving a .leo file,
namely the file read in item 3 if it exists, or the file read in item 2
otherwise.

This is a flexible scheme that should meet most needs without having to resolve
thorny questions about exactly where recent files info belongs.
</t>
<t tx="ekr.20050429094215.354">@killcolor

- Properly implemented undo/redo Clear Recent Files.

- readSettingsFiles now reads @recentfiles nodes from all settings files.

- Created @settings nodes and @recent-files nodes if they do not exist.
</t>
<t tx="ekr.20050429094215.355">You all have convinced me that storing recent files data in .leo files is a
dubious idea. My new plan is as follows:

1. Leo will store recent files info in files called .leoRecentFiles.txt. These
will be a plain text files with one line per recent files entry. These will be
local files, so problems concerning directory structure and path specifications
should go away.

2. On startup, Leo will search for the .leoRecentFiles.txt files in the user's
home directory, if it exists. Leo will look in Leo's config directory next, but
only if the home directory does not exist, or does not contain a
.leoRecentFiles.txt file. In other words, Leo will use at most one
.leoRecentFiles.txt file on startup.

3. When opening a .leo file, Leo will look for .leoRecentFiles.txt in the
directory containing the file.

4. At no time after installation will Leo create any .leoRecentFiles.txt file.
This will allow users (or their managers) to set policy regarding where to store
this information (if anywhere).

5. Leo will write at most one .leoRecentFiles.txt file when saving a .leo file,
namely the file read in item 3 if it exists, or the file read in item 2
otherwise.

6. Leo will have settings to tell which .leoRecentFiles.txt files may be
written.

7. Leo will never create @settings nodes or @recent-files nodes automatically.
Moreover, I shall remove the @recent-files panel from the settings dialog and
the corresponding @recent-files code from the config classes.

I believe this will address everyone's concerns without the need for resolving
thorny questions about exactly where recent files info belongs.
</t>
<t tx="ekr.20050429094215.41">The De-hoist command conflicted with the Expand/Contract submenu.

The Paste Node As Clone conflicted with the Mark submenu.
</t>
<t tx="ekr.20050429095849">- Saved expansion state of @settings trees when the user hits the OK button.

- Added support for UNL's in the status line when the settings dialog is active.

- Debugged @if-platform, @if-gui, @ints &amp; @strings.

- Reloaded settings files when opening the settings dialog.

- Removed support for @recent-files nodes.  This is now handled by .leoRecentFiles.txt files.
</t>
<t tx="ekr.20050509085713"></t>
<t tx="ekr.20050510071834">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3137690
By: nobody

I dont know if anyone has solved this for regular Leo, but in the JyLeo JythonShell,
when the user executes a script with Pdb it:
1. dumps the script in a tmp file system's tmp directory.
2. Executes pdb based off of that tmp file.

that way you get all the goodness that pdb can offer.
</t>
<t tx="ekr.20050513141852">Leo 4.3 beta 2                 May 15, 2005

Leo 4.3 beta 2 completes all major features of Leo 4.3 and fixes all bugs
reported since the beta 1 release.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.
</t>
<t tx="ekr.20050513141913.1"></t>
<t tx="ekr.20050513141913.127">doStrings now accepts either:

@strings[values]name=value
@strings name[values]=value

Similarly, doInts accepts:

@ints[values]name=value
@ints name[values]=value
</t>
<t tx="ekr.20050513141913.140">http://sourceforge.net/forum/message.php?msg_id=3149604

Changed c.hoistStack[-1].current to c.hoistStack[-1].p in c.insertHeadline.
</t>
<t tx="ekr.20050513141913.145">The code now calls frame.resizePanesToRatio in createFrame in Leo.

Not only does this fix this bug, it honors the following settings:

- initial_horizontal_ratio
- initial_horizontal_secondary_ratio
- initial_vertical_ratio
- initial_vertical_secondary_ratio
</t>
<t tx="ekr.20050513141913.149">http://sourceforge.net/forum/message.php?msg_id=3138608

Replaced individual shortcuts widget with a single text widget. This allows the
user to add or delete shortcuts.
</t>
<t tx="ekr.20050513141913.16">http://sourceforge.net/forum/message.php?msg_id=3133917

'Recent' and 'Marked' button now appear in new windows.
</t>
<t tx="ekr.20050513141913.17">http://sourceforge.net/forum/message.php?msg_id=3133915

The colorizer now correctly handles the following:

\@, \(, \), \{, \}

And also constructs like \documentclass{report}.
</t>
<t tx="ekr.20050513141913.187"></t>
<t tx="ekr.20050513141913.188">http://sourceforge.net/forum/message.php?msg_id=3135170
</t>
<t tx="ekr.20050513141913.194">For a test of this, see the script in test.leo at:

Scripts--&gt;Script to execute @test, @suite or file

Read the documentation in that node before running the script.
</t>
<t tx="ekr.20050513141913.197">g.getScript now fully processes all scripts, regardless of where they came from.

- Changed g.getScript:
    - p arg is now required.
    - Removed unused script arg.
    - Added forcePythonSentinels arg (default is True).
    - g.getScript no longer temporarily alters any body text.
        - atFile.writeFromString gets the initial text using the fromString arg.
    - g.getScript now always calls atFile.writeFromString to handle all Leo directives.

- Added forcePythonSentinels to atFile.initWriteIvars and atFile.scanAllDirectives.
    - Default is None, in which case the code sets forcePythonSentinels to the scriptWrite arg.

- Added forcePythonSentinels to atFile.scanAllDirectives.
    - Default is False.

- Created atFile.putAtFirstLines and atFile.putAtLastLines.
    - These replace the corresponding sections in writeOpenFile.
    - It was not actually necessary to define these, but it cleans up the code.

- Created atFile.writeFromString.
    - This handles all the details of simulating a write _from_ a string _to_ a string.

- atFile.initWriteIvars and atFile.openFileForWriting now allow root to be None.
    - This is not used at present: root is always defined.

- Added fromString arg to atFile.writeOpenFile and atFile.putBody.
</t>
<t tx="ekr.20050513141913.22">http://sourceforge.net/forum/message.php?msg_id=3051870
</t>
<t tx="ekr.20050513141913.233">http://sourceforge.net/forum/forum.php?thread_id=1281640&amp;forum_id=10228

The default is ''.  It define_name exists c.executeScript executes the script in an environment containing
__name__ = define_name.
</t>
<t tx="ekr.20050513141913.30">The nav_buttons plugin was using self.c rather than keywords.get('c') in a hook
handler. The general rule is that hook handlers should do nothing if self.c !-
keywords.get('c').  This was an old bug, arising from the rewrite of the plugin.

I added a warning to that effect in the plugin template.

It would perhaps be better to specify an optional commander in registerHandler
and only call the handler if the commander matches. However, this isn't so easy
or clean to do.I

The plugin was failing to set the positionList ivar (in the base
tkinterListBoxDialog class). This was a fairly recent blunder: I saw that
positionList wasn't used in the plugin directly, so I 'improved' the code by
using a local var instead of self.positionList. This illustrates a hazard of
using subclassing.
</t>
<t tx="ekr.20050513141913.57">This happened when creating a new chapter with chapters.py enabled.
</t>
<t tx="ekr.20050513141913.60">The fix was to recompute newSel in &lt;&lt; handle backspace with negative tab_width &gt;&gt; in idle_body_key.
</t>
<t tx="ekr.20050513141913.82">- The section name lost its indentation.
- The created section had extra indentation.
- Undoing did not remove the inserted section node.

The unit tests now properly test indentation.
</t>
<t tx="ekr.20050513141913.91">http://sourceforge.net/forum/message.php?msg_id=3143895

The Edit-&gt;Delete command did nothing when the selected text was in a headline.
</t>
<t tx="ekr.20050513141913.97">The following methods changed:

- markAllAtFileNodesDirty
- markAtFileNodesDirty
- markClones
- markHeadline
- markSubheads

I also rewrote the code using explicit positions.
</t>
<t tx="ekr.20050513164506">@killcolor

Jon Schull &lt;jschull@softlock.com&gt;  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 

I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations:
- Leo runs under X11 as well as under OS X.
- My X11 python configuration was created using the recipe at XXX (which enables vpython).
- The OS X configuration is vanilla MacPython from MacPython.org, along with AquaTclTk batteries included XXX.

In both environments I can run leo under python leo.py and under idle.
Under OS X we get font smoothing, but we can't run visual python programs (python crashes;  this is a known incompatibility with  MacPython.)

- Under X11 we can run visual python programs like this one
    #box.py
    from visual import *
    box()

And we can even run them under leo (under X11). HOWEVER, when the visual python program is terminated, leo vanishes (leo and the vp program apparently run in the same space)

Under x11, we can keep leo alive by putting the vp program in its own space:

    os.popen3('/sw/bin/python /Users/jis/box.py')

However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...

    def do(cmd='ls'):
        from os import popen3
        pIn,pOut,pErr=0,1,2
        popenResults=popen3(cmd)
        print popenResults[pOut].read()
        print popenResults[pErr].read()

    import os
    do('/sw/bin/python /Users/jis/box.py')

...but only when the vpython program terminates.

Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).

    import os
    os.chdir('/sw/lib/python2.3/idlelib')
    os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')

#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.

Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.

It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
</t>
<t tx="ekr.20050523092026">Leo 4.3 final                 May 23, 2005

Leo 4.3 is here after almost five months of work.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.
</t>
<t tx="ekr.20050523092056.1">http://sourceforge.net/forum/message.php?msg_id=3155657

Enabling the Pie Menu plug-in caused Leo to quit when opening .leo files.
</t>
<t tx="ekr.20050523092056.4">This fixed a recent bug.
The crash happened if not section text was specified.
Added new checks and new error messages.
</t>
<t tx="ekr.20050620144052">Leo 4.3.1                    June 20, 2005

- Added support for Tk resource files.
- Added support for coloring the PL/SQL language.
- All Mark commands are now undoable.
- Improved Resize To Screen command.
- The usual assortment of minor bug fixes.
</t>
<t tx="ekr.20050620144052.112">The problem was that leo.__file__ returns a randomly upper or lower cased drive letter.
</t>
<t tx="ekr.20050620144052.114"># The About Leo dialog was not getting focus.
</t>
<t tx="ekr.20050620144052.116"></t>
<t tx="ekr.20050620144052.119">http://sourceforge.net/forum/message.php?msg_id=3176499

5) am I missing text in the Settings panels?  the outline shows that certain
nodes have text (e.g., "About keyboard shortcuts" has the blue rectangle), yet
the body pane is empty; heck, even the title suggests that something should
be there...
</t>
<t tx="ekr.20050620144052.154">http://sourceforge.net/forum/message.php?msg_id=3190593

As luck would have it, I need to put an @ character at the beginning of a line
in source code (windows registry file format) and can't figure out how to do
it. 
</t>
<t tx="ekr.20050620144052.166"></t>
<t tx="ekr.20050620144052.182">http://sourceforge.net/forum/message.php?msg_id=3186385

I just tried 4.3-final, and it seems it does not work with Chinese LC_CTYPE:
</t>
<t tx="ekr.20050620144052.185">http://sourceforge.net/forum/message.php?msg_id=3175553

When I set default_target_language to plain in 4.2., no words in any body text
is colored. This behavior seems to have changed in 4.3. Is it right, that I
now have to write @nocolor on top of *every* body text to get rid of randomly
colored words?

What I did:

- Added entries for target_language to ivarsDic and defaultsDict in leoConfig.py.
- Added @language target_language = Python to leoSettings.leo.
- Convert c.target_language to lowercase in several places.
</t>
<t tx="ekr.20050620144052.2"></t>
<t tx="ekr.20050620144052.207"></t>
<t tx="ekr.20050620144052.208">idle_body_key now calls doAutoIndent and convertBlanksToTabs. The idea is that
plugins could override these methods if desired.
</t>
<t tx="ekr.20050620144052.210"># I also fixed a bug: the Mark Clones command did not work!
</t>
<t tx="ekr.20050620144052.222">Some non-standard distributions don't include the profile and pstats modules.
</t>
<t tx="ekr.20050620144052.231">Leo will now look for a file called .leo_xresources in the users home directory.
If found, Leo will pass that file to Tk's option_readfile method for the top
widget. This allows users to set Tk options.
</t>
<t tx="ekr.20050620144052.3">http://sourceforge.net/forum/message.php?msg_id=3166883
By: rogererens

I swear I didn't wait for the release to be the first to report a bug! I just
didn't try this in the alpha/beta versions:

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.4.1, Tk 8.4.7, win32

Changing
Global settings: C:\Leo\config\leoSettings.leo--&gt;Window options--&gt;@page Options
for new windows--&gt;@ratio initial_horizontal_ratio = 0.3
or any of the other ratios, does not save them to leoSettings.leo. So after
restarting I still have the old settings in use.
</t>
<t tx="ekr.20050620144052.48">- Fixed bugs in convertAllBlanks and convertAllTabs.

These must always call afterChangeGroup to match beforeChangeGroup, even if
nothing has changed.

- Added u.getMark and u.rollbackToMark.

These allow unit tests to cut the undo stack back to an initial position in the
tearDown method. This should be done for all tests that use u.undo and u.redo
methods. The bug was probably the result of changing the outline in the tearDown
method.

Both the Reformat Paragraph and Edit Body unit tests now roll back the undo stack.

- Added traces for unexpected conditions in u.undo, u.redo and tree.select.

- Call u.setUndoTypes() in u.setUndoTypingParams when returning early.

- Corrected Edit Body unit tests.

These tests should not call undo/redo when nothing is expected to change. Doing
so may trigger the new 'cant undo' traces in u.undo.

- doTest in leoTest.py now makes copies of both p and p1.

It's not clear that this is needed, it can't hurt, and it may have been important.
</t>
<t tx="ekr.20050620144052.6">http://sourceforge.net/forum/message.php?msg_id=3167166

The fix was to add the following line to the init function:

    global click_registry, coloured_nodes
</t>
<t tx="ekr.20050620144052.8">Modifying outlines can invalidate existing positions! This rarely happens. At
present it affects the atFile.read logic when reading an outline whose initial
current position is a clone outside an @thin tree with another clone inside the
@thin tree. So the read logic computes the expected current position before
reading all external files, and this expected current position becomes invalid.

What I did:

1. Moved &lt;&lt; set current and top positions &gt;&gt; from getVnodes to end of
getLeoFile. This ensures that the outline won't change after computing the
position.

2. Unit tests will have to be revised to make sure that only valid positions get
used.
</t>
<t tx="ekr.20050620144425"></t>
<t tx="ekr.20050620144602"></t>
<t tx="ekr.20050716104357">@language rest
- put the jyleo-nnn.jar file in c:\prog

- Execute the following command in a console window
    cd c:\prog
    jar xvf j-leo-nnn.jar

This creates a folder called j-leo-nnn

- Do the following, or execute jleo.bat

cd c:\prog\j-leo-nnn\src
java -jar c:\jython22a0\jython.jar leo.py

Note:  at present this gives KeyError: HOME
@language python

In leo.py, in computeHomeDir, I changed::

    home = os.getenv('HOME' )#,default=dotDir)

to::
    
    try:
        home = os.getenv('HOME' )#,default=dotDir)
    except Exception:
        home = ''

</t>
<t tx="ekr.20050812123002"></t>
<t tx="ekr.20050812123002.1"></t>
<t tx="ekr.20050812123002.2">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.
</t>
<t tx="ekr.20050812123002.3"></t>
<t tx="ekr.20050812123002.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:

1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map
</t>
<t tx="ekr.20050812123002.5"></t>
<t tx="ekr.20050812123002.6">True: call body_filter to massage text.

Removes @ignore, @nocolor, @wrap directives.
</t>
<t tx="ekr.20050812123002.7">Used differently.  See rst2_pure_document.
</t>
<t tx="ekr.20050812134441.1">.. Links used in this document.

.. |br| raw:: html

   &lt;br /&gt;

.. _`Leo's Directive Reference`: directives.html
.. _`Leo's cheat sheet`: cheatsheet.html
.. _`Python generators`:    https://wiki.python.org/moin/Generators
.. _`scripting portion`: cheatsheet.html#scripting
</t>
<t tx="ekr.20050818163826">######################
rst3 Command Reference
######################

.. _`rst3 tutorial`: tutorial-rst3.html

Please read the `rst3 tutorial`_ before reading this chapter.

This chapter covers advanced settings and features of the rst3 command. It
is for power users only.

Are you sure you want to read this chapter? The tutorial covers everything
most people need to know about the rst3 command. Leo's own documentation
uses none of the features discussed here.

.. contents::
    :depth: 4
</t>
<t tx="ekr.20050818163826.10">The rst3 command defines a code-block rST directive. The primary purpose of this
directive is to show formatted source code.

In rst mode you can insert the code-block directive like any other rST markup.

The rst3 command generates code-block directives automatically in code mode.

This directive takes one argument, a language name.  Like this::

    .. code-block:: Python

        import leo.core.leoPlugins as leoPlugins
        import leo.core.leoGlobals as g

The output looks like this::

    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoGlobals as g

.. _`Scripting Tutorial`:   tutorial-scripting.html

See the `Scripting Tutorial`_ for many examples of how to use code-blocks.
</t>
<t tx="ekr.20050818163826.11">HTML files generated by the rst3 command assume that three .css (cascading style
sheet) files exist in the same directory. For the HTML output to look good the
following .css files should exist:

- default.css is the default style sheet that docutils expects to exist.

- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.

.. - silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**Important:** You can use cascading style sheets to do things that otherwise
wouldn't be possible with "plain" rST. For instance, the background color of
this page was specified in a body style.
</t>
<t tx="ekr.20050818163826.13">.. _ListManagerDocs.html: http://leoeditor.com/ListManagerDocs.html
.. _wxListManager.leo:    http://leoeditor.com/wxListManager.leo

The file `ListManagerDocs.html`_ is an impressive example of the kind of output
that can be generated relatively easily using the rst3 command.

The source for ListManagerDocs.html is `wxListManager.leo`_. **Important**:
wxListManager.leo was written for the old rst2 plugin; it could be greatly
simplified if adapted for the rst3 command.

This documentation was created using the rst3 command. The source code for this
documentation is in LeoDocs.leo. The source code for the rst3 command is in
leoRst.py in leoPy.leo.
</t>
<t tx="ekr.20050818163826.14">The code for the rst3 command is more complex than usual. Fortunately, the
overall organization is straightforward.

defaultOptionsDict
    This dictionary represents each rst3 option.
    To add another option, just add another entry to this dictionary.
    Keys are the option name, including the `rst3_` prefix.
    Values are the default value of the option.
    The hard-coded values in the dictionary may be changed as the result of @settings entries.

processTree
    processTree is the top-level code that handles one rst root node.
    It calls preprocessTree to create the **vnodeOptionDict** ivar.
    processTree then calls either writeNormalTree or writeSpecialTree
    depending on whether text will be sent to docutils for further processing.
    These two methods handle mundane details of opening and closing files.
    Both writeNormalTree and writeSpecialTree call **writeTree** to do the actual work.

vnodeOptionDict
    The entries in this dictionary represent the options that are set in one particular node.
    The keys of vnodeOptionDict are vnodes, the values are anonymous dictionaries.
    These anonymous inner dictionaries contain the options that are explicitly set at each vnode
    (and thus each position).
    Preprocessing the tree this way ensures that each node (headline and body text) is parsed exactly once.

writeTree
    writeTree first calls **scanAllOptions**, which has the effect of
    initializing all options. writeTree then calls **writeNode** for each node
    that will be processed by the rst3 command. Options may cause the rst3 command to
    skip a node or an entire subtree.

writeNode
    writeNode first calls **scanAllOptions** to compute the options that are in
    effect for that *single* node. Once options have been computed, processing the
    node is straightforward. writeNode calls writeBody and writeHeadline
    to do the real work. These methods generate or skip text based on various
    options.

scanAllOptions
    scanAllOptions recreates the optionsDict ivar to represent *all* the options
    in effect for *for the particular node being processed by writeNode*. Client
    code gets these options by calling the getOption method.

    scanAllOptions first inits all options from settings,
    then updates those options using the anonymous
    dictionaries contained in the vnodeOptionsDict.
    scanAllOptions works like g.scanAllDirectives, but the code is much simpler.
</t>
<t tx="ekr.20050818163826.16">Josef Dalcolmo wrote the initial rst plugin.
Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and
Steve Zatz made contributions to the rst and rst2 plugins.
</t>
<t tx="ekr.20050818163826.4">The material covered so far in this chapter suffices to create most books
and documentation, including Leo's own documentation.

The rest of this chapter covers advanced topics. These can seem bewilderingly
complex. Alas, they are complex! However, they all arose from a single problem::

    How to generate documentation from computer source code in a Leo outline.

or equivalently::

    How to embed documentation in computer source code in a Leo outline.

This is an interesting problem, but it has little general interest. Please stop
reading now if this problem doesn't interest you!
</t>
<t tx="ekr.20050818163826.5">The following options are for the use of Bernhard Mulder's http plugin. The http
plugin creates an http server running on a local port, typically 8080. When the
http plugin is running you will see a purple message in the log window that
looks something like this::

    http serving enabled on port 8080, version 0.91

To use the http plugin, start a web browser and enter this url::

    http://localhost:8080/

You will see a a top level page containing one link for every open .leo file.
Clicking on a link will cause the http server to pass a new page to the browser.
You can use the browser's refresh button to update the top-level view in the
browser after you have opened or closed files.

**Important**: See the docstring for the http plugin for information on
configuring the plugin. Some of the following rst3 settings must match values of
settings for the http plugin.

Here are the rst3 options that support the http plugin:

.. glossary::

http_server_support (default: False)

    A master switch: none of the following options have any effect unless this
    option is True. If True, the rst3 command does the following:

    1. Writes **node markers** in the rst output for use by the http plugin.
       Node markers are rst named hyperlink targets. By default they look like::

            .. _http-node-marker-N

       where N is a unique node number.

    2. Adds additional information to all nodes of the tree being formatted using
       Leo's unknownAttributes mechanism.

http_attributename (default: 'rst_http_attribute')

    The name of the attribute name written to the unknownAttributes attribute of
    each outline node in the rst root tree. The default is
    'rst_http_attribute'; it should match the following setting of the http
    plugin::

        @string rst_http_attributename = 'rst_http_attribute'

clear_http_attributes (default: False)

    If True the rst3 command initially clears the fields specified by `http_attributename`.  

node_begin_marker (default: 'http-node-marker-')

    The string used for node markers.
</t>
<t tx="ekr.20050818163826.6">.. EKR: This kind of "flexibility" is a really bad idea.

The following options specify the 'spelling' of headline commands. The
option_prefix and option_prefixes command also define the spelling of special
doc parts.

You can change these to make them shorter or to avoid conflicts with headlines
in your Leo files. The list below merely gives the default value for each
setting.

`code_prefix`: '\@rst-code'

`ignore_headline_prefix`: '\@rst-no-head'

`ignore_headlines_prefix`: '\@rst-no-headlines'

`ignore_prefix_tree`: '\@rst-ignore'

`ignore_node_prefix`: '\@rst-ignore-node'

`ignore_tree_prefix`: '\@rst-ignore-tree'

`option_prefix`: '\@rst-option'

`options_prefix`: '\@rst-options'

`preformat_prefix`: '\@rst-preformat'

`rst_prefix`: '\@rst'

`show_headline_prefix`: '\@rst-head'
</t>
<t tx="ekr.20050818163826.7">Any headline that starts with @rst- controls the rst3 command.

.. glossary::
    :sorted:

..  @rst-code &lt;section&gt; 

    ..  Enter code mode. (Code mode is covered in the advanced topics sections)
    ..  Create a section if the show_headlines option is True.

@rst-ignore &lt;ignored-text&gt;

    Ignore the node and its descendants.

@rst-ignore-node &lt;ignored-text&gt;

    Ignore the node, but *not* its descendants.

@rst-ignore-tree &lt;ignored-text&gt;

    Same as \@rst-ignore.  Ignore the node and its descendants.

@rst-no-head &lt;ignored-text&gt;

    Ignore the headline but not the body text of this node.
    This has no effect on descendant nodes.

@rst-no-headlines &lt;ignored-text&gt;

    Ignore all headlines. (Set show_headlines=False)

@rst-option &lt;option&gt; = &lt;value&gt;

    Set a single option to the given value. The default value is True.

@rst-options &lt;ignored-text&gt;

    Set options from body text. The body text should contain nothing but
    lines of the form::

        &lt;option&gt;=&lt;value&gt;

@rst-preformat &lt;ignored-text&gt;

    Format the body text of the node as computer source code. In effect, this
    option adds a line containing '::' at the start of the body text. The option
    then indents all following lines.

    This option has no effect on descendant nodes.

..  @rst-rst

    ..  Enter rst mode. (Rst mode is the mode of operation discussed in the tutorial.)
    ..  Create a section if the show_headlines option is True.

</t>
<t tx="ekr.20050818163826.8">**Option doc parts** set rst3 options. Option doc parts start with \@
\@rst-options followed by lines of the form name=value. (Comment lines starting
with '..' are allowed.) For example::

    @ @rst-options
    .. This comment line is ignored.
    show_headlines=False
    show_leo_directives=False
    verbose=True
    @c

This is a real Leo doc part. Like all other doc parts an option doc part starts
with the \@ directive and continues until the end of body text or until the next
\@c directive.
</t>
<t tx="ekr.20050818163826.9">Settings in leoSettings.leo or myLeoSettings.leo specify the defaults
to be used for all rst3 options.  The form of these settings is::

    @bool rst3_&lt;option name&gt; = True/False
    @string rst3_&lt;option name&gt; = aString

That is, to create a default value for an rst3 setting, you must
prefix the option name with 'rst3\_'.  For example::

    @bool rst3_write_intermediate_file = True
</t>
<t tx="ekr.20050828160132">.. _front:                      index.html
.. _`Leo's tutorial`:           tutorial.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:           appendices.html#history-of-leo
.. was history.html
.. _`Using Chapters`:           outlines.html#using-chapters

.. For reasons unknown, images must appear in the _images folder on the web site.
.. .. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. .. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. .. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
</t>
<t tx="ekr.20050830074815.1">.. epigraph::

   I am using Leo since a few weeks and I brim over with enthusiasm for it. I think it is the most amazing software since the invention of the spreadsheet.

   --Anon.

.. epigraph::

   We who use Leo know that it is a breakthrough tool and a whole new way of writing code.

   --Joe Orr

.. epigraph::

   I am a huge fan of Leo. I think it's quite possibly the most revolutionary programming tool I have ever used and it (along with the Python language) has utterly changed my view of programming (indeed of writing) forever.
   
   --Shakeeb Alireza

.. epigraph::

   Thank you very much for Leo. I think my way of working with data will change forever... I am certain [Leo] will be a revolution. The revolution is as important as the change from sequential linear organization of a book into a web-like hyperlinked pages. The main concept that impress me is that the source listing isn't the main focus any more. You focus on the non-linear, hierarchical, collapsible outline of the source code.
   
   --Korakot Chaovavanich

.. epigraph::

   Leo is a quantum leap for me in terms of how many projects I can manage and how much information I can find and organize and store in a useful way.
   
   --Dan Winkler

.. epigraph::

   Wow, wow, and wow...I finally understand how to use clones and I realized that this is exactly how I want to organize my information. Multiple views on my data, fully interlinkable just like my thoughts.
   
   --Anon

.. epigraph::

   Edward... you've come up with perhaps the most powerful new concept in code manipulation since VI and Emacs.
   
   --David McNab

.. epigraph::

   Leo is...a revolutionary step in the right direction for programming.
   
   --Brian Takita
</t>
<t tx="ekr.20050830074815.10">.. epigraph::

   I am extremely impressed at how stable and useful Leo appears to be.
   
   --Marcus A. Martin

.. epigraph::

   Leo is amazingly stable. Docs are often weak with Open Source Software. Not so Leo: Leo is unusually well documented.
   
   --F. Geiger

.. epigraph::

   Leo is unimaginably useful and I always find new things it already knows(!) how to do. Indeed I am amazed by the never-ending resources and patience Edward is putting into it and its users community. Excellent.
   
   --Gil Shwartz

.. epigraph::

   I feel strongly that Ed Ream, our ever-patient, ever-productive Leo architect deserves a nomination [for the ActiveState OpenSource Award.] Among other reasons, for:

  - Delivering the first usable visual literate programming tool.
  - Adding a vast abundance of new features.
  - Making possible a previously unimaginable amount of leverage in code editing.
  - Eliminating vast amounts of menial programming labour.
  - Tirelessly and patiently supporting users, and catering to a wide range of feature requests.
  
  --David McNab
</t>
<t tx="ekr.20050830074815.11"></t>
<t tx="ekr.20050830074815.12">.. _`slashdot`: http://slashdot.org/comments.pl?sid=38848&amp;amp;cid=4171478

August 28, 2002, on `slashdot`_.

Hello, my full name is David Speed Ream. I am known as Speed to friends and
enemies alike, but I gladly answer to David or most any other handle. I am an
unabashed and biased fan of Leo, the fact that it was written by my brother
Edward only slightly coloring my already colored glasses. I have been testing
and using Leo in software production for over 4 years. My company currently has
over 50,000 lines of code in over 100 source files that are written using Leo.

My comments are from two points of view, the first being software project
manager for a complicated, multi-module software product, and the second being
as a production line coder. For me, Leo’s greatest and only real drawback is the
learning curve. This learning curve can be shallow is if all that is required is
that someone code using Leo. However, in our company we allocate 40 to 80 hours
*on top* of the normal coding load for someone to come up to speed on Leo. The
ROI (return on investment) is calculated by me to be on the order of 3 months.
So if I hire a consultant for less than 3 months, I don’t teach him Leo, even
though all source code in our company must reside in Leo files for the reasons I
won’t go into now.

I consider that my coders are 15 to 30 percent more efficient in their daily
operations than my competition’s people. This indefensible claim of mine is
based on the changes in my productivity as Leo grew from a test document
production tool to the primary production method for all our assembly, c and cpp
source code.

Personally, I hate to deal with documentation when I write code, except:

1) When I am first sitting down to solve a new problem.
   Then the documentation becomes quite long-winded and pontificatory,
   as if I were the only one on earth smart enough to solve the problem - or
2) When I come back to code I or someone else has written and find the documentation insufficient to
   understand the code without study (seems to be most of the time).

So I do not require my engineers or myself to do a great job of documentation,
nor do I use Leo for that purpose. Rather, it is Leo’s outlining and organizing
ability, and Leo’s ability to create source files from within the outline that
give me what I think is a tremendous competitive advantage. Each of my company’s
products run on all versions of windows from Win 3.1 to XP. In our flagship
software piece, there are ten main modules, and each module is maintained by one
single Leo file. In the CODEC module, one Leo file named compress.leo organizes
and creates seven .asm files, forty-four .c files, twenty .h files, two .def
files, four .mak files, etc. etc. etc. This one file can be checked out from
source code control and given to an engineer for the addition of a new feature.

In it are contained all the known issues for the CODEC, each issue arranged in
its own clone section. One clone section groups together every routine, variable
or type definition that must change between different versions of Windows. These
sections could be from six different c source files, two assembly files, and
eight .h files. Another clone section groups together those sections relating to
memory problems, which change according to the memory configuration and TSR
configuration (or lack thereof) on the target machine. Another clone section
groups sections that fail (or don’t fail) if the routine in question was
accidentally run during the dreaded ‘interrupt time’. Another clone section is a
section containing clones, each of which is named after the major bug that was
fixed when the engineer who fixed the bug grouped a bunch of routines,
definitions, etc. together to fix the bug.

None of the above clone sections was ‘designed’ into the document. Just the
opposite happens. When the codec was first written, there was just a single Leo
file with a bunch of sections for each c routine or assembly module. As the
product grew and was tested on various platforms, each failure of the module was
organized into clones each time a failure was fixed. This is what I call “SELF
DOCUMENTING CODE”. This has nothing to do with me sitting and documenting
anything. Its just that the STRUCTURE of a bug fix (or product enhancement)
lives on long after the coding is done, as long as no one is foolish enough to
delete the cloned sections that ‘DOCUMENT’ what happened.

In actual practice, this organizational ‘history’ is so powerful that I can’t
begin to describe it. A ‘REVERSE LEARNING CURVE’ happens when an engineer gets a
Leo file that already has the ‘interrupt time sensitive’ routines grouped
together by the last unfortunate soul who had to work on them. There may not be
any more written documentation, but the knowledge contained in the structure can
be breathtaking. It is certainly time saving. I find this particularly true in
my own case. Often I’ll look at some code that seems totally unfamiliar and
think ‘what idiot wrote this crap’. Then I’ll look at the version control
comments and realize that I wrote the crap. Then for sure I know the
documentation is non-existent, but the clones I used to develop it are still
there, and they always serve to refresh my memory in an indescribable way.

Enough of this commentary, I just looked at the clock. Best wishes to anyone
willing to try Leo for a week. I hope you will be glad you did.
</t>
<t tx="ekr.20050830074815.13">The Word outlines are very useful. But Leo makes Word look like a clunky toy.

#1 Reason would probably be clone nodes. One node can point to another. Another
way of putting this is is that a leaf can be on more than one tree. For
example, suppose you have a list of recipes. You simultaneously put a single
recipe under multiple categories or even multiple hierarchies. You could put "3
bean enchilada" simultaneously under Recipes-Mexican and Food-Gas. Another
example would be, if you are a biologist trying to decide under which genus to
put a new species, you could put the species under two simultaneously. In
effect, you can build a 3-D tree.

.. For a further illustration see http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm

#2 Reason would probably be that Leo outlines can be embedded in external text
files. So, a Leo outline is more than an outline, it is a meta-structure that
can be added to another text without changing that text, but rather providing
an external road map to the text. Microsoft Word has a text (xml) version with a
commenting convention, so Leo can even be used to add outlines into Word docs,
although it isn't set up to do that now. For example, see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm In this case, the upper
window of Leo is the meta-structure, and the bottom window is the file to which
the meta-structure is being applied, viewed one node at a time.

I may not have made #2 very clear, but it is actually a very useful feature. It
takes some getting used to before one sees all of the possibilities tho. One
way to think of it is that Leo allows you to throw external documents into your
outline, and yet the external document remains independent and can still be
edited separately.

Some other cool things about Leo which Word doesn't feature:
1. Pure xml output that is easy to transform into other formats (next
version of Word will have true XML format, but not as easy to work with).
One consequence of this is that Leo files can be transformed pretty easily
to web pages with their outlining capability intact.
2. Easy to add features since is programmed in Python and open source. Maybe
your average user can't start hacking on it, but a surprising amount can be
tacked on...
3. Free, opensource, multi-platform
4. Leo is scriptable with Python. It should be possible to build a Tickler
into Leo using Python scripting, for example.
</t>
<t tx="ekr.20050830074815.14">First of all, kudos to you for the excellent progress you've been making with
Leo. I upgraded today after about three months of using and older version and I
was thrilled to see all the great improvements that have happened so fast. I
especially love the ability to go to next clone. I think you're really showing
what open source can do and your current trajectory puts you on track to kick
Emacs into the dustbin of computing history.

So today I copied all my data (personal information manager and project
management stuff) out of my old outliner (ThoughtManager, which syncs with and
runs on the Palm) and put it into Leo. It took me hours to do it and then to
rearrange it the way I really wanted it. But having the ability to make clones
and have different ways to view my data is, as you know, fabulous. In my case,
for personal information and project management things, I used the flexibility
of clones to allow me to see my data in several different views: 1) by project,
the logical hierarchical breakdown by topic, 2) by person, so whenever I'm
talking to someone I can easily see all the pending items related to them which
may be spread over multiple projects, 3) by priority, so I can see what needs to
get done sooner and what can wait for later and, 4) a special case of priority
called "Today" for the things I'm going to focus on in the coming hours.

Now here's why I don't miss the ability of my old outliner to synch the entire
outline with the Palm. It turns out the main thing I really want in the Palm is
the top category "Today" so all I have to do is have Leo flatten that one
heading into a text file (and it kindly remembers the name and directory of the
file I used last time) and then I'm done because I've told the Palm Hotsync
manager that that file should be sent to Palm memo pad every time I synch. The
Palm Hotsync manager does a nice job of sending a text file to the Palm memo pad
and even breaks the file up into multiple memo records if it's too big to fit in
just one. So that gives me enough to be able to browse (or full text search) the
small amount of data that I really want right inside my Palm (which is also my
cell phone). Quick and dirty but it works.

For times when I want my whole outline with me, Leo wins again because thanks to
its cross platform nature I can take my whole outline with me on my Mac iBook,
even though I usually edit it on a Windows PC (which is the only kind of machine
my old outliner would run on). Quite frankly, although my old outliner was able
to shoehorn the whole thing into my palm/cellphone, it was a pain to access it
on the small screen and slow processor. Now when I anticipate I'll need the
whole thing, for example when I'm going to a meeting, I can put it on my Mac
iBook (under X and Fink for now until Python can do it native under Aqua) and
have real, full access to it all.

I think now in addition to being great for programming Leo is also a great PIM.
Being able to flatten a strategically chosen portion of the outline into a known
file name that the Palm synch manager has been told to send to the Palm on every
synch does the trick for me. I wonder if you would consider something like an
@flatten directive so I can have that done automatically for me every time I
save my outline? For now it's up to me to flatten the node I want manually,
although once I've done that the transfer to the Palm is automatic.

You're my hero! Thank you so much.
</t>
<t tx="ekr.20050830074815.15">Another day, another breakthrough using Leo--now I realize Leo is the 
best URL bookmark manager there is.  No more bookmarks menus or 
favorites lists inside the browser for me.  With the @url directive I 
can just double click on the URL to open it in my browser.  Leo lets me 
arrange the URLs in a hierarchy (or multiple hierarchies), attach notes 
to them, save clippings of things I read on the sites.  It's sooo much 
better than anything the browsers have built in and it lets me easily 
use different browsers on different platforms and different machines 
(try that with the browsers' built-in bookmark managers).  

When using Leo as a project manager and personal information manager as 
I do I can heavily annotate every task and project with helpful and 
relevant URLs.  And since URLs can be of the file:// form, they're not 
just for web pages or HTML documents;  I can link to any file on my disk 
of any type to be opened by any program.

Leo is a quantum leap for me in terms of how many projects I can manage 
and how much information I can find and organize and store in a useful 
way.  I'm a data-mining army of one now and the web is my playground. 
Every time I find a web page that has interesting links to others, 
those links get stored in my Leo outline too, right where I can find 
them and make practical use of them.  I can easily accept dozens of 
valuable links every day and integrate them into what I'm doing in a way 
that I'm confidant they won't get lost or forgotten.  Before I always 
used to get bogged down by the difficulty of managing bookmarks inside 
the browser.  But now I'm no longer the victim of information overload 
buried in the knowledge landslide of the Internet;  instead I'm the 
professional strip miner with the world's biggest bulldozer.  I eagerly 
plunge into mountains of data and emerge with all the valuable 
information nuggets neatly stored and organized.  And my storehouse of 
knowledge is a flexible thing where I can reorganize and prioritize and 
massage the data to my heart's content as I learn more about it and 
decide to use it in different ways for different purposes.  It's the 
difference between the pick axe and the steam shovel for me.
</t>
<t tx="ekr.20050830074815.16">This year my accountant is getting a beautiful printout generated by LaTeX and
Leo. I have a complicated tax situation this year, but I got it all laid out and
organized in Leo. Then I had each of the nodes that had something my accountant
needs to see write the data out to a file in the form a LaTeX table.

Sometimes a row of a table would have a result that was calculated by adding up
a list of numbers. For that I used the modern day equivalent of an adding
machine paper tape--I stored a lisp s-expression in a Leo comment. I like
s-expressions for this because once I put the opening "(+" on one line and the
closing ")" on another line, I can fill in additional numbers just by typing
them and can even annotate them with comments. So in the middle of generating a
LaTeX file I might have something like this::

    @
    (+
    1165.26 1823.70 ; May 2002
    123.38 ; June 2002
    13.50 ; July 2002
    13.21 ; October 2002
    55.25 ; November 2002
    )
    @c

That's an annotated record of how I arrived at the number the accountant will
actually see. I can just paste it into any lisp or scheme interpreter and get
the total. Adding additional numbers is easy.

For next year, I think I might take this a step further. What I did
this year is good for adding up numbers to get a total for one row of
a LaTeX table. But it turns out I'd also like some more processing
done on those tables (which I had to do by hand this time--I'd like
the rows sorted in reverse order by magnitude (so that the big numbers
jump out at you from the start of the tables) and I'd like a total of
all the rows in the table. So I think next year, instead of having an
s-expression that computes the total of one row for me, I think I'll
use s-expressions that generate whole tables, formatted for LaTex,
from the underlying data. So I'm thinking next year my s-expressions
might look more like this::

    @
    (table "Widget Related Expenses"
        ("widget insurance" (+
                        1165.26 1823.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                      ))
         ("widget shipping" (+
                        472.15 651.94 ; May 2002
                        54 ; June 2002
                       ))
         ("widget cleaning" (+
                        165.26 183.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                       ))
    )
    @c

The job of that "table" function would be to return the LaTeX code
needed to display a table with the category names and values, sorted
descending by magnitude, with the total displayed. It's sort of a poor
man's way of doing a spreadsheet inside Leo and then making it look
great using LaTeX. The idea would be as I wanted to add more data, I'd
add it to the s-expression and then reevaluate the whole thing by
pasting it into a lisp interpreter and then copying the result back
into the same Leo node for LaTeX to process.---Dan
</t>
<t tx="ekr.20050830074815.2">.. epigraph::

   Thanks for a wonderful program – everybody should be using it! It blows the socks off that Java Mind mapping software that won project of the month a while back on sourceforge!

   --Derick van Niekerk.

.. epigraph::

   A few years back I would have said Zope was #1 Python showcase, but I agree 100% that Leo is tops now.

   --Jason Cunliffe

.. epigraph::

   Leo is the most interesting Python project I know of...I see lots of stuff posted on the Daily Python page, but I usually yawn and come over to this forum to see what's cooking.

   --Anon

..  "Leo is the best Tkinter application ever written. It convinces me that Tkinter
..  can really *do something*, and do [it] well." - Anon

.. epigraph::

   What an original synthesis of different ideas, why can't other Open Source projects change the way I think?

   --Anon
</t>
<t tx="ekr.20050830074815.3">.. epigraph::

   When first I opened Leo, it was out of curiosity. But having used it...I'll never go back. They'll have to pry Leo out of my cold, dead fingers! Seriously, it should be renamed 'Crack Cocaine' because it's that addictive. I'm ready to start a 12-Step group.

   --Travers A. Hough

.. epigraph::

   I feel addicted to programming again...in fact [Leo] has resurrected a dead project of mine :) The Outline has proven most liberating in terms of testing ideas out.

   --Anon

.. epigraph::

   I have been absolutely seduced by Leo over the past few days. I tell you, I can not put it down. I feel like a kid with a shiny new bike...I'm already bursting with new ways I'd like to use the tool in the future.

   --Lyn Adams Headley

.. epigraph::

   Thanks for the great work--I love Leo!!!

   --Josef Dalcolmo

.. epigraph::

   Leo has simplified updating and creating new scripts and .bats keeping similar information in the same place. there is almost an addictive withdrawal effect when I can complete an operation in so much less time with Leo &amp; python than I had become used to.

   --Anon

.. _`atta. snap`: https://11707503125000652521.googlegroups.com/attach/44b6acf597f1cb02/snap4ZQMBP_131025_10.54.12.png?part=2&amp;view=1&amp;vt=ANaJVrFBMujBCjUslLye_M28daClPfNBKlr-AIYDCPl3DjULx2ZQPEOVBygH9p_vWzHCZS9xxRrW6h0HjabrZkEY3_jID2hmRdXaBh0NunGKcwov2tkazJY
.. `atta. snap`_ is my slides write env: 

.. epigraph::

   Leo is my Favorites Mind Capsule ;-)
   
   - she can contain all kinds of my Works (novel, code, slides, documents...)
   
   - and she can magic record my chaos mind in same time and same place and NOT Disturb my working...
   
   - livin Leo, make me freedom with chaos mind and structuring work export!
   
   - all my Slides is make with rst2s5
   
   - write rst in Leo
   
   - usage CLI tools generate html slides
   
   - easy, geek, and freedom!
   
   -- 周琦 (Zoom.Quiet)
</t>
<t tx="ekr.20050830074815.4">.. epigraph::

   [Leo] should either replace or greatly augment the development tools that I use.

   --Zak Greant

.. epigraph::

   Leo is a marriage of outlining and programming. Pure genius. The main reason I am impressed with this tool is that it doesn't affect your choice of tools. You can use whatever IDE for whatever language and switch back and forth between Leo and it.
   
   --Austin King

.. epigraph::

   Leo is the best IDE that I have had the pleasure to use. I have been using it now for about 2--3 months. It has totally changed not only the way that I program, but also the way that I store and organize all of the information that I need for the job that I do.
   
   --Ian Mulvany

.. epigraph::

   I only have one week of Leo experience but I already know it will be my default IDE/project manager...people complain about the lack of a project manager for the free/standard Python IDE's like Idle. Leo clearly solves that problem and in a way that commercial tools can't touch.
   
   --Marshall Parsons

.. epigraph::

   I have been using Leo for about 3 weeks and I hardly use my other programming editor anymore...I find it easy and enjoyable to use. I plan to adopt it as my presentation tool for code reviews.
   
   --Jim Vickroy

.. epigraph::

   I'm absolutely astounded by the power of such a simple idea! It works great and I can immediately see the benefits of using Leo in place of the standard flat file editor.
   
   --Tom Lee

.. epigraph::

   I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history.
   
   --Dan Winkler

</t>
<t tx="ekr.20050830074815.5">.. epigraph::

   Word outlines are very useful. But Leo makes Word look like a clunky toy.
   
   --Joe Orr

.. epigraph::

   Leo is an interactive editor for organizing text fragments hierarchically and sequentially into one or more files and hierarchical folders, without arbitrary limits on the number and size of text fragments and the depth of the hierarchy...

   --Alex Abacus

.. epigraph::

   Leo reminds me a great deal of things I loved when I used Userland's Frontier (an outlining cms with a native oodb) - but Frontier wasn't hackable enough for me, and it wasn't oriented towards coding..., and you couldn't round-trip rendered pages (big Leo win). This is really a super tool - in a matter of days I've started to use it on all my projects and I still haven't figured out how I lived without it.

   --John Sequeira

.. epigraph::

   Leo is EXACTLY the kind of outliner I was looking for--fantastic job!
   
   --Steve Allen
</t>
<t tx="ekr.20050830074815.6">.. epigraph::

   If you are like me, you have a kind of knowledge base with infos gathered over time. And you have projects, where you use some of those infos. Now, with conventional outliners you begin to double these infos, because you want to have the infos needed for the project with your project. With Leo you can do this too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE TOO!
   This is a feature I did not see with any other outliner (and I tried a few).
   Amazing! Leo directly supports the way I work!

   --F. Geiger

.. epigraph::

   Another day, another breakthrough using Leo--now I realize Leo is the best URL bookmark manager there is. No more bookmarks menus or favorites lists inside the browser for me. With the @url directive I can just double click on the URL to open it in my browser. Leo lets me arrange the URLs in a hierarchy (or multiple hierarchies), attach notes to them, save clippings of things I read on the sites. It's sooo much better than anything the browsers have built in and it lets me easily use different browsers on different platforms and different machines (try that with the browsers' built-in bookmark managers).

   --Dan Winkler

.. epigraph::

   I am an amateur photographer. I use plain old 35mm. film for my pictures. Over the weekend, I used Leo to organize my lists of pictures. It is quite helpful--I can have separate nodes for pictures I have enlarged, as well as pictures I have submitted to our local camera club. Thanks!
   
   --Rich Reis

.. epigraph::

   Cloning is pure genius!... Leo's cloning facility, allows me to create several views on the CFA course material. My main view follows the prescribed study guide. Another view is organized like the textbooks. Yet another gives me a glossary of terms. And when I'm done, I'll have some nice libraries...I can re-use later in other projects.

   --Michael Manti

.. epigraph::

   Despite I am no programmer, I have been using Leo for some years now as my "Intelligent PIM" - I organize my (complex) life with Leo. Many thanks to Edward and others for the great application 
   
   -- vili &lt;viljem.tisnikar@gmail.com&gt;
</t>
<t tx="ekr.20050830074815.8">.. epigraph::

   I've written documentation in WordPerfert, Ventura, Word, PageMaker, and FrameMaker and even though they create wonderfully looking and useful documents, they've never been able to do what I've been looking for. HTML, compiled help files, and later PDF came closer, but still not there...I think I've found it in Leo, a way to make a "living" document. A document built out of discrete parts that can be re-organized on the fly to meet the needs of a varying audience...I've already started converting the IT Procedures manual from Open Office to Leo because I know it's going to be much more useful to me and anyone else...just the possibility of keeping system maintenance scripts in the IT manual is mind boggling.

   --David Nichols

.. epigraph::

   With the help of the rst2 plugin, [Leo is] the best outliner I have yet encountered for writing the early stages of academic papers.

.. epigraph::

   A Leo file is an ideal documentation tool, collecting the assorted readme.txt files, the comments from the source files...as well as the config files themselves.

   --Kent Tenney
</t>
<t tx="ekr.20050830074815.9">.. epigraph::

   Just as structured programming reveals and disciplines the flow control of a program, [Leo] allows the designer to reveal and discipline structure at many layers simultaneously: data structures, object structure, entity-relationship structure, client-server structure, design pattern structure, temporal structure, project management structure, and any other structure relevant to the system.

   --Steven P. Schaefer

.. epigraph::

   A funny observation with Leo is that when I 'Leo-ise' other people's code, Leo makes the code's structure so transparent that design faults become very quickly apparent. For example, maintenance pain caused by lack of factorization.

   --David McNab

.. epigraph::

   Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective.

   --Joe Orr

.. epigraph::

   I found this blog entry by someone (a talented former coworker of mine actually) complaining about some poorly written code she had to maintain: http://snippy.ceejbot.com/wiki/show/start/2003/01/29/001 She said: 'You'd need a bulldozer to start refactoring it.' That was my cue to write a long message explaining that there is indeed such a bulldozer and it's called Leo. (You can see my message there as a reply to her original posting.) I gave her my recipe for how to get someone else's messy, scary code into Leo and how to break it down into manageable chunks.

   --Dan Winkler

.. epigraph::

   Ed, you continue to push the envelope. The amazing thing is that the footprint isn't doubling every few months like it would be in another designer's hands.
   Adding features by removing constraints, hot refactoring while adding unit tests. Forget the book. I would pay to see the movie.
</t>
<t tx="ekr.20050830115714">####
FAQ
####

This is Leo's Frequently Asked Questions document.

.. index:: FAQ

.. contents::
    :depth: 4
</t>
<t tx="ekr.20050830115714.1"></t>
<t tx="ekr.20050830115714.10">The encoding used in the file being imported doesn't match the encoding in effect for Leo.
You have two options:

- Use the @encoding directive_ in an ancestor of the node_ selected when
  doing the Import command_ to specify the encoding of file to be imported.
</t>
<t tx="ekr.20050830115714.113">**Question**:
It would be nice if Leo could open empty files. I tend to be "document oriented"
rather than "application oriented" in my thinking and prefer "create empty file
at location -&gt; open it with program" to "start program -&gt; create new file -&gt;
save it at location".

**Answer** by Paul Paterson:
If you are on Windows 98/2000/XP then the procedure is as follows...

1. Start Leo
2. Click New
3. Click Save as...
4. Save the file as "c:\\windows\\shellnew\\leofile.leo" (or c:\\winnt for 2000/XP)
5. Open regedit "start...run...regedit"
6. Open HKEY_CLASSES_ROOT and find the ".leo" extension type
7. Go New ... Key from the context menu 
8. Call the new key ShellNew 
9. Select the new key, right-click, choose New...String Value from the context menu
10. Call it FileName 
11. Double-click on the string, and modify it to be the filename of the leofile.leo file you created,
    including the extension
12. Exit the registry editor and restart Windows Explorer (you may need to reboot on Windows 98)

Now you should have a New:Leo File option in Explorer. This creates a duplicate
of the file you saved. This can be useful because you could make a template Leo
file containing some standard nodes_ that you always have and then save this.
</t>
<t tx="ekr.20050830115714.115" str_atime="1376412852.0">For the most part, docutils_ does a good job of reporting errors. docutils_ prints
a message to the console and inserts an unmistakable error message in the
generated .html file.
**Important**: On Windows it is helpful to `run Leo in a console window`_.

However, in some cases, docutils_ crashes instead of properly reporting the
problem. There are several workarounds:

1.  The crashes I have seen arise from the following bug in docutils.
    **Hyperlinks in image:: markup must be lower case**.  This will work::

        .. .. |back| image:: arrow_lt.gif
            :target: faq_

    This will **crash**::

        .. .. |back| image:: arrow_lt.gif
            :target: FAQ_

    So avoid this crash by making sure to use lower case targets in ':target:' markup.

2.  You can change the docutils_ source slightly so that it prints a traceback when it
    crashes. (The rst3 plugin should be able to do this, but I haven't figured
    out how yet.) It's easy enough to do this:

    - Find the file core.py in top-level docutils folder.
      Typically this folder will be in Python's site-packages folder.

    - Open core.py in some editor other than Leo.

    - Find the method called report_Exceptions.

    - Insert the following lines at the very start of this method::

        print 'EKR: added traceback'
        import traceback ; traceback.print_exc()

    This will cause a traceback whenever docutils_ crashes. I have found that
    such tracebacks are generally enough to locate the general area of the
    problem. **Note**: These tracebacks go to the console window, so you should
    `run Leo in a console window`_.

3.  As a last resort, you can isolate syntax errors by reducing your input files
    until they work again, then adding sections until you get a crash. This is
    easy enough to do (when using the rst3 plugin) by change a headline 'x' to
    @rst-ignore-tree x.
</t>
<t tx="ekr.20050830115714.116">From: http://sourceforge.net/forum/message.php?msg_id=3240374
Using Leo's File-Export-Flatten Outline commands creates a MORE style outline which places
all Leo body sections on the left margin.
The headlines_ are indented with tabs which Excel will read as a tab delimited format.
Once inside Excel there are benefits.

1.  The most obvious benefit inside Excel is that the body sections (Excel first
    column) can be selected easily and highlighted with a different font color.
    This makes the MORE format very readable. Save a copy of your sheet as HTML
    and now you have a web page with the body sections highlighted.

2.  It is possible to hide columns in Excel.
    Hiding the first column leaves just the headlines showing.

3.  Formulas based on searching for a string can do calculations in Excel.
    For example if a heading "Current Assets" appears on level 4 then the body formula::

        =INDEX(A:A,MATCH("Current Assets",D:D,0)+1)

    will retrieve it. The +1 after match looks down one row below the matched
    headline. The trick is to place all your headlines in quotes because Excel
    will see + "Current Assets" from the MORE outline. When Excel tries
    without the quotes it thinks it is a range name and displays a #N/A
    error instead of the headline. Also you must place a child node_ below to
    get the + sign instead of a - sign which would give a MORE headline of
    -"Current assets" , also is an error.

I think there is some interesting possibility here because of the enforcement of
Leo body text being always in the first column. The Leo outline provides
additional reference to organizing the problem not typical of spreadsheet
models. Beyond scripting in Python, Excel is good at doing interrelated
calculations and detecting problems like circular references. In Excel
Tools-Options-General is a setting for r1c1 format which then shows numbers
instead of letters for column references. Using this would allow entries like
this in the leo body::

    1000
    3500
    =R[-1]C+R[-2]C

In Excel you would see 4500 below those two numbers. This is completely
independent of where the block of three cells exists on the sheet.
</t>
<t tx="ekr.20050830115714.117">Python's decorator_ syntax is ill-conceived.
This syntax file hack works well enough anyway to work with Leo '@' markup::

    syn region leoComment start="^@\\s*" end="^@c\\s*$"
    syn match   pythonDecorator	"@\\S\\S+" display nextgroup=pythonFunction skipwhite
</t>
<t tx="ekr.20050830115714.118"></t>
<t tx="ekr.20050830115714.119">By Rich Ries.
I often rework C code that's already been "Leo-ized"--the first pass was quick
and dirty to get it going. When I do subsequent passes, I wind up with subnodes
that are out of order with the sequence found in the main node_. It's not a big
deal, but I like 'em ordered. With just one editor pane, clicking on the node_ to
move would switch focus to that node_. I'd then need to re-focus on the main
node_. A minor nuisance, but it does slow you down.

My solution is to open a second editor with its focus on the main node_. Switch
to the other editor, and, referring to the first editor pane, move the nodes as
you like. The second editor's pane will change focus to the node_ you're moving,
but the first editor will stay focused on the main node_. It's a lot easier to
do than to describe!
</t>
<t tx="ekr.20050830115714.12">Using @file trees can eliminate most problems with using Leo in cooperative
(SCCS) environments:

- Developers should use @file trees to create external files in any kind of
  cooperative environment.

- If sentinels are frowned upon in your development community, use @auto or
  @shadow instead of @file.

- The repository contains **reference** .leo files. These reference files should
  contain nothing but @file nodes. Reference files should change only when
  new external files get added to the project. Leo's `git repository`_ and Leo
  distributions contain the following reference files: LeoPyRef.leo,
  LeoPluginsRef.leo and leoGuiPluginsRef.leo. Developers should use
  local copies of reference files for their own work. For example, instead of
  using LeoPyRef.leo directly, I use a copy called LeoPy.leo.
</t>
<t tx="ekr.20050830115714.120">One way is to link directly to the media file from a Leo node_ (with @url) and
write a script button to wrap all URL-nodes under the current node_ in a single
HTML page. Then, you can view your media in two ways:

-   Individually. You can directly click on the @url link to display the media
    in the browser (assuming you have your MIME/filetype associations set up
    correctly for your browser).

-   In a group. You can click on a script button (you have to code this yourself,
    very simple) which should collect all @url nodes_ under the current node_
    and dynamically generate a HTML page displaying either links to or embedded
    versions of the media (using the HTML trick described above to invoke the
    browser). This way, you can create collections of @url nodes under a
    single node_ (like a bookmark folder), and press a single button to view the
    @url collection as a single entity in the browser (with all browser
    capabilities like displaying the media).

You could probably generalize this idea of "collect all @url nodes under current
node_ and display as HTML in browser" into a general-purpose plugin. However,
the plugin would have to be somewhat smart in mapping a link to its corresponding
HTML code (e.g. an image link gets mapped to an &lt;img&gt; HTML tag, a link to a
Flash file gets mapped to an &lt;embed&gt; tag, etc).
</t>
<t tx="ekr.20050830115714.13"></t>
<t tx="ekr.20050830115714.14">You have two options, depending on whether you want to be able to use sections
or not.

-   Use @nosent trees.
    Files derived from @nosent trees contain no sentinels_.
    However, Leo create the external file just as in @file trees.
    In particular, Leo expands section references and understands the @others directive.

-   Use @asis trees.
    Files derived from @asis trees contain no sentinels_.
    Moreover, Leo does not expand section references in asis trees.
    In other words, Leo creates the `external file` simply by writing all body text in outline order.
    Leo can't update the outline unless the external file contains sentinels,
    so Leo does not update @nosent trees or @asis trees automatically when
    you change the external file in an external editor.
</t>
<t tx="ekr.20050830115714.16">Use @asis trees. Files derived from @asis trees contain no sentinels. Leo
creates the external file simply by writing all body text in outline order. Leo
can't update the outline unless the external file contains sentinels, so Leo
does not update @asis trees automatically when you change the external file in
an external editor.
</t>
<t tx="ekr.20050830115714.17">The import commands insert @ignore directives_ in the top-level node_.
Leo does this so that you won't accidentally overwrite your files after importing them.
Change the filename following @file (or @file) as desired,
then remove the @ignore directive_.
Saving the outline will then create the external file.
</t>
<t tx="ekr.20050830115714.18">**Question**: I'm writing a Windows Script Component, which is an XML file with
a CData section containing javascript. I can get the XML as I want it by using
\@language html, but how can I get the tangling comments inside the CData
section to be java-style comments rather than html ones?

**Answer**: In @file trees you use the @delims directive to change comment delimiters.
For example::

    @delims /* */ 
    Javascript stuff 
    @delims &lt;-- --&gt; 
    HTML stuff

**Important**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another @delims directive_.
</t>
<t tx="ekr.20050830115714.19">By Zvi Boshernitzan: I was having trouble disabling '&lt;?php' with comments (and
couldn't override the comment character for the start of the page). Finally, I
found a solution that worked, using php's heredoc string syntax::

    @first &lt;?php
    @first $comment = &lt;&lt;&lt;EOD
    EOD;

    // php code goes here.
    echo "boogie";

    $comment2 = &lt;&lt;&lt;EOD
    @last EOD;
    @last ?&gt;

or::

    @first &lt;?php
    @first /*
    */

    echo "hi";

    @delims /* */
    @last ?&gt;
</t>
<t tx="ekr.20050830115714.2">First, read the tutorial_. This will be enough to get you started if you just
want to use Leo as an outliner_. If you intend to use Leo for programming, read
the `tutorial about programming`_, then look at Leo's source code in the file LeoPy.leo.
Spend 5 or 10 minutes browsing through the outline. Don't worry about details;
just look for the following common usage patterns:

-   The (Projects) tree shows how to use clones to represent tasks.

-   Study @file leoNodes.py.
    It shows how to define more than one class in single file.

-   Most other files show how to use a single @others directive to define one class.

-   Most methods are defined using @others, *not* section definition nodes.
</t>
<t tx="ekr.20050830115714.20">Here is a posting which might be helpful:
http://sourceforge.net/forum/message.php?msg_id=2300457 The @first
directive_ is the key to output usable code in unsupported languages. For
example, to use Leo with the Basic language, use the following::

    @first $IFDEF LEOHEADER
    @delims '
    @c
    $ENDIF

So this would enable a basic compiler to "jump" over the "true" Leo-header-lines.
Like this::

    $IFDEF LEOHEADER &lt;-conditional compilation directive 
    #@+leo-ver=4 &lt;-these lines not compiled
    #@+node:@file QParser005.INC
    #@@first
    #@delims ' 
    '@@c
    $ENDIF &lt;-... Until here!
    &lt;rest of derived code file ... &gt;

This changes the comment symbol the apostrophe,
making comments parseable by a BASIC (or other language.)
</t>
<t tx="ekr.20050830115714.21">Use the @first directive_ in @file trees or @nosent trees.

The @first directive puts lines at the very start of files derived from @file.
For example, the body text of @file spam.py might be::

    @first #! /usr/bin/env python

The body text of @file foo.pl might be::

    @first #/usr/bin/perl

Leo recognizes the @first directive_ only at the start of the body text of @file nodes.
No text may precede @first directives_.
More than one @first directive may exist, like this::

    @first #! /usr/bin/env python
    @first # more comments.
</t>
<t tx="ekr.20050830115714.24">No. Everything in an @file trees must be part of the external file: orphan and
\@ignore nodes are invalid in @file trees. This restriction should not be
troublesome. For example, you can organize your outline like this::

    + myClass
    ..+ ignored stuff
    ..+ @file myClass

(As usual, + denotes a headline.) So you simply create a new node_, called
myClass, that holds your @file trees and stuff you don't want in the @file
trees.
</t>
<t tx="ekr.20050830115714.25">By Rich Ries.
Some older C compilers don't understand the "//" comment symbol, so using @language C won't work.
Moreover, the following does not always work either::

    @comment /* */

This generates the following sentinel line::

    /*@@comment /* */*/

in the output file, and not all C compilers allow nested comments, so the last \*\/ generates an error.
The solution is to use::

    #if 0
    @comment /* */
    #endif

Leo is happy: it recognizes the @comment directive_.
The C compiler is happy: the C preprocessor strips out the offending line before the C
compiler gets it.
</t>
<t tx="ekr.20050830115714.26" str_atime="1376412984.0"></t>
<t tx="ekr.20050830115714.29">See the instructions are in LeoPy.leo in::

    Notes:How To:How to add support for a new language section.

This section contains clones of all relevant parts of Leo that you will change.
Coming in Leo 4.4: Leo will use JEdit's language description files to drive the
syntax colorer. To add support for a new language, just add another such
description file.
</t>
<t tx="ekr.20050830115714.30" str_atime="1376412828.0">You have two options: 

-   Get cvs write access, and add the @file file to the plugins directory.

-   Just send the @file file to me at edreamleo@gmail.com.
    That's all you need to do.  In particular that there is no need to change leoPlugins.leo.
</t>
<t tx="ekr.20050830115714.4">You will lose much of Leo's power if you don't use clones.
See `Clones`_ and `Views`_ for full details.
</t>
<t tx="ekr.20050830115714.7">Use methods for any code that is used (called or referenced) more than once.

Sections_ are convenient in the following circumstances:

-   When you want to refer to snippets of code the can not be turned into methods.
    For example, many plugins start with the code like this::

    &lt;&lt; docstring &gt;&gt;
    &lt;&lt; imports &gt;&gt;
    &lt;&lt; version history &gt;&gt;
    &lt;&lt; globals &gt;&gt;

    None of these sections could be replaced by methods.

-   When you want to refer to a snippet of code that shares local variables with the enclosing code.
    This is surprisingly easy and safe to do, *provided* the section is used only in one place.
    `Section names`_ in such contexts can be clearer than method names.  For example::

    &lt;&lt; init ivars for writing &gt;&gt;

In short, I create sections when convenient,
and convert them to functions or methods if they need to be used in several places.
</t>
<t tx="ekr.20050830115714.74">The Import Files dialog allows you to select multiple files provided you are running Python 2.3 or above.
There is also an importFiles script in LeoPy.leo.  You can use that script as follows::

    import leo.core.leoImport as leoImport
    leoImport.importFiles(aDirectory, ".py")

This will import all .py files from aDirectory, which should be a full path to a particular directory.
You could use ".c" to import all .c files, etc.
</t>
<t tx="ekr.20050830115714.76" str_atime="1376412985.0"></t>
<t tx="ekr.20050830115714.77">Just `run Leo in a console window`_. At the point you want to drop into the
debugger, execute this line::

    g.pdb()

All output from pdb goes to stdout, which is the console window. It would be
good to create a subclass of pdb.Pdb that uses Leo's log pane rather than a
console window, but I haven't done that. It could be done easily enough in a
plugin...

**Important**: I recommend using g.trace instead of pdb.  For example::

    g.trace(x)

prints the name of the function or method containing the trace, and the value of
x. g.callers is often useful in combination with g.trace. g.callers(5)
returns the last 5 entries of the call stack. For example::

    g.trace(x,g.callers(5))

Used this way, g.trace shows you patterns that will be invisible using pdb.
</t>
<t tx="ekr.20050830115714.9">Internally, Leo represents all strings as unicode. Leo translates from a
particular encoding to Unicode_ when reading .leo files or external files. Leo
translates from Unicode_ to a particular encoding when writing external files.
You may see strange looking characters if your text editor is expecting a
different encoding. The encoding used in any external file is shown in the
#@+leo sentinel line like this::

    #@+leo-encoding=iso-8859-1.

**Exception**: the encoding is UTF-8 if no -encoding= field exists.
You can also use the @encoding directive_ to set the encoding for individual external files.
If no @encoding directive_ is in effect,
Leo uses the following settings_ to translate to and from unicode:

default_derived_file_encoding
    The encoding used for external files if no @encoding directive_ is in effect.
    This setting also controls the encoding of files that Leo writes.
    The default is UTF-8 (case not important).

new_leo_file_encoding
    The encoding specified in the following line of new .leo files::

        &lt;?xml version="1.0" encoding="UTF-8"&gt;

    The default is UTF-8 (upper case for compatibility for old versions of Leo).
</t>
<t tx="ekr.20050830120007">.. Links used in this document...

.. ----- External links.

.. _decorator:          http://www.python.org/peps/pep-0318.html
.. _docutils:           http://docutils.sourceforge.net/
.. _unicode:            http://www.unicode.org/
.. _`git repository`:   https://github.com/leo-editor/leo-editor

.. ----- Relative links into Leo's documentation.

.. _`Associating Leo with .leo Files`:  installing.html#creating-windows-file-associations
.. _`How to install Leo on Windows`:    installing.html#installing-leo-on-windows

.. _`Clones`:       tutorial-pim.html#clones
.. _`Views`:        tutorial-pim.html#views
.. _`CWEB mode`:    directives.html#cweb-mode
.. _command:        commands.html
.. _commands:       commands.html
.. _`tutorial about programming`:               tutorial-programming.html
.. _tutorial:                                   tutorial.html
.. _`Leo 4.0: Eliminating error 'recovery'`:    appendices.html#leo-4-0-eliminating-error-recovery
.. was: history.html#leo-4-0-eliminating-error-recovery
.. _`History of Leo`:                           appendices.html#history-of-leo
.. was: history.html
.. _`run Leo in a console window`:              running.html#running-leo-from-a-console-window
.. _`console window`:                           running.html#running-leo-from-a-console-window

.. ----- References to the glossary: the glossary now contains references to the tutorial.
.. _`@asis`:                glossary.html#asis-trees
.. _`@auto`:                glossary.html#auto-trees
.. _`@file`:                glossary.html#file-trees
.. _`@others directive`:    glossary.html#others
.. _`@nosent`:              glossary.html#nosent
.. _`@shadow`:              glossary.html#shadow-trees
.. _`@thin`:                glossary.html#thin-trees
.. _`@unit`:                glossary.html#unit
.. _`body text`:            glossary.html#body-text
.. _cweb:                   glossary.html#cweb
.. _directive:              glossary.html#directive
.. _directives:             glossary.html#directives
.. _`external file`:        glossary.html#external-file
.. _`external files`:       glossary.html#external-files
.. _headline:               glossary.html#headline
.. _headlines:              glossary.html#headlines
.. _node:                   glossary.html#node
.. _nodes:                  glossary.html#nodes
.. _outliner:               glossary.html#outliner
.. _sections:               glossary.html#sections
.. _`section name`:         glossary.html#section-name
.. _`section names`:        glossary.html#section-names
.. _sentinels:              glossary.html#sentinels
.. _`sentinel line`:        glossary.html#sentinel
.. _`sentinel lines`:       glossary.html#sentinel
.. _setting:                glossary.html#setting
.. _settings:               glossary.html#settings
</t>
<t tx="ekr.20050830120844" str_atime="1376412842.0">c.frame.menu.createMenuItemsFromTable will append items to the end of an existing menu.
For example, the following script will add a new item at the end of the 'File' menu::

    def callback(*args,**keys):
        g.trace()

    table = (("Test1",None,callback),)

    c.frame.menu.createMenuItemsFromTable('File',table)

Plugins can do anything with menus using c.frame.menu.getMenu. For example, here
is a script that adds a Test menu item after the 'Open With' menu item in the
File menu::

    def callback(*args,**keys):
        g.trace()

    fileMenu = c.frame.menu.getMenu('File')

    # 3 is the position in the menu.  Other kinds of indices are possible.
    fileMenu.insert(3,'command',label='Test2',command=callback)
</t>
<t tx="ekr.20050830120857">The trick is to create a workflow that separates editing from testing. Putting
test code in LeoPy.leo would waste a lot of time. To run tests you would
have to exit Leo and reload LeoPy.leo. A much quicker way is to put all test
code in a test.leo file. So to change and test code, do the following:

1. Save LeoPy.leo but do **not** exit Leo. 

2. Quit the copy of Leo running test.leo, then reload test.leo.

3. Run test scripts from test.leo.

That's all. Python will recompile any changed .py files in the new copy of Leo.
**Note**: I create a batch file called t.bat that runs test.leo, so to the
"edit-reload-test" cycle is just:

1. Control-S (in LeoPy.leo: saves the .leo file)
2. t         (in a console window: runs test.leo, compiling all changed .py files as a side effect)
3. Control-E (in test.leo: runs the test script)

The benefits of the new workflow:

- test.leo loads  _much_ more quickly than LeoPy.leo does.
  This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10.
  Hitting Control-S, t, Control-E takes about 5 seconds.

- LeoPy.leo runs with the *old* code,
  so it is much easier to fix syntax errors or exceptions in the *new* code:
  just fix the problem and save LeoPy.leo *without* closing LeoPy.leo,
  then restart test.leo.
  You run your tests on the new code, but you edit the new code with the old, stable code.

- test.leo is the perfect place to develop test.
  I can create and organize those tests and when I am done, ''test.leo'' is a log of my work.
</t>
<t tx="ekr.20050831184021.1"></t>
<t tx="ekr.20050831184021.4">.. |---| unicode:: U+02015 .. for quotes
   :trim:
   
################################
What People are Saying about Leo
################################

.. |br| raw:: html

   &lt;br /&gt;

.. contents::
    :depth: 3
</t>
<t tx="ekr.20050831184021.5"></t>
<t tx="ekr.20050831195331.1"></t>
<t tx="ekr.20050831232205">.. Relative links.
.. _`Writing plugins`:   writingPlugins.html

.. References to the glossary.
.. _`sentinel lines`:   glossary.html#sentinel-lines
</t>
<t tx="ekr.20050901084134">I wrote this soon after discovering Python in 2001. The conclusions are
still valid today.
    
I've known for a while that Python was interesting; I attended a Python
conference last year and added Python support to Leo. But last week I got that
Python is something truly remarkable. I wanted to convert Leo from wxWindows to
wxPython, so I began work on c2py, a Python script that would help convert from
C++ syntax to Python. While doing so, I had an Aha experience. Python is more
than an incremental improvement over Smalltalk or C++ or objective-C; it is
"something completely different". The rest of this post tries to explain this
difference.


</t>
<t tx="ekr.20050901092232.2">What struck me first as I converted C++ code to Python is how much less blah,
blah, blah there is in Python. No braces, no stupid semicolons and most
importantly, *no declarations*. No more pointless distinctions between
const, char \*, char const \*, char \* and wxString.
No more wondering whether a variable should be signed, unsigned, short or long.

Declarations add clutter, declarations are never obviously right and
declarations don't prevent memory allocation tragedies. Declarations also hinder
prototyping. In C++, if I change the type of something I must change all related
declarations; this can be a huge and dangerous task. With Python, I can change
the type of an object without changing the code at all! It's no accident that
Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code
clarity. No more passing pointers to data, no more defining (and allocating and
deallocating) temporary structs to hold multiple values.

.. _`pylint`: http://www.logilab.org/857

Python can't check declarations because there aren't any. However, there is a
really nifty tool called `pylint`_ that does many of the checks typically done
by compilers.
</t>
<t tx="ekr.20050901092232.3">Python is much more powerful than C++, not because Python has more features, but
because Python needs *less* features. Some examples:

-   Python does everything that the C++ Standard Template Library (STL) does,
    without any of the blah, blah, blah needed by STL.
    No fuss, no muss, no code bloat.

-   Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).
    Python's string library does more with far less functions because slices replace many functions
    typically found in other string libraries.

-   Writing dict = {} creates a dictionary (hash table).
    Hash tables can contain anything, including lists and other hash tables.

-   Python's special functions,  __init__, __del__, __repr__, __cmp__, etc.
    are an elegant way to handle any special need that might arise.
</t>
<t tx="ekr.20050901092232.4">Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.
Try doing::

        aList[i:j] = list(aString)

in C.  You will write about 20 lines of C code.
Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe. C++ is fundamentally unsafe. When I am using
Python I am free from worry and anxiety. When I am using C++ I must be
constantly "on guard." A momentary lapse can create a hard-to-find pointer bug.
With Python, almost nothing serious can ever go wrong, so I can work late at
night, or after a beer. The Python debugger is always available. If an exception
occurs, the debugger/interpreter tells me just what went wrong. I don't have to
plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can
keep right on going even after a crash!
</t>
<t tx="ekr.20050901092232.5">Python has almost all the speed of C. Other interpretive environments such as
icon and Smalltalk have clarity, power and safety similar to Python. What makes
Python unique is its seamless way of making C code look like Python code.
Python executes at essentially the speed of C code because most Python modules
are written in C. The overhead in calling such modules is negligible. Moreover,
if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to higher levels of
expression. For example, Leo's Open command reads an XML file. If this command
is too slow I can use Python's XML parser module. This will speed up Leo while
at the same time raising the level of the code.
</t>
<t tx="ekr.20050901092232.6">Little of Python is completely new. What stands out is the superb engineering
judgment evident in Python's design. Python is extremely powerful, yet small,
simple and elegant. Python allows me to express my intentions clearly and at the
highest possible level.

The only hope of making Leo all it can be is to use the best possible tools. I
believe Python will allow me to add, at long last, the new features that Leo
should have.

Edward K. Ream, October 25, 2001.  P.S., September, 2005:

Four years of experience have only added to my admiration for Python. Leo could
not possibly be what it is today without Python.
</t>
<t tx="ekr.20050901101608">##############
Using Outlines
##############

This chapter tells how to use Leo's outlines. Most of the commands can be
invoked by clicking with the pointer in the outline pane or by using the pointer
to select the command from the ``Outline`` menu. The key bindings mentioned here
are those of the default EKR bindings.

.. contents::
    :depth: 2

</t>
<t tx="ekr.20050901101608.1">.. _`A Tutorial Introduction to Leo`:   intro.html
.. _`Writing Programs in Leo`:          directives.html
.. _`Clones and views`:                 intro.html#clones-views
</t>
<t tx="ekr.20050901101608.2">########################
Leo's Commands Reference
########################

This chapter discusses the basics of using Leo, including all of Leo's
commands. It starts with a discussion of the Emacs-like minibuffer,
then continues with a discussion of commands in each of Leo's menus.

.. contents::
    :depth: 3

</t>
<t tx="ekr.20050901101608.4">################
Customizing Leo
################

This chapter discusses how to customize Leo using the plugins and other means.
See `Specifying settings`_ for a description of how to change Leo's settings.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20050901101852">.. External links...
.. _CWEB:       http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _noweb:      http://www.eecs.harvard.edu/~nr/noweb/

.. Relative links...
.. _`Writing Programs in Leo`:          directives.html
.. _`Customizing Leo`:                  customizing.html
.. _`Clones`:                           tutorial-pim.html#clones
.. _`A Tutorial Introduction to Leo`:   tutorial.html
</t>
<t tx="ekr.20050901102055">.. _`Scripting Leo with Python`:    tutorial-scripting.html
.. _`History of Leo`:               appendices.html#history-of-leo
.. was: history.html
.. _`rst3 plugin`:                  glossary.html#rst3-plugin
.. _`Specifying settings`:          commands.html#specifying-settings
</t>
<t tx="ekr.20050901102147">.. Relative links...
.. _`Scripting Leo with Python`:        tutorial-scripting.html
.. _`Customizing Leo`:                  customizing.html
.. _`Theory of Operation`:              theory.html
.. _`Controlling Syntax Coloring`:      coloring.html
.. _`Debugging with Leo`:               debuggers.html
.. _`Using ZODB with Leo`:              zodb.html
.. _`Leo and Emacs`:                    emacs.html
.. _`Embedding Leo with the leoBridge Module`: leoBridge.html
.. _`Unit testing with Leo`:            unitTesting.html
.. _`ILeo - the IPython bridge`:        IPythonBridge.html
.. _`the IPython bridge`:               IPythonBridge.html
.. _`Using @shadow`:                    atShadow.html
.. _`What's New`:                       what-is-new.html

.. Absolute links..
.. _OPML:   http://en.wikipedia.org/wiki/OPML
</t>
<t tx="ekr.20050902100834">This following information may be of interest to historians. It is not of
general enough interest to put in Leo's Users Guide on the web. I am including
this mass of detail here to indicate the complexities that were involved in
designing Leo's simple-looking mechanisms.
</t>
<t tx="ekr.20050902105852">Leo grew out of my efforts to use Donald Knuth's "CWEB system of Structured
documentation." I had known of literate programming since the mid 1980's, but I
never understood how to make it work for me. In November 1995 I started thinking
about programming in earnest. Over the holidays I mused about making programs
more understandable. In January 1996 the fog of confusion suddenly cleared. I
summarized my thinking with the phrase, **web are outlines in disguise**. I
suspected that outline views were the key to programming, but many details
remained obscure.
</t>
<t tx="ekr.20050902105852.1">March 5, 1996, is the most important date in Leo's history. While returning from
a day of skiing, I discussed my thoughts with Rebecca. During that conversation
I realized that I could use the MORE outliner as a prototype for a "programming
outliner." I immediately started work on my first outlined program. It quickly
became apparent that outlines work: all my old problems with programming
vanished. The @others directive dates from this day. I realized that MORE's
outlines could form the basis for Leo's screen design. Rather than opening body
text within the outline, as MORE does, I decided to use a separate body pane.

I hacked a translator called M2C which allowed me to use MORE to write
real code. I would write code in MORE, copy the text to the clipboard in
MORE format, then run M2C, which would convert the outline into C code.
This process was useful, if clumsy. I called the language used in the outline
SWEB, for simplified CWEB. Much later Leo started supporting the noweb
language.
</t>
<t tx="ekr.20050902105852.10">Leo first used gnx's (global node indices) as a foolproof way of associating
nodes in .leo files with nodes in external files. At the time, there was
still intense discussions about protecting the logical consistency of
outlines. \@thin was later to solve all those problems, but nobody knew
that then.
</t>
<t tx="ekr.20050902105852.11">Leo 4.2 Final went out the door September 20, 2004.
This surely is one of the most significant dates in Leo's history:

-   This marked the end worries about consistency of outlines and external files:
    Leo recreates all essential information from thin external files,
    so *there is nothing left in the .leo file to get out of synch*.

- Thin external files use gnx's extensively. This simplifies the file format and
    makes thin external files more cvs friendly.

-   A sensational scripting plugin showed how to create script buttons.
    This has lead to improvements in the Execute Script command and
    other significant improvements in Unit testing.

-   As if this were not enough, 4.2 marked the 'great divide' in Leo's internal
    data structures. Before 4.2, Leo every node in the outline had its own
    vnode. This was a big performance problem: clone operations had to
    traverse the entire outline! 4.2 represents clones by sharing subtrees.
    Changing Leo's fundamental data structures while retaining compatibility
    with old scripts was engineering work of which the entire Leo community can
    be proud. `Scripting Leo with Python`_ tells how the position
    class makes this happen.
    This was a cooperative effort. Kent Tenney and Bernhard Mulder made
    absolutely crucial contributions. Kent pointed out that it is a tnode,
    not a vnode that must form the root of the shared data. Bernhard showed
    that iterators are the way to avoid creating huge numbers of positions.

Leo 4.2 marked so many significant changes. I often find it hard to remember
what life with Leo was like before it.
</t>
<t tx="ekr.20050902105852.12">Leo 4.3 corrected many problems with leoConfig.txt. Instead, Leo gets
settings from one or more leoSettings.leo files. This version also
introduced a way to changed settings using a settings dialog.  However,
the settings dialog proved not to be useful (worse, it inhibited design) and
the settings dialog was retired in Leo 4.4.
</t>
<t tx="ekr.20050902105852.2">Throughout 1996 I created a version of Leo on the Macintosh in plain C and the
native Mac Toolbox. This was a poor choice; I wasted a huge amount of time
programming with these primitive tools. However, this effort convinced me that
Leo was a great way to program.

Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving)
is supposedly a key feature of literate programming. Imagine my surprise when I
realized that such a "beautiful" program listing was almost unintelligible; all
the structure inherent in the outline was lost! I saw clearly that typesetting,
no matter how well done, is no substitute for explicit structure.

In 1998 I created a version of Leo using Apple's YellowBox environment. Alas,
Apple broke its promises to Apple developers. I had to start again.
</t>
<t tx="ekr.20050902105852.3">I rewrote Leo for Borland C++ starting in May 1999. Borland C++ was much better
than CodeWarrior C, but it was still C++. This version of Leo was the first
version to use xml as the format of .leo files. The last version of Borland Leo,
3.12 Final went out the door July 17, 2003.
</t>
<t tx="ekr.20050902105852.4">I attended the Python conference in early 2001. In May of 2000 I began work on
an wxWindows version of Leo. This did not work out, but something good did come
from this effort. I spent a lot of time adding Python scripting to the wxWindows
code and I became familiar with Python and its internals.

I really started to 'get' Python in September 2001. I wrote the white papers at
about this time. Python solved *all* my programming problems. I rewrote Leo in
Python in about two months! For the first time in my career I was no longer
anxious while programming; it simply isn't possible to create bad bugs in
Python. The Python version of Leo was the first officially OpenSoftware version of
Leo. The first functional version of Leo in Python was 0.05 alpha, December 17,
2001.
</t>
<t tx="ekr.20050902105852.5">I registered the Leo project on SourceForge on March 10, 2003. It is certainly
no accident that Leo started a new life shortly thereafter. Prior to SourceForge
my interest in Leo had been waning.
</t>
<t tx="ekr.20050902105852.6">In the summer of 2001 I began to consider using sentinel lines in external files.
Previously I had thought that outline structure must be 'protected' by remaining
inside .leo files. Accepting the possibility that sentinels might be corrupted
opened vast new design possibilities. In retrospect, problems with sentinel
almost never happen, but that wasn't obvious at the time! The result of this
design was known at first as Leo2. That terminology is extinct. I think of
this version as the first version to support @file and automatic tangling
and untangling.
</t>
<t tx="ekr.20050902105852.7">The biggest surprise in Leo's history was the realization it is **much** easier
to untangle files derived from @file. Indeed, the old tangle code created all
sorts of problems that just disappear when using @file. The new Python version
of Leo became fully operational in early 2002. It was probably about this time
that I chose noweb as Leo's preferred markup language. My decision not to
support noweb's escape sequences made Leo's read code much more robust.
</t>
<t tx="ekr.20050902105852.8">I spent 2002 taking advantages of Python's tremendous power and safety.
Many improvements were at last easy enough to do:

- Nested @others directives appeared in 3.2.
- Unicode support started in 3.3.
- @first and @last appeared in 3.7
- @asis and @nosent appeared in 3.8.
- Incremental syntax coloring and incremental undo appeared in 3.9.
- Paul Paterson created Leo's plugin architecture sometime during this period.
  Plugins have been a driving force in Leo's development because people can
  change how Leo works without altering Leo's core.
- 3.12 fixed a huge memory leak.
- 3.12 Final, the last 3.x version, appeared July 17, 2003.
</t>
<t tx="ekr.20050902105852.9">In late 2002 and throughout 2003 I worked on an entirely new file format.
4.0 final went out the door October 17, 2003 after almost a year intense
design work trying to improve error recovery scheme used while reading
external files. In the summer of 2003 I realized that orphan and @ignore'd
nodes must be prohibited in @file trees. With this restriction, Leo
could finally recreate @file trees in outlines using **only** the
information in external files. This made the read code much more robust, and
eliminated all the previous unworkable error recovery schemes. At last Leo
was on a completely firm foundation.
</t>
<t tx="ekr.20050903074833">Plugins and other scripts can register event handlers (also known as hooks)::

    leoPlugins.registerHandler("after-create-leo-frame",onCreate)
    leoPlugins.registerHandler("idle", on_idle) 
    leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu) 

As shown above, a plugin may register one or more event handlers with a single call to
leoPlugins.registerHandler. Once a hook is registered, Leo will call the
registered function' at the named **hook time**. For example::

    leoPlugins.registerHandler("idle", on_idle)

causes Leo to call on_idle at "idle" time.

Event handlers must have the following signature::

    def myHook (tag, keywords):
        whatever

-   tag is the name of the hook (a string).
-   keywords is a Python dictionary containing additional information.
    The following section describes the contents of the keywords dictionary in detail.

**Important**: hooks should get the proper commander this way::

    c = keywords.get('c')
</t>
<t tx="ekr.20050903074833.1">The following table tells about each event handler: its name, when it is called,
and the additional arguments passed to the hook in the keywords dictionary.
For some kind of hooks, Leo will skip its own normal processing if the hook
returns anything *other* than None. The table indicates such hooks with 'yes' in
the 'Stop?' column.

**Important**: Ever since Leo 4.2, the v, old_v and new_v keys in
the keyword dictionary contain *positions*, not vnodes. These keys are
deprecated. The new_c key is also deprecated. Plugins should use the c key instead.

============================= ======== =================================== =============================
Event name (tag argument)     Stop?    When called                         Keys in keywords dict
============================= ======== =================================== =============================
'after-auto'                           after each @auto file loaded        c,p (note 13)
'after-create-leo-frame'               after creating any frame            c
'after-redraw-outline'                 end of tree.redraw                  c (note 6)
'before-create-leo-frame'              before frame.finishCreate           c
'bodyclick1'                   yes     before normal click in body         c,p,v,event
'bodyclick2'                           after normal click in body          c,p,v,event
'bodydclick1'                  yes     before double click in body         c,p,v,event
'bodydclick2'                          after  double click in body         c,p,v,event
'bodykey1'                     yes     before body keystrokes              c,p,v,ch,oldSel,undoType
'bodykey2'                             after  body keystrokes              c,p,v,ch,oldSel,undoType
'bodyrclick1'                  yes     before right click in body          c,p,v,event
'bodyrclick2'                          after  right click in body          c,p,v,event
'boxclick1'                    yes     before click in +- box              c,p,v,event
'boxclick2'                            after  click in +- box              c,p,v,event
'clear-all-marks'                      after clear-all-marks command       c,p,v
'clear-mark'                           when mark is set                    c,p,v
'close-frame'                          in app.closeLeoWindow               c
'color-optional-markup'        yes *   (note 7)                            colorer,p,v,s,i,j,colortag (note 7)
'command1'                     yes     before each command                 c,p,v,label (note 2)
'command2'                             after  each command                 c,p,v,label (note 2)
'create-optional-menus'                (note 8)                            c (note 8)
'create-popup-menu-items'              in tree.OnPopup                     c,p,v,event (new)
'draw-outline-box'             yes     when drawing +- box                 tree,p,v,x,y
'draw-outline-icon'            yes     when drawing icon                   tree,p,v,x,y
'draw-outline-node'            yes     when drawing node                   tree,p,v,x,y
'draw-outline-text-box'        yes     when drawing headline               tree,p,v,x,y
'drag1'                        yes     before start of drag                c,p,v,event
'drag2'                                after  start of drag                c,p,v,event
'dragging1'                    yes     before continuing to drag           c,p,v,event
'dragging2'                            after  continuing to drag           c,p,v,event
'enable-popup-menu-items'              in tree.OnPopup                     c,p,v,event
'end1'                                 start of app.quit()                 None
'enddrag1'                     yes     before end of drag                  c,p,v,event
'enddrag2'                             after  end of drag                  c,p,v,event
'headclick1'                   yes     before normal click in headline     c,p,v,event
'headclick2'                           after  normal click in headline     c,p,v,event
'headrclick1'                  yes     before right click in headline      c,p,v,event
'headrclick2'                          after  right click in headline      c,p,v,event
'headkey1'                     yes     before headline keystrokes          c,p,v,ch (note 12)
'headkey2'                             after  headline keystrokes          c,p,v,ch (note 12)
'hoist-changed'                        whenever the hoist stack changes    c
'hypercclick1'                 yes     before control click in hyperlink   c,p,v,event
'hypercclick2'                         after  control click in hyperlink   c,p,v,event
'hyperenter1'                  yes     before entering hyperlink           c,p,v,event
'hyperenter2'                          after  entering hyperlink           c,p,v,event
'hyperleave1'                  yes     before leaving  hyperlink           c,p,v,event
'hyperleave2'                          after  leaving  hyperlink           c,p,v,event
'iconclick1'                   yes     before single click in icon box     c,p,v,event
'iconclick2'                           after  single click in icon box     c,p,v,event
'iconrclick1'                  yes     before right click in icon box      c,p,v,event
'iconrclick2'                          after  right click in icon box      c,p,v,event
'icondclick1'                  yes     before double click in icon box     c,p,v,event
'icondclick2'                          after  double click in icon box     c,p,v,event
'idle'                                 periodically (at idle time)         c
'init-color-markup'                    (note 7)                            colorer,p,v (note 7)
'menu1'                        yes     before creating menus               c,p,v (note 3)
'menu2'                        yes     during creating menus               c,p,v (note 3)
'menu-update'                  yes     before updating menus               c,p,v
'new'                                  start of New command                c,old_c,new_c (note 9)
'open1'                        yes     before opening any file             c,old_c,new_c,fileName (note 4)
'open2'                                after  opening any file             c,old_c,new_c,fileName (note 4)
'openwith1'                    yes     before Open With command            c,p,v,d (note 14)
'openwith2'                            after  Open With command            c,p,v,(note 14)
'recentfiles1'                 yes     before Recent Files command         c,p,v,fileName,closeFlag
'recentfiles2'                         after  Recent Files command         c,p,v,fileName,closeFlag
'redraw-entire-outline'        yes     start of tree.redraw                c (note 6)
'save1'                        yes     before any Save command             c,p,v,fileName
'save2'                                after  any Save command             c,p,v,fileName
'scan-directives'                      in scanDirectives                   c,p,v,s,old_dict,dict,pluginsList (note 10)
'select1'                      yes     before selecting a position         c,new_p,old_p,new_v,new_v
'select2'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'select3'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'set-mark'                             when a mark is set                  c,p,v
'show-popup-menu'                      in tree.OnPopup                     c,p,v,event
'start1'                               after app.finishCreate()            None
'start2'                               after opening first Leo window      c,p,v,fileName
'unselect1'                    yes     before unselecting a vnode          c,new_p,old_p,new_v,old_v
'unselect2'                            after  unselecting a vnode          c,new_p,old_p,old_v,old_v
'\@url1'                        yes     before double-click @url node       c,p,v,url (note 5)
'\@url2'                                after  double-click @url node       c,p,v(note 5)
============================= ======== =================================== =============================

**Notes**:

1.  'activate' and 'deactivate' hooks have been removed because they do not work as expected.

2.  'commands' hooks: The label entry in the keywords dict contains the
    'canonicalized' form of the command, that is, the lowercase name of the command
    with all non-alphabetic characters removed.
    Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
    rather than 'cantundo' and 'cantredo'.

3.  'menu1' hook: Setting g.app.realMenuNameDict in this hook is an easy way of
    translating menu names to other languages. **Note**: the 'new' names created this
    way affect only the actual spelling of the menu items, they do *not* affect how
    you specify shortcuts settings, nor do they affect the 'official'
    command names passed in g.app.commandName. For example::

        app().realMenuNameDict['Open...'] = 'Ouvre'.

4.  'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:

    - c:          The commander of the newly opened window.
    - old_c:      The commander of the previously open window.
    - new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.
    - fileName:   The name of the file being opened.

    You can use old_c.p and c.p to get the current position in the old and new windows.
    Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
    will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
    Recent Files menu and b) the file is not already open.

5.  '\@url1' and '\@url2' hooks are only executed if the 'icondclick1' hook returns None.

6.  These hooks are useful for testing.

7.  These hooks allow plugins to parse and handle markup within doc parts,
    comments and Python ''' strings. Note that these hooks are *not* called in
    Python ''' strings. See the color_markup plugin for a complete example of how to
    use these hooks.

8.  Leo calls the 'create-optional-menus' hook when creating menus. This hook need
    only create new menus in the correct order, without worrying about the placement
    of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
    examples of how to use this hook.

9.  The New command calls 'new'.
    The 'new_c' key is deprecated.  Use the 'c' key instead.

10. g.scanDirectives calls 'scan-directives' hook.
    g.scanDirectives returns a dictionary, say d.
    d.get('pluginsList') is an a list of tuples (d,v,s,k) where:

    - d is the spelling of the @directive, without the leading @.
    - v is the vnode containing the directive, _not_ the original vnode.
    - s[k:] is a string containing whatever follows the @directive.
      k has already been moved past any whitespace that follows the @directive.

    See the add_directives plugins directive for a complete example of how to use
    the 'scan-directives' hook.

11. g.app.closeLeoWindow calls the 'close-frame' hook just before
    removing the window from g.app.windowList. The hook code may remove the window
    from app.windowList to prevent g.app.closeLeoWindow from destroying the window.

12. Leo calls the 'headkey1' and 'headkey2' when the headline *might* have changed.

13. p is the new node (position) containing '@auto filename.ext'

14. New in Leo 4.10: the d argument to the open-with event handlers is a python
    dictionary whose keys are all the tags specified by the user in the body of the
    @openwith node.
</t>
<t tx="ekr.20050903161843">.. index::
    pair: Script Button; Tutorial
    pair: @button Node; Tutorial

@button nodes create **script buttons** in Leo's icon area.

Each @button node also creates a corresponding minibuffer command.

Pressing the script button (or executing the command from the minibuffer)
applies the script in the @button node to the presently selected outline
node.

Script buttons **bring scripts to outlines** a powerful pattern. Creating
an @button script should be your first thought whenever you want to
automate any task.

- The mod_scripting.py plugins must be enabled to create @button nodes.

- Script buttons execute the **present** body text of the @button node. |br|
  You can modify a script button's script at any time.

- You can bind keys to the commands created by script buttons::

    @button my-button @key=Alt-8

- Right-clicking a script button deletes it.
</t>
<t tx="ekr.20050906090012">Leo (and other programs) often send more detailed error messages to stderr,
the output stream that goes to the console window. In Linux and MacOS
environments, python programs normally execute with the console window visible.
On Windows, can run Leo with the console window visible by associating .leo
files with python.exe *not* pythonw.exe.
</t>
<t tx="ekr.20050906104918">Leo 4.3.2 beta 1                  September 10, 2005

To learn about Leo, see: http://leoeditor.com/tutorial.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo.
    - A 5-minute guide to programming with Leo.

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://leoeditor.com/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim plugin now uses Python's subprocess module if it is present.

- Improved the Pretty Printing command.

- The usual assortment of bug fixes.
</t>
<t tx="ekr.20050906104918.1">Here is a summary of the changes:

- General: All chapters created with rst3 plugin. This ensures a uniform look.
The source is in LeoDocs.leo. Removed all references to older versions of Leo,
except when discussing old file formats in the Appendices. Corrected all text so
it discusses present version.

- rst3 plugin itself: Correct bug that caused chapters to be formatted
differently when processing multiple @rst trees.

- rst3 button in LeoDocs.leo: The script first looks *up* the tree, looking for
an @rst node. If found, it processes just that tree. If not found, it processes
all @rst nodes *below* the originally selected node. The button is now much more
convenient to use.

- Preface: Shorter, no history. No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised. Added entries for running Leo in a
console window and debugging docutils. Improved entry for using cvs.

- Chapter 1: Installation: Now the first chapter. Revised.

- Chapter 2: Tutorial: Completely rewritten. Like Python's tutorial, this
chapter contains everything a beginner needs to understand and use Leo. The
`Quickstart for programmers` section is the heart of this chapter. All terms
used have links either to their definition in the tutorial or in the Glossary.
Newbies should be able to digest this chapter easily. This chapter should make
Leo comprehensible to many more people.

- Chapter 3: Using Outlines: Revised per general remarks above.

- Chapter 4: Writing Programs in Leo. Completely rewritten. The old chapter was
an embarrassment. The new chapter is a reference guide, properly organized as
such. The introduction warns newbies away.

- Chapter 5: Using Leo's Commands. 'Minor' revisions and corrections create a
substantially better result.

- Chapter 7: Scripting Leo with Python: Rewritten, simplified, updated and
corrected. The sources in LeoDocs.leo are directly executable. rST sources use
literal blocks instead of code-blocks so that the sources are simplified.
(Important when executing examples). Properly discusses positions, including
'supremely important' section on copying positions.

- Chapter 8: Customizing Leo. Heavily revised. Discusses leoSettings.leo, not
leoConfig.txt. Security warnings are more reasonable. Section on script buttons.
Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- Chapter 9: History of Leo. Rewritten. Much shorter and more useful. Discusses
the major milestones, concentrating on explaining the major differences between
versions. Gone are details of how discoveries came to be. They are in
LeoPostings.leo, which will be included in the distribution.

- Chapter 10: Theory of Operation. Largely rewritten. Discusses positions
properly. Omits discussion of how clones were implemented before 4.2.

- Chapter 11: White Papers. A new chapter. This is a slightly-edited version of
writing that had been buried in the appendices.

- Appendices. Heavily revised and reformatted. Rewrote sections on file formats.

- Glossary: A separate chapter. All terms have links to their definition. All
definitions are rST targets so other chapters may refer to them. Added several
new entries.
</t>
<t tx="ekr.20050906104931.1"></t>
<t tx="ekr.20050906104931.15">http://sourceforge.net/forum/message.php?msg_id=3218558
</t>
<t tx="ekr.20050906104931.38">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.
</t>
<t tx="ekr.20050906104931.42">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py
</t>
<t tx="ekr.20050906104931.43">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.
</t>
<t tx="ekr.20050906104931.48"></t>
<t tx="ekr.20050906104931.49">Calling print directly is dangerous: it will fail for unicode characters.
</t>
<t tx="ekr.20050906104931.56">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.
</t>
<t tx="ekr.20050907094633">Settings may be different for each commander.

The c.config class has the following getters.

- c.config.getBool(settingName,default=None)
- c.config.getColor(settingName)
- c.config.getDirectory(settingName)
- c.config.getFloat(settingName)
- c.config.getInt(settingName)
- c.config.getLanguage(settingName)
- c.config.getRatio(settingName)
- c.config.getShortcut(settingName)
- c.config.getString(settingName)

These methods return None if no setting exists.

The getBool 'default' argument to getBool specifies the value to be
returned if the setting does not exist.
</t>
<t tx="ekr.20050908164150"></t>
<t tx="ekr.20050908164150.1">See http://leoeditor.com/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.
</t>
<t tx="ekr.20050909082711">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635

    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750

    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318
</t>
<t tx="ekr.20050910143326">These plugins now use Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:

    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe

This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050912125144" str_atime="1376413890.0"></t>
<t tx="ekr.20050912125144.1" str_atime="1376413508.0">#######
Plugins
#######

.. _`Using @button nodes`:  tutorial-scripting#using-button-nodes
.. _`Writing Plugins`:  writingPlugins.html

This chapter discusses the plugins contained in leoPlugins.leo.
These plugins are part of Leo's official distribution.
The next chapter, `Writing Plugins`_, tells how to write plugins.

The scripting plugin (mod_scripting.py) deserves special mention. This
plugin lets you create **script buttons** in a matter of seconds. See
`Using @button nodes`_. Script buttons are extraordinarily useful.

.. contents::
    :depth: 5
</t>
<t tx="ekr.20050912125735">.. External links...
.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. .. _SilverCity:           http://silvercity.sourceforge.net

.. Relative links...
.. _`Specifying settings`:      customizing.html#specifying-settings
.. _`Customizing Leo`:          customizing.html
.. .. _`Writing Plugins`:          writingPlugins.html
</t>
<t tx="ekr.20050912125735.363">The dyna_menu plugin is a remarkable body of work by 'e'.
This plugin creates a dyna_menu menu from which you can execute commands.
You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html
</t>
<t tx="ekr.20050913131848">Leo 4.3.2 final                 September 16, 2005

To learn about Leo, see: http://leoeditor.com/tutorial.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo.
    - A 5-minute guide to programming with Leo.

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://leoeditor.com/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim plugin now uses Python's subprocess module if it is present.

- Improved the Pretty Printing command.

- The usual assortment of bug fixes.
</t>
<t tx="ekr.20050917092557">Leo 4.3.3 final                 September 17, 2005

Leo 4.3.3 fixes several bugs reported in Leo 4.3.2 final in the last several days.

To learn about Leo, see: http://leoeditor.com/tutorial.html

The highlights of 4.3.3 (and 4.3.2)
-----------------------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo.
    - A 5-minute guide to programming with Leo.

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://leoeditor.com/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim plugin now uses Python's subprocess module if it is present.

- Improved the Pretty Printing command.

- The usual assortment of bug fixes.
</t>
<t tx="ekr.20050917092557.1">Here is a summary of the changes:

- General: All chapters created with rst3 plugin. This ensures a uniform look.
The source is in LeoDocs.leo. Removed all references to older versions of Leo,
except when discussing old file formats in the Appendices. Corrected all text so
it discusses present version.

- rst3 plugin itself: Correct bug that caused chapters to be formatted
differently when processing multiple @rst trees.

- rst3 button in LeoDocs.leo: The script first looks *up* the tree, looking for
an @rst node. If found, it processes just that tree. If not found, it processes
all @rst nodes *below* the originally selected node. The button is now much more
convenient to use.

- Preface: Shorter, no history. No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised. Added entries for running Leo in a
console window and debugging docutils. Improved entry for using cvs.

- Installation: Now the first chapter. Revised.

- Tutorial: Completely rewritten. Like Python's tutorial, this
chapter contains everything a beginner needs to understand and use Leo. The
`Quickstart for programmers` section is the heart of this chapter. All terms
used have links either to their definition in the tutorial or in the Glossary.
Newbies should be able to digest this chapter easily. This chapter should make
Leo comprehensible to many more people.

- Using Outlines: Revised per general remarks above.

- Writing Programs in Leo. Completely rewritten. The old chapter was
an embarrassment. The new chapter is a reference guide, properly organized as
such. The introduction warns newbies away.

- Using Leo's Commands. 'Minor' revisions and corrections create a
substantially better result.

- Scripting Leo with Python: Rewritten, simplified, updated and
corrected. The sources in LeoDocs.leo are directly executable. rST sources use
literal blocks instead of code-blocks so that the sources are simplified.
(Important when executing examples). Properly discusses positions, including
'supremely important' section on copying positions.

- Customizing Leo. Heavily revised. Discusses leoSettings.leo, not
leoConfig.txt. Security warnings are more reasonable. Section on script buttons.
Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- History of Leo. Rewritten. Much shorter and more useful. Discusses
the major milestones, concentrating on explaining the major differences between
versions. Gone are details of how discoveries came to be. They are in
LeoPostings.leo, which will be included in the distribution.

- Theory of Operation. Largely rewritten. Discusses positions
properly. Omits discussion of how clones were implemented before 4.2.

- White Papers. A new chapter. This is a slightly-edited version of
writing that had been buried in the appendices.

- Appendices. Heavily revised and reformatted. Rewrote sections on file formats.

- Glossary: A separate chapter. All terms have links to their definition. All
definitions are rST targets so other chapters may refer to them. Added several
new entries.
</t>
<t tx="ekr.20050917092557.11">The vim plugin now uses Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:

    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe

This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050917092557.12"></t>
<t tx="ekr.20050917092557.13">Calling print directly is dangerous: it will fail for unicode characters.
</t>
<t tx="ekr.20050917092557.14">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.
</t>
<t tx="ekr.20050917092557.2"></t>
<t tx="ekr.20050917092557.3">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635

    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750

    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318
</t>
<t tx="ekr.20050917092557.4">http://sourceforge.net/forum/message.php?msg_id=3218558
</t>
<t tx="ekr.20050917092557.5">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.
</t>
<t tx="ekr.20050917092557.6">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py
</t>
<t tx="ekr.20050917092557.7">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.
</t>
<t tx="ekr.20050917092557.8"></t>
<t tx="ekr.20050917092557.9">See http://leoeditor.com/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.
</t>
<t tx="ekr.20050917105646">- Fixed bug that caused the Open With command to crash if the subprocess module was not installed.

- Fixed problems in the niceNocent and fastGotoNode plugins.
</t>
<t tx="ekr.20050920084036.207">class QueryReplaceCommandsClass (baseEditCommandsClass):

    '''A class to handle query replace commands.'''

    @others
</t>
<t tx="ekr.20050920084036.208">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    self.regexp = False # True: do query-replace-regexp.  Set in stateHandler.

def init (self):

    self.qQ = None
    self.qR = None
    self.replaced = 0 # The number of replacements.
</t>
<t tx="ekr.20050920084036.209">def getPublicCommands (self):

    return {
        'query-replace':        self.queryReplace,
        'query-replace-regex':  self.queryReplaceRegex,
    }
</t>
<t tx="ekr.20050920084036.210">def queryReplace (self,event):

    '''Interactively find and replace text.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = False
    self.stateHandler(event)

def queryReplaceRegex (self,event):
    '''Interactively find and replace text using regular expressions.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = True
    self.stateHandler(event)
</t>
<t tx="ekr.20050920084036.211">def getUserResponse (self,event):

    w = self.editWidget(event)
    char = event and event.char or ''
    
    if not w or not char return

    if char in ('Y','y'):
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif char in ('Q','q','\n','Return'):
        self.quitSearch(event)
    elif char == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif char in ('N','n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
</t>
<t tx="ekr.20050920084036.212">def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return

    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    ins = w.getInsertPoint()
    w.insert(ins,self.qR)
    self.replaced += 1
</t>
<t tx="ekr.20050920084036.215">def stateHandler (self,event):

    k = self.k ; state = k.getState('query-replace')

    prompt = g.choose(self.regexp,'Query replace regexp','Query replace')

    if state == 0: # Get the first arg.
        self.init()
        k.setLabelBlue(prompt + ': ',protect=True)
        k.getArg(event,'query-replace',1,self.stateHandler)
    elif state == 1: # Get the second arg.
        self.qQ = k.arg
        if len(k.arg) &gt; 0:
            prompt = '%s %s with: ' % (prompt,k.arg)
            k.setLabelBlue(prompt)
            k.getArg(event,'query-replace',2,self.stateHandler)
        else:
            k.resetLabel()
            k.clearState()
    elif state == 2: # Set the prompt and find the first match.
        self.qR = k.arg # Null replacement arg is ok.
        k.setLabelBlue('Query replacing %s with %s\n' % (self.qQ,self.qR) +
            'y: replace, (n or Delete): skip, !: replace all, (q or Return): quit',
            protect=True)
        k.setState('query-replace',3,self.stateHandler)
        self.findNextMatch(event)
    elif state == 3:
        self.getUserResponse(event)
</t>
<t tx="ekr.20050920084036.219">def findNextMatch (self,event):

    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    w.tag_delete('qR')
    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;
</t>
<t tx="ekr.20050920084036.220">def quitSearch (self,event,message=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_delete('qR')
    k.clearState()
    if message is None:
        message = 'Replaced %d occurences' % self.replaced
    k.setLabelGrey(message)
</t>
<t tx="ekr.20051005151838"></t>
<t tx="ekr.20051005155611">try:
    regex = re.compile(self.qQ)
except Exception:
    self.quitSearch(event,'Illegal regular expression')
    return False

i = w.getInsertPoint()
txt = w.get(i,'end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    i = w.getInsertPoint()
    txt = w.get(i,i+length)
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20051005160923">i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051028051444">Leo 4.4 alpha 4                                         December 5, 2005

Leo 4.4 a4 introduces the 'Newer World Order' for redrawing the screen,
corrects numerous bugs in the 4.4 code base, and introduces several new features.

You should be able to use this version safely. There are no known serious bugs,
but several minibuffer commands are not ready for prime time. All the major
features of 4.4 are in place.

To learn about Leo, see: http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for almost all commands in the Emacs Cmds menu, including cursor
and screen movement, basic character, word and paragraph manipulation, and
commands to manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane. Per-pane key bindings are essential for mouseless Leo.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- A rewrite of Leo's keystroke handling. In particular, Leo handles key events
immediately rather than queuing them for idle time.

- Leo recovers from crashes much more reliably than in any previous version.

- Leo updates the screen immediately rather than waiting for idle time.
This 'Newer World Order' simplifies the code and improves performance.

Known bugs in Leo 4.4a4
-----------------------
- Several minibuffer commands do not work.  See the release notes for details.

Coming in later releases of Leo 4.4:
------------------------------------
- An auto-complete command that shows class members in the Completion tab.

- More support for mouseless Leo. There will be commands to manipulate all
aspects of Leo using commands, so your fingers will never have to leave the
keyboard.

- Support for Vim and other 'plain-key' input modes.
</t>
<t tx="ekr.20051028051444.1">Here are the default bindings relating to the minibuffer. Any of
these may be changed by changing @shortcuts nodes in leoSettings.leo.

Alt-x: Just like Emacs: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not for file names.

Alt-c: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

Alt-u: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

Ctrl-g: Just like Emacs Ctrl-g: Closes the mini-buffer.

The @bool useMinibuffer setting in leoSettings.leo just controls whether the
minibuffer is visible. The minibuffer exists (and you can type into it) even if
it isn't visible! You can use the show-mini-buffer, hide-mini-buffer and
toggle-mini-buffer commands to show or hide the minibuffer.
</t>
<t tx="ekr.20051028051444.10">Leo maintains the following dictionaries.  As usual, k refers to c.keyHandler:

- c.keyHandler.registerCommand can be called from scripts to register new alt-x
  commands. It probably won't work from plugins yet.

New dictionaries and methods make it easier to customize and extend Leo:

- c.commandsDict describes all commands. Keys are full Emacs command names;
values are functions f.

- k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

- k.leoCallbackDict: keys are leoCallback functions, values are called
functions.

- k.bindingsDict: keys are shortcuts, values are g.bunches with the following
    members: func, name, warningGiven, fromMenu.
</t>
<t tx="ekr.20051028051444.11">The following helper functions make it easy to discover the binding presently in
effect for a command:

- k.getShortcutForCommandName(self,commandName) returns the shortcut given
  f.__name__.

- k.getShortcutForCommand(self,f) returns the shortcut for f.
</t>
<t tx="ekr.20051028051444.12">c.k.registerCommand (self,commandName,shortcut,func)

This function make the func available as a minibuffer command, and optionally
binds a shortcut to func. You can wrap any method in a function, so the
restriction to functions is not significant.

Here is an example take from an @button node::

k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f)
</t>
<t tx="ekr.20051028051444.13">The following bugs exist in 4.3 final.
</t>
<t tx="ekr.20051028051444.14">This makes it much harder to hang Leo after taking an exception. Leo 4.4a1 is
*much* more robust than Leo 4.3 final in this regard.
</t>
<t tx="ekr.20051028051444.15">Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.
</t>
<t tx="ekr.20051028051444.16">http://sourceforge.net/forum/message.php?msg_id=3351985

Leo did not read empty tnodes like &lt;t/&gt; properly.
</t>
<t tx="ekr.20051028051444.17"></t>
<t tx="ekr.20051028051444.18">http://sourceforge.net/forum/message.php?msg_id=3376527
</t>
<t tx="ekr.20051028051444.19">It now computes the minimum leading whitespace of all non-blank lines. The old
code computed the leading whitespace of the *first* non-blank line. This would
give the wrong results if the first line were indented.
</t>
<t tx="ekr.20051028051444.2">The most important new features of Leo 4.4 have to do with key bindings.

See the children of this node for details.


</t>
<t tx="ekr.20051028051444.4"></t>
<t tx="ekr.20051028051444.5">1. The minibuffer exists regardless of this setting, but will not be shown
   initially if it is False.

2. Hiding the minibuffer does not change any bindings or the operation of Leo in
   any other way. Therefore, if you do hide the minibuffer initially, and never
   want to use it, you should not bind shortcuts to any commands that use the
   minibuffer.

3. You can execute the show-mini-buffer, hide-mini-buffer and toggle-mini-buffer
   commands (or any other minibuffer command!) if the minibuffer is hidden.
   Indeed, the following will work even if the minibuffer is hidden.

       &lt;alt-x&gt;show-mini-buffer&lt;return&gt;
</t>
<t tx="ekr.20051028051444.6">This option controls whether Leo creates a Cmds menu.

This menu is not ready yet, though nothing bad happens if this option is True.
</t>
<t tx="ekr.20051028051444.7">http://sourceforge.net/forum/message.php?msg_id=3355954

'body_text_selection_background_color'  Default is 'Gray80'
'body_text_selection_foreground_color'  Default is 'white'
</t>
<t tx="ekr.20051028051444.8">- The contract-and-go-right command moves to the parent node and collapses the
parent node.

- The goto-first-sibling and goto-last-sibling commands allow rapid movement
through an ouline without collapsing nodes.

- The print-bindings and print-commands show what commands exist and what keys
are bound to them.

- The help command gives a brief quick start introduction to Leo's Emacs-like
features.
</t>
<t tx="ekr.20051028051444.9"></t>
<t tx="ekr.20051028051616"></t>
<t tx="ekr.20051028051616.1"></t>
<t tx="ekr.20051028051616.160">@nocolor

The scripting plugin has been improved as follows:

1. You can bind shortcuts in @button nodes.  Like this:

@button name @key=shortcut

This binds the shortcut to the script in the script button. The button's name is
'name', but you can see the full headline in the status line when you move the
mouse over the button. This is a clean and simple way of discovering the
shortcut.

2. You can create your own minibuffer commands with @command nodes.

A node whose headline has the form:

@command command-name

a new minibuffer command whose name is 'command-name'.

A node whose headline has the form:

@command command-name @key=shortcut

creates new minibuffer command and binds shortcut to it.

3. The scripting plugin no longer contains the 'bindLate' code-level option. The
scripts for all @button or @command nodes are computed 'dynamically', that is,
when the button is pushed or the command is executed from the minibuffer. This
is the most useful way, and the most intuitive.

Previously, scripts for @button nodes were never dynamic, while scripts in
@button nodes created by the 'Script button' button were dynamic only if
bindLate was True. You could call this a bug: it was unhelpful, annoying and
confusing.

4. The scripting plugin no longer prints an 'end of script' message. This allows
scripts to select tabs in the log pane
</t>
<t tx="ekr.20051028051616.172">@color

# Plugins and scripts can easily create new tabs in the log panel.
# Important: you can run any of these examples using the 'Run Script' button.

# To create a tab named "Test" or make it visible if it already exists:

c.frame.log.selectTab('Test')

# When first created, a tab contains a text widget.
# To write to this widget, add the tabName argument to g.es:

g.es('Test',color='blue',tabName='Test')

# Plugins and scripts can easily replace the default Text widget with other Tk widgets.
# c.frame.log.tabFrame contains the Tk.Frame that contains all the other widgets of the frame.
# c.frame.log.logCtrl contains the Tk.Text widget that is initially the only widget in this frame.
# So to remove this text widget just do:

c.frame.log.logCtrl.pack_forget()

# Now you can pack any other widgets into c.frame.log.tabFrame.

import Tkinter as Tk ; log = c.frame.log
log.selectTab('Test')
log.logCtrl.pack_forget()
f = Tk.Frame(log.tabFrame,bg='red',height='1inch',width='2inch')
f.pack(side='left',expand=0,fill='none')
</t>
<t tx="ekr.20051028051616.299">Leo can optionally generate matching brackets depending on the setting:

@bool autocomplete-brackets = TrueOrFalse

If True, Leo will immediately type the corresponding closing bracket whenever
you type a '(', '[' or '{' character. You can use the forward-char command to
move past the closing bracket, and Leo will move past any closing bracket if you
type the closing bracket with the cursor just to the left of a closing bracket.
</t>
<t tx="ekr.20051028061322">**Important**: The print-bindings and print-commands commands (new in a1) show
what commands exist and what keys are bound to them.

- The help command tells how to use the minibuffer.

- The show-minibuffer, hide-minibuffer and toggle-mini-buffer commands show and hide the minibuffer.

It *is* possible to execute these command even if the minibuffer isn't presently
visible. For example, typing 

&lt;alt-x&gt;toggle-mini-buffer&lt;return&gt;

should always work.

- The open-find-tab command opens the Find tab. The Find tab replaces the old
Find panel. The Find panel is deprecated.

- The open-spell-tab command opens the Spell-checking tab.

- The show-colors command creates the 'Colors' tab in the log pane. This tab allows you to
experiment with picking fonts.

- The show-fonts command creates the 'Fonts' tab in the log pane. This tab allows you to
experiment with picking colors.
</t>
<t tx="ekr.20051101161405">At the bottom of Leo's window you will now see an area labeled the mini-buffer.
You can't type in it directly, you activate the buffer by typing Alt-x or Alt-c.
Typing Alt-x takes you to 'full-command' mode. Type the full name of a command,
followed by a 'return'. 

- To get help, type Alt-x help.
- For a list of commands, type Alt-x print-commands.
- For a list of present key bindings, type Alt-x print-bindings.
- To leave the mini-buffer at any time type Ctrl-g.

Note: you can redefine any of these keys as you wish.

Important: you can execute any of Leo's 'legacy' commands from the mini-buffer.
For example, Alt-x about-leo or Alt-x open-find-dialog. Note: Leo's Find
*dialog* is deprecated. You will find it much more convenient to use Leo's new
Find *tab*. Use the open-find-tab command.

You can use tab-completion in the minibuffer to cycle through the list of
commands that start with what is in the buffer. Typing backspace takes you back
to the what you previously typed (less on character.) The 'Completion' tab shows
all possible completions. This tab appears automatically when you type a tab in
the minibuffer.

The mini-buffer reduces the need for shortcuts dramatically. For example, none
of Leo's import commands need a shortcut because it is easy enough to execute
them from the minibuffer. In particular, executing commands from the minibuffer
is much easier than executing commands by hand from a menu. 
</t>
<t tx="ekr.20051101161405.1">leoSettings.leo contains one functional @shortcuts node and one disabled
@@shortcuts node. These node contain entries for every command.

You can assign key shortcuts to any command, as discussed in the comments in
that file. You can leave the nodes as they are, use them as base for
modifications, or roll your own. You should define a binding for every function,
even if that binding is 'None'. If you don't, Leo will issue a warning.

Leo now supports per-pane bindings.  Bindings of the form:

command-name ! pane = shortcut

bind the shortcut to the command only withing a single pane. The possible values
for 'pane' are:

pane    affected panes
----    --------------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree
</t>
<t tx="ekr.20051101161405.2">The scripting plugin has been improved in two ways:

1. You can specify key bindings in @button nodes as follows:

@button name @key=shortcut

This binds the shortcut to the script in the script button. The button's name is
'name', but you can see the full headline in the status line when you move the
mouse over the button.

2. You can create new minibuffer commands with @command nodes:

@command name @key=shortcut

This creates a new minibuffer command and binds shortcut to it.
</t>
<t tx="ekr.20051101161405.3">Abbreviations may not work at present. A new kind of abbreviation is presently
hard coded in add_ekr_altx_commands in leoKeys.py. For example, one ekr-shortcut
is: 'f', which is bound to leo-find-panel. Typing Alt-x f Return executes
leo-find-panel. These may be quicker than Emacs abbreviations, or not.
</t>
<t tx="ekr.20051101161949"></t>
<t tx="ekr.20051101162123">These 'hard-coded' bindings are no longer needed and interfere with per-pane bindings.
</t>
<t tx="ekr.20051101162123.1">- The open-find-tab command opens the Find tab.

- The open-spell-tab command opens the Spell-checking tab.

The Find and Spell *tabs* replace the corresponding legacy *dialogs*. Using tabs
eliminates previous problems with dialogs obscuring Leo's main window.

Two essential components of the settings dialog now are implemented in the tabbed log:

- The show-colors command creates the 'Colors' tab in the log pane.

- The show-fonts command creates the 'Fonts' tab in the log pane.

These two tabs allow you to pick color or font names without using the @settings dialog.

Important: scripts and plugins can easily create new tabs in the Log pane. See
Chapter 7 of the Users Guide for details.
</t>
<t tx="ekr.20051101162947">Leo's core now supports tabs in the log pane.
</t>
<t tx="ekr.20051101163145">Leo 4.4a2 contains a large number of code-level improvements--some very
significant. For full details, see the (Projects) section of LeoPy.leo.
</t>
<t tx="ekr.20051101163404">The following bugs existed in the 4.4a1 code base and have now been fixed:

- Removed warnings from compare dialog.
</t>
<t tx="ekr.20051101182739">- The node::

    @shortcuts traditional Leo shortcuts with important emacs bindings

contains Leo key bindings.

- The spelling settings in leoSettings.leo replace the settings in spellpyx.ini.

- You can specify the background of tabs using the following pattern::

    @color log_pane_XXX_tab_background_color = aColor

For example::

    @color log_pane_Find_tab_background_color = #d6c7d3

- The @bool autocomplete-brackets setting controls whether Leo types a matching
closing bracket immediately when you type '(', '[' or '{'.
</t>
<t tx="ekr.20051109112610"></t>
<t tx="ekr.20051109112826">@nocolor

The New World Order means that drawing happens immediately, not at idle time.

The Newer World Order means that c.endUpdate is equivalent to c.redraw_now.
</t>
<t tx="ekr.20051109112826.217">http://sourceforge.net/forum/message.php?msg_id=3411030

The fix was to add guards so the code does not assume w._name exists for all widgets w.
</t>
<t tx="ekr.20051109112826.222">Scripts.leo contains general-purpose scripts.

unitTest.leo contains all of Leo's unit tests.

test.leo is now for recent tests.  Its small size speeds up my workflow.
</t>
<t tx="ekr.20051109112826.223">Changed the following plugins:

cleo.py, footprints.py,__wx_gui.py, zodb.py
</t>
<t tx="ekr.20051109112826.224">Removed tree.redrawScheduled, tree.updateCount and tree.disableRedraw

Three major complications are gone.
</t>
<t tx="ekr.20051109112826.227"></t>
<t tx="ekr.20051109112826.254">http://sourceforge.net/forum/message.php?msg_id=3412644

You can invoke minibuffer commands by name.  For example:

c.executeMinibufferCommand('open-outline')

Note: c.keyHandler.funcReturn contains the value returned from the command. In
many cases, as above, this value is simply 'break'.
</t>
<t tx="ekr.20051109112826.257">For now, I just set c.useTextMinibuffer = False,
so Leo uses a Tk.Label rather than a Tk.Text widget.

This will cause less confusion than always having the minibuffer enabled.
</t>
<t tx="ekr.20051109112826.265">http://sourceforge.net/forum/message.php?msg_id=3415021

The code now uses the settings in leoSettings.leo.
</t>
<t tx="ekr.20051109112826.310">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3414639

The entries for Perl and Perlpod are now as follows:

@color

self.language_extension_dict = {
    "perl" : "pl",
    "perlpod" : "pod",
}

self.extension_dict = {
    "pl"    : "perl",
    "pod"   : "perlpod",
}
</t>
<t tx="ekr.20051109112826.315">http://sourceforge.net/forum/message.php?msg_id=3418304

Fixed an edge effect when backward searching for a match that occurs at the very
end of body text. In the process I removed an ancient hack.
</t>
<t tx="ekr.20051109141223"></t>
<t tx="ekr.20051109141524"></t>
<t tx="ekr.20051109141524.1"></t>
<t tx="ekr.20051109142920">This code should never have existed.  It was used only in the macro plugin.
</t>
<t tx="ekr.20051110155735.1">- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.
_ Spell checker should check headlines.
</t>
<t tx="ekr.20051113110735">def createCloneFindAllNode(self,flattened):
    '''Create a "Found" node as the last node of the outline.'''
    c = self.c
    # Don't link the node into the outline so that positions remain valid.
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    p.h = 'Found:%s %s' % (
        ' (flattened)' if  flattened else '',
        self.find_text)
    return p
</t>
<t tx="ekr.20051128181229"></t>
<t tx="ekr.20051128181302.147"></t>
<t tx="ekr.20051128181302.148">The plugin can not call bodyWantsFocus.
</t>
<t tx="ekr.20051128181302.149">Later may never come in the Newer World Order, so everything must happen immediately.
</t>
<t tx="ekr.20051128181302.150">This ensures that the widget is always visible.
</t>
<t tx="ekr.20051128181302.151"></t>
<t tx="ekr.20051128181302.156">http://sourceforge.net/forum/message.php?msg_id=3425070

This code was contributed by Roger Erens.

When the Clone Find All checkbox is checked, the Find All command creates a new
root node called Found: &lt;your search pattern&gt;

This node contains clones of the nodes found by the Find All command. It is your
own responsibility to navigate to this new node and to clean it up when it's no
longer needed.
</t>
<t tx="ekr.20051128181302.171">The tab now scrolls properly.
</t>
<t tx="ekr.20051128181302.183">http://sourceforge.net/forum/message.php?msg_id=3434727

- Added calls to c.frame.body.onBodyChanged in cut/paste handlers.

- Added call to c.selectPosition(c.currentPosition()) in undo/redo.
    This is essential because previous calls to c.selectPosition may have had redraw_flag = False.
</t>
<t tx="ekr.20051128181302.192"></t>
<t tx="ekr.20051128181302.193">http://sourceforge.net/forum/message.php?msg_id=3425967

When creating a new Leo outline (no leo file created yet), the Save As command
created the file Test4.leo instead of the expected Test4.3.leo
</t>
<t tx="ekr.20051128181302.196"></t>
<t tx="ekr.20051128181302.204">http://sourceforge.net/forum/message.php?msg_id=3427809

Allowed relative path to stylesheets.

http://sourceforge.net/forum/message.php?msg_id=3433717

The rst3 plugin now traverses the tree as was done previously in the @button rst3 nodes.

http://sourceforge.net/forum/message.php?msg_id=3456419

The rst3 plugin now looks up and down the tree for settings doc parts.

The rst3 plugin now supports the default_path option.
</t>
<t tx="ekr.20051128181302.208">@nocolor

- The focusIn/Out trace is a great tool.

- doTabCompletion now calls w.update before calling bodyWantsFocus.

- Eliminated w.update from g.app.gui.set_focus.  It is now called only in
those places where it is truly essential, such as in k.doTabCompletion and
wherever else it might be required.

- Pmw.Notebook does a *lot* when it switches panes (e.g., the _layout method)
and potentially any of the things it does could result in focus shifting to
widget. Rather than trying to make sense of it all, Leo will simply call
w.update as necessary to force completion of the Pmw.Notebook work before trying
to set focus.
</t>
<t tx="ekr.20051128181302.211"></t>
<t tx="ekr.20051128181302.213">http://sourceforge.net/forum/message.php?msg_id=3440420

Added @string vim_cmd and @string vim_exe settings. The defaults now correspond
to default installations of vim.
</t>
<t tx="ekr.20051128181302.214">http://sourceforge.net/forum/message.php?msg_id=3436726

The dialog warns about the extensions folder not containing Pmw. This can happen
when getting files from cvs.
</t>
<t tx="ekr.20051128181302.229">http://sourceforge.net/forum/message.php?msg_id=3437089

The new default binding causes focus to move to the body pane when the user hits
&lt;Return&gt; to end editing in a headline.
</t>
<t tx="ekr.20051128181302.231">http://sourceforge.net/forum/message.php?msg_id=3442064

This was not, in fact, a problem with the plugins manager plugin.

The bug was in &lt;&lt; put up a dialog requiring a valid id &gt;&gt; in app.setLeoID.
The code set g.app.gui to None after calling g.app.gui.runAskLeoIDDialog the code set!

While I was at it, Leo's core now always inits Pmw when creating Tk.Tk. This
removes the necessity for Plugins to do this.
</t>
<t tx="ekr.20051128181302.244">1: Outline not marked dirty during editing

https://sourceforge.net/forum/message.php?msg_id=3447570

2: Inserting a headline didn't save previous edits of headlines
</t>
<t tx="ekr.20051128181351"></t>
<t tx="ekr.20051128181651">Leo 4.4a4 completes the transition to the 'Newer World Order'.
</t>
<t tx="ekr.20051128181651.1"></t>
<t tx="ekr.20051129084430">- Download jython_Release_2_2alpha1.jar and put it anywhere (say on the desktop)

- Double-click the file.  This brings up an installer.  Follow the direction.
  (I installed to c:\jython-2.2a1

- Using the Control Panel, System, Advanced tab, environment variables,
  add c:\jython-2.2a1\jython.jar to CLASSPATH (in user variables)
</t>
<t tx="ekr.20051129084430.1"></t>
<t tx="ekr.20051202072010"></t>
<t tx="ekr.20051203084725">- Put whatever.jar in c:\prog
- cd: c:\prog
- jar xvf whatever.jar
</t>
<t tx="ekr.20051203084725.1">Install:

Put JythonShellEA.jar in c:\prog\JythonShell

(optional) Expand the jar so you can see the code:

jar xvf JythonShellEA.jar

Run:

Here is the contents of jythonShell.bat:

cd c:\prog\jythonShell
java -cp c:\jython-2.2a1\jython.jar;c:\prog\jythonShell\JythonShellEA2.1.jar org.leo.shell.JythonShell
</t>
<t tx="ekr.20051205090923.13"></t>
<t tx="ekr.20051205090923.16">http://sourceforge.net/forum/message.php?msg_id=3450435
</t>
<t tx="ekr.20051205090923.22">http://sourceforge.net/forum/message.php?msg_id=3389810
</t>
<t tx="ekr.20051205091625">- The abbreviation and buffer commands are not ready yet.

- repeat-complex-command does not work.

- Moving the cursor when the 'mark' has been defined does not expand the visibly
selected text.

- Yanking and killing have not been well tested.

- C-u 5 &lt;return&gt; works but is not undone properly. Also, the kill-line command
does not work as in Emacs.

- Many new commands must be generalized to handle the more complex environment
Leo offers. For example, search commands must be told whether to limit the
search a single node, or a node or and its descendants, or the entire outline.
We need a set-variable command that sets a (Python) variable using an
emacs-style variable name.

- The notion of the 'point' must be expanded so it indicates a node as well as
text location.

- New commands are needed to support 'mouseless-Leo'. The user must be able to
drive all dialogs from the keyboard, or to get the same effect without using a
dialog at all. Examples: dismiss-top-dialog, scroll-outline-up/down. We also
need commands to change focus and to manage menus. Examples: focus-in-body,
focus-in-tree, etc, activate-edit-menu, etc.
</t>
<t tx="ekr.20051219150602">Leo 4.4 alpha 5                                             January 6, 2006

This release completes the last major features of Leo 4.4:

- User-specified key-binding modes.
- Support for multiple key-bindings for individual minibuffer commands.

This will be the last alpha version of Leo 4.4. Beta 1 is coming in about a
week. You should be able to use this version safely; there are no known serious
bugs.

To learn about Leo, see: http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for most commands in the Emacs Cmds menu, including cursor and screen
movement, basic character, word and paragraph manipulation, and commands to
manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane.

- User-specified key-binding modes. This feature makes it possible to emulate all
aspects of Emacs and Vim as far as key bindings are concerned.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- Leo recovers from crashes much more reliably than in any previous version.

- Leo handles keystrokes and updates the screen immediately rather than waiting
for idle time.
</t>
<t tx="ekr.20051219150602.10">http://sourceforge.net/forum/message.php?msg_id=3464874
</t>
<t tx="ekr.20051219150602.100"></t>
<t tx="ekr.20051219150602.101">The provide batch-mode unit testing.
</t>
<t tx="ekr.20051219150602.102"></t>
<t tx="ekr.20051219150602.105">Leo now supports the following commands, shown below with their present bindings:

back-char ! text = LtArrow
back-char-extend-selection ! text = Shift-LtArrow
back-paragraph ! text = Alt-braceleft 
back-paragraph-extend-selection ! text = Alt-Shift-braceleft
back-sentence ! text = Alt-a 
back-sentence-extend-selection  = None
back-word ! text = Alt-b  # No conflict   
back-word-extend-selection  ! text = Alt-Shift-b
beginning-of-buffer ! text = Alt-less # Note: same as Alt-Shift-less
beginning-of-buffer-extend-selection  = None
beginning-of-line ! text = Ctrl-a
beginning-of-line-extend-selection = None
exchange-point-mark = None
forward-char ! text = RtArrow
forward-char-extend-selection ! text = Shift-RtArrow
forward-paragraph ! text = Alt-braceright
forward-paragraph-extend-selection ! text = Alt-Shift-braceright
forward-sentence ! text = Alt-e
forward-sentence-extend-selection ! text = Alt-Shift-e
forward-word ! text = Alt-f
forward-word-extend-selection ! text = Alt-Shift-f
next-line ! text = DnArrow
next-line-extend-selection  ! text = Shift-DnArrow
previous-line ! text = Uparrow
previous-line-extend-selection ! text = Shift-UpArrow

The -extend-selection variants move the cursor and also extend the selection
from the insert point in the indicated direction. As usual exchange-point-mark
switches the insert point from one side of the selection to the other: which
side of the selection the insert point is on does make a difference.

I also added three commands that implement so-called 'extend mode':

clear-extend-mode = None
set-extend-mode = None
toggle-extend-mode = None

When extend mode is on (it is off at first), all cursor movement commands listed
above extend the selection. Very handy. Thanks to Brian for this suggestion.

This is the start of mouseless Leo. For the first time all the common Emacs
cursor-movement commands exist. These commands should work in any text widget.
</t>
<t tx="ekr.20051219150602.13">http://sourceforge.net/forum/message.php?msg_id=3466412

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headline, and ch is always '\r', regardless of
platform.

http://sourceforge.net/forum/message.php?msg_id=3462294
</t>
<t tx="ekr.20051219150602.2"></t>
<t tx="ekr.20051219150602.28">http://sourceforge.net/forum/message.php?msg_id=3467558

What I did:

- atFile.readError deletes root's entire subtree.
- atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20051219150602.3"></t>
<t tx="ekr.20051219150602.7"></t>
<t tx="ekr.20051219150602.75">http://sourceforge.net/forum/message.php?msg_id=3461068

And a recent bug: clicking in the expand/contract box didn't save the headline.
</t>
<t tx="ekr.20051219150602.81">The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.
</t>
<t tx="ekr.20051219150602.85">Read @file Nodes and Import external file commands no longer create copies of the root node.
</t>
<t tx="ekr.20051219151926">leoSettings.leo now contains a node called:

@@shortcuts traditional Leo bindings

This node contains the 'classic' Leo key bindings that appeared in Leo 4.3. I
have proofed these settings carefully, but some errors may remain. Please report
any errors or any other suggestions for these settings.
</t>
<t tx="ekr.20060105182648.376">Leo no longer creates a duplicate root node when importing external files.

The code is due to LeoUser.
</t>
<t tx="ekr.20060105182648.377"></t>
<t tx="ekr.20060105182648.378"></t>
<t tx="ekr.20060105182648.379"></t>
<t tx="ekr.20060105182648.382">The reason for this assert is unclear.
</t>
<t tx="ekr.20060105182648.432"></t>
<t tx="ekr.20060105182648.469">This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.
</t>
<t tx="ekr.20060105214753">Leo now allows you to specify input modes. You enter mode x with the
enter-x-mode command. The purpose of a mode is to create different bindings
for keys within a mode. Often plain keys are useful in input modes.

You can specify modes with @mode nodes in leoSettings.leo. @mode nodes work
just like @shortcuts nodes, but in addition they have the side effect of
creating the enter-&lt;mode name&gt;-mode command.

Notes:

- You can exit any mode using the keyboard-quit (Control-g) command. This is the
  **only** binding that is automatically created in each mode. All other bindings
  must be specified in the @mode node. In particular, the bindings specified in
  @shortcuts nodes are **not** in effect in mode (again, except for the
  keyboard-quit binding).

- Leo supports something akin to tab completion within modes: if you type a key
  that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab
  shows all the keys that you can type and the commands to which they are bound.
  The mode-help command does the same thing.

- @shortcuts nodes specify the bindings for what might be called the 'top-level'
  mode. These are the bindings in effect when no internal state is present, for
  example, just after executing the keyboard-quit command.

- The top_level_unbound_key_action setting determines what happens to
  unbound keys in the top-level mode. Leo ignores unbound keys in all other modes.
  The possibilities are 'insert', 'replace' and 'ignore'.

- The set-insert-mode, set-overwrite-mode and set-ignore-mode
  commands alter what happens to unbound keys in the top-level mode.
  
- If the @mode headline contains ::, everything following
  the :: is the mode prompt. For example::
    
    @mode abc :: xyz
    
Creates the enter-abc-mode command, but the prompt for the command is xyz.

With all these options it should be possible to emulate the keyboard behavior of any other editor.
</t>
<t tx="ekr.20060111112513.1">http://sourceforge.net/forum/message.php?msg_id=3516227
By: leouser

Some highlights:
* simpler startup:
jyleo leo.py
should be sufficient to start it up.
* new editor colorization
* the JythonShell is much more powerful and cooler
* new plugins
* Chapters support
* mod_script is in place.
* dyna-menu was converted.  I guess 'e' will have to judge the conversion.
* multi-language script support.
* drag and drop
* some powerful new editor commands.  Try keyword completing on the language
in effect.  Say if it is python:
se(Tab)
becomes
self

Some warnings:
1. Be careful about reading your regular leo files into jyleo and saving them.
Its quite conceivable that jyleo will write it out to an XML format that regular
leo can't handle.  Why?  Well jyleo is using an XML library to spit its XML
out while leo uses a home grown method.  The library can handle leo's XML, but
Ive seen regular leo not be able to handle jyleo's XML.  Its based around &lt;tag/&gt;
I believe.

2. If you move jyleo after executing it you will need to clear out your compiled
py files as the __file__ attribute is hard compiled into the resulting objects.
Not what we want.  We want it to be set at runtime.  Ive been waiting a long
time for jython to release again and hopefully fix this, but Im not holding
my breath anymore.

----------
Its hard to give this thing a number, I want to call it jyleo2, but jyleo is
sufficient.  Dependent upon bug reports the next release could be much sooner
than before, maybe even weeks.  I hope one thing, that the dreaded "I can't
get it to start" problems are gone.  I took the snapshot and expanded it in
Windows XP.  Went to the src directory and typed: jython leo.py
and it started.  That's what I wanted to see.  I didn't have to mess with the
CLASSPATH or anything.

things needed:
java 5
a jython2.2a1 or beyond.  jython2.2a1 is the most recent snapshot.

Beyond bug fixing, I will be planning to add more SwingMacs command as time
goes along.  But I think most major features are in place.  Of course the 3D
experiments in the future could change that... :D

A NOTE ON STARTUP TIMES: In my experience it takes awhile for jyleo to start.
It will take much longer the first time you execute it because the py files
are being compiled.  Ive haven't been able to figure out what eats the time,
it may just have a slow startup in the aggregate.  So don't think its not doing
anything, it probably is.
</t>
<t tx="ekr.20060111192108">A **dangerous** delete is a deletion of a node so that all the data in the node
is deleted *everywhere* in an outline. The data is gone, to be retrieved only
via undo or via backups. It may not be obvious which deletes are dangerous in an
outline containing clones. Happily, there is a very simple rule of thumb::

    Deleting a non-cloned node is *always* dangerous.
    Deleting a cloned node is *never* dangerous.

We could also consider a delete to be dangerous **if it results in a node being
omitted from an external file.** This can happen as follows. Suppose we have the
following outline (As usual, A' indicates that A is marked with a clone mark)::

    - @file spam.py
        - A'
            - B
    - Projects
        - A'
            - B

Now suppose we clone B, and move the clone so the tree looks like this::

    - @file spam.py
        - A'
            - B'
    - Projects
        - A'
            - B'
        - B'

If (maybe much later), we eliminate B' as a child of A will get::

    - @file spam.py
        - A'
    - Projects
        - A'
        - B

B has not been destroyed, but B is gone from @file spam.py! So in this sense deleting a clone node can also be called dangerous.
</t>
<t tx="ekr.20060116090428"></t>
<t tx="ekr.20060116174906">Leo 4.4 beta 1                                             January 17, 2006

The code is stable; there are no known serious bugs. Some features are
incomplete.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060116174906.100">https://sourceforge.net/forum/message.php?msg_id=3514627

c.endUpdate now restores the previous focus by default.
</t>
<t tx="ekr.20060116174906.103"></t>
<t tx="ekr.20060116174906.104">http://sourceforge.net/forum/message.php?msg_id=3514755
</t>
<t tx="ekr.20060116174906.113">http://sourceforge.net/forum/message.php?msg_id=3515341
</t>
<t tx="ekr.20060116174906.118">http://sourceforge.net/forum/message.php?msg_id=3509141

Problems with cleo.  Installed patch: http://sourceforge.net/forum/message.php?msg_id=3517080

https://sourceforge.net/forum/message.php?msg_id=3515025

Problems with fastgotonode and and groupOperations.
</t>
<t tx="ekr.20060116174906.122">http://sourceforge.net/forum/message.php?msg_id=3518722

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt
</t>
<t tx="ekr.20060116174906.125">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803
</t>
<t tx="ekr.20060116174906.130">These should be considered bug fixes.

- copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

- Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.
</t>
<t tx="ekr.20060116174906.160">Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().
</t>
<t tx="ekr.20060116174906.163"></t>
<t tx="ekr.20060116174906.164"></t>
<t tx="ekr.20060116174906.185">extensionHelper resets movePoint any time there is no selection.
</t>
<t tx="ekr.20060116174906.187"></t>
<t tx="ekr.20060116174906.194">The fix was to call endUpdate() rather than endUpdate(changed) in onHeadChanged.
</t>
<t tx="ekr.20060116174906.195"></t>
<t tx="ekr.20060116174906.198">g.top and the associated g.app.log logic is inherently unreliable.
</t>
<t tx="ekr.20060116174906.199">This allows code to determine in a standard way whether a window is in the process of being destroyed.
</t>
<t tx="ekr.20060116174906.2"></t>
<t tx="ekr.20060116174906.213">This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060116174906.255">Leo now calls doCommand on all commands, so the 'command' hooks and error
processing always get done.
</t>
<t tx="ekr.20060116174906.257"></t>
<t tx="ekr.20060116174906.258"></t>
<t tx="ekr.20060116174906.259">@nocolor
</t>
<t tx="ekr.20060116174906.262"></t>
<t tx="ekr.20060116174906.263">http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.
</t>
<t tx="ekr.20060116174906.267"></t>
<t tx="ekr.20060116174906.272">http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.
</t>
<t tx="ekr.20060116174906.296">Still to do:

Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?
</t>
<t tx="ekr.20060116174906.3">A 'backward' delete at the start of a headline deletes the first character.
delete-char did not work in headlines.
</t>
<t tx="ekr.20060116174906.306"></t>
<t tx="ekr.20060116174906.63">http://sourceforge.net/forum/message.php?msg_id=3465251
</t>
<t tx="ekr.20060116174906.86">http://sourceforge.net/forum/message.php?msg_id=3495741

The plugin now uses sys.getdefaultencoding() to set the encoding.
</t>
<t tx="ekr.20060116174906.87">This could have been the source of weird find behavior.
</t>
<t tx="ekr.20060116174906.88">The fix was to have x.getSelectedText return '' instead of None.
</t>
<t tx="ekr.20060116174906.90">http://sourceforge.net/forum/message.php?msg_id=3510983
</t>
<t tx="ekr.20060116174906.97"></t>
<t tx="ekr.20060123091352"></t>
<t tx="ekr.20060206111508">Leo 4.4 beta 2                                              February 14, 2006

This version fixes dozens of bugs, improves performance and polishes the user
interface. The code is stable; there are no known serious bugs.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4b2:
----------------------------
- Much better 'fit and finishes'.
- New commands that support mouseless Leo.
- Minibuffer search commands provide all features of Leo's legacy search commands.
- User modes are fully functional and you can create special bindings for the minibuffer.
- New master key and click handlers and improved allocation of screen widgets.

Coming in Leo 4.4b3:
--------------------
- A revived chapters plugin.
- Autocompleter Tab.
- Improved incremental searches.

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060206111508.103">The outline jumps around too much when expanding/contracting nodes
</t>
<t tx="ekr.20060206111508.136"># This is required now that scrolling is disabled by default.
</t>
<t tx="ekr.20060206111508.14">@nocolor

What I did:

- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color
</t>
<t tx="ekr.20060206111508.2"></t>
<t tx="ekr.20060206111508.3">@nocolor

Must check for c.exists in c.executeScript after executing the script.
</t>
<t tx="ekr.20060206111508.4">@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings &amp; mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaining the headline editing state.

@color
</t>
<t tx="ekr.20060206111508.40"></t>
<t tx="ekr.20060206111508.48">
</t>
<t tx="ekr.20060206111508.49">Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 250, in doCommand
    val = command() # Call legacy command

  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1777, in cutText
    oldText = w.get('1.0','end')

AttributeError: Canvas instance has no attribute 'get'
</t>
<t tx="ekr.20060206111508.5">@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
</t>
<t tx="ekr.20060206111508.54"></t>
<t tx="ekr.20060206111508.547">- Replaced frame.xWantsFocus with c.xWantsFocus.
- Added event arg to all legacy commands.
- Replaced k.tkBindingFromSetting by k.shortcutFromSetting.
- Replaced k.canonicalizeShortcut by k.shortcutFromSetting.
- Replaced k.bindShortcut with bindKey.
- k.makeBindingsFromCommandsDict does not call k.bindKey for mode bindings.
- Call update_idletasks when writing to the log.
- Updated selection point immediately in masterKeyHandler.
  Otherwise, updateStatusLine would be one click behind.
</t>
<t tx="ekr.20060206111508.550">@nocolor

This is logically and practically dubious.
True, a screen redraw shouldn't mess with the focus,
but there are the following problems:

1. c.endUpdate can happen anytime, and it could interfere with other efforts to set focus.
2. g.app.get_focus might get the 'wrong' or a 'bad' focus.
</t>
<t tx="ekr.20060206111508.553"></t>
<t tx="ekr.20060206111508.58"></t>
<t tx="ekr.20060206111508.596">A *major* improvement to the tree allocation code:

1.  Use p.key() to as keys to tree.visibleText.
 This greatly speeds up tree.findEditWidget

2. Eliminated the brain-dead requirement that previously-allocated widgets must match the position.
   - The allocation code just gets *any* previously allocated widget.
     This eliminates an n**2 search!
   - The ancient problem was that theId refers to the *window* not its Text widget:
     the *window* must be moved to the right spot.

3. recycleWidgets is simpler and a bit faster.

4. destroyWidgets now works: (the bug was not clearing tree.ids).
</t>
<t tx="ekr.20060206111508.63"></t>
<t tx="ekr.20060206111508.74">Call w.see('insert'), not w.see('insert-5L')
</t>
<t tx="ekr.20060206111508.75"></t>
<t tx="ekr.20060206111508.97"></t>
<t tx="ekr.20060206111600"></t>
<t tx="ekr.20060206111717.1"></t>
<t tx="ekr.20060206112001">- Improved format of print-commands and print-bindings commands.

- Eliminated clone-find-all, selection-only, show-context checkboxes
  when show_only_find_tab_options setting is True.

- All minibuffer find commands copy the find string from the Find tab into the minibuffer.

- The replace-string command sets up arguments for Tab find. This is different
  from the normal Emacs replace-string command, but it works well in Leo.

- Leo doesn't abort the minibuffer if the command does not exist.
  This is much more convenient.
</t>
<t tx="ekr.20060208112908"></t>
<t tx="ekr.20060211104746.12">* Found the reason why focus was *still* sticking in the outline pane:
    - The click handlers must return 'break', not continue.
    - However, OnActivateHeadline must return 'continue' when the headline is active
      so that Tk will handle the click properly.

- UNL does not seem to be causing problems.

- No need to save/restore focus in status line.

- Added several new traces to tkTree class.

* tree.redraw_now now ends editing properly. This fixes lots of bugs. In
particular, it avoid any chance that p.edit_widget won't correspond to the
present position.

- k.masterClickHandler calls tree.OnDeactivate() if there is no callback function.
  This solves most headline focus problems, provided that all panes bind clicks to k.masterClickHandler.

- toggle-active-pane now ends editing properly.

- insert-headline now calls c.editPosition after calling c.endUpdate().
</t>
<t tx="ekr.20060211104746.162">Backspace in empty body text sometimes moved focus to canvas, and sometimes
improperly drew icon.

Made several fixes to onBodyChanged. There was no test for unchanged text! This
could have created all sorts of problems for undo.
</t>
<t tx="ekr.20060211104746.168">@ This revealed several problems:

- Most find dialog commands do not actually exist. All find commands except
open-find-dialog actual refer to the find tab.

- Several other minor shortcut problems.
</t>
<t tx="ekr.20060211104746.177">http://sourceforge.net/forum/message.php?msg_id=3549737

for extend selection,
with binding to arrow keys,
if you switch from up to down arrow,
the selection restarts again.
this should just change extend direction
while still using the same selection.
</t>
<t tx="ekr.20060211104746.2">In the new drawing scheme, tree.redraw_now always calls c.endEditing, which
calls tree.onHeadChanged. The effect of this was to reverse the action of
undo/redoNodeContents.

The solution was to change the edit widget directly before calling
tree.redraw_now. To do this, I created the new tree.setHeadline method.
</t>
<t tx="ekr.20060211104746.208"></t>
<t tx="ekr.20060211104746.346">select-all-text, move back/forward line/char, start/end-of-line.
</t>
<t tx="ekr.20060212102459.4">All minibuffer search commands, with the exception of the isearch (incremental) commands, simply provide a minibuffer interface to Leo's legacy find commands.  This means that all the powerful features of Leo's legacy commands are available to the minibuffer search commands.

Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcuts nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.  It's not necessary for it to be visible, but I think it provides good feedback about what search-with-present-options does.  YMMY.  When True, the sequence Control-F, Control-G is one way to show the Find Tab.

Basic find commands

- The open-find-tab command makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- The hide-find-tab commands hides the Find tab, but retains all the present settings.

- The search-with-present-options command (Control-F) prompts for a search string.  Typing the &lt;Return&gt; key puts the search string in the Find tab and executes a search based on all the settings in the Find tab.   This command is my 'workhorse' search command.

- The show-search-options command shows the present search options in the status line.  At present, this command also shows the Find tab.

Search again commands

- The find-tab-find command (F3) is the same as the search-with-present-options command, except that it uses the search string in the find-tab.  This is what I use as my default 'search again' command.

- Similarly, the find-tab-find-previous command (F2) repeats the command specified by the Find tab, but in reverse.

- The find-again command a combination of the search-with-present-options and find-tab-find command.  It is the same as the find-tab-find command if a search pattern other than '&lt;find pattern here&gt;' exists in the Find tab.  Otherwise, the find-again is the same as the search-with-present-options command.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.


Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- The enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- The search-backward and search-forward commands set the 'Whole Word' checkbox to False.

- The word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- The re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- The find-all command prints all matches in the log pane.

- The clone-find-all command replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

The replace-string prompts for a search string.  Type &lt;Return&gt; to end the search string.  The command will then prompt for the replacement string.  Typing a second &lt;Return&gt; key will place both strings in the Find tab and executes a **find** command, that is, the search-with-present-options command.

So the only difference between the replace-string and search-with-present-options commands is that the replace-string command has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- The find-tab-change command (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- The find-tab-change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

The find-tab-find, find-tab-change and find-tab-change-then-find commands can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- The find-tab-change-all command changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Coming in Leo 4.4b3: the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''
</t>
<t tx="ekr.20060214074035.101"></t>
<t tx="ekr.20060214074035.12">http://sourceforge.net/forum/message.php?msg_id=3237845

On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.
</t>
<t tx="ekr.20060214074035.20">http://sourceforge.net/forum/message.php?msg_id=3534349
By: edcdave

Saving the Leo file is not sufficient - I have to exit the document and open
it again before the rst destination directory is set correctly.

The fix was to set c.frame.openDirectory in save.
</t>
<t tx="ekr.20060214074035.41">The problem: event.widget is the minibuffer.  It must be the body text.

- k.fullCommand saves the initial event and passes it on to callAltXFunction.

- There was a bug in c.masterFocusHandler.  The correct test for 'no change' is:

    if c.hasFocusWidget and c.requestedFocusWidget == c.hasFocusWidget:

** Important: the 'extra' calls to set_focus are correct. The minibuffer messes
with the tab pane, and so we *must* be careful to yank the focus back to the
body.
</t>
<t tx="ekr.20060214074035.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737

\src\leoEditCommands.py:340: 
Warning: 'yield' will become a reserved keyword 

for python2.2 leoEditCommands.py needs
from __future__ import generators

Also changed the following plugins:

at_produce.py
fastGotoNode.py
rst3.py
zodb.py
</t>
<t tx="ekr.20060214074035.65">http://sourceforge.net/forum/message.php?msg_id=3538274

It's not clear that there were serious problems with the plugin, but I improved the code and error messages.  All features work for me.

Several plugins use the icon-double-click hook.  The reported problems could have been due to plugin conflicts.
</t>
<t tx="ekr.20060214074035.66">http://sourceforge.net/forum/message.php?msg_id=3517080
</t>
<t tx="ekr.20060214074035.67">http://sourceforge.net/forum/message.php?msg_id=3571431
By: ktenney

To reiterate a request:

When doing File-&gt;Open the default directory should the directory which
was navigated to for previous 'Open'

What I did:

- Defined g.app.globalOpenDir # The directory last used to open a file.
</t>
<t tx="ekr.20060214074035.9">http://sourceforge.net/forum/message.php?msg_id=3549737

The fix was to call getBool rather than getString.
</t>
<t tx="ekr.20060214083647">New settings:

- @int max_undo_stack_size
- @bool minibufferSearchesShowFindTab
- @bool show_only_find_tab_options

New debugging settings:

@bool allow_idle_time_hook
@bool gc_before_redraw
@bool show_tree_stats
@bool trace_bindings
@bool trace_doCommand
@bool trace_f.set_focus
@bool trace_focus = False
@bool trace_g.app.gui.set_focus
@bool trace_gc
@bool trace_gc_calls
@bool trace_gc_verbose
@bool trace_masterClickHandler
@bool trace_masterCommand
@bool trace_masterFocusHandler
@bool trace_masterKeyHandler
@bool trace_modes
@bool trace_redraw_now
@bool trace_select
@bool trace_tree
@bool trace_tree_alloc
@bool trace_tree_edit
@bool use_syntax_coloring
@string trace_bindings_filter
@string trace_bindings_pane_filter
</t>
<t tx="ekr.20060214083808">Debugging commands:

- dump-all-objects, ump-new-objects, verbose-dump-objects.
- free-text-widgets.

Find commands:

See the child of this node for details.

- find-again.
- find-all and clone-find-all.
- find-tab-find command, find-tab-find-previous.
- find-tab-change, find-tab-change-all, find-tab-change-then-find.
- hide-find-tab, open-find-tab.
- re-search-forward and re-search-backward.
- replace-string.
- search-with-present-options.
- search-backward and search-forward.
- show-search-options.
- word-search-backward and word-search-forward.

Search options:

- set-find-everywhere, set-find-node-only, and set-find-suboutline-only.
- toggle-find-ignore-case-option, toggle-find-in-body-option,
  toggle-find-in-headline-option, toggle-find-mark-changes-option,
  toggle-find-mark-finds-option, toggle-find-regex-option,
  toggle-find-reverse-option, toggle-find-word-option, 
  toggle-find-wrap-around-option.

Mouseless Leo:

- activate-cmds-menu, activate-edit-menu, activate-file-menu activate-help-menu,
  activate-outline-menu, activate-plugins-menu, activate-window-menu.
- contract-body-pane, contract-log-pane, contract-outline-pane, contract-pane.
- expand-body-pane, expand-log-pane, expand-outline-pane, expand-pane.
- fully-expand-body-pane, fully-expand-log-pane, fully-expand-outline-pane, fully-expand-pane.
- hide-body-pane, hide-log-pane, hide-outline-pane, hide-pane.
- click-click-box, click-headline, click-icon-box, double-click-headline,
  double-click-icon-box, simulate-begin-drag, simulate-end-drag.
  (These commands trigger event hooks. In particular, double-click-icon-box will
  invoke the vim or xemacs plugins if they are enabled.)
</t>
<t tx="ekr.20060214085054">The problem with focus 'sticking' in the Pmw.Notebook was due to a call to
bringToFront. Apparently, the side effect was to assign a focus to the widget
that had it previously. This makes sense, and can not be considered a Tk bug.

Remove almost all calls to w.update in Leo.

No more calls to w.after that were used to draw the status line. The master key
and click handlers now call the label update method directly. This may ease a
major stress on Tk.
</t>
<t tx="ekr.20060214090742"></t>
<t tx="ekr.20060214092741">- @mode nodes in leoSettings.leo allow you to specify input modes with separate key bindings.

See the child of this node for full details.

- All key bindings specified with !mini pane specifier apply to all modes.

</t>
<t tx="ekr.20060215112429">Leo 4.4 experimental 1                                      February 15, 2006

This version is an emergency measure.  It's goals:

1.  To fix some of the key-handling issues in Leo 4.4 b2.
2.  To allow further experimentation with key handling.
3.  To allow easy reporting of any other key handling problems.

Please do not use this version (or Leo 4.4b2) unless you are ready to report bugs.

My apologies for the key handling problems in Leo 4.4 b2.  I hope this version will
be all that is necessary to fix those problems.

Here are the details of the key-handling changes:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.
</t>
<t tx="ekr.20060215112429.2">extract                             = Shift-Ctrl-D
extract-names                       = Shift-Ctrl-N
extract-section                     = Shift-Ctrl-S  # Shift-Ctrl-E: end-of-line-extend-selection

write-at-file-nodes                 = Shift-Ctrl-W # Was enter-file-mode.
write-dirty-at-file-nodes           = Shift+Ctrl+Q

# Removed definitions of find and file modes.  I never used them.
</t>
<t tx="ekr.20060215112429.3">http://sourceforge.net/forum/message.php?msg_id=3545403
</t>
<t tx="ekr.20060215112429.6">The patch was reported at:

http://sourceforge.net/forum/message.php?msg_id=3577681
</t>
<t tx="ekr.20060215112429.9">http://sourceforge.net/forum/message.php?msg_id=3573470

What I did:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.
</t>
<t tx="ekr.20060217071505">Leo 4.4 alpha 6                                         February 17, 2006

Leo 4.4 b2 was broken on some platforms.  Leo 4.4 a6 should fix those problems
forever.  However, only wider distribution will verify that for certain.

Besides fixing the fatal problems with Leo 4.4b2, this version fixes two minor bugs
and adds some new settings in leoSettings.leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4 b2 and a6:
----------------------------
- Smoother user interface.
- New commands that support mouseless Leo.
- Minibuffer search commands provide all features of Leo's legacy search commands.
- User modes are fully functional; you can create special bindings for the minibuffer.
- New master key and click handlers and improved allocation of screen widgets.

Coming in Leo 4.4b3:
--------------------
- A revived chapters plugin.
- Autocompleter Tab.
- Improved incremental searches.

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060217071505.1">The new scheme binds to keystrokes, not commands.  This should be as portable
and robust as all previous versions (except b2, which was broken).

- Created k.completeAllBindings, called last in k.makeAllBindings. This binds
all keystrokes in k.bindingsDict to k.masterKeyHandler with an optional stroke
argument. This allows k.masterKeyhandler to dispense with the problematic call
to k.strokeFromEvent. This is all that is really required. 

- Added code to menu.createMenuEntries that clears the accelerator on MacOS for
any key that isn't a control, alt or command key. This solves the recurring
problems with the Return key. The only effect is that the menu won't mention a
binding that is actually in effect, but apparently that cannot be helped.

- Added g.safeCompareStrings, which may, or may not, fix the crasher when
comparing k.abortAllModesKey to the incoming keystroke in k.masterKeyHandler.
It's a bit tricky to test.

- The ignore_caps_lock is no longer functional. Sigh. This depends on knowing
the Caps_Lock bit in key events. I may put this back later, but I can't delay a6
even a minute for this.
</t>
<t tx="ekr.20060217072324">- Fixed crasher in k.masterCommand.

- Arrow keys no longer destroy UNL line
</t>
<t tx="ekr.20060217072647">- @bool trace_autocompleter # The autocompleter itself is not ready yet.
- @bool trace_key_event
- @bool trace_minibuffer
- @bool trace_status_line
</t>
<t tx="ekr.20060217111834"></t>
<t tx="ekr.20060227102028">Leo 4.4 alpha 7                                             February 28, 2006

This version fixes some minor problems with Leo 4.4a6 and adds autocompletion
and calltips.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060227102028.14">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3586962
By: bwmulder

the open-find-dialog is broken. 

Error: 4 
TypeError Exception in Tk callback 
Function: &lt;function findButtonCallback at 0x04E219F0&gt; (type: &lt;type 'function'&gt;) 
Args: () 
Traceback (innermost last): 
File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__ 
return apply(self.func, args) 
TypeError: findButtonCallback() takes at least 1 argument (0 given) 
</t>
<t tx="ekr.20060227102028.15"></t>
<t tx="ekr.20060227102028.16"># This was causing problems.  It may be an easy fix, but I kinda doubt it.
</t>
<t tx="ekr.20060227102028.17">
</t>
<t tx="ekr.20060227102028.18">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3597694
By: tfer

Template Plug-in (maybe others too) co,plain when activated:
exception executing command
Traceback (most recent call last):
  File "leoCommands.py", line 265, in doCommand
    val = command(event)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 350, in about
    PluginAbout(self.name, self.version, self.doc)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 576, in __init__
    g.app.dialogs += 1
AttributeError: LeoApp instance has no attribute 'dialogs'
</t>
<t tx="ekr.20060227102028.2"></t>
<t tx="ekr.20060227102028.3"># http://sourceforge.net/forum/message.php?msg_id=3583335
</t>
<t tx="ekr.20060227123536">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
</t>
<t tx="ekr.20060227124411">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3583737
By: Offray

I was previously thinking in the relation between Leo and Wikis, and I think
that may be a thing that would help to make Leo more visible in Wiki space could
be if Leo can export/import to/from a Wiki (something limilar to th @file or
@url directives). Let me explain a little better the scenary where this idea
come.

We have a local wiki for colombian Free Software Community related issues, and
I have used Leo for writing the migration scripts from Mediawiki to MoinMoin
(wich I think is more flexible and extensible that the popular wiki behind
wikipedia). I was probing also the idea of a Wiki like environment for solving
colaborative problems, so I was posting the scripts I made on Leo in a Wiki
page, and republishing them in the moment they changed. This keeps me pasting
all the time the script and in some moments I was thinking what about if someone
make a change in the Wiki page. Would be nice then to have the same capability
to detect and sincronize that change as Leo make with the hard disk files.

But this doesnt end here. Another Wiki-Leo interaction is to use outlines as
a way to organice Wiki content. For example "= Title =" in a Wiki would be a
Outline Node in Leo and "== Subtitle ==" Would become a outline subnode all
arranged in the proper hierarchy.

Somekind of Wisiwyg display would be nice, but this must be a plugin or something
like that, so Leo could become a "Layered" front end to some kind of data.

About and article on Wikipedia. That would be nice, but I'm a little tired of
fighting with some wikipedians ignorance on certain matters combined with power
(a pretty bad combination). I think that a Wiki page is nice because its live
comes from the community knowledge, but I'm not interested in that fighting,
so I have made a Leo wiki page in our local Wiki:

http://www.el-directorio.org:8080/Leo

and when I have enough knowledge about Leo (and time) I hope to start making
contribs in the spanish documentation (for the moment I'm only workind in the
evangelism here).
</t>
<t tx="ekr.20060227131611">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3593116
By: ktenney

Zope3, with it's component based architecture,
has machinery which hooks components together ..
Interfaces, Adapters and ZCML, the configuration
language.

It sounds like the autocompleter code is able
to build indexes of classes and methods. It would
be cool if that capability could be extensible,
allowing building indexes of the couplings between
components.

I think this might look like some kind of automatic
hyperlinking, providing access to related code,
as defined for that application.

I really don't know if this makes sense, but
I see you moving in the direction of making Leo
capable of doing some _explaining_ of the code 
being written.
</t>
<t tx="ekr.20060306194040">The curse of knowledge
http://groups.google.com/group/leo-editor/browse_thread/thread/3e75787223ee9303

(Rich) I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
</t>
<t tx="ekr.20060328171518">Leo 4.4 beta 3                                             April 14, 2006

This version fixes some minor problems and adds various features.  This code
has been in use for several weeks without any major problems reported.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060328171518.1"></t>
<t tx="ekr.20060328171518.10">http://sourceforge.net/forum/message.php?msg_id=3608246

Added the following commands:

scroll-outline-down-line       
scroll-outline-down-page       
scroll-outline-up-line       
scroll-outline-up-page
</t>
<t tx="ekr.20060328171518.101">Apparently g.app.unitTesting isn't set properly for the new-window test.
</t>
<t tx="ekr.20060328171518.108">The bug: Hit control-f, then select the text that doesn't have focus.
</t>
<t tx="ekr.20060328171518.11">It now properly creates bindings.
</t>
<t tx="ekr.20060328171518.111">http://sourceforge.net/forum/message.php?msg_id=3641107

ConfigSettings.initEncoding now uses the g.app.config settings if no other settings are available.

In particular, this causes at.encoding to be inited to a reasonable value.
</t>
<t tx="ekr.20060328171518.119">- onBodyChanged now converts everything to unicode, either directly or by calling g.app.gui.getAllText.

- Replaced all calls to g.safeStringCompare by g.app.gui.getAllText which calls g.toUnicode.

- Converted all shortcuts to unicode in shortcutFromSetting (a.k.a strokeFromSetting)

- Removed g.safeStringCompare.  This function was a bad idea.

Important: Leo is supposed to convert all characters to unicode, so there should
never be a need for safeStringCompare. The proper way to avoid UnicodeError's is
to call g.toUnicode(s,g.app.tkEncoding).
</t>
<t tx="ekr.20060328171518.135">http://sourceforge.net/forum/message.php?msg_id=3607355
</t>
<t tx="ekr.20060328171518.15"></t>
<t tx="ekr.20060328171518.151"></t>
<t tx="ekr.20060328171518.152">http://sourceforge.net/forum/message.php?msg_id=3573148

c.openWith now calls g.enableIdleTimeHook
</t>
<t tx="ekr.20060328171518.16">http://sourceforge.net/forum/message.php?msg_id=3572598
</t>
<t tx="ekr.20060328171518.169">These commands now set g.app.globalOpenDir.
</t>
<t tx="ekr.20060328171518.190">http://sourceforge.net/forum/message.php?msg_id=3585710
</t>
<t tx="ekr.20060328171518.191"></t>
<t tx="ekr.20060328171518.238">http://sourceforge.net/forum/message.php?msg_id=3637393

I'm trying to set up a default stylesheet for a project and want this to be
held relative to the project directory (where the .leo file is). The default
is to place it in the same directory as the output, which is a couple of levels
down.

http://sourceforge.net/forum/message.php?msg_id=3639216

g.os_path_dirname(self.outputFileName) with self.c.frame.openDirectory. This
makes the path relative to the project. Not 100% as the stylesheet filename
would need a path embedded in it to move the location down the tree. However,
it is consistent with the way the output file is named.
</t>
<t tx="ekr.20060328171518.240">See the chapters2 in leoPlugins.leo.

See also:

http://sourceforge.net/forum/message.php?msg_id=3626542

https://sourceforge.net/forum/message.php?msg_id=3629055

http://sourceforge.net/forum/message.php?msg_id=3632004
</t>
<t tx="ekr.20060328171518.244">Cleaned up the code and added support minibuffer commands:

group-operations-clear-marked       = Alt-Ctrl-Shift-l
group-operations-mark-for-copy      = Alt-Ctrl-Shift-c
group-operations-mark-for-move      = Alt-Ctrl-Shift-m
group-operations-mark-for-clone     = Alt-Ctrl-`
group-operations-mark-target        = Alt-Ctrl-Shift-t
group-operations-operate-on-marked  = Alt-Ctrl-Shift-o
group-operations-transfer           = Alt-Ctrl-Shift-d

This code has not been tested with the chapters2 plugin.
</t>
<t tx="ekr.20060328171518.245">http://sourceforge.net/forum/message.php?msg_id=3617936

The fix was to plugins_menu.py: the cmd_callback must have an event argument.
</t>
<t tx="ekr.20060328171518.246">The fix: all menu commands now have event=None in their argument list.
</t>
<t tx="ekr.20060328171518.248">Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
</t>
<t tx="ekr.20060328171518.249">It's not ready for prime time.
</t>
<t tx="ekr.20060328171518.45">This is equivalent to the Unit Test script button in unitTest.leo
</t>
<t tx="ekr.20060328171518.47"></t>
<t tx="ekr.20060328171518.48">http://sourceforge.net/forum/message.php?msg_id=3619340

Just tried out CVS today, and on Linux left/right and L/R in outline mode
(Ctrl-Shift-O) seem to do nothing, whereas they should expand/contract parent
nodes.
</t>
<t tx="ekr.20060328171518.57">http://sourceforge.net/forum/message.php?msg_id=3639193

The dirty bits were not updated properly in several undo/redo operations.
</t>
<t tx="ekr.20060328171518.83">http://sourceforge.net/forum/message.php?msg_id=3642892

The present code is probably the best compromise between strict accuracy and marking too many nodes dirty.
</t>
<t tx="ekr.20060328171518.85">http://sourceforge.net/forum/message.php?msg_id=3606515

Added insert-newline command and fixed some related commands.
</t>
<t tx="ekr.20060329101442">Missing modules can cause installation problems.
If the installer doesn't work (or puts up a dialog containing no text), you may install Leo from the .zip file
as described at `How to install Leo on Windows`_.
However you are installing Leo,
be sure to `run Leo in a console window`_.
because as a last resort Leo prints error messages to the console.
</t>
<t tx="ekr.20060331094112">To generate a SSH key using PuTTY:

Execute c:\"Program Files"\tortoiseCVS\PUTTYGEN.EXE

Select "SSH2 DSA", within the "Parameters" section.

Click on the "Generate" button. Follow the instruction to move the mouse over
the blank area of the program in order to create random data used by PUTTYGEN to
generate secure keys. Key generation will occur once PUTTYGEN has collected
sufficient random data.

Enter edream@cvs.sourceforge.net for the key comment (depends on what host the
key is for)

(Omit) Enter the desired passphrase in the "Key passphrase" and "Confirm passphrase"
fields. If the key will be used for automation of operations (i.e. as part of a
script), you may choose to omit this step from the key generation process.

Click on the "Save private key" button. Use the resulting dialog to save your
private key data for future use. You may use a filename such as
"SourceForge-Shell.ppk" or "SourceForge-CF.ppk". The .ppk extension is used for
PuTTY Private Key files.

Go to the SSH key posting page on the SourceForge.net site: http://sourceforge.net/account/

Copy your public key data from the "Public key for pasting into OpenSSH
authorized_keys2 file" section of the PuTTY Key Generator, and paste the key
data to the provided form on the SourceForge.net site. Click on the "Update"
button to complete the posting process.

Exit the PuTTY Key Generator (PUTTYGEN).

Key data sync to hosts from the SourceForge.net site occurs on regular
intervals. Your key data will be synchronized to the designated servers (either
shell and CVS, or the Compile Farm) after a short delay.
</t>
<t tx="ekr.20060414071350.1"></t>
<t tx="ekr.20060414071350.47">exception executing command
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 884, in clearRecentFiles
    u.afterClearRecentFiles(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 621, in afterClearRecentFiles
    u.pushBead(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 192, in pushBead
    u.setUndoTypes()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 341, in setUndoTypes
    u.cutStack()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 136, in cutStack
    if bunch.kind == 'beforeGroup':
AttributeError: 'Bunch' object has no attribute 'kind'
</t>
<t tx="ekr.20060414071350.58"># No change for now
C:\prog\tigris-cvs\leo\src\leoKeys.py:1050: Parameter (thread) not used

# Fixed
C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py:1428: Function returns a value and also implicitly returns None
C:\prog\tigris-cvs\leo\src\leoTkinterTree.py:1222: Local variable (delta) not used
C:\prog\tigris-cvs\leo\src\leoKeys.py:1931: Local variable (f) not used
C:\prog\tigris-cvs\leo\src\leoGlobals.py:5246: Local variable (buttonList) not used
C:\prog\tigris-cvs\leo\src\leoCommands.py:493: No global (enableIdleTimeHook) found
</t>
<t tx="ekr.20060414071350.8">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3671350

Change aString.lstrip and aString.rstrip to the aString.replace.
@color
</t>
<t tx="ekr.20060417092536">Leo 4.4 beta 4                                             April 21, 2006

This version fixes a long-standing MacOS bug.  It is likely to be the last
beta release before 4.4 final.  This release also adds several new commands
and contains a script for updating leoSettings.leo.

Warning: The previous beta was not widely distributed. Please do some testing in
your environment before recommending this version of Leo to others, (such as
your students).

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060417092825.1">See the (presently disabled) script button in scripts.leo at:

Buttons--&gt;@@button updateSettings

From the docstring:

Here is a **preliminary** script that updates a new leoSettings.leo file
(path2) from the settings in a previous leoSettings.leo file (path1).
Presumably, the path2 file is the leoSettings.leo file from a new distribution,
and the path1 file a leoSettings.leo file containing settings that you have
modified.  You must specify the full path of both files in the top-level @button node.

**Warning**: This script modifies the path2 file. Make sure that you don't mind
modifying this file.

**Warning**: This script is unsophisticated in its update algorithm. If if finds
corresponding nodes (node with the same settings name) in both outlines it simply
replaces the node in the path2 file with the node in the path1 file. In
particular, it does not keep track of individual shortcuts: it replaces the body
of one @shortcuts node with the body of the corresponding @shortcuts node.

**Note**: If the path1 file contains a settings node not in the path2 file it
attempts to create a new node in the corresponding place in the path2 file. If
this is not possible, say because the structures of the files are different, the
script places the new node as the last child of the @settings node in the path2
file.
</t>
<t tx="ekr.20060421070409.1"></t>
<t tx="ekr.20060421070409.10">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247

Find panel cannot be re-opened. Run open-find-dialog. Close it. Run open-find-dialog
again -- crash.

The fix was to move the line:

self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)

from createBindings to createFrame in the leoTkinterFind class.
</t>
<t tx="ekr.20060421070409.11">TclError Exception in Tk callback
  Function: &lt;function bindKeyCallback at 0x0169B170&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01865EB8&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 1991, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2931, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2990, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2208, in callStateFunction
    val = k.state.handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2289, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2327, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2801, in showFindPanel
    c.frame.findPanel{|{ingToFront()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFind.py", line 469, in bringToFront
    self.top.withdraw() # Helps bring the window to the front.
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1562, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".25637872"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1486
    state: 0
    time: 1717970
    type: 2
    widget: .17570752.17571352.19882152.minibuffer
    width: ??
    x: 183
    x_root: 576
    y: -62
    y_root: 859

</t>
<t tx="ekr.20060421070409.2">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3688804
By: paulpaterson

It seems that copying and pasting nodes with CTRL-SHIFT-C, V is not working.
- (legacy bindings)
- select a node
- CTRL-SHIFT-C
- CTRL-SHIFT-V
- Vim opens up! I expect to paste the node. The clipboard doesn't seem to contain
any XML
- The menu items show that these keys are bound to the copy and paste node
commands

*** Also on legacy bindings the arrow keys don't seem to move the cursor in the
body.
</t>
<t tx="ekr.20060421070409.3"></t>
<t tx="ekr.20060421070409.33"># getLeadinWord must clear self.membersList to disable completion.
</t>
<t tx="ekr.20060421070409.36">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\Documents and Settings\Ed\My Documents\ekr.leo
rst3 plugin: SilverCity not loaded
exception executing command
Traceback (most recent call last):

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2969, in pasteOutline
    u.afterInsertNode(pasted,undoType,undoData)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 750, in afterInsertNode
    u.pushBead(bunch)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 182, in pushBead
    if bunch2 and bunch2.kind == 'beforeGroup':

AttributeError: 'Bunch' object has no attribute 'kind'
</t>
<t tx="ekr.20060421070409.37"></t>
<t tx="ekr.20060421070409.4">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247
By: vpe

After cutting selection in the headline, headline area shrinks too much.  Example:
headline is 'NewHeadline', select last 'e', ctrl-x, it shrinks to 'Ne'

To fix by hand: add

s=g.app.gui.getAllText(w)

Just before

w.configure(width=f.tree.headWidth(s=s))

in cutText in leoTkFrame.py
</t>
<t tx="ekr.20060421070409.40"></t>
<t tx="ekr.20060421070409.41">New commands:

add-space-to-lines,
add-tab-to-lines
clean-lines
clear-selected-text
goto-global-line
help-for-command
open-outline-by-name (filename completion)
remove-space-from-lines
remove-tab-from-lines
</t>
<t tx="ekr.20060421070409.9"></t>
<t tx="ekr.20060421070602"></t>
<t tx="ekr.20060428084553">Leo 4.4 release candidate 1                                 April 28, 2006

This version fixes a few minor bug reported in 4.4b4 and adds 9 new commands.
The open-outline-by-name command supports filename completion.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060428084553.10">http://sourceforge.net/forum/message.php?msg_id=3692247

Find panel cannot be re-opened. Run open-find-dialog. Close it. Run open-find-dialog
again -- crash.
</t>
<t tx="ekr.20060428084553.2"></t>
<t tx="ekr.20060428084553.273">At present, only the open-outline-by-name command supports filename completion.
</t>
<t tx="ekr.20060428084553.34"># getLeadinWord must clear self.membersList to disable completion.
</t>
<t tx="ekr.20060428084553.37">Traceback (most recent call last):

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)

  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2969, in pasteOutline
    u.afterInsertNode(pasted,undoType,undoData)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 750, in afterInsertNode
    u.pushBead(bunch)

  File "C:\prog\tigris-cvs\leo\src\leoUndo.py", line 182, in pushBead
    if bunch2 and bunch2.kind == 'beforeGroup':

AttributeError: 'Bunch' object has no attribute 'kind'
</t>
<t tx="ekr.20060428084553.38"></t>
<t tx="ekr.20060428084553.39">Useful, e.g., after a find.
</t>
<t tx="ekr.20060428084553.4">http://sourceforge.net/forum/message.php?msg_id=3692247

After cutting selection in the headline, headline area shrank too much.  
</t>
<t tx="ekr.20060428084553.41">self.beginCommand(undoType='xxx')
...
self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20060428084553.42">New commands:

add-space-to-lines
add-tab-to-lines
clean-lines
clear-selected-text
goto-global-line
help-for-command
remove-space-from-lines
remove-tab-from-lines
</t>
<t tx="ekr.20060428084711">https://sourceforge.net/forum/message.php?msg_id=3699799
</t>
<t tx="ekr.20060428084957"></t>
<t tx="ekr.20060430220749">The jEdit_ editor drives its syntax colorer using xml **language description files.**
Rather than using the xml language description files directly, Leo uses
Python **colorer control files**, created automatically from the xml files by a
script called jEdit2Py.  All these files reside in the leo/modes directory.

These Python files contain all the information in the jEdit's xml files, so we
can (loosely) speak of modes, rulesets, rules, properties and attributes in the
Python colorer control files. Later sections of this documentation will make
this loose correspondence exact.

`jEdit's documentation`_ contain a complete description of these xml files.
Each xml file describes one **colorizing mode**.
A mode consists of one or more **rulesets**, and each ruleset consists of a list of **colorizing rules**.
In addition, modes, rulesets and rules may have associated **properties** and **attributes**.
Various rules may specify that the colorizer uses another ruleset (either in the same mode or another mode).

**Important**: jEdit's xml language description files contain no explicit &lt;RULE&gt; elements
Rules are simply sub-elements of an enclosing &lt;RULES&gt; element.
The element indicates the kind of rule that is specified,
for example, &lt;SPAN&gt;, &lt;SEQ&gt;, etc.
By the term **rule element** we shall mean any sub-element of the &lt;RULES&gt; element.

**Important**: throughout this documentation,
**x.py** will refer to the Python colorer for language x,
and **x.xml** will refer to the corresponding xml language-description file.

Using Python colorer control files has the following advantages:

- Running jEdit2Py need only be done when x.xml changes,
  and the speed of the xml parser in jEdit2Py does not affect the speed of Leo's colorizer in any way.
  Moreover, the jEdit2Py script can contain debugging traces and checks.

- Colorer control files are valid .py files, so all of Python's import optimizations work as usual.
  In particular, all the data in colorer control files is immediately accessible to Leo's colorer.

- Colorer control files are easier for humans to understand and modify than the equivalent xml file.
  Furthermore, it is easy to insert debugging information into Python colorer control files.

- It is easy to modify the Python colorer control files 'by hand' without changing the corresponding xml file.
  In particular, it would be easy to define entirely new kinds of pattern-matching rules in Python merely
  by creating functions in a colorer control file.
</t>
<t tx="ekr.20060430221745"></t>
<t tx="ekr.20060430221745.1">###########################
Controlling Syntax Coloring
###########################

This chapter discusses the settings to control Leo's syntax colorer. This
chapter also discusses how to extend Leo's colorizer by creating xml language
descriptions files and corresponding Python files. **Important**: this material
is for those who want to support Leo's colorizing code. To use Leo's colorizers
you only need to know about syntax-coloring settings.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20060430222753">.. External links...
.. _jEdit:                      http://www.jedit.org/
.. _`jEdit's documentation`:    http://www.jedit.org/42docs/users-guide/writing-modes-part.html

.. Relative links...
.. _`Ruleset name`:      `Ruleset names`_
.. _`Customizing Leo`:           customizing.html
</t>
<t tx="ekr.20060502084233">When Leo's syntax colorer sees the '@language x' directive,
it will import x.py from Leo's modes folder.
The colorer can then access any module-level object obj in x.py as x.obj.

Colorizer control files contain **rules functions** corresponding to rule elements in x.xml.
The colorizer can call these functions as if they were members of the colorizer class by
passing 'self' as the first argument of these functions.
I call these rules *functions* to distinguish them from the corresponding
**rules methods** which are actual methods of the colorizer class.
Rules *functions* merely call corresponding rules *methods*.
Indeed, rules functions are simply a way of binding values to keyword arguments of rules methods.
These keywords arguments correspond to the xml attributes of rule elements in x.xml.

The colorizer calls rules functions until one matches, at which point a range of text gets colored and the process repeats.
The inner loop of the colorizer is this code::

    for f in self.rulesDict.get(s[i],[]):
        n = f(self,s,i)
        if n &gt; 0:
            i += n ; break
        else: i += 1

- rulesDict is a dictionary whose keys are rulesets and whose values are ruleset dictionaries.
  Ruleset dictionaries have keys that are single characters and whose values are
  the list of rules that can start with that character. 

- s is the full text to be colorized.

- i is the position within s is to be colorized.

Rules methods (and functions) return n &gt; 0 if they match, and n == 0 if they fail.
</t>
<t tx="ekr.20060502084233.1">The following sections describe the top-level data in x.py.
</t>
<t tx="ekr.20060502090516">**x.properties** is a Python dictionary corresponding to the &lt;PROPS&gt; element in x.xml.
Keys are property names; values are strings, namely the contents of &lt;PROPERTY&gt; elements in x.xml.
x.properties contains properties for the entire mode.
That is, only modes have &lt;PROPS&gt; elements.
For example, here is x.properties in php.py::

    # properties for mode php.xml
    properties = {
        "commentEnd": "--&gt;",
        "commentStart": "&lt;!--",
        "indentCloseBrackets": "}",
        "indentOpenBrackets": "{",
        "lineUpClosingBracket": "true",
    }
</t>
<t tx="ekr.20060502090516.1">x.py contains a **keyword dictionary** for each ruleset in x.xml.
x.py contains an empty keywords dictionary if a ruleset contains no &lt;KEYWORDS&gt; element.

Keys are strings representing keywords of the language describe by the mode.
Values are strings representing syntactic categories,
i.e. a TYPE attribute valid in x.xml, namely:
COMMENT1, COMMENT2, COMMENT3, COMMENT4,
FUNCTION,
KEYWORD1, KEYWORD2, KEYWORD3, KEYWORD4,
LABEL, LITERAL1, LITERAL2, LITERAL3, LITERAL4,
MARKUP, NULL and OPERATOR.

For example, here (parts of) some keyword dictionaries in php.py::

    # Keywords dict for mode php::PHP
    php_PHP_keywords_dict = {
        "COM_invoke": "keyword2",
        "COM_load": "keyword2",
        "__CLASS__": "keyword3",
        ...
        "abs": "keyword2",
        "abstract": "keyword1",
        "accept_connect": "keyword2",
        ...
    }

    # Keywords dict for mode php::JAVASCRIPT_PHP
    php_JAVASCRIPT_PHP_keywords_dict = {}

    # Keywords dict for mode php::PHPDOC
    php_PHPDOC_keywords_dict = {
        "@abstract": "label",
        "@access": "label",
        "@author": "label",
        ...
        "@var": "label",
        "@version": "label",
    }

x.py also contains **x.keywordsDictDict**.
Keys are ruleset names, values are keywords dictionaries.
Here is keywordsDictDict for php.py::

    # Dictionary of keywords dictionaries for php mode.
    keywordsDictDict = {
        "php_javascript": php_javascript_keywords_dict,
        "php_javascript_php": php_javascript_php_keywords_dict,
        "php_main": php_main_keywords_dict,
        "php_php": php_php_keywords_dict,
        "php_php_literal": php_php_literal_keywords_dict,
        "php_phpdoc": php_phpdoc_keywords_dict,
        "php_tags": php_tags_keywords_dict,
        "php_tags_literal": php_tags_literal_keywords_dict,
    }

The colorizer can get the keywords dictionary for a ruleset as follows::

    keywordsDict = x.keywordsDictDict(rulesetName)

**Note**:
The jEdit2Py script creates 'friendly' names for keyword dictionaries *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.keywordsDictDict;
Leo's colorer never uses the actual names of keywords dictionaries such as php_PHPDOC_keywords_dict.
</t>
<t tx="ekr.20060502090516.2">x.py contains one **rule function** for every rule in every ruleset (&lt;RULES&gt; element) in x.xml.
These rules have names rule1 through  ruleN,
where N is the total number of rules in all rulesets in x.xml.

Each rules *function* merely calls a rules *method* in Leo's colorizer.
Which method gets called depends on the corresponding element in `x.xml`.
For example, the first rule in php.xml is::

    &lt;SPAN TYPE="MARKUP" DELEGATE="PHP"&gt;
		&lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt;
		&lt;END&gt;?&amp;gt;&lt;/END&gt;
	&lt;/SPAN&gt;

and the corresponding rule function is::

    def php_rule0(colorer, s, i):
        return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="PHP",exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)


php_rule0 calls colorer.match_span because the corresponding xml rule is a &lt;SPAN&gt; element.

For each ruleset, x.py also contains a **rules dictionary**,
a Python dictionary whose keys are characters and whose values are all lists
of rules functions that that can match the key.
For example::

    # Rules dict for phpdoc ruleset.
    rulesDict8 = {
        "*": [rule64,],
        "0": [rule70,],
        "1": [rule70,],
        "2": [rule70,],
        "3": [rule70,],
        "4": [rule70,],
        "5": [rule70,],
        "6": [rule70,],
        "7": [rule70,],
        "8": [rule70,],
        "9": [rule70,],
        "&lt;": [rule65,rule66,rule67,rule68,rule69,],
        "@": [rule70,],
        "A": [rule70,],
        "B": [rule70,],
        ...
        "X": [rule70,],
        "Y": [rule70,],
        "Z": [rule70,],
        "_": [rule70,],
        "a": [rule70,],
        "b": [rule70,],
       ...
        "x": [rule70,],
        "y": [rule70,],
        "z": [rule70,],
        "{": [rule63,],
    }

**Note**: The order of rules in each rules list is important;
it should be the same as rules element in x.xml.

Finally, x.py contains **x.rulesDictDict**.
Keys are ruleset names, values are rules dictionaries.
The colorer can get the rules list for character ch as follows::

    self.rulesDict = x.rulesDictDict.get(rulesetName) # When a mode is inited.
    ...
    rules = self.rulesDict.get(ch,[]) # In the main loop.

For example, here is the rules dictionary for php.py::

    # x.rulesDictDict for php mode.
    rulesDictDict = {
        "php_javascript": rulesDict6,
        "php_javascript_php": rulesDict7,
        "php_main": rulesDict1,
        "php_php": rulesDict4,
        "php_php_literal": rulesDict5,
        "php_phpdoc": rulesDict8,
        "php_tags": rulesDict2,
        "php_tags_literal": rulesDict3,
    }

**Note**:
The jEdit2Py script creates 'friendly' names for rules lists *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.rulesDictDict;
Leo's colorer never uses the actual names of rules lists such as rulesDict8,
and Leo's colorer never uses the actual names of rules functions such as rule64.
</t>
<t tx="ekr.20060502100550">A **ruleset name** is a Python string having the form 'x_setname',
where setname is the value of the SET attribute of the &lt;RULES&gt; element in x.xml.
For example, the ruleset name of the ruleset whose SET attribute is JAVASCRIPT in php.xml is
'php_JAVASCRIPT'.
**Important**: by convention, the ruleset name of the default &lt;RULES&gt; element is 'x_main';
note that default &lt;RULES&gt; element have no SET attributes.

The colorizer uses ruleset names to gain access to all data structures in x.py.
To anticipate a bit, ruleset names are keys into two standard dictionaries,
x.rulesDict and x.keywordsDictDict,
from which the colorizer can get all other information in x.py::

    # The rules list for the 'JAVASCRIPT' ruleset in php.xml.
    rules = x.rulesDict('php_JAVASCRIPT')

    # The keywords dict for the 'JAVASCRIPT' ruleset in php.xml.
    keywordsDict = x.keywordsDictDict('php_JAVASCRIPT')

In fact, ruleset names (and x.rulesDict and x.keywordsDictDict)
are the **only** names that the colorizer needs to know in order to access all information in x.py.
</t>
<t tx="ekr.20060502122950">This section describes each rules method in Leo's new colorizer.
Rules methods are called by rules functions in colorizer control file;
they correspond directly to rules elements in jEdit's language description files.
In fact, this documentation is a 'refactoring' of `jEdit's documentation`_.

All rule methods attempt to match a pattern at a particular spot in a string.
These methods all return True if the match succeeds.
</t>
<t tx="ekr.20060502122950.10">::

    def match_eol_span_regexp (self,s,i,kind,regex,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = '',
        exclude_match = False):

match_eol_span_exp succeeds if:

1. The regular expression regex matches at s[i:], and

2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_eol_span_regexp  highlights from i to the end of the line.
If the exclude_match argument is True, only the text before the matched text will be colored.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502122950.13">::

    def match_keywords (self,s,i):

match_keywords succeeds if s[i:] starts with an identifier contained in the mode's keywords dictionary d.

If successful, match_keywords colors the keyword.
match_keywords does not take a kind keyword argument.
Instead, the keyword is colored as specified by d.get(theKeyword).
</t>
<t tx="ekr.20060502122950.14">::

    def match_mark_following (self,s,i,kind,pattern,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False):

match_mark_following succeeds if s[i:].startswith(pattern), and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_mark_following colors from i to the start of the next token
with the color specified by kind.
If the exclude_match argument is True, only the text after the matched text will be colored.
</t>
<t tx="ekr.20060502122950.40">::

    def match_seq (self,s,i,kind,seq,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = ''):

match_seq succeeds if s[i:].startswith(seq) and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_seq highlights from i to the end of the sequence
with the color specified by kind.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502122950.41">::

    def match_seq_regexp (self,s,i,kind,regex,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = ''):

match_seq succeeds if:

1. The regular expression regex matches at s[i:], and

2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_seq_regexp highlights from i to the end of the sequence
with the color specified by kind.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502122950.42">::

    def match_span (self,s,i,kind,begin,end,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False,
        delegate = ''
        no_escape = False,
        no_line_break = False,
        no_word_break = False):

match_span succeeds if there is an index j &gt; i such that
s[:i].startswith(begin) and s[i:j].endswith(end) and the
at_line_start, at_whitespace_end, at_word_start,
no_escape, no_line_break and no_word_break conditions are all satisfied.

If successful, match_span highlights from s[i:j
with the color specified by kind;
but if the exclude_match argument is True, the begin and end text are not colored.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502122950.47">::

    def match_span (self,s,i,kind,regex,end,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False,
        delegate = ''
        no_escape = False,
        no_line_break = False,
        no_word_break = False):

match_span_regex succeeds if:

1. The regular expression regex matches at s[i:],

2. There is an index j &gt; i such that s[i:j].endswith(end),

3. The at_line_start, at_whitespace_end, at_word_start,
   no_escape, no_line_break and no_word_break conditions are all satisfied.

If successful, match_span colors s[i:j],
with the color specified by kind;
but if the exclude_match argument is True, the begin and end text are not colored.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502122950.48">::

    def match_terminate (self,s,i,kind,at_char):

match_terminate succeeds if s[i:] contains at least at_char more characters.

If successful, match_terminate colors at_char characters
with the color specified by kind.
</t>
<t tx="ekr.20060502122950.7">::

    def match_eol_span (self,s,i,kind,begin,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        delegate = '',
        exclude_match = False):

match_eol_span succeeds if s[i:].startswith(begin) and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_eol_span highlights from i to the end of the line
with the color specified by kind.
If the exclude_match argument is True, only the text before the matched text will be colored.
The delegate argument, if present, specifies the ruleset to color the colored text.
</t>
<t tx="ekr.20060502125223">::

    def match_mark_previous (self,s,i,kind,pattern,
        at_line_start = False,
        at_whitespace_end = False,
        at_word_start = False,
        exclude_match = False):

match_mark_previous succeeds if s[i:].startswith(pattern),and
the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied.

If successful, match_mark_previous colors from the end of the previous token to i
with the color specified by kind.
If the exclude_match argument is True, only the text before the matched text will be colored.
</t>
<t tx="ekr.20060503064515">All rule methods take three required arguments and zero or more optional keyword arguments.

Here is a list of the required arguments and their meaning:

- **self**: An instance of Leo's colorizer.

- **s**: The string in which matches may be found.

- **i**: The location within the string at which the rule method looks for a match.

Here is a list of all optional keyword arguments and their meaning:

- **at_line_start**:
  If True, a match will succeed only if i is at the start of a line.

- **at_whitespace_end**:
  If True, the match will succeed only if i is at the first non-whitespace text in a line.

- **at_word_start**:
  If True, the match will succeed only if i is at the beginning of a word.

- **delegate**:
  If non-empty, the value of this argument is a `ruleset name`_.
  If the match succeeds, the matched text will be colored recursively with the indicate ruleset.

- **exclude_match**:
  If True, the actual text that matched will not be colored.
  The meaning of this argument varies slightly depending on whether one or two sequences are matched.
  See the individual rule methods for details.

- **kind**: A string representing a class of tokens, i.e., one of:
  'comment1', 'comment2', 'comment3', 'comment4', 'function',
  'keyword1', 'keyword2', 'keyword3', 'keyword4',
  'label', 'literal1', 'literal2', 'literal3', 'literal4',
  'markup', 'null' and 'operator'.

- **no_escape**:
  If True, the ruleset's escape character will have no effect before the end argument to match_span.
  Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored.

- **no_line_break**:
  If True, the match will not succeed across line breaks.

- **no_word_break**:
  If True, the match will not cross word breaks.

New in Leo 4.4.1 final: the regular expression rule matchers no longer get a hash_char argument
because such matchers are called only if the present search pattern starts with hash_char.
</t>
<t tx="ekr.20060503072213">x.importDict is a Python dictionary.
Keys are ruleset names; values are a list of ruleset names.
For example::

    # Import dict for php mode.
    importDict = {
        "php_javascript_php": ["javascript::main"],
    }

For any ruleset R whose ruleset name is N, x.importDict.get(N)
is the list of rulesets names whose rulesets appear in
a DELEGATE attribute of an &lt;IMPORT&gt; rule element in R's ruleset.
Such **imported** ruleset are copied to the end of the R's rules list.
Leo's colorizer does this copying only once, when loading ruleset R for the first time.

**Note 1**: Loading imported rulesets must be done at 'run time'.
It should definitely not be done by jEdit2Py at 'compile time';
that would require running jEdit2Py on *all* .xml files whenever any such file changed.

**Note 2**:  Multiple &lt;IMPORT&gt; rule elements in a single ruleset are allowed:
delegated rules are copied to the end of N's rules list in the order they appear in the ruleset.

**Note 3**: The DELEGATE attribute of &lt;IMPORT&gt; elements is, in fact,
completely separate from the DELEGATE attributes of other rules as
discussed in `Arguments to rule methods`_.
Indeed, the DELEGATE attribute of &lt;IMPORT&gt; elements creates entries in
x.importDict, which in turn causes the colorizer to append the rules of the imported ruleset
to the end of the present rules list.
In contrast, the DELEGATE attributes of other rules sets the delegate argument to rules methods,
which in tern causes the colorizer to recursively color the matched text with the **delegated** ruleset.
In short:

- The rules of **imported** rulesets are appended to the end of another rules list;
  the rules of **delegated** rulesets never are.

- **Imported** ruleset names appear as the values of items in x.importDict;
  **delegated** ruleset names appear as delegate arguments to rule methods.
</t>
<t tx="ekr.20060510085547">x.py contains a **attribute dictionary** for each ruleset in x.xml.
Keys are attribute names, values strings representing the values of the attributes.
This dictionary is empty if a ruleset contains no attributes.
The valid keys are:

- 'default': the default token type.  'null' is the default.

- 'digit_re': a regular expression.
  Words matching this regular expression are colored with the digit token type.

- 'ignore_case': 'true' or 'false'.  Default is 'true'.

- 'highlight_digits': 'true' or 'false'.  Default is 'true'.

- 'no_word_sep': A list of characters treated as 'alphabetic' characters when matching keywords.

For example, here is one attribute dictionary in php.py::

    # Attributes dict for php_javascript ruleset.
    php_javascript_attributes_dict = {
        "default": "MARKUP",
        "digit_re": "",
        "highlight_digits": "true",
        "ignore_case": "true",
        "no_word_sep": "",
    }

x.py also contains **x.attributesDictDict**.
Keys are ruleset names, values are attribute dictionaries.
Here is attributesDictDict for php.py::

    # Dictionary of attributes dictionaries for php mode.
    attributesDictDict = {
        "php_javascript": php_javascript_attributes_dict,
        "php_javascript_php": php_javascript_php_attributes_dict,
        "php_main": php_main_attributes_dict,
        "php_php": php_php_attributes_dict,
        "php_php_literal": php_php_literal_attributes_dict,
        "php_phpdoc": php_phpdoc_attributes_dict,
        "php_tags": php_tags_attributes_dict,
        "php_tags_literal": php_tags_literal_attributes_dict,
    }

**Note**:
The jEdit2Py script creates 'friendly' names for attribute dictionaries *solely* as an aid for people reading the code.
Leo's colorer uses only the name x.attributeDictDict;
Leo's colorer never uses the actual names of attribute dictionaries.
</t>
<t tx="ekr.20060511074853">Leo 4.4 Final                                                     May 11, 2006

Leo 4.4 Final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.
  To enable autocompletion, bind a key to the auto-complete command.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060527103630">A new method has been added to make it more easily to write rST code from scripts::

    c.rstCommands.writeNodeToString(p)

writeNodeToString scans p's tree (p defaults to presently selected node) looking for @rst nodes.
When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes:

- @rst need not be followed by a filename; any filename and its extension are *ignored*.

- Only the ext argument to writeNodeToString determines the type of output produced.
  The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'.

- Instead of writing the result to a file, writeNodeToString returns the tuple (p,s),
  where p is the node whose tree produced the output, and s is the output itself.

- writeNodeToString returns after processing at most one @rst node.

Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output.
For example::

    p,s = c.rstCommands.writeNodeToString(p,ext='html')

Notes:

- This script scans the presently selected tree for @rst nodes.
  In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees.
  When an @rst node is found, it converts the node (and descendants) to html and returns p,
  the found @rst node and s, the html itself.

- Valid values for the ext argument are ".html", ".tex" or None (specifies rst output)

- There is some support for ext=".pdf", but this is experimental code.  Expect crashes.
</t>
<t tx="ekr.20060527105211" str_atime="1376414159.0"></t>
<t tx="ekr.20060527105617">##################
Debugging with Leo
##################

This chapter discusses debugging Python scripts with Leo.
Be aware of the distinction between **Leo-specific** scripts and **general** scripts.
Leo-specific scripts access data in the Leo outline in which they are contained;
general scripts do not.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20060527105804">.. External links...
.. _Idle:                       http://www.python.org/idle/
.. _pdb:                        http://docs.python.org/lib/module-pdb.html
.. _winpdb:                     http://www.digitalpeers.com/pythondebugger/
.. _`the FAQ`:                  http://leoeditor.com/FAQ.html#how-can-i-use-python-s-pdb-debugger-with-leo
.. _`embedded winpdb`:          http://www.digitalpeers.com/pythondebugger/embedded.htm
.. _`Leo's forums`:             http://sourceforge.net/forum/?group_id=3458
.. _`work flow`:                http://leoeditor.com/FAQ.html#how-can-i-use-leo-to-develop-leo-itself

.. .. _`running Leo in a console`: http://leoeditor.com/FAQ.html#how-can-i-run-leo-from-a-console-window
.. _`running Leo from a console window`:    installing.html#running-leo-from-a-console-window
.. _`run Leo in a console window`:          installing.html#running-leo-from-a-console-window
.. _`console window`:                       installing.html#running-leo-from-a-console-window
</t>
<t tx="ekr.20060527112801">The following settings in leoSettings.leo control debugger operation.
The settings shown here will be assumed to be in effect throughout this chapter::

    @string debugger_kind = winpdb

This setting controls what debugger the 'Debug Script' script button uses.
Eventually this setting will control what debugger the debug command uses::
At present the only valid value is 'winpdb'

    @bool write_script_file = True

True: The execute script command writes the script to be executed to a file,
then executes the script using Python's execFile function. The script_file_path
setting specifies the path to this file. False (legacy): The execute script
command uses Python's exec command to execute the script.

@string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command. Notes:

- This setting has effect only if the write_script_file setting is True.
- Use / as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py.
- The filename should end in .py.

@string debugger_path = None

</t>
<t tx="ekr.20060529053407">@ignore can only be used in the root node of @file trees.  It tells Leo to ignore the tree.

The @ignore directive can not be used elsewhere in @file trees because of the way Leo recreates 
outlines from external files. This is an absolutely crucial restriction and will never go away.
For a few more details, see `Leo 4.0: Eliminating error 'recovery'`_ in `History of Leo`_.

There are several workaround, as shown in LeoPy.leo:

- keep notes in the outline outside of any external file.

- Use @all to gather notes in a external file, as in done in @file leoProjects.txt.
</t>
<t tx="ekr.20060601101643">Leo 4.4.1 beta 1                                            June 3, 2006

Leo 4.4.1 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060601101958.1"></t>
<t tx="ekr.20060601101958.13">http://sourceforge.net/forum/message.php?msg_id=3737745

- Added event keyword argument to parameterize function.
</t>
<t tx="ekr.20060601101958.14">http://sourceforge.net/forum/message.php?msg_id=3737745

The fix was to add a c argument to g.findTopLevelNode and g.findNodeInTree.
</t>
<t tx="ekr.20060601101958.16"></t>
<t tx="ekr.20060601101958.172">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014

Actually, the run-unit-tests command first appeared in Leo 4.4, but it never got
properly announced.
</t>
<t tx="ekr.20060601101958.174">http://sourceforge.net/forum/message.php?msg_id=3729823

This is intended to help with redraw problems on Linux.
</t>
<t tx="ekr.20060601101958.2">http://sourceforge.net/forum/message.php?msg_id=3729858

Fixed crasher in Leo 4.4 by initing self.p in Quickfind ctor.
</t>
<t tx="ekr.20060601101958.218"></t>
<t tx="ekr.20060601101958.234"></t>
<t tx="ekr.20060601101958.235">It is now clearer what the selected values are.
</t>
<t tx="ekr.20060601101958.238"></t>
<t tx="ekr.20060601101958.239"></t>
<t tx="ekr.20060601101958.244">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737745

Added warnings in various places that the setting:

@bool expanded_click_area = True

interferes with the  Universal Scrolling plugin.
</t>
<t tx="ekr.20060601101958.245">The add-editor command adds a new editor, the delete-editor command deletes the
presently selected editor, and the cycle-editor-focus command cycles focus
between editors in the body text.
</t>
<t tx="ekr.20060601101958.264">@nocolor

leoSettings.leo now contains the following setting, with default as shown:

@bool autoindent_in_nocolor_mode = True


True:  auto-indent regardless of how text is colored.
False: disable auto-indenting if in range @nocolor or @kill.

This will make the default action work as Roger Erens requested, and will allow
you to make Leo work exactly as before if you want.
</t>
<t tx="ekr.20060601101958.276">@shortcut nodes never worked and apparently nobody ever used them.
</t>
<t tx="ekr.20060601101958.277"></t>
<t tx="ekr.20060601101958.28"></t>
<t tx="ekr.20060601101958.52">This runs the winpdb debugger in a separate process.

The winpdb debugger must be installed for this command to work.

For more details, see: http://leoeditor.com/debuggers.html
</t>
<t tx="ekr.20060601101958.56">This fixes all conflicts between Leo and Idle.
</t>
<t tx="ekr.20060601101958.58"></t>
<t tx="ekr.20060601101958.6">http://sourceforge.net/forum/message.php?msg_id=3737879
</t>
<t tx="ekr.20060601101958.70">- Allow \1, \2, etc. replacements in re searches.

- Allow \n and \t in plain searches.

- The shortcut for the replace-string command now changes from the find command
to the replace command.
</t>
<t tx="ekr.20060601102802"></t>
<t tx="ekr.20060601102802.2"></t>
<t tx="ekr.20060603072938">This prompts for a string s, then puts the result of help(s) in Leo's log pane.
</t>
<t tx="ekr.20060603081537">This plugin creates a 'Shortcut' button in the icon area. Pressing the Shortcut
button creates *another* button which when pressed will select the presently
selected node at the time the button was created.
</t>
<t tx="ekr.20060603082009">http://sourceforge.net/forum/message.php?msg_id=3761285

There were actually two bugs:

- parseLeoSentinel was not recognizing the closing comment delim (!!)

- putDirective was incorrectly setting delims for @language and @comment delims.
  This is wrong: the init code calls scanAllDirectives, and the comment delims
  **must not change** in the file (except as the result of @delims.)
</t>
<t tx="ekr.20060612102055" str_atime="1376414161.0">.. Most of this has nothing to do with *writing* plugins.</t>
<t tx="ekr.20060612103240" str_atime="1376414163.0">###############
Writing Plugins
###############

Plugins modify how Leo works. With plugins you can give Leo new commands,
modify how existing commands work, or change any other aspect of Leo's look
and feel.

leoPlugins.leo contains all of Leo's official plugins. Studying this file is
a good way to learn how to write plugins.

Writing plugins is like writing any other Leo script.  See
`Scripting Leo with Python`_. In particular:

1. Plugins can use any of Leo's source code simply by importing any module
   defined in leoPy.leo.

2. Plugins can register event handlers just like any other Leo script. For full
   details, see the section called `Handling Events`_ later in this chapter.

The rest of this chapters discusses topics related specifically to plugins.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20060612103824">.. External links...
.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html

.. Relative links...
.. _`Scripting Leo with Python`:    tutorial-scripting.html
.. _`Customizing Leo`:              customizing.html
</t>
<t tx="ekr.20060620094033.1">The main features of Leo 4.4.1 are:

- Multiple editors in Leo's body pane and
- A new colorizer plugin controlled by jEdit language description files.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.
</t>
<t tx="ekr.20060620094033.2">The main features of Leo 4.4 are:

- An Emacs-like mini-buffer: you can now execute any command by typing its long
  name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
  and paragraph manipulation, and commands to manipulate buffers, the kill ring,
  regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
  Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
  dialogs, making those commands much easier to use. Plugins or scripts can easily
  create new tabs. The Completion tab shows possible typing completions.

- Autocompletion and calltips.  Autocompletion works much like tab completion.
  To enable autocompletion, bind a key to the auto-complete command.

.. .. contents::
</t>
<t tx="ekr.20060620094645">Leo 4.4.1 beta 2                                            June 23, 2006

Leo 4.4.1 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060620094645.103"></t>
<t tx="ekr.20060620094645.106"></t>
<t tx="ekr.20060620094645.107">Leo now supports bindings of the form:

command-name !command = shortcut

You will find examples in leoSettings.leo in the node

@keys EKR bindings: vim mode bindings--&gt;Shortcuts--&gt;@shortcuts top-level keys

Such bindings are essential for all plain key bindings that are *only* to be executed in command mode.  Most, but *not* all plain key bindings should be bound in the !command 'pane'.  The two exceptions presently are '.' which *always* invokes the autocompleter code and '(' which *always* invokes the calltips code.

It is now possible to have a *single* set of key bindings be 'Emacs-like' and
'Vim-like' at the same time. See the node EKR bindings: vim mode bindings in
leoSettings.leo.

One setting switches between emacs-like operation and vim-like operation:

For emacs, use:
@strings  [ignore,insert,overwrite] top_level_unbound_key_action = insert

For vim, use:
@strings  [ignore,insert,overwrite] top_level_unbound_key_action = ignore

Vim-like modes are made possible by two new features:

1. Entry commands in @mode nodes. In the body of @mode nodes, lines of the form

--&gt; command-name

tell Leo to execute the command when entering the mode. More than one such lines
may exist; Leo executes them in the order they appear. Entry commands are
potentially a very powerful feature. To avoid chaos, entry commands should not
alter the minibuffer :-)

2. Silent modes. In order to keep the selected text visible, Leo must *not* move
focus into the minibuffer for editing commands. The set-silent-mode command
tells Leo to treat the mode described in the @mode node as a silent mode. A true
mode is created, but it only affects key bindings and the minibuffer never
becomes active.

Thus, all @mode nodes for vim-like modes contain the following line:

--&gt; set-silent-mode.
</t>
<t tx="ekr.20060620094645.108">All sets of key bindings in leoSettings.leo now start with @keys in the headline
of the root node. The @keys convention is used *only* by the Check Bindings
script. So now, instead of having a static list of key bindings sets (which is
guaranteed to get out-of-date), the Check Bindings script can scan all of
leoSettings.leo for sets of key bindings.

Another improvement to the Check Bindings script. Besides doing a better job of
checking, you may now specify optional commands, such as commands defined in
plugins. The Check Bindings will not complain if the commands don't presently
exists in k.commandsDict. You specify such commands by adding items to the
following lists in the root node of the Check Bindings script, i.e., the node
Buttons--&gt;@button Check Bindings.

optionalCommandPrefixes = ['group-operations']
optionalCommandNames = []
</t>
<t tx="ekr.20060620094645.109">- added isearch-with-present-options.
- many small improvements to isearch code.
- regex searches now highlighted properly.
- isearches are (and should be) confined to a single body text.
- Backspace now handled properly.

A small glitch. Starting a regexp pattern with '.' will cause the entire pattern
to turn red initially, which is technically correct but perhaps a bit
confusing.
</t>
<t tx="ekr.20060620094645.194">http://sourceforge.net/forum/message.php?msg_id=3767016
</t>
<t tx="ekr.20060620094645.225"></t>
<t tx="ekr.20060620094645.231">The commands that enable and disable calltips now update the status line.
</t>
<t tx="ekr.20060620094645.232">Creating a script button creates the press-xxx-button command,
and you can specify settings for such commands using @shortcuts nodes.
</t>
<t tx="ekr.20060620094645.233"></t>
<t tx="ekr.20060620094645.234">@nocolor

The scripting plugin now creates a press-x-button command for each scripting button named x.
You can bind shortcuts to such commands by placing @shortcuts nodes in an @setting tree in the outline containing the @button nodes.  test.leo shows an example.

What I did:

- The scripting plugin now defines button bindings with the 'button' pane specifier.
  This takes precedence over all other specifiers.

- k.bindKeyToDict now does a better job of detecting and warning about redefinitions.

- k.printBindings now properly sorts entries.
  This was causing me a great deal of confusion.

- k.registerCommand now properly gets shortcuts from settings if possible,
  and makes bindings in the new 'button' pane specifier.

- masterKeyHandlerHelper now supports the 'button' pane specifier,
  which overrides all others.

@color
</t>
<t tx="ekr.20060620094645.242"></t>
<t tx="ekr.20060620094645.243">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3772475

Maybe put a link to the html TOC into the Help Menu,
"%leodir%/doc/html/leo_TOC.html".

This is more intuitive (to newbies) than the LeoDocs.leo link.  I found this
very confusing in the beginning.

What I did:

- Created open-users-guide command.
- Created Open Users Guide menu item.
- Removed Open Offline Tutorial menu item.

@color
</t>
<t tx="ekr.20060620094645.252"># Important: this can be done better using per-pane bindings as in the default leoSettings.leo.
</t>
<t tx="ekr.20060620094645.258"></t>
<t tx="ekr.20060620094645.286"></t>
<t tx="ekr.20060620094645.299">http://sourceforge.net/forum/message.php?msg_id=3778744

Added editor_orientation setting: valid values are vertical and horizontal.
</t>
<t tx="ekr.20060620094645.302"></t>
<t tx="ekr.20060620094645.303">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3767601
http://sourceforge.net/forum/message.php?msg_id=3768413
Craig

I have an @thin file with @Doc and @Code sections scattered though out the tree,
where each node has one or more doc and code sections.

I would like to be able to use the rst3 plugin to produce an html file containing
only info from the doc sections, ignoring the code sections.

I added the 
</t>
<t tx="ekr.20060620094645.304">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3770732
By: ktenney

In &lt;&lt; Theory of operation of find/change &gt;&gt; 
the opening paragraph does not appear in the html,
</t>
<t tx="ekr.20060620094645.305">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3780216
Craig

In Doc_Only_Mode the rst3 plugin outputs headlines irrespective of the show_headlines
setting.  The other modes do honor this setting.

I scratched around and managed to fix this by changing the node: rst3.py--&gt;class
rstClass--&gt;write methods--&gt;writeBody &amp; helpers--&gt;handleDocOnlyMode

In Line 25 I added a new statement:
     if showHeadlines:
and indented the following 3 lines to make them conditional on this if:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.headString())
            self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20060620094645.306">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3785400
By: craigj3


I have a @url node pointing to a Leo file which has a filename with %20 in it.
When I double-click this node I get:

"can not open: \\\Documents%20and%20Settings\tftcj1.EDCON\My%20Documents\Proj\RI
CAA\PcasCellLink.leo"

Taking a look with a debugger, I see that Plugins--&gt;Enhancing the icon and status
areas--&gt;@thin UNL.py--&gt;onUrl1 line 29ish does not covert %20 to spaces before
calling openWithFileName.
</t>
<t tx="ekr.20060620094645.307">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3783225
Craig

I am looking at the image plugin for organizing photos, and discovered that
it is limited to gif files only.  I found this a bit silly as installing the
ImageTk module from the Python Imaging Library and making a two line change
to the plugin enables it to be used on practically any image type.

The two line are:
1.  a new import:-
import ImageTk

2. In &lt;&lt;select image&gt;&gt; line 9 change 
photo = Tk.PhotoImage(master=a.root, file=filename)

to

photo = ImageTk.PhotoImage(master=a.root, file=filename)
</t>
<t tx="ekr.20060620094645.308">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3779706
By: mstarzyk

My point was not about not found CSS, but that .html files are written to
default_path directory, but .txt files are not written to default_path
directory.
</t>
<t tx="ekr.20060620094645.309">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3784636
By: craigj3

I note that the scheduler plugin is currently broken.

The problem was that all commands now get an event arg.

The Begin Recording and End Recording commands do not seem to work...
</t>
<t tx="ekr.20060620094645.34"></t>
<t tx="ekr.20060620094645.35"></t>
<t tx="ekr.20060620094645.43"></t>
<t tx="ekr.20060620094645.44">Called c.bringToFront() after open/save/import dialogs.
</t>
<t tx="ekr.20060620094645.45">FAIL: @test return ends editing of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 155, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 14, in ?
AssertionError: oops2

----------------------------------------------------------------------
Ran 438 tests in 193.628s

FAILED (failures=1)
&gt;&gt;&gt;
</t>
<t tx="ekr.20060620094645.46">http://sourceforge.net/forum/message.php?msg_id=3764077
</t>
<t tx="ekr.20060620094645.50"></t>
<t tx="ekr.20060620094645.52">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3771032
By: paulpaterson

The cycle-editor-focus command causes Leo to lock up  on my machine (WinXP,
Python 2.4).

@color
</t>
<t tx="ekr.20060620094645.64">http://sourceforge.net/forum/message.php?msg_id=3771014
</t>
<t tx="ekr.20060620094645.68">lstrip and rstrip do not exist in Python 2.2.1.
</t>
<t tx="ekr.20060620094645.76">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3778764
By: davidmcnab

When I hit my 'change-editor-focus' binding, the cursor jumps
to unpredictable places within the next editor pane.
</t>
<t tx="ekr.20060620094645.77"></t>
<t tx="ekr.20060620094645.78"></t>
<t tx="ekr.20060620094645.79">Added makeMasterGuiBinding.
</t>
<t tx="ekr.20060620094645.85"></t>
<t tx="ekr.20060620094645.86"></t>
<t tx="ekr.20060620094645.96"></t>
<t tx="ekr.20060620094645.97"></t>
<t tx="ekr.20060620095655">- The print-bindings command now properly sorts bindings.
- The help-for-command command now works for almost all commands.
- Improved filename completion.
- Better listings for print-commands and print-bindings &amp;amp; mode-help commands.
- Allow shortcuts to be overridden outside of leoSettings.leo.
- Finished Cmds menu.
- Improved show-fonts command.
- Strip quotes from color, font settings.
- Warn about invalid Enter and Leave key bindings.
</t>
<t tx="ekr.20060620095949.15">- Removed warning about changed node.
- Added scroll-outline-left/right commands.
- Leo outputs decorators correctly, assuming the decorator does not conflict with a Leo directive.
- Wrote script to convert g.es to g.et where appropriate.
  The first step in translating all Leo messages.
- Leo highlights (flashes) matching brackets when typing typing (, ), [, ], { or }.
- Fixed long-standing problem reporting indentation errors.
- Fixed long-standing bug in Remove Sentinels command.
- Fixed long-standing bugs in import commands.
- The scroll-up/down commands now scroll the outline if focus is in outline pane.
  However, his can be done better using per-pane bindings as in the default leoSettings.leo.
- Incremental searches are (properly) confined to a single body text.
- Backspace now handled properly in incremental searches.
- The add-editor command adds a new editor in the body pane.
  The delete-editor command deletes the presently selected editor,
  and the cycle-editor-focus command cycles focus between editors in the body text.
- The standard \1, \2, etc. replacements can now be performed in regular expression searches.
- The standard escapes \n and \t are now valid in plain searches.
- The shortcut for the replace-string command now changes from the find command
  to the replace command.
</t>
<t tx="ekr.20060620095949.25">::

    @bool autoindent_in_nocolor_mode
    @bool flash_matching_brackets
    @bool idle_redraw
    @bool trace_bind_key_exceptions
    @bool warn_about_redefined_shortcuts
    @color flash_brackets_background_color
    @color flash_brackets_foreground_color
    @int flash-brackets-delay
    @int flash_brackets_count
    @string close_flash_brackets
    @string open_flash_brackets
    @string editor_orientation
</t>
<t tx="ekr.20060620130636">::

    cycle-focus
    debug
    find-character
    find-word
    hide-invisibles 
    isearch-with-present-options
    open-users-guide
    python-help
    run-unit-test
    toggle-autocompleter
    toggle-calltips
    toggle-invisibles
</t>
<t tx="ekr.20060620130943">- The slideshow plugin
- The mod_scripting plugin now creates a press-x-button command for every button 'x'.
  You can specify settings for such commands using @shortcuts nodes.
- The shortcut_button plugin plugin creates a 'Shortcut' button in the icon area.
  Pressing the Shortcut button creates *another* button which when pressed
  will select the presently selected node at the time the button was created.
- Added Debug button to scripting plugin.
</t>
<t tx="ekr.20060620133820.16">- Added script to update new copies of leoSetttings.leo from previous copies.
- Made all edit command undoable.
- Improved registerCommand.
- Suppressed autocompletion after numbers.
- Added colorizing support for Lua language.
- Added run-unit-test command.
- Autocompletion and calltips.
- Leo remembers the previous open directory.
- Fixed problem with view plugin.
- Installed cleo patch.
- User input modes.
- Installed many standard bindings to leoSettings.leo.
- Added Check Bindings script in leoSettings.leo.
- Scripts now maintain original focus.
- Improved cursor move/extend commands.
- Added support for @mode nodes.
- keyboard-quit restores default input mode.
- Created ut.leo, ut.py and ut.bat.
- Added modes/\*.xml to distribution.
- Revised cursor movement commands and added selection-extension commands.
- Added classic key bindings in leoSettings.leo.
- Allow multiple key bindings to the same command.
- Settings command now opens leoSettings.leo.
- Moved all scripts into scripts.leo.
- Improved how the New Tab and Rename Tab commands work in the log pane.
- Improved the appearance of the Spell tab.
- Added Clone-find checkbox to the Find tab.
- Improved find tab.
- Improved formatting of shortcuts in print-commands and print-bindings.
- Added settings for vim plugin.
- Put up a dialog if can't import Pmw.
- Bound &lt;Return&gt; to end-edit-headline.
- Leo now ignores key bindings in menu tables.
- Created scripts.leo and unitTest.leo.
- c.executeMinibufferCommand executes a minibuffer command by name.
- Improved perl entries in language dicts. 
- The tabbed log.
- The Find tab replaces the old Find panel; the old Find panel is deprecated.
</t>
<t tx="ekr.20060620140130">- Changed path to stylesheet in the rst3 plugin.
- Fixed crasher in Word (and other) plugins.
- Fixed problem with labels plugin.
- Added the following commands for the groupoperations plugin::

    group-operations-clear-marked
    group-operations-mark-for-copy
    group-operations-mark-for-move
    group-operations-mark-for-clone
    group-operations-mark-target
    group-operations-operate-on-marked
    group-operations-transfer

- Installed cleo patch.
- The scripting plugin now supports shortcuts in @button nodes::

    @button name @key=shortcut

- The scripting plugin now supports @command nodes::

    @command name @key=shortcut
</t>
<t tx="ekr.20060620140228">Added new settings::

    @bool allow_idle_time_hook
    @bool autocomplete-brackets.
    @bool gc_before_redraw
    @bool minibufferSearchesShowFindTab
    @bool show_only_find_tab_options
    @bool show_tree_stats
    @bool trace_autocompleter
    @bool trace_bindings
    @bool trace_doCommand
    @bool trace_f.set_focus
    @bool trace_focus
    @bool trace_g.app.gui.set_focus
    @bool trace_gc
    @bool trace_gc_calls
    @bool trace_gc_verbose
    @bool trace_key_event
    @bool trace_masterClickHandler
    @bool trace_masterCommand
    @bool trace_masterFocusHandler
    @bool trace_masterKeyHandler
    @bool trace_minibuffer
    @bool trace_modes
    @bool trace_redraw_now
    @bool trace_select
    @bool trace_status_line
    @bool trace_tree
    @bool trace_tree_alloc
    @bool trace_tree_edit
    @bool useCmdMenu
    @bool useMinibuffer
    @bool use_syntax_coloring
    @color body_text_selection_background_color
    @color body_text_selection_foreground_color.
    @color log_pane_Find_tab_background_color
    @color log_pane_Spell_tab_background_color, etc.
    @int max_undo_stack_size,
    @string trace_bindings_filter
    @string trace_bindings_pane_filter

- Added @shortcuts nodes.
- Leo now supports per-pane bindings of the form::

    command-name ! pane = shortcut

- The spelling settings replace the settings in spellpyx.ini.
</t>
<t tx="ekr.20060622130553">
http://sourceforge.net/forum/message.php?msg_id=3784292

http://leoeditor.com/installing.html#updating-settings-from-previous-versions-of-leo
</t>
<t tx="ekr.20060622130553.2">http://sourceforge.net/forum/message.php?msg_id=3778946

http://leoeditor.com/writingPlugins.html#turning-script-buttons-into-plugins
</t>
<t tx="ekr.20060622130815">http://sourceforge.net/forum/message.php?msg_id=3790857
</t>
<t tx="ekr.20060622130815.3">http://sourceforge.net/forum/message.php?msg_id=3790814
</t>
<t tx="ekr.20060622130815.9"></t>
<t tx="ekr.20060622132524"></t>
<t tx="ekr.20060628103226.3"></t>
<t tx="ekr.20060629083400.1">Leo 4.4.1 beta 3                                            June 29, 2006

Leo 4.4.1 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- A new colorizer plugin controlled by jEdit language description files.
  At present this plugin only reliably colors @language python code.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help and toggle-invisibles.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060629083935">Leo 4.4 was a year-long effort to incorporate an Emacs-style minibuffer and
related commands into Leo. Thinking in terms of minibuffer commands frees my
thinking. Leo 4.4 also featured many improvements in how keys are bound to
commands, including per-pane bindings and user-defined key-binding modes.

Development on long-delayed projects accelerated after 4.4 final went out the door.
Recent projects include:

- Controlling syntax coloring with jEdit's xml language-description files.
- Support for debugging scripts using external debuggers.
- Modifying Leo's vnodes and tnodes so that Leo's data can be used with ZODB.
- Using pymacs to write Leo scripts within Emacs.
- Using the leoBridge module to embed Leo support in other programs.
- Using Leo to run unit tests.

</t>
<t tx="ekr.20060629083935.100">@killcolor

@bool flash_matching_brackets: True: flash matching bracket when typing (, ), [, ], { or }.

@color flash_brackets_background_color and @color flash_brackets_foreground_color.

@int flash_brackets_count: The number of times to flash matching brackets.

@int flash-brackets-delay: One half the total cycle time of bracket flashes, in milliseconds.
</t>
<t tx="ekr.20060629083935.15">http://sourceforge.net/forum/message.php?msg_id=3510448

The fix was to getLastTracebackFileAndLineNumber.

I also created handleScriptException.
</t>
<t tx="ekr.20060629083935.2"></t>
<t tx="ekr.20060629083935.25">http://sourceforge.net/forum/message.php?msg_id=3413805
</t>
<t tx="ekr.20060629083935.3"></t>
<t tx="ekr.20060629083935.32">- Underindented comments do not end the scan of Python classes or methods.
- Handles continued signature lines properly.
</t>
<t tx="ekr.20060629083935.61">Note: Editing headline text will happen in insert mode unless

@strings top_level_unbound_key_action = overwrite
</t>
<t tx="ekr.20060629083935.70">After executing a command we must be careful to test c.exists.
</t>
<t tx="ekr.20060629083935.71">- A better trace, and the trace goes to the log pane.

- Eliminated k.keysymHistory: Tk keysyms are pretty useless.
</t>
<t tx="ekr.20060629083935.74"></t>
<t tx="ekr.20060629083935.75">@nocolor

- Improved prompt.
- Added message if no previous complex command.
- Added mode entries.
</t>
<t tx="ekr.20060629083935.76">http://sourceforge.net/forum/message.php?msg_id=3794854
</t>
<t tx="ekr.20060629083935.8">http://sourceforge.net/forum/message.php?msg_id=3795258

The column display doesn't change while typing.

</t>
<t tx="ekr.20060629083935.93">@killcolor

Here are the relevant settings:

@bool flash_matching_brackets: True: flash matching bracket when typing (, ), [, ], { or }.

@color flash_brackets_background_color and @color flash_brackets_foreground_color.

@int flash_brackets_count: The number of times to flash matching brackets.

@int flash-brackets-delay: One half the total cycle time of bracket flashes, in milliseconds.
</t>
<t tx="ekr.20060629083935.96"></t>
<t tx="ekr.20060629083935.97"># Ctrl-k is no longer needed by the match-brackets command now that brackets flash automatically.
</t>
<t tx="ekr.20060629083935.98"></t>
<t tx="ekr.20060629083935.99">When True, this provides a full traceback for all exceptions taken when binding keyboard shortcuts.
</t>
<t tx="ekr.20060805094325">You can 'revert' to old key bindings as follows:

1. Open leoSettings.leo.

2. Find the node 'Keyboard shortcuts'.

3. Disable the old bindings by moving the node
   '@keys EKR bindings: Emacs keys + modes'
   so that it is a child of the node:
   '@ignore Unused key bindings'.

4. Notice that there are two child nodes of the node
   '@ignore Unused key bindings'
   that refer to legacy key bindings:

   - '@keys Legacy Leo shortcuts with important Emacs bindings'

   - '@keys Legacy Leo bindings'.

5. Move **one** of these two legacy nodes up one level so that it is a child of the node
   'Keyboard shortcuts'.
   It should **not** be a child of the node
   '@ignore Unused key bindings'.
</t>
<t tx="ekr.20060822140418"></t>
<t tx="ekr.20060822140418.1">Leo 4.4.1 beta 4                                            August 24, 2006

Leo 4.4.1 beta 4 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060822140418.26">http://sourceforge.net/forum/message.php?msg_id=3839322
</t>
<t tx="ekr.20060822140418.29">http://sourceforge.net/forum/message.php?msg_id=3805745
</t>
<t tx="ekr.20060822140418.3"></t>
<t tx="ekr.20060822140418.36">http://sourceforge.net/forum/message.php?msg_id=3841115

There is still some doubt about what the best operation of this command should be.
</t>
<t tx="ekr.20060822140418.39">http://leo.zwiki.org/9RussianUnicodeWordsAreNotDetectedProperlyInBodyPane
</t>
<t tx="ekr.20060822140418.4">http://sourceforge.net/forum/forum.php?thread_id=1542384&amp;forum_id=10228
</t>
<t tx="ekr.20060822140418.41">http://sourceforge.net/forum/message.php?msg_id=3874380

Setting a value for background color in the body pane had no effect.

There were several problems, among which conflicting and confusing settings.
In particular, the insert_mode_bg_color setting overrides the body_text_background_color setting.

I changed the code so that insert_mode_bg_color defaults to
body_text_background_color, and put all the settings for the body text in one
place.
</t>
<t tx="ekr.20060822140418.49"></t>
<t tx="ekr.20060822140418.69"></t>
<t tx="ekr.20060822140418.70">http://sourceforge.net/forum/message.php?msg_id=3802624

Added @font menu font setting
</t>
<t tx="ekr.20060822140418.76">http://sourceforge.net/forum/message.php?msg_id=3834645
</t>
<t tx="ekr.20060822140418.77">http://sourceforge.net/forum/message.php?msg_id=3802513

Added these settings:

@string open_flash_brackets = ([{
@string close_flash_brackets = )]}
</t>
<t tx="ekr.20060822140418.88">Leo *already* outputs decorators correctly, assuming the decorator does not conflict with a Leo directive.
</t>
<t tx="ekr.20060822140418.92">http://sourceforge.net/forum/message.php?msg_id=3858363
</t>
<t tx="ekr.20060822140418.97">These were overly complicated an not useful.
</t>
<t tx="ekr.20060824110846"></t>
<t tx="ekr.20060830141224">Leo 4.4.1 final                                            August 30, 2006

Leo 4.4.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060830141224.13"></t>
<t tx="ekr.20060830141224.14"></t>
<t tx="ekr.20060830141224.15">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3885494
By: mikecrowe

OK, I found out how to duplicate this one.  This caused me a lot of grief until
I found out what is causing it.

NodeA:
...Child1
...Child2
...Child3

NodeB:
...CloneChild1
...CloneChild2
...CloneChild3

Now, put cursor on NodaA.  Ctrl-Shift-C (copy node).
Next, put cursor on CloneChild3.  Paste Node as Clone
You should get an invalid paste clone message.

Now, first cursor move (for me) puts NodeB as top node, ERASING all other nodes.
Warning:  DO NOT SAVE NOW.  It will erase all other nodes.
</t>
<t tx="ekr.20060830141224.16">@nocolor

- Created getLeoOutlineHelper.  This simplifies the code.
- Init self.checking in getLeoFile and getLeoOutline.
- Use self.checking in getVnodes, getVnode and createVnode.
  Using self.checking in getVnode complicates an already way-too-complex method, but it can't be helped.
</t>
<t tx="ekr.20060830141224.2"># Possibly a less intrusive warning should be used.
</t>
<t tx="ekr.20060830141224.37"></t>
<t tx="ekr.20060830141224.38">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3886250
By: znafets

A .leoID.txt with a \n behind the idstring creates a problem. 
It will be read in g.app.leoID and being used as is when writing the Leo file.

The fix is in app.setLeoID -&gt; &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
</t>
<t tx="ekr.20060830141224.45"></t>
<t tx="ekr.20060830141224.46">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3890031
By: terry_n_brown

I have a tree of some 2500 nodes, run a script that marks
probably 1500-2000 of them, and that's quick (2-3 seconds max.).

I can clear all the marks with:

for p in c.all_positions():
    p.v.clearMarked()

and that also is quick (2-3 seconds max.).  But when I use the menu option Unmark
All, that takes forever (1-2 minutes :-) running 100% CPU all the while.
</t>
<t tx="ekr.20060830142929">This section discusses only those settings that affect syntax coloring.
See `Customizing Leo`_ for a general discussion of Leo's settings.

Both the old colorizer (in Leo's core) and the new colorizer (the
threading_colorizer and qtGui plugins) now support \@color and \@font settings for colorizing
options. The settings for the old colorizer are::

    comment_font, cweb_section_name_font, directive_font,
    doc_part_font, keyword_font, leo_keyword_font, section_name_font,
    section_name_brackets_font, string_font, undefined_section_name_font,
    latexBackground_font, and latex_background_font.

The settings for the new colorizer are all of the above (except keyword_font) plus the following::

    comment1_font, comment2_font, comment3_font, comment4_font, function_font,
    keyword1_font, keyword2_font, keyword3_font, keyword4_font, label_font,
    literal1_font, literal2_font, literal3_font, literal4_font, markup_font,
    null_font, and operator_font.
    
To specify a color, say for comment1, for *all* languages, create an @color node::

    @color comment1_color = blue
    
To specify a color for a **particular** language, say Python, prepend the setting name
with the language name.  For example::

    @color python_comment1_color = pink

To specify a font, say for keyword_font, to be used as the default font for **all** languages,
put the following in the body text of an @font node in leoSettings.leo::

    # keyword_font_family = None
    keyword_font_size = 16
    keyword_font_slant = roman
        # roman, italic
    keyword_font_weight = bold
        # normal, bold

Comments are allowed and undefined settings are set to reasonable defaults. 
At present, comments can not follow a setting: comments must start a line.

You can specify per-language settings by preceding the settings names by a prefix x.
Such settings affect only colorizing for language x (i.e., all the modes in modes/x.py when using the new colorizer).
For example, to specify a font for php (only), put the following in the body text of an @font node in leoSettings.leo::

    # php_keyword_font_family = None
    php_keyword_font_size = 16
    php_keyword_font_slant = roman
        # roman, italic
    php_keyword_font_weight = bold
        # normal, bold
</t>
<t tx="ekr.20060903102158">Leo 4.4.1.1 final                                       September 3, 2006

Leo 4.4.1.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.1.1 corrects a serious last-minute unicode bug in Leo 4.4.1.
This version also adds the new slideshow plugin.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.1:
----------------------------
- Leo outputs decorators correctly, provided that the decorator is not a Leo directive.
- A new colorizer plugin controlled by jEdit language description files.
- A new shadow files plugin that allows external files not to have sentinel lines.
- A new slide show plugin allows you to use Leo outlines as slide shows.
- Multiple editors in Leo's body pane.
- Search commands now support regex replace patterns: \1, \2, etc.
- Support for external debuggers: see http://leoeditor.com/debuggers.html
- The scripting plugin now creates a Debug Script button.
- Several new commands including run-unit-test, python-help, toggle-invisibles,
  and scroll-outline-left/right.
- The help-for-command commands now contains information for almost all commands.
- A new shortcut_button plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060913164304"></t>
<t tx="ekr.20060913164304.1">###################
Using ZODB with Leo
###################

This chapter discusses how to write Leo scripts that store and retrieve data using ZODB_.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20060913164311">.. External links...
.. _ZODB:               http://www.zope.org/Wikis/ZODB/guide/zodb.html
.. _`Installing ZODB`:  http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000
</t>
<t tx="ekr.20060913165542.1"></t>
<t tx="ekr.20060913165542.2">This function inits the zodb.
pathToZodbStorage is the full path to the zodb storage file.
You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.
</t>
<t tx="ekr.20060913165542.3">This vnode method returns v2, a copy of v that is completely detached from the
outline. v2.fileIndex is unrelated to v.fileIndex initially, but it may be
convenient to copy this field::

    v2 = v.detach()
    v2.fileIndex = v.fileIndex
</t>
<t tx="ekr.20060913170145">To enable zodb scripting within Leo, you must set use_zodb = True in the root node of leoNodes.py.
You must also install ZODB itself.  See `Installing ZODB`_ for details.

When ZODB is installed and use_zodb is True,
Leo's vnode class becomes a subclass of ZODB.Persistence.Persistent.
This is all that is needed to save/retrieve vnodes or tnodes to/from the ZODB.

**Important notes**:

- Scripts **should not** store or retrieve positions using the ZODB!
  Doing so makes sense neither from Leo's point of view nor from ZODB's point of view.

- The examples below show how to store or retrieve Leo data by accessing the
  so-called root of a ZODB connection. However, these are only examples. Scripts
  are free to do with Leo's vnodes *anything* that can be done with
  ZODB.Persistence.Persistent objects.
</t>
<t tx="ekr.20060913170403">Scripts should call g.init_zodb to open a ZODB.Storage file.
g.init_zodb returns an instance of ZODB.DB.  For example::

    db = g.init_zodb (zodbStorageFileName)

You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.
</t>
<t tx="ekr.20060913170403.1">The following script writes v, a tree of vnodes, to zodb::

    db = g.init_zodb (zodbStorageFileName)
    connection = db.open()
    try:
        root = connection.root()
        root[aKey] = v # See next section for how to define aKey.
    finally:
        get_transaction().commit()
        connection.close()

Notes:

- v must be a vnode.
  Scripts should *not* attempt to store Leo positions in the zodb.
  v can be the root of an entire outline or a subtree.
  For example, either of the following would be reasonable::

    root[aKey] = c.rootPosition().v
    root[aKey] = c.p.v

- To write a single vnode without writing any of its children you can use v.detach.
  For example::

    root[aKey] = v.detach()

- **Important**: It is simplest if only one zodb connection is open at any one time,
  so scripts would typically close the zodb connection immediately after processing the data.
  The correct way to do this is in a finally statement, as shown above.

- The script above does not define aKey.
  The following section discusses how to define reasonable zodb keys.
</t>
<t tx="ekr.20060913170403.2">The following script reads a tree of vnodes from zodb and sets p as the root position of the tree::

    try:
        connection = db.open()
        root = connection.root()
        v = root.get(aKey)
        p = leoNodes.position(v)
    finally:
        get_transaction().commit()
        connection.close()
</t>
<t tx="ekr.20060913175437">The keys used to store and retrieve data in connection.root() can be any string that uniquely identifies the data.
The following are only suggestions; you are free to use any string you like.

1. When saving a file, you would probably use a key that is similar to a real file path.
   For example::

        aKey = c.fileName()

2. When saving a single vnode or tree of vnodes, say v,
   a good choice would be to use v's gnx, namely::

        aKey = g.app.nodeIndices.toString(v.fileIndex)

   Note that v.detach() does not automatically copy v.fileIndex to the detached node,
   so when writing a detached node you would typically do the following::

       v2 = v.detach()
       v2.fileIndex = v.fileIndex
       aKey = g.app.nodeIndices.toString(v2.fileIndex)
</t>
<t tx="ekr.20060913175437.1">The scripts shown above close the zodb connection after processing the data.
This is by far the simplest strategy.
I recommend it for typical scripts.

**Important**: you must **leave the connection open** if your script modifies persistent data in any way.
(Actually, this statement is not really true,
but you must define zodb transaction managers if you intend to use multiple connections simultaneously.
This complication is beyond the scope of this documentation.)
For example, it would be possible to create a new Leo outline from the data just read,
but the script must leave the connection open.
I do not recommend this tactic, but for the adventurous here is some sample code::

    connection = self.db.open()
    root = connection.root()
    v = root.get(fileName)
    if v:
        c2 = c.new()
        c2.openDirectory = c.openDirectory # A hack.
        c2.mFileName = fileName # Another hack.
        c2.beginUpdate()
        try:
            c2.setRootVnode(v)
            c2Root = c2.rootPosition()
            c2.atFileCommands.readAll(c2Root)
            g.es_print('zodb read: %s' % (fileName))
        finally:
            c2.endUpdate()
        # Do *not* close the connection while the new Leo window is open!
    else:
        g.es_print('zodb read: not found: %s' % (fileName))


This will work **provided** that no other zodb connection is ever opened while this connection is opened.
Unless special zodb precautions are taken (like defining zodb transaction managers)
calling get_transaction().commit() will affect **all** open connections.
You have been warned.
</t>
<t tx="ekr.20060915112109">Find the @file leoApp.py node in leoPy.leo.
In the ctor for the LeoApp class set self.use_psyco to True or False.
You will find this ctor in the node::

    Code--&gt;Core classes...--&gt;@file leoApp.py--&gt;app.__init__

Note that this ivar can not be set using settings in leoSettings.leo because
Leo uses g.app.use_psyco before processing configuration settings.
</t>
<t tx="ekr.20060917130130">Add the following to the start of your scripts::

    @first # -*- coding: utf-8 -*-

Without this line, constructs such as::

    u = u'a-(2 unicode characters here)-z'
    u = 'a-(2 unicode characters here)-z'

will not work when executed with Leo's execute script command.
Indeed, the Execute Script command creates the script by writing the tree
containing the script to a string. This is done using Leo's write logic, and
this logic converts the unicode input to a utf-8 encoded string. So *all
non-ascii characters* get converted to their equivalent in the utf-8 encoding. 
Call these encoding &lt;e1&gt; and &lt;e2&gt;. In effect the script becomes::

    u = u'a-&lt;e1&gt;-&lt;e2&gt;-z'
    u = 'a-&lt;e2&gt;-&lt;e&gt;-z'

which is certainly *not* what the script writer intended!
Rather than defining strings using actual characters, Instead, one should use
the equivalent escape sequences. For example::

    u = u'a-\\u0233-\\u8ce2-z'
    u = 'a-\\u0233-\\u8ce2-z'
</t>
<t tx="ekr.20060920145745">Three commands in the Cmds-&gt;Body Editors menu allow one to create, destroy, or focus on separate editors in the body pane.
- The ``add-editor`` (Cmds-&gt;Body Editors-&gt;Add Body Editor) command adds a new editor in the body pane and gives it the body editor focus.
- The ``delete-editor`` (Cmds-&gt;Body Editors-&gt;Delete Body Editor) command deletes the editor with body editor focus.
- The ``cycle-editor-focus`` (Cmds-&gt;Body Editors-&gt;Change Body Editor) command cycles body editor focus between editors in the body text.

There is a single body editor focus which determines which body editor shows the content of the selected outline node and which allows that node to be edited; other body editors continue to show the node contents they last had when they had the body editor focus.
</t>
<t tx="ekr.20060921064744.1">This section describe the format of external files. Leo's `sentinel lines`_ are
comments, and this section describes those comments.

Files derived from @file use gnx's in \@+node sentinels. Such gnx's permanently
and uniquely identify nodes. Gnx's have the form::

    id.yyyymmddhhmmss
    id.yyyymmddhhmmss.n

The second form is used if two gnx's would otherwise be identical.

- id is a string unique to a developer, e.g., a cvs id.

- yyyymmddhhmmss is the node's creation date.

- n is an integer.

Here are the sentinels used by Leo, in alphabetical order.
Unless otherwise noted, the documentation applies to all versions of Leo.
In the following discussion, gnx denotes a gnx as described above.

\@&lt;&lt;
    A sentinel of the form @&lt;&lt;section_name&gt;&gt; represents a section reference.

    If the reference does not end the line,
    the sentinel line ending the expansion is followed by the remainder of the reference line.
    This allows the Read code to recreate the reference line exactly.

\@@
    The \@@ sentinel represents any line starting with @ in body text
    except \@*whitespace*, @doc and @others.
    Examples::

      @@nocolor
      @@pagewidth 80
      @@tabwidth 4
      @@code

\@afterref
    Marks non-whitespace text appearing after a section references.

\@+all
    Marks the start of text generated by the \@all directive.

\@-all
    Marks the end of text generated by the \@all directive.

\@at and \@doc

    The \@+doc \@+at sentinels indicate the start of a doc parts.

    We use the following **trailing whitespace convention** to
    determine where putDocPart has inserted line breaks::

        A line in a doc part is followed by an inserted newline
        if and only if the newline if preceded by whitespace.

    To make this convention work, Leo's write code deletes the trailing
    whitespace of all lines that are followed by a "real" newline.

\@+body **(Leo 3.x only)**
    Marks the start of body text.

\@-body **(Leo 3.x only)**
    Marks the end of body text.

\@delims
    The \@delims directive inserts \@@delims sentinels into the external file.
    The new delimiter strings continue in effect until the next \@@delims sentinel
    *in the external file* or until the end of the external file.
    Adding, deleting or changing \@@delim *sentinels* will destroy Leo's ability to read the external file.
    Mistakes in using the \@delims *directives* have no effect on Leo,
    though such mistakes will thoroughly mess up a external file as far as compilers,
    HTML renderers, etc. are concerned. 

\@+leo
    Marks the start of any external file. This sentinel has the form::

        &lt;opening_delim&gt;@leo&lt;closing_delim&gt;

    The read code uses single-line comments if &lt;closing_delim&gt; is empty.
    The write code generates single-line comments if possible.

    The \@+leo sentinel contains other information. For example::

        &lt;opening_delim&gt;@leo-ver=4-thin&lt;closing_delim&gt;

\@-leo
    Marks the end of the Leo file.
    Nothing but whitespace should follow this directive.

\@+middle **(Leo 4.0 and later)**
    Marks the start of intermediate nodes between the node that
    references a section and the node that defines the section.
    Typically no such sentinels are needed:
    most sections are defined in a direct child of the referencing node.

\@-middle **(Leo 4.0 and later)**
    Marks the end of intermediate nodes between the node that
    references a section and the node that defines the section.

\@+node
    Mark the start and end of a node.

        @+node:gnx:&lt;headline&gt;

\@others
    The @+others sentinel indicates the start of the expansion of an \@+others directive,
    which continues until the matching \@-others sentinel.

\@verbatim
    @verbatim indicates that the next line of the external file is not a sentinel.
    This escape convention allows body text to contain lines that would otherwise
    be considered sentinel lines.

\@@verbatimAfterRef
    @verbatimAfterRef is generated when a comment following a section reference would
    otherwise be treated as a sentinel. In Python code, an example would be::

      &lt;&lt; ref &gt;&gt; #+others
</t>
<t tx="ekr.20060928172040">Leo 4.4.2 beta 1                                  September 29, 2006

Leo 4.4.2 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline using Alt-arrow keys.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse.
- Many new minibuffer commands now appear in the Cmds menu.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20060928172457"></t>
<t tx="ekr.20060928172457.4">- Added support for controlling Leo from Emacs_ with pymacs_.
  See the `Leo and Emacs`_ chapter for full details.
- Added Minibuffer and Settings submenus of the Cmds menu.
- At long last Leo creates a proper help menu on the Mac.
- Added a new convention for menu tables. If the first item (a string
  representing the menu label) starts with '*' Leo will convert hyphens to
  spaces and upcase the label. This convention allows a single string to
  represent both the menu label and its associated minibuffer command. As part
  of this reorganization, all menu tables in Leo's core now use only strings.
  This is an essential precondition to supporting @menu nodes in
  leoSettings.leo.
- Leo's Help menu now contains the Open scripts.leo command.
- Leo uses ctypes to import Aspell when run from Python 2.5 or later.
  Leo no longer needs Python-specific versions of aspell.dll.
- Added support for x-windows middle-button paste.
  This only works when the paste is made in the pane containing the selected text.
- Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
- Created three scripts (in test.leo) that help create unit tests for Leo's edit commands.
  Create Created runEditCommandTest for use by these scripts.
- Improved print-bindings command.
  The bindings are sorted by prefix: this is a big help in understanding bindings.
  For each prefix, first print items with only a single character after the prefix.
- Made writing .leo files faster.
  The new code almost exactly twice as fast as the old.
- Added p.archivedPosition.
  This is a key first step towards Leap 204.
- Integrated sax with read logic.
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Eliminated unnecessary redraws when moving the cursor in the outline pane.
- Much faster navigation through the outline using Alt-arrow keys.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse.
- Many new minibuffer commands now appear in the Cmds menu.

Further improved outline navigation:

- Generalized navigation in outline pane to ignore @file, @thin, etc prefixes.
- Made outline navigation cumulative.
  When keystrokes in the outline pane are typed 'close' together Leo first tries to look
  for prefix + ch, where ch is the character just typed and prefix is the previous match.
  The term 'close together' is specified by the setting @float outline_nav_extend_delay.
  The outline search revers to a single-character if the extended search
  fails, so in fact the delay is not too significant. In practice everything works
  well without me thinking at all about what is happening.
</t>
<t tx="ekr.20060928172457.5">- Improved the mod_scripting plugin. Every button created by the plugin creates
  a corresponding command. The command name is the 'cleaned' version of the
  button name. Likewise, the plugin also creates a delete-x-button command,
  where x is the command name as just discussed. So now you can delete script
  buttons without right-clicking.
- Made 'About Plugin' dialog scrollable.
- Fixed bugs in groupoperations, multifile, nodenavigator and shortcut_button plugins.
- The rst3 plugin now registers the rst3-process-tree command.
- The leoOPML.py plugin defines commands to read and write OPML files.
- The slideshow.py plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- The paste_as_headlines.py plugins creates multiple headlines at once.
- The word_count.py plugin.

Improved the mod_scripting plugin:

- Made showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.
</t>
<t tx="ekr.20060928172525.167"></t>
<t tx="ekr.20060928172525.172">It now prints the binding for the command.
</t>
<t tx="ekr.20060928172525.180">Rewrote moveWordHelper. It now avoids Tk and regexes.  *Much* simpler.
</t>
<t tx="ekr.20060928172525.195">@nocolor

My present thinking is that scripts should be able to store/retrieve persistent
objects to/from the zodb. That is, the zodb plugin is likely to be retired.

Leo's vnode and tnode classes now derive from ZODB.Persistence.Persistent if
leoNodes.use_zodb is True. It remains to be seen whether having use_zodb = True
will cause any serious problems.

See the posting below (Scripting using zodb) for latest details.

See the node 'zodb get/put buttons' in test.leo for examples of how scripts can access zodb easily.

Created g.init_zodb and v.detach.
</t>
<t tx="ekr.20060928172525.197">&gt; Do you see zodb as persisting Leo files or Leo nodes?

Interesting question.  I now see the zodb plugin as a proof-of-concept for *user-defined* scripts.  The zodb plugin is probably going to go away.

Let us suppose that db is a ZODB.DB instance. (To see how to create such an instance, see the init_zodb method in the zodb plugin.  Perhaps I'll defines something like g.openZodb to make this easier.)  Then the statements:

connection = db.open()
root = connection.root()
root[aKey] = v
get_transaction().commit()
connection.close()

will write all of v's data (all vnodes and tnodes) to the zodb.  This is true whatever v is: it can be the root of an entire outline, or any suboutline.  If you want to write a single node, you would have to 'detach' that node from the outline.  You can do this by copying the node and then unlinking the node from its descendants. Perhaps I could add a convenience method to the vnode class to make this easier.

&gt;Do you see zodb work as providing enhanced access to nodes across multiple files?

Scripts could do so easily.  Happily, the distinction between 'long-lived' and 'short-lived' connections is not important for scripts: a script should hold a connection open only for as long as needed.  So it would be easy to write any number of vnode trees to the zodb.  Later, another script could access any of the data in the zodb by zodb key.  Like this:

connection = db.open()
root = connection.root()
v = root.get(aKey)
p = leoNodes.position(v,[])

After running this script, p is a position representing the root of the tree of 'imported' vnodes.  The script above does not 'connect' the imported trees to an outline, nor should it do so.  As I write this, I realize that the position ctor should make the second argument optional, so that leoNodes.position(v) would be equivalent to leoNodes.position(v,[]).

Each script should open at most connection at a time and be sure to close any zodb connection it creates.  The proper way to do this is in a finally statement, like this:

try:
....connection = db.open()
....root = connection.root()
....v = root.get(aKey)
....p = leoNodes.position(v,[])
....&lt;&lt; do something with the nodes in p's tree&gt;&gt;
finally:
....get_transaction().commit()
....connection.close()

In short, the recent changes to Leo's vnode and tnode classes give scripts the ability to save/retrieve Leo data to/from the zodb in any way a script wants, without any further support from Leo, or from me.

I shall spend an hour or two more with the zodb plugin, but it looks to me that the plugin has served its purpose.  Rather than trying to guess how people will want to use the zodb, it will be simpler and more general to have people write scripts that do exactly what they want.  In particular, such scripts can easily sidestep the problems with multiple open connections.

Edward

P.S. Please note that the scripts shown above could not have been written without all the recent work with the zodb plugin and the big code reorg.

P.P.S. A couple of unit tests involving the new v/t.__hash__ methods just failed, so it may be just a little bit longer before the code on cvs is truly zodb ready.  I'll also be working on example scripts and the convenience methods described above.

EKR
</t>
<t tx="ekr.20060928172525.198">- Removed all modes except Alt-C mode.
- Use Shift-arrows for outline moves when focus is in outline pane.
- Put help / apropos commands in help menu.
- Put focus commands in Cmds menu.
- When focus is in outline, normal character navigates like Windows explorer.
- Put Scrolling commands in Cmds menu.
- Screened out(some) unwanted characters from affecting outline navigation.More work is needed.
- Esc character is never inserted into text.
- Replaced @button clones-tab with @command clones-tab.
- Scripting plugins now sets verbose=True so @commands get shown.
* Alt keys (outline move commands) should set focus to outline even if nothing else happens.
- Closing a window no longer puts focus in limbo: added force argument to c.set_focus.
- New gui bindings: (I should actually be able to remember these).
    contract-pane                       = Alt+Ctrl+-
    expand-pane                         = Alt+Ctrl-=
    focus-to-tree                       = Alt-space
    scroll-outline-down-page            = Alt-PageDn
    scroll-outline-down-page            ! tree = PageDn
    scroll-outline-up-page              = Alt-PageUp
    scroll-outline-up-page              ! tree = PageUp
    scroll-outline-left                 = Alt+Ctrl+LtArrow
    scroll-outline-right                = Alt+Ctrl+RtArrow
- Put find-character and back-find-character in Edit:Find menu.
- Use Alt-S,Alt-R for incremental searches.
- Created find-character-extend-selection and back-find-character-extend-selection.
- Added binding (Ctrl-W) and entry in Cmds menu for select-word-at-cursor.
- Added binding (Ctrl-P) for repeat-complex-command.
- Added binding (Ctrl-B) for execute-script.
* Fixed bug in extend mode.
- Added binding (Ctrl-space) for toggle extend mode.
- Removed most cursor move bindings involving ctrl keys. Exception: ctrl-a and ctrl-e.
    ** The idea is that I'll use extend mode instead.
- Stay in outline mode: added @bool stayInTreeAfterEditHeadline setting.
- Added Cmds:Toggle Settings submenu.
- Use emacs names in Cmds menu (and in some other places): allow single item in menu tables.
</t>
<t tx="ekr.20060928172525.237">http://sourceforge.net/forum/message.php?msg_id=3935368
</t>
<t tx="ekr.20060928172525.240">http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.
</t>
<t tx="ekr.20060928172525.252">http://sourceforge.net/forum/message.php?msg_id=3935981

@url nodes of the form::

    @url -- aComment

now get the actual url from the entire first line of body text.
Such url's need not be quoted if they contain spaces.

</t>
<t tx="ekr.20060928172525.81">What I did:

- Removed c argument from t, v and p ctors.
- Removed c argument from most position methods.
    - In particular, p.link, p.unlink, v.link and v.unlink no longer update c.currentPosition()
    - Moved all position methods that still had a c argument to the Commands class.
- Removed p.all_positions.
- Added c.findRootPosition and c.findRootVnode.
- c.rootPosition now returns c.findRootPosition(c.currentPosition())

As a result:

- The tnode, vnode and position classes are *completely* independent of Leo.
  In particular, no tnode, vnode or position method gets a c argument.
- The p.link, p.unlink, v.link and v.unlink are significantly simpler.
- The machinery for keeping the root position up-to-date is
  simple and confined to one place in the Commands class.
</t>
<t tx="ekr.20060928194633.1">The myLeoSettings.leo file is a way of ensuring that your customized settings
are not altered when updating Leo from cvs or while installing a new version of
Leo. The myLeoSettings.leo acts much like Python's site-customize.py file. The
myLeoSettings.leo file will never be part of any Leo distribution. This solution
is *much* better than trying to update leoSettings.leo with scripts.

Leo loads settings from myLeoSettings.leo *after* loading settings from
leoSettings.leo files but *before* loading settings from the .leo file being
opened.
</t>
<t tx="ekr.20060928195040"></t>
<t tx="ekr.20060928195040.1">The following plugins are new in Leo 4.4.2 b2:

leo_to_rtf
leo_to_html
leoOPML  (At present, contained in leoOPML.leo instead of leoPlugins.leo)
paste_as_headlines
slideshow
word_count

The __saxRead__.py plugin is an **experimental** for use by EKR.
It will be folded into Leo's core in the near future.
</t>
<t tx="ekr.20060929040750">Leo has many commands that select nodes in the outline. These commands can be
found in the Outline:Go To menu.

As described in the tutorial, you can move about the outline by clicking on the
headlines or using Alt+arrow keys.
</t>
<t tx="ekr.20060929043325">Leo's vnode and tnode classes are now completely independent of the rest of Leo.
Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
</t>
<t tx="ekr.20060929043325.1">Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
i.e., they can optionally derive from ZODB.Persistence.Persistent.
See Chapter 17: Using ZODB with Leo for details.
</t>
<t tx="ekr.20061002093442"></t>
<t tx="ekr.20061008190633.248"></t>
<t tx="ekr.20061008190633.249">http://sourceforge.net/forum/message.php?msg_id=3932641

Leo *always* outputs the first line of a node without indentation even if it is indented in the node.
</t>
<t tx="ekr.20061008190633.250">This was a very weird one.  It's not clear why it wasn't biting before.

Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 321, in &lt;module&gt;
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 151, in run
    g.app.gui.runMainLoop()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 182, in runMainLoop
    self.root.mainloop()
  File "c:\python25\lib\lib-tk\Tkinter.py", line 1023, in mainloop
    self.tk.mainloop(n)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1756, in __call__
    _reporterror(self.func, args)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1782, in _reporterror
    msg = exc_type + ' Exception in Tk callback\n'
TypeError: unsupported operand type(s) for +: 'type' and 'str'
</t>
<t tx="ekr.20061008190633.257">- created g.isWordChar.  It does proper test for letters and numbers.
- Used g.isWordChar in extendToWord and moveWordHelper.
- OnBodyDoubleClick now just calls c.editCommands.extendToWord.

So Russian characters, e.g., no longer 'interrupt' words.

Another fix: extend-to-word now works properly at the very end of a word.
</t>
<t tx="ekr.20061008190633.261">Installer does not complain about missing Python and does not install anything
either. Here is a fix to this behavior. In most user-friendly way it would be
better to provide a clickable link to Python site and a way to specify the path
manually, but for now it is just that - a fix.
</t>
<t tx="ekr.20061008190633.262"></t>
<t tx="ekr.20061008190633.264">w was set to self.w, rather than event.widget.
</t>
<t tx="ekr.20061008190633.265">Added self.editWidget.  This sets self.w and makes sure w is a text widget.
</t>
<t tx="ekr.20061008190633.283">This fixes a long-standing, annoying bug.
</t>
<t tx="ekr.20061008190633.294">The solution was to call setTimestamp if needed in getNewIndex.

</t>
<t tx="ekr.20061008190633.295"></t>
<t tx="ekr.20061008190633.296">- Make showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.
</t>
<t tx="ekr.20061008190633.297"></t>
<t tx="ekr.20061008190633.298">New in beta 2: Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
</t>
<t tx="ekr.20061008190633.306"></t>
<t tx="ekr.20061008190633.307">http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.

Added support for @bool collapse_nodes_during_finds setting.
</t>
<t tx="ekr.20061008190633.311">The code that writes .leo files is now almost exactly twice as fast as the old code.
</t>
<t tx="ekr.20061008190633.325"></t>
<t tx="ekr.20061008190633.347"></t>
<t tx="ekr.20061008190633.351">http://sourceforge.net/forum/message.php?msg_id=3941670

The code on cvs now supports the 'extended' character search. When keystrokes
(in the outline pane) are typed 'close' together in time Leo first tries to look
for prefix + ch, where ch is the character just typed and prefix is the previous
match.

By 'close together' I mean the time interval specified by the new setting:

@float outline_nav_extend_delay = 2.0

The unit of time is seconds.

The outline nav search revers to a single-character if the extended search
fails, so in fact the delay is not too significant. In practice everything works
well without me thinking at all about what is happening.
</t>
<t tx="ekr.20061008190633.353"></t>
<t tx="ekr.20061008190633.354"></t>
<t tx="ekr.20061008190633.356">The bindings are sorted by prefix: this is a big help in understanding bindings.
For each prefix, first print items with only a single character after the prefix.
</t>
<t tx="ekr.20061008190633.360"></t>
<t tx="ekr.20061008190633.362">




</t>
<t tx="ekr.20061008190633.364">Possibly define kill-sentence and kill-paragraph in terms of these.
</t>
<t tx="ekr.20061008190633.371"></t>
<t tx="ekr.20061008190633.382"></t>
<t tx="ekr.20061008190655">Leo 4.4.2 beta 2                                  October 9, 2006

Leo 4.4.2 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20061008190905"></t>
<t tx="ekr.20061008192040"></t>
<t tx="ekr.20061008192040.1"></t>
<t tx="ekr.20061009074305">Leo's theory of relativity

1. We can archive any position p by saving the list [p.childIndex() for p in
   p.self_and_parents_iter()]. Let us call the *reverse* of this list the
   **parents index list**. Clearly, this list provides an unambiguous way of
   reaching position p from the root node. Archived positions, like all other
   positions, become invalid when the outline changes. 

2. Leo's position class can be based on parents index lists. Let us call such
   positions **new positions**. Replacing legacy positions with new position
   will have important benefits: 

- The only structure information in vnodes will be a v.links field. Two
  interpretations of v.links are possible. When Leo's data is a DAG (the clone
  world), v.links is a lists of v's children. This is the legacy world we all
  know and love. When Leo's data is an arbitrary graph, v.links is simply the
  list of all vnodes to which v points, with *no* necessary restrictions on what
  nodes may be contained in v.links. 

- New positions provide a self contained way of traversing an arbitrary graphs
  **largely independently** of the data. This is Leo's theory of relativity. The
  notions of 'parent' and 'sibling' have meaning *only* in the context of a
  particular position. The v.links field appears to be the absolute minimum
  amount of structure information that vnodes must contain. v.links defines the
  children or linked-to nodes in a general graph. 

- Leo's data can be considered an unrooted tree: *any* node could be considered
  the root. New positions provide enough information to traverse an arbitrary
  graph starting at any node. 

- The fundamental p.moveToX methods should be significantly faster. All of Leo's
  iterators use p.moveToX methods. 

3. The changeover to new positions can be done easily. Initially, the api of the
   new position class will be identical to the api of the present position
   class. Later, the api for the new position class might be extended in an
   upward compatible manner. The api's for the vnode and tnode class will remain
   strictly unchanged. 

4. These changes imply no change to the separation of data into vnodes and
   tnodes. This separation is required to handle clones. Furthermore, the format
   of .leo files is a separate issue from the internal representation of Leo's
   data, as proved by the opml plugin. Thus, the transition to new positions
   will have *no* effect on file formats, and no effect of scripts. All scripts
   will continue to work *exactly* as they have before, *except* scripts, e.g.
   unit tests, that probe Leo's internals. 

Summary 

Leo's theory of relativity is this: the position class provides a 'frame of
reference' for traversing data. **Only in a particular frame of reference** do
the notions of 'parent' and 'siblings' have meaning. Leo's theory of relatively
is the ultimate expression of LeoUser's notion of a 'sea of nodes'. It provides
a solid context on which to base traversals of either outlines with clones
(DAG's) or general directed graphs. 

Leo's position class, far from being just a technical tool, is important
theoretically. The position class (old or new) provides the essential tool
needed to separate data from traversals of the data. The re-visioning of the
position and vnode classes brings that potential into reality. 
</t>
<t tx="ekr.20061009111417.11">- Removed .leoRecentFiles.txt from the distribution and cvs and added @bool
  write_recent_files_as_needed. The presence or absence of .leoRecentFiles.txt
  no longer controls whether Leo creates and updates .leoRecentFiles.txt.
- Added @bool insert_new_nodes_at_end.
- Added @bool select_all_text_when_editing_headlines.
  Creating a new node always selects the entire text, regardless of this option.
- Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.
- Added settings for all mod_scripting switches.
- Added @bool collapse_nodes_during_finds.
  This greatly speeds searches that used to open many nodes.
  See: http://sourceforge.net/forum/message.php?msg_id=3935780
- Added @bool outline_pane_has_initial_focus.
- Added @bool sparse_move_outline_left.
- Added bindings for Alt-Shift-Arrow keys to force an outline move.
- Added @bool use_sax_based_read = False.
  True:  Use a sax-based parser to read .leo files.
  This is slower than using Leo's legacy xml parser, but may solve some unicode problems.

Changed default settings::

    focus-to-body = Alt-D
    focus-to-tree = Alt-T
    toggle-extend-mode = Alt-3
</t>
<t tx="ekr.20061009111417.18">::

    extend-to-line
    extend-to-paragraph
    extend-to-sentence
    forward-end-word
    forward-end-word-extend-selection
</t>
<t tx="ekr.20061009112808">True:  Use a sax-based parser to read .leo files.
       This is slower than using Leo's legacy xml parser, but may solve some unicode problems.

False: Use Leo's legacy xml parser code.
</t>
<t tx="ekr.20061011111007">http://sourceforge.net/forum/message.php?msg_id=3957908

Is there a setting for autmoatically loading most recent file or files.
</t>
<t tx="ekr.20061020155235.1"></t>
<t tx="ekr.20061020155235.123">http://sourceforge.net/forum/message.php?msg_id=3960993
</t>
<t tx="ekr.20061020155235.124">https://sourceforge.net/forum/message.php?msg_id=3961623
</t>
<t tx="ekr.20061020155235.125">No longer needed now that the datenodes plugins gets settings from cvs.
</t>
<t tx="ekr.20061020155235.126"></t>
<t tx="ekr.20061020155235.149">Did not restore selection after indent/undent commands.
</t>
<t tx="ekr.20061020155235.180">The 'hang' was due to removeRKeys, which removes the bindings create by
setRegion (set-mark-command) by *also* cleared all the other bindings!
For now I have simply disabled the set-mark-command and commented out all
calls to removeRKeys.

Note that toggle-extend-mode (Alt-3) is a good way to define regions.
</t>
<t tx="ekr.20061020155235.185">onFocusIn and its associated binding were a very bad idea.  It is not needed:
k.masterClickHandler simply calls the new onClick method.

What I did:

- Eliminating onFocusIn and its associated binding.
  Hurray: this also fixed the Find problem.
- Fixed problem with deleting nodes when multiple editors are present.
- Removed title bar when penultimate editor is deleted.
</t>
<t tx="ekr.20061020155235.2"></t>
<t tx="ekr.20061020155235.254"></t>
<t tx="ekr.20061020155235.255">Double-clicking  @url &lt;leo-file&gt; did not bring Leo file to top.
</t>
<t tx="ekr.20061020155235.263"></t>
<t tx="ekr.20061020155235.264">What I did

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.
</t>
<t tx="ekr.20061020155235.27">@command whatever @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.
</t>
<t tx="ekr.20061020155235.271">http://sourceforge.net/forum/message.php?msg_id=3588148

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.
</t>
<t tx="ekr.20061020155235.292">This is much more visible.
</t>
<t tx="ekr.20061020155235.294">Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.
</t>
<t tx="ekr.20061020155235.304">At long last Leo creates a proper help menu on the Mac.
</t>
<t tx="ekr.20061020155235.307">This would greatly simplify menu entries.
</t>
<t tx="ekr.20061020155235.308">This is an important step towards making all menus configurable.
</t>
<t tx="ekr.20061020155235.335">The open-scripts-leo command.
</t>
<t tx="ekr.20061020155235.337"></t>
<t tx="ekr.20061020155235.34">http://sourceforge.net/forum/message.php?msg_id=3956836
</t>
<t tx="ekr.20061020155235.35">http://sourceforge.net/forum/message.php?msg_id=3958333
</t>
<t tx="ekr.20061020155235.36"></t>
<t tx="ekr.20061020155235.37"></t>
<t tx="ekr.20061020155235.385"></t>
<t tx="ekr.20061020155235.393"></t>
<t tx="ekr.20061020155235.394">http://sourceforge.net/forum/message.php?msg_id=3958380
</t>
<t tx="ekr.20061020155235.395">http://sourceforge.net/forum/message.php?msg_id=3423121
</t>
<t tx="ekr.20061020155235.396">http://sourceforge.net/forum/message.php?msg_id=3959003
</t>
<t tx="ekr.20061020155235.397"></t>
<t tx="ekr.20061020155235.398">http://sourceforge.net/forum/message.php?msg_id=3962632
</t>
<t tx="ekr.20061020155235.399">- Every button created by the plugin creates a corresponding command. The
command name is the 'cleaned' version of the button name.

- Every button created by the plugin also creates a delete-x-button command,
where x is the command name as just discussed. So now you can delete script
buttons without right-clicking.

- I took the time to revise, refactor, clean up, reorganize and better document
the code. This was overdue: the previous code had grown difficult to understand
through multiple small accretions. I can actually understand the new code.
</t>
<t tx="ekr.20061020155235.400"></t>
<t tx="ekr.20061020155235.402">http://sourceforge.net/forum/message.php?msg_id=3963657
</t>
<t tx="ekr.20061020155235.403"></t>
<t tx="ekr.20061020155235.404">As always, you can set max_undo_stack_size in myLeoSettings.leo.
</t>
<t tx="ekr.20061020155235.405">A highly useful option.
However, creating a new node always selects the entire text, regardless of this option.
</t>
<t tx="ekr.20061020155235.41">The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --&gt; search-with-present-options.
</t>
<t tx="ekr.20061020155235.410">- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the process
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.
</t>
<t tx="ekr.20061020155235.411">Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
</t>
<t tx="ekr.20061020155235.412">- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3
</t>
<t tx="ekr.20061020155235.413"></t>
<t tx="ekr.20061020155235.47">https://sourceforge.net/forum/message.php?msg_id=3957980

This was a major effort.  What I did:

- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.

- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.
</t>
<t tx="ekr.20061020155306">Leo 4.4.2 beta 3                                  October 20, 2006

Leo 4.4.2 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

The beta release fixed dozens of bugs and smoothed many rough edges.  There
are no known major bugs in Leo.  This will be the last beta release before
Leo 4.4.2 final.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:        http://leoeditor.com
What's new: http://leoeditor.com/new-4-4-2.html
Home:       http://sourceforge.net/projects/leo/
Download:   http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:        http://leo.tigris.org/source/browse/leo/
Quotes:     http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20061021164213">Set @bool ignore_unbound_non_ascii_keys = False in LeoSettings.leo or myLeoSettings.leo.
</t>
<t tx="ekr.20061023153133">patch -p1 &lt; patchfile
</t>
<t tx="ekr.20061025065357"></t>
<t tx="ekr.20061025065357.1">#############
Leo and Emacs
#############

This chapter several topics relating to the Emacs editor.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20061025065357.2">.. Links
.. _elisp:              http://en.wikipedia.org/wiki/Emacs_Lisp
.. _Emacs:              http://www.xemacs.org/
.. _ZODB:               http://www.zope.org/Wikis/ZODB/guide/zodb.html
.. _`Installing ZODB`:  http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000
.. _pymacs:             http://pymacs.progiciels-bpi.ca/index.html
.. _`Customizing Leo`:  customizing.html
</t>
<t tx="ekr.20061025070825.1">The leoPymacs module is intended to be called from Emacs using pymacs.  It contains the following top-level functions:

- get_app()

  Returns the hidden app created by the leoPymacs.init function.

- dump(anyPythonObject)

  Returns str(repr(anyPythonObject)).

- get_g()

  Returns the leoGlobals module of the hidden app created by the leoPymacs.init function.

- get_script_result()

  Returns g.app.scriptResult, where g.app is the hidden app.

- init()
  Calls leo.run(pymacs=True) to create a hidden Leo application.
  Later calls to open can open hidden Leo outlines that can be accessed via runScript.

- open(fileName)

  Opens the .leo file given by fileName.
  fileName must be the full path to a .leo file.
  Returns the commander of the open Leo outline, or None if the outline could not be opened.

- run_script(c,script,p=None)

  Executes a script in the context of a commander c returned by the leoPymacs.open.
  c may be None, in which case a dummy commander is created in which to run the script.
  In the executed script, p is set to c.p if no p argument is specified.
  Returns g.app.scriptResult, where g.app is the hidden app.
</t>
<t tx="ekr.20061025081359">Leo's leoPymacs module is a simple 'server' for the pymacs_ package.
Using pymacs and leoPymacs, elisp_ scripts in Emacs_ can open .leo files and execute *Python* scripts
as if they were executed inside Leo.
In particular, such scripts can use Leo's predefined c, g and p variables.
Thus, *Python* scripts running in Emacs can:

- Open any .leo file. 
- Access any part of the outline. 
- Change any part of the outline, including external files, 
- Save .leo files.
- Execute *any* Leo script.

In short, you can now do from Emacs anything that you can do with Leo scripting inside Leo.

Here are step-by-step instructions for executing Python scripts in Emacs:

**Step 1. Install pymacs** 

   The pymacs installation instructions should be clear enough.
   A clarification is needed about two-way communication between Python and lisp scripts:
   in truth, Python scripts can call the Pymacs.lisp function *only* if the Python script
   was invoked from emacs.
   Otherwise, calling Pymacs.lisp will hang the process making the call.
   For example, executing the following script as an ordinary Leo script will hang Leo::

        from Pymacs import lisp
        print lisp("""2+2""") # Hangs

**Step 2. Load the leoPymacs module from Emacs, creating a hidden Leo application**

  From inside Emacs, you load Leo's leoPymacs module as follows::

    (pymacs-load "leoPymacs" "leo-")

  The call to pymacs-load is similar to 'import leoPymacs as leo-' in Python.
  The side effect of pymacs-load is to define the elisp function leo-x for every top-level function x in leoPymacs.py,
  namely leo-dump, leo-get-app, leo-get-g, leo-get-script-result, leo-init, leo-open and leo-run-script.
  The first call to any of these functions creates a **hidden Leo application**
  in which .leo files may be loaded, modified and saved,
  and in which Leo scripts may be executed.
  This hidden Leo application uses Leo's nullGui class as its gui,
  so Leo commands and Leo scripts that require a fully functional gui will not work as
  expected in the hidden Leo application.
  Steps 3 and 4 tell how to use this hidden Leo application.

  pymacs-load works like a Python reload, so you can redefine leoPymacs.py while Emacs is running.
  However, calling pymacs-load destroys the old hidden Leo application and creates a new one,
  so typically you would want to call pymacs-load only once per Emacs session.
  Like this::

        (setq reload nil) ; change nil to t to force a reload.

        (if (or reload (not (boundp 'leoPymacs)))
            (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
            (message "leoPymacs already loaded")
        )

**Step 3. From Emacs, open .leo files**

   Once we have loaded the leoPymacs module
   we can open a .leo file as follows::

    (setq c (leo-open fileName))

   This binds the elisp c variable to the Leo commander created by opening fileName.
   fileName should be the full path to a .leo file.
   In the next step we will use this c variable to execute *Leo* scripts in the
   context of an open Leo outline.

   Sometimes we want to execute a Leo script before opening any Leo commanders.
   For example, we might want to compute the fileName passed to leo-open.
   leo-run-script allows the c argument to be nil,
   in which case leo-run-script creates a dummy commander in which to run the script.
   For example, the following script calls g.os_path_join and g.os_path_abspath::

        (setq script "g.app.scriptResult =
            g.os_path_abspath(g.os_path_join(
                g.app.loadDir,'..','test','ut.leo'))"
        )

        (setq fileName (leo-run-script nil script))

   leo-run-script returns the value of g.app.scriptResult
   As shown above, Python scripts may set g.app.scriptResult to indicate their result.
   elisp scripts can also get g.app.scriptResult using leo-script-result.
   Note that the Python script may span multiple lines.

**Step 4. From Emacs, execute Leo (Python) scripts**

   From emacs we can execute a Python script **as if** it were executed in an
   open Leo outline.
   Suppose aLeoScript is an **elisp** string containing a Leo (Python) script.
   We can execute that script in the hidden Leo application as follows::

        (leo-run-script c aLeoScript)

   For example::

        (setq c (leo-open fileName)
        (csetq script "print 'c',c,'h',c.p.h")
        (leo-run-script c script)

Putting this all together, we get::

        ; Step 1: load leoPymacs if it has not already been loaded.
        (setq reload nil)
        (if (or reload (not (boundp 'leoPymacs)))
            (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
            (message "leoPymacs already loaded")
        )

        ; Step 2: compute the path to leo/test/ut.leo using a Leo script.
        (setq script
            "g.app.scriptResult = g.os_path_abspath(
                g.os_path_join(g.app.loadDir,'..','test','ut.leo'))"
        )
        (setq fileName (leo-run-script nil script))

        ; Step 3: execute a script in ut.leo.
        (setq c (leo-open fileName))
        (setq script "print 'c',c.shortFileName() ,'current:',c.p.h")
        (leo-run-script c script)
</t>
<t tx="ekr.20061025142434">Leo's mini-buffer is a text area at the bottom of the body pane.
You use Leo's minibuffer like the Emacs mini-buffer to invoke commands by their so-called *long name*.
The following commands affect the minibuffer:

- **full-command**: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
  full command name, then hit &lt;Return&gt; to execute the command. Tab completion
  works, but not yet for file names.

- **quick-command-mode**: (default shortcut: Alt-x) Like Emacs Control-C. This mode is
  defined in leoSettings.leo. It is useful for commonly-used commands.

- **universal-argument**: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat
  count for later command. Ctrl-u 999 a adds 999 a's.

- **keyboard-quit**: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
  the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.
</t>
<t tx="ekr.20061026095728">Leo 4.4.2.1 final                                October 29, 2006

Leo 4.4.2.1 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.2.1 final fixes a recent bug that caused Leo not to create the
.leoRecentFiles.txt file properly in some situations. There are no known
significant bugs in this version of Leo.

Leo 4.4.2 final fixes a few bugs and adds support for pymacs. 

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.2:
----------------------------
- You can now store settings in myLeoSettings.leo without fear of those settings
  being changed by cvs updates or in future versions of Leo.
- Leo's vnode and tnode classes are now completely independent of the rest of Leo.
  Some api's have been changed.  This 'big reorg' and may affect scripts and plugins.
- Leo's vnode and tnode classes can optionally be compatible with ZODB databases,
  i.e., they can optionally derive from ZODB.Persistence.Persistent.
  See Chapter 17: Using ZODB with Leo for details.
- The leoOPML plugin defines commands to read and write OPML files.
- The slideshow plugin allows Leo to run slideshows defined by @slideshow and @slide nodes.
- The leo_to_rtf and leo_to_html plugins create rtf and html files from Leo outlines.
- Much faster navigation through the outline.
- When focus is in the outline pane, you can move to headlines by typing the first letter of headlines.
- The find command now optionally closes nodes not needed to show the node containing the present match.
- Numerous changes that make Leo easier to use without using a mouse, including new commands and options.
- Many new minibuffer commands now appear in the Cmds menu.
- A sax parser can now optionally read .leo files.
- Fixed numerous bugs.

Links:
------
Leo:        http://leoeditor.com
What's new: http://leoeditor.com/new-4-4-2.html
Home:       http://sourceforge.net/projects/leo/
Download:   http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:        http://leo.tigris.org/source/browse/leo/
Quotes:     http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20061026095922.1"></t>
<t tx="ekr.20061026095922.15">http://sourceforge.net/forum/message.php?msg_id=3971242
</t>
<t tx="ekr.20061026095922.17"></t>
<t tx="ekr.20061026095922.19"></t>
<t tx="ekr.20061026095922.2"></t>
<t tx="ekr.20061026095922.25">The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entries to leoColor.leoColors.
</t>
<t tx="ekr.20061026095922.3"></t>
<t tx="ekr.20061026095922.32">It required a space after the '@'
</t>
<t tx="ekr.20061026095922.33">http://sourceforge.net/forum/message.php?msg_id=3975898
</t>
<t tx="ekr.20061026095922.35"></t>
<t tx="ekr.20061026095922.36">For full details, see Chapter 18 of Leo's Users Guide: Emacs and Leo.
</t>
<t tx="ekr.20061026095922.51">http://sourceforge.net/forum/message.php?msg_id=3980193

</t>
<t tx="ekr.20061031131434.43">def completeSelf (self):

    g.trace(g.callers(4))

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfVnodesDict [p.v] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20061031131434.57"></t>
<t tx="ekr.20061031131434.58">def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
</t>
<t tx="ekr.20061031131434.59">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) # Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
</t>
<t tx="ekr.20061031131434.60">class ForgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
</t>
<t tx="ekr.20061031131434.61">def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
</t>
<t tx="ekr.20061031131434.62">def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


</t>
<t tx="ekr.20061031131434.63">def forgivingParser (self,p,suppress=False):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            if not g.isPython3:
                s = g.toEncodedString(s)
            compile(s+'\n','&lt;string&gt;','exec')
            break
        except SyntaxError:
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                if not suppress:
                    g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.h)
                self.excludedTnodesList.append(p.v)
                s = g.getScript(c,root,useSelectedText=False)
        except Exception:
            g.trace('unexpected exception')
            g.es_exception()
            break
    return s or ''
</t>
<t tx="ekr.20061031131434.64">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    # vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        # lines, n, root, scriptFind = True)

    goto = goToLineNumber(c)
    vnodeName,junk,junk,junk = goto.findVnode(
        root,lines,n,ignoreSentinels)

    if vnodeName:
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                return p

    return None
</t>
<t tx="ekr.20061031131434.65">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.h)
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
</t>
<t tx="ekr.20061031131434.66"># Called by completeSelf, which is not used.

class ClassScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
</t>
<t tx="ekr.20061031131434.67">def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
</t>
<t tx="ekr.20061031131434.68">def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.p)
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
</t>
<t tx="ekr.20061031131434.69">def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents():
        obj = autoCompleter.selfVnodesDict.get(p.v)
        if obj:
            # g.trace('found',obj,'in',p.h)
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.h)
            return className,None,p

    return None,None,None
</t>
<t tx="ekr.20061031131434.70">def findClass (self,p):

    lines = g.splitLines(p.b)
    inDoc = self.start_in_doc
    # g.trace(p.h)
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
</t>
<t tx="ekr.20061031131434.71">def endsDoc (self,s):

    return s.startswith('@c')
</t>
<t tx="ekr.20061031131434.72">def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
</t>
<t tx="ekr.20061031131434.73">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
</t>
<t tx="ekr.20061109102912">mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasSelection',
    'oops',
    'onBodyChanged',
    'recolor',
    'recolor_now',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
)
</t>
<t tx="ekr.20061109120704">mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
</t>
<t tx="ekr.20061109120726">mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
</t>
<t tx="ekr.20061109164512">mustBeDefinedOnlyInBaseClass = (
    # Getters &amp; setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
</t>
<t tx="ekr.20061109164610">mustBeDefinedInSubclasses = (
    # Colors &amp; fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing &amp; scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
</t>
<t tx="ekr.20061109211022">mustBeDefinedInSubclasses = (
    # Startup &amp; shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    'createFindTab',
    # 'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    #'eventChar',
    #'eventKeysym',
    'eventWidget',
    # 'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    # 'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
</t>
<t tx="ekr.20061109211054">mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
</t>
<t tx="ekr.20061116060847"></t>
<t tx="ekr.20070115172724">The following three section discuss three ways of debugging scripts with winpdb_.
The first two sections tell how to debug general scripts;
the last section tells how to debug Leo-specific scripts.

winpdb_ and its documentation have been improved recently.
For more details, see the `embedded winpdb`_ docs.
The discussion of embedded debugging may have been written specifically with Leo in mind.
</t>
<t tx="ekr.20070115172724.1">This way of debugging can only be used for general scripts, not leo-specific scripts.  
The debug command writes the script to scriptFile.py and invokes winpdb.
winpdb opens and is already 'attached' to the script to be debugged.
You can single-step as you like.
Leo continues to run, but killing the debugger will also kill Leo.
</t>
<t tx="ekr.20070115172724.3">This way of debugging scripts allows winpdb to debug scripts that use c, g and p.
A bit more work is needed because winpdb does not start automatically.
Here are step-by step instructions:

1. Insert the following two lines of code at the start of the script to be debugged::

    import rpdb2
    rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

2. Execute Leo's execute-script command (*not* the debug command).
   Leo will appear to hang: start_embedded_debugger is waiting for *another* copy of winpdb to 'attach' to the script's process.
   The default timeout is 5 minutes, after which an exception gets thrown.

3. Start winpdb explicitly by executing something like the following in a console::

    python /Python26/Scripts/_winpdb.py -t

   The -t option tells winpdb that no encoding of password is necessary.
   The password is specified in the call to rpdb2.start_embedded_debugger in your script.
   In our example, the password is 'go'.

4. Use winpdb's File:Attach command to attach winpdb to Leo.
   Specify the password as 'go' and you will see the scriptFile.py containing your entire script.
   You can now execute or single-step through the script. 
   To repeat, c, g and p are defined, so you can debug any script this way.
</t>
<t tx="ekr.20070116062405">Inserting g.trace statements in my Python code is usually my first debugging
choice. The g.trace statement prints the name of the function in which the call
to g.trace occurs, followed by the value of its arguments. The output of the
g.trace goes to the console, so you must `run Leo in a console window`_ to use
g.trace.

Inserting and deleting g.trace statements is fast, provided that your `work
flow`_ makes it easy to restart the program under test. As a result, using
g.trace statements is similar to setting tracepoints in a debugger, with the
advantage that (disabled) tracepoints remain in the source code for future use.
You will find many examples of using g.trace throughout Leo's source code.

My second choice is using g.pdb to set breakpoints for the pdb_ debugger. Pdb
uses the console for all interaction, so you must `run Leo in a console window`_.
See `the FAQ`_ for a discussion of both g.trace and g.pdb.
</t>
<t tx="ekr.20070120075236">.. index::
    pair: Predefined Symbols; Tutorial
    
The execute-script command predefines the symbols c, g and p.

c is the **commander** of the outline containing the script.

- Commanders are instances of the Commands class, defined in leoCommands.py.

- Commanders provide access to all outline data *and* all of Leo's source code.

g is Leo's **leo.core.leoGlobals** module.

- This module contains many useful functions, including g.es.

p is the **position** of the presently selected node.

- positions are instances of the position class, defined in leoNodes.py.

- The position class provides safe, convenient ways of accessing and
  modifying outline nodes.

- For any position p, p.v is a **vnode** object.

- vnodes contain all the permanent data in a Leo outline.

The next two sections are crucial: they discuss vnodes and positions in all
necessary detail.
</t>
<t tx="ekr.20070122070619">Leo 4.4.3 alpha 1                                  January 26, 2006

Leo 4.4.3 alpha 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Important: the wxGui plugin is still alpha-quality code at present.

The highlights of Leo 4.4.3:
----------------------------
- A functional wxWidgets plugin.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Many minor improvements, new settings and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070122070634.1"></t>
<t tx="ekr.20070122070634.13">http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.
</t>
<t tx="ekr.20070122070634.2">Example:

print "\\" + " this is a test"

The escape mechanism must treat an even number of trailing escapes as not an escape.
</t>
<t tx="ekr.20070122070634.209">
</t>
<t tx="ekr.20070122070634.220">http://sourceforge.net/forum/message.php?msg_id=3987635
</t>
<t tx="ekr.20070122070634.223">New settings

The following two new settings now control whether the execute-script and debug commands write the script to an external file.

- @bool write_script_file = True

True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file.

False (legacy): The execute script command uses Python's exec command to execute the script. 

- @string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command.

Notes:

- This setting has effect only if the write_script_file setting is True.
- Use / to as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py
- The filename should end in .py.

From here on, let us assume the settings are as shown above.  There are at least three ways of debugging scripts, depending on your preferences and whether the script contains leo-specific code (g, c or p) or not.

First way:  The debug command

The debug command now works almost exactly like Kent's original @button node. This way of debugging can only be used for general scripts, not leo-specific scripts.  

The debug command writes the script to scriptFile.py and invokes the debugger as specified by the existing @string debugger_kind option.  winpdb opens and is already 'attached' to the script to be debugged.  You can single-step as you like.  Leo continues to run, but killing the debugger will also kill Leo.  When started this way, winpdb is really 'attached' to *all* of Leo, which means you can single step past the end of the script into Leo's executeScript code and from there into all of Leo(!)

As I write this I realize that the code uses arguments specific to winpdb.  That may have to be generalized, though I am not sure why anyone would want to use another debugger...

Second way: @button winpdb

This is almost exactly equivalent to the debug command, except that the script file must be *different* from the script file specified by the  script_file_path setting (The @button code *itself* uses the execute-script command, so we have to pass the script code, not the @button code to the debugger).

Third way: The execute-script command with explicit debugger breaks

The third way of debugging scripts allows winpdb to debug scripts that use c, g and p.  I'm actually not sure of exactly how and why it works, but it certainly does work.

In contrast to the previous two ways, a little more work is needed because winpdb does not start automatically.  But I am getting ahead of myself.

To use this way, insert the following two lines of code at the start of the script to be debugged::

import rpdb2
rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

Now just execute the execute-script command (*not* the debug command)  Leo will appear to hang.  Indeed, the  start_embedded_debugger command is waiting for *another* copy of winpdb to 'attach' to the script's process.  This process is all of Leo!  The default timeout is 5 minutes: I'm not sure what happens when the timeout happens: probably an exception gets thrown.

So you must start winpdb explicitly.  On XP just do something like

python c:\python25\Scripts\_winpdb.py -t

The -t option tells winpdb that no encoding of password is necessary.  The password is specified in the call to rpdb2.start_embedded_debugger in your script.  In this example, the password is 'go'.  Use the File:Attach command in winpdb to attach winpdb to Leo.  Specify the password as 'go' and you will see the scriptFile.py containing your entire script.  You can execute or single-step through the script. 

To repeat, the big difference is that c, g and p are defined, so you can debug any script this way.  As before, killing winpdb also kills Leo.

P.S.  winpdb and its documentation has been improved recently.  See

http://www.digitalpeers.com/pythondebugger/  and especially

http://www.digitalpeers.com/pythondebugger/embedded.htm

The discussion of embedded debugging may have been written specifically with Leo in mind.  It certainly could have been.
</t>
<t tx="ekr.20070122070634.298"></t>
<t tx="ekr.20070122070634.299">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991223

I assigned both Control and Shift modifiers to do scrolling: this is so my
finger can hit a key in the lower left corner of the keyboard, and I don't have
to worry too much about my aim (I have LARGE fingers). Also, I stop the
scrolling on the JUST button release -- less worry about my finger slipping off
the key.
</t>
<t tx="ekr.20070122070634.300"></t>
<t tx="ekr.20070122070634.301"></t>
<t tx="ekr.20070122070634.302">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LEFT" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.

EKR: I love this new option: how did we ever live without it?

@color
</t>
<t tx="ekr.20070122070634.303">@nocolor

This option tells how to treat an uppercase letter typed when the outline pane
is active but no headline is being edited. In such situations Leo searches for an
node whose headline starts with the present prefix, ignoring case The prefix
starts with the first letter typed and other letters are added if they are typed
within a 'short' period of time, as specified by the outline_nav_extend_delay

True: Look in invisible nodes.
False: Look only in visible nodes.

I set this option to False because it is too easy form me to type Shift-whatever
when I meant Ctrl-whatever.

@color
</t>
<t tx="ekr.20070122070634.304">http://sourceforge.net/forum/message.php?msg_id=3985382

</t>
<t tx="ekr.20070122070634.305">Leo's core is now largely free of gui-dependent code, and should be completely
free of such code by the time Leo 4.4.3 final is released.
</t>
<t tx="ekr.20070122070634.4"></t>
<t tx="ekr.20070122070634.40">http://sourceforge.net/forum/message.php?msg_id=3991369

The bindings to f.f.OnControlKeyDown/Up were mistakenly deleted in createOuterFrames.
</t>
<t tx="ekr.20070122070634.51"></t>
<t tx="ekr.20070122070634.54">http://sourceforge.net/forum/message.php?msg_id=4112347
</t>
<t tx="ekr.20070122070634.58"></t>
<t tx="ekr.20070122070634.59"></t>
<t tx="ekr.20070122070634.66"></t>
<t tx="ekr.20070122070634.69"></t>
<t tx="ekr.20070122070634.81">This is much less confusing.
</t>
<t tx="ekr.20070122070634.82"></t>
<t tx="ekr.20070122070634.83">http://sourceforge.net/forum/message.php?msg_id=4014079
</t>
<t tx="ekr.20070122070634.89">http://sourceforge.net/forum/message.php?msg_id=4005750

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.
</t>
<t tx="ekr.20070122070634.91"></t>
<t tx="ekr.20070122072110"></t>
<t tx="ekr.20070122093626">Positions become invalid whenever the outline changes. 

This script finds a position p2 having the same vnode as an invalid
position p::

    if not c.positionExists(p):
        for p2 in c.all_positions():
            if p2.v == p.v: # found
                c.selectPosition(p2)
        else:
            print('position no longer exists')
</t>
<t tx="ekr.20070122104240">http://sourceforge.net/forum/message.php?msg_id=4113315
</t>
<t tx="ekr.20070215183046">- IronPython does not accept 'from __future__ import x'
  I could work around this, but perhaps it is time to abandon Python 2.2.2.

- Amazingly, it is possible to add Python24\Lib to IronPython's path!
  Almost all of those modules import correct.

- IronPython has troubles with the xml modules.
  It complains about a missing 'strict' codec.

- IronPython has trouble with the pdb module, so some other way must be found to debug IronPython programs.
</t>
<t tx="ekr.20070308062440"></t>
<t tx="ekr.20070308062440.1">On 2/26/07, Edward Ream &lt;edreamleo@charter.net&gt; wrote:

&gt; threads will swap after sys.getcheckinterval() bytecodes have been
&gt; processed for that thread.

Many thanks for this detailed summary.  I think this is the guarantee I need
a) to experiment with threads and b) to fiddle with settings should that 
appear to be necessary.

Just be careful.  Test your assumptions before you rely on them, especially regarding threads.  Generally threading is seen as a "hard" problem.  If you want to help make them easier, use Queues to handle inter-thread communication. 


&gt; you can use a technique known as 'cooperative multithreading with 
&gt; generators'.

Googling this leads directly to an entry in the Python Cookbook.  The site
is down at present.  I'll study this entry when it's back up.

The basic idea is to have each task be a generator, with each generator giving up control after some amount of work.  Here's a variant of the recipe in the cookbook... 

 - Josiah

import collections

tasks = collections.deque()

def busy():
    while 1:
        yield None

def delay(v):
    import time
    while 1:
        time.sleep(v)
        yield None 

def xpasses(x):
    while x &gt; 0:
        x -= 1
        yield None

def runtasks():
    while 1:
        task = tasks.popleft()
        try:
            task.next()
        except StopIteration: 
            pass
        else:
            tasks.append(task)
</t>
<t tx="ekr.20070316182323"></t>
<t tx="ekr.20070316182323.1">Leo 4.4.3 alpha 2                                  March 17, 2006

Leo 4.4.3 alpha 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version of Leo should be safe enough for production use. It is an alpha
distribution because not all plugins have been tested on the reorganized code
base.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3:
----------------------------
- A leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Added support for @enabled-plugins nodes in settings files.
- The__wx_gui plugin is now functional.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Many minor improvements, new settings and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070316182341.1"></t>
<t tx="ekr.20070316182341.10">http://sourceforge.net/forum/message.php?msg_id=4134384
</t>
<t tx="ekr.20070316182341.112">It's about Nav_buttons v1.5 (cvs version from last Saturday) 

Pressing the green back button causes 

Error: 1 
AttributeError Exception in Tk callback 
Function: &lt;bound method Commands.goPrevVisitedNode of Commander 39717104: u'F:\\D\\PIM\\PIM_main.leo'&gt; (type: &lt;type 'instancemethod'&gt;) 
Args: () 
Traceback (innermost last): 
File "F:\C\Programs\Leo_cvs\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__ 
return apply(self.func, args) 
File "F:\C\Programs\Leo_cvs\src\leoCommands.py", line 4435, in goPrevVisitedNode 
c.treeCommandHelper(v) 
AttributeError: Commands instance has no attribute 'treeCommandHelper' 
</t>
<t tx="ekr.20070316182341.113">http://sourceforge.net/forum/message.php?msg_id=4201463
</t>
<t tx="ekr.20070316182341.137">http://sourceforge.net/forum/message.php?msg_id=4205072
</t>
<t tx="ekr.20070316182341.138">Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2474, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 156, in rClicker
    n0,p0=ind0.split('.',2)

AttributeError: 'int' object has no attribute 'split'
</t>
<t tx="ekr.20070316182341.139">Leo did not write to the log pane that settings, either present
in myLeoSettings.leo or the current file, were read.
</t>
<t tx="ekr.20070316182341.155"></t>
<t tx="ekr.20070316182341.2"></t>
<t tx="ekr.20070316182341.39">Down arrow wasn't handled properly.
</t>
<t tx="ekr.20070316182341.41"></t>
<t tx="ekr.20070316182341.42">http://sourceforge.net/forum/message.php?msg_id=3994218
</t>
<t tx="ekr.20070316182341.43"></t>
<t tx="ekr.20070316182341.437"></t>
<t tx="ekr.20070316182341.438">http://sourceforge.net/forum/message.php?msg_id=4162357
</t>
<t tx="ekr.20070316182341.440">The leoBridge module allows complete access to all aspects of Leo from programs
running independently of Leo. Let us call such a program a **host** program.
Using the leoBridge module, foreign programs can get access to:

- all of Leo's source code,
- the contents of any .leo file,
- the commander of any .leo file.

Host programs use the leoBridge module as follows::

    import leoBridge
    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)

Let us look at these statements in detail.  The statements::

    import leoBridge
    controller = leoBridge.controller(gui='nullGui')

import the leoBridge module and create a **bridge controller**. In effect, these
statements embed an 'invisible' copy Leo into the host program. This embedded
copy of Leo uses a 'null' gui, which simulates all aspects of Leo's normal gui
code without creating any screen objects.

The statement::

    g = controller.globals()

provides access to Leo's leoGlobals module, and properly inits globals such as g.app, g.app.gui, etc.  Host programs **should not** import leoGlobals directly, because doing so would not init the g.app object properly.

The statement::

    c = controller.openLeoFile(path)

invisibly opens the .leo file given by the path argument. This call returns a
completely standard Leo commander, properly inited. This is the big payoff from
the leoBridge module: the host program gets instant access to c.config.getBool,
etc. Do you see how sweet this is?

The following script runs leo/test/leoBridgeTest.py outside of Leo.
leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo.
Try it::

    import os,sys

    path = g.os_path_abspath(
        g.os_path_join(
            g.app.loadDir,'..','test','leoBridgeTest.py'))

    os.system('%s %s' % (sys.executable,path))
</t>
<t tx="ekr.20070316182341.54"></t>
<t tx="ekr.20070316182341.56"># The buggy code only happens when there is no binding for backward-delete-char.
# http://sourceforge.net/forum/forum.php?thread_id=1681392&amp;forum_id=10227
</t>
<t tx="ekr.20070316182341.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4132529

I'm generating Leo files with ElementTree and ran into a minor issue.

ElementTree generates an empty tag with a space before the closing slash:

&lt;globals /&gt;

in Leo's code for dummy elements to allow copied nodes to be valid Leo files,
the empty tags are generated without the space

leoFileCommands.py 2917
        self.put('&lt;globals/&gt;\n')
        self.put('&lt;preferences/&gt;\n')
        self.put('&lt;find_panel_settings/&gt;\n')

it then checks for these tags in getDummyElements() leoFileCommands.py 1298

Since ElementTree has the space before the slash, 
it's XML is considered invalid by Leo according to
this test.

I would like it if the space could be added in Leo's
self.put(...) and the check in getDummyElements()

The XML specs show the space as optional.

@color
</t>
<t tx="ekr.20070316182341.66"></t>
<t tx="ekr.20070316182341.718">http://sourceforge.net/forum/message.php?msg_id=4169720
</t>
<t tx="ekr.20070316182341.723">Any .leo file may now contain an @enabled-plugins node as a child of an
@settings node.

Notes:

A) Leo attempts to load all plugins every time an @enabled-plugins node is seen.
   If the plugin has already been loaded, Leo silently ignores the
   request to re-enable the plugin.
   Leo never attempts to disable a plugin while processing enabled plugin
   strings. Thus, plugins enabled in an @enabled-plugins node in leoSettings.leo
   *will* be enabled regardless of the contents of any other @enabled-plugins node.

B) The default plugins will be enabled in an @enabled-plugins
   node in leoSettings.leo.

C) g.app.gui.getEnabledPlugins contains the last value last processed @enabled-plugins node.
</t>
<t tx="ekr.20070317033759"></t>
<t tx="ekr.20070317033759.1">#######################################
Embedding Leo with the leoBridge module
#######################################

The leoBridge module allows complete access to all aspects of Leo from other
Python programs running independently of Leo. Let us call such a program a
**host** program. Using the leoBridge module, host programs can get access to:

- all of Leo's source code,
- the contents of any .leo file,
- the commander of any .leo file.

.. contents::
    :depth: 2

</t>
<t tx="ekr.20070317033759.2">.. Links
</t>
<t tx="ekr.20070317033759.3">Host programs use the leoBridge module as follows::

    import leo.core.leoBridge as leoBridge
    
    controller = leoBridge.controller(gui='nullGui',
        loadPlugins=True,  # True: attempt to load plugins.
        readSettings=True, # True: read standard settings files.
        silent=False,      # True: don't print signon messages.
        verbose=False)     # True: print informational messages.

    g = controller.globals()
    c = controller.openLeoFile(path)

Let us look at these statements in detail. The first two statements
import the leoBridge module and create a **bridge controller**. In
effect, these statements embed an invisible copy of Leo into the host
program. This embedded copy of Leo uses a null gui, which simulates
all aspects of Leo's normal gui code without creating any screen
objects.

The statement::

    g = controller.globals()

provides access to Leo's leoGlobals module, and properly inits globals such as
g.app, g.app.gui, etc. *Host programs should not import leoGlobals directly*,
because doing so would not init the g.app object properly.

The statement::

    c = controller.openLeoFile(path)

invisibly opens the .leo file given by the path argument. This call returns a
completely standard Leo commander, properly inited. This is the big payoff from
the leoBridge module: the host program gets instant access to c.config.getBool,
etc. Do you see how sweet this is?

For example, the following script runs leo/test/leoBridgeTest.py outside of Leo.
leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo::

    import os,sys

    path = g.os_path_abspath(
        g.os_path_join(
            g.app.loadDir,'..','test','leoBridgeTest.py'))

    os.system('%s %s' % (sys.executable,path))

The file leo/test/test.leo contains the source code for leoBridgeTest.py.
Here it is, stripped of its sentinel lines::

    '''A program to run unit tests with the leoBridge module.'''

    import leo.core.leoBridge as leoBridge
    import leo.core.leoTest as leoTest

    def main ():
        tag = 'leoTestBridge'

        # Setting verbose=True prints messages that would be sent to the log pane.
        bridge = leoBridge.controller(gui='nullGui',verbose=False)
        if bridge.isOpen():
            g = bridge.globals()
            path = g.os_path_abspath(g.os_path_join(
                g.app.loadDir,'..','test','unitTest.leo'))
            c = bridge.openLeoFile(path)
            g.es('%s %s' % (tag,c.shortFileName()))
            runUnitTests(c,g)

        print tag,'done'

    def runUnitTests (c,g):
        nodeName = 'All unit tests' # The tests to run.
        try:
            u = leoTest.testUtils(c)
            p = u.findNodeAnywhere(nodeName)
            if p:
                g.es('running unit tests in %s...' % nodeName)
                c.selectPosition(p)
                c.debugCommands.runUnitTests()
                g.es('unit tests complete')
            else:
                g.es('node not found:' % nodeName)
        except Exception:
            g.es('unexpected exception')
            g.es_exception()
            raise

    if __name__ == '__main__':
        main()
</t>
<t tx="ekr.20070317043727">Organizer nodes have headlines that do no start with @.
Organizer nodes may be inserted freely without changing the meaning of an @setting tree.
</t>
<t tx="ekr.20070317043727.2">Simple settings nodes have headlines of the form::

    @&lt;type&gt; name = val

set the value of name to val, with the indicated type.

&lt;type&gt; may be one of the following:

=============== =========================================================================================
&lt;type&gt;          Valid values
--------------- -----------------------------------------------------------------------------------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)
\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@keys[name]     Gives a name to a set of bindings for the Check Bindings script in leoSettings.leo.
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'
=============== =========================================================================================

**Note**: For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

**Important**: you can use the show-colors minibuffer command to guide you in making these settings.
</t>
<t tx="ekr.20070317043727.3">Complex settings nodes have headlines of the form::

    @&lt;type&gt; description

The type may be one of the following:

=================== =====================================================================
&lt;type&gt;              Valid values 
------------------- ---------------------------------------------------------------------
\@buttons           Child @button nodes create global buttons
\@commands          Child @command nodes create global buttons
\@data              Body text contains a list of strings, one per line.
\@enabled-plugins   Body text contains a list of enabled plugins
\@font              Body text contains a font description
\@menus             Child @menu and @item nodes create menus and menu items.
\@menuat            Child @menu and @item nodes modify menu tree create by \@menus.
\@mode [name]       Body text contains a list of shortcut specifiers.
\@recentfiles       Body text contains a list of file paths.
\@shortcuts         Body text contains a list of shortcut specifies.
=================== =====================================================================

Complex nodes specify settings in their body text.
See the following sections for details.
</t>
<t tx="ekr.20070317044545">The __wx_gui.py plugin is now minimally functional. All significant unit tests
pass with this plugin in effect. However, problems remain. See the bug list in
the plugin for details.
</t>
<t tx="ekr.20070513111132">Leo 4.4.3 beta 1                                May 18, 2006

Leo 4.4.3 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
  Chapters are disabled by default.  To enable, set @bool use_chapters = True.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @openwith nodes in settings files.
- The__wx_gui plugin is now functional.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070513111526.1"></t>
<t tx="ekr.20070513111526.10"></t>
<t tx="ekr.20070513111526.105"></t>
<t tx="ekr.20070513111526.14">http://sourceforge.net/forum/message.php?msg_id=3737745

http://sourceforge.net/forum/message.php?msg_id=3785897

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, thereby being less intimidating.
</t>
<t tx="ekr.20070513111526.198">http://sourceforge.net/forum/message.php?msg_id=4215654

There was a bug with ordinary hoisting: in the "Outline" menu the "Delete Node"
menu item was not disabled when the local root is selected.
</t>
<t tx="ekr.20070513111526.2">It is True by default. In effect, this setting was False in previous versions
of Leo, which might be considered a bug.
</t>
<t tx="ekr.20070513111526.200"></t>
<t tx="ekr.20070513111526.39"></t>
<t tx="ekr.20070513111526.42">Leo now supports zipped .leo files:

- Leo now has save-file-as-zipped and save-file-as-unzipped commands, and
corresponding Save File As Zipped and Save File as Unzipped items in the File
menu. These are exactly the same as Leo's Save As commands except that they
temporarily force Leo to write the file in either zipped or unzipped format.

- Leo remembers whether a file was originally zipped. The read logic handles
either zipped or unzipped .leo files automatically. The write logic will zip the
file if it was originally zipped or if the save-file-as-zipped command is being
executed.

- Leo writes files with .leo extension, regardless of whether the file is zipped
or not. Zipped .leo files contain a single archive, whose name is the same as
the .leo file itself.

Notes:

- The new save commands suffice to compress and expand .leo files on a
file-by-file basis. In particular, there is no need for any user settings.

- Outside of Leo you can change the extension to .leo.zip and use stuffit or
other program to expand the .leo file contained within. I've only tested this on
XP, but it should work everywhere...

- At present the code uses Python's zipfile module to read and write zipped files.
In turn, the zipfile module uses the zlib module to do the compression.
Conceivably somebody might want Leo to use some other compression technique, say
Python's tarfile module. However, I think the present way should suffice for
most people.
</t>
<t tx="ekr.20070513111526.7"></t>
<t tx="ekr.20070513111526.77"></t>
<t tx="ekr.20070513111526.78"># Found via unit test.  Happens regardless of chapters.
</t>
<t tx="ekr.20070513111526.8"></t>
<t tx="ekr.20070513111526.80"># Returns in finally clauses prevent the re-raising of the saved exception(!!)
</t>
<t tx="ekr.20070513112414">- Added support for chapters to Leo's core

  Chapters are regions of a Leo outline whose root is an @chapter node. @chapter
  nodes may appear anywhere in an outline, but the create-chapter command (see
  below) creates @chapter nodes as children of a single @chapters node.

  Selecting a chapter shows only then nodes in the selected chapter; in this
  respect, chapters are like hoists. The main chapter represents the entire
  outline and can not be deleted by name. When chapters are in effect, Leo
  creates a hidden @chapters node containing one @chapter node for every chapter
  except the 'main' chapter.

  Associated settings:

  - The @bool use_chapters setting determines whether chapters are enabled.
  - The @bool use_chapter_tabs setting determines whether the chapters
    pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

  When chapters are enabled, the Cmds:Chapters menu shows all available chapter commands:

  - The create-chapter command creates an @chapter node and with a single node.
  - The delete-chapter command deletes the presently selected chapter.
  - The select-chapter command makes only the nodes of the selected chapter visible.
  - The move-node-to-chapter, clone-node-to-chapter and copy-node-to-chapter commands
    add a node (and its descendants) to another chapter.
</t>
<t tx="ekr.20070513113903">The highlights of Leo 4.4.3:

- @test and @suite nodes may now be embedded directly in external files.
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- The new leoBridge module allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins and @openwith nodes in settings files.
- Removed all gui-dependent code from Leo's core.
- The__wx_gui plugin is now functional.
</t>
<t tx="ekr.20070610063456">Leo 4.4.3 beta 2                                June 12, 2006

Leo 4.4.3 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
  Chapters are disabled by default.  To enable, set @bool use_chapters = True.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @openwith nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070610063538.1"></t>
<t tx="ekr.20070610063538.151"></t>
<t tx="ekr.20070610063538.163">http://sourceforge.net/forum/message.php?msg_id=4320971
</t>
<t tx="ekr.20070610063538.164">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4309448

Still to do: update urls for tigris.
</t>
<t tx="ekr.20070610063538.165">http://sourceforge.net/forum/message.php?msg_id=4301021
</t>
<t tx="ekr.20070610063538.168">- Select a node by clicking on it.
- The node is selected, but shift-arrow does not work.

However, clicking the canvas does work.

The fix was to give the canvas, not the headline focus when clicking on a headline.
This results in canvas bindings, not text bindings, having priority.
This is not a kludge: the text widget isn't active, so text bindings should not be in effect.
</t>
<t tx="ekr.20070610063538.171"></t>
<t tx="ekr.20070610063538.175">http://sourceforge.net/forum/message.php?msg_id=4340244
</t>
<t tx="ekr.20070610063538.2">http://sourceforge.net/forum/message.php?msg_id=4315027

The fix was to g.skip_to_end_of_line (!)

All such functions now return len(s) as a boundary condition.
This is a major change.  All unit tests pass.
</t>
<t tx="ekr.20070610063538.209">http://sourceforge.net/forum/message.php?msg_id=4341644
</t>
<t tx="ekr.20070610063538.212"></t>
<t tx="ekr.20070610063538.280"></t>
<t tx="ekr.20070610063538.281"></t>
<t tx="ekr.20070610063538.334">The following chapter commands now exist:

clone-node-to-chapter
convert-node-to-chapter
copy-node-to-chapter
create-chapter
create-chapter-from-node
move-node-to-chapter
remove-chapter
rename-chapter
select-chapter
</t>
<t tx="ekr.20070610063538.366">http://sourceforge.net/forum/message.php?msg_id=4255709

Added globalDynamicAbbrevs setting.
Added tab completion for dabbrev-expand.
</t>
<t tx="ekr.20070610063538.377">This for the use of the hoist plugin.
</t>
<t tx="ekr.20070610173300">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

The following are now enabled by default:

# Plugin_manager.py needs plugins_menu.py
plugins_menu.py
plugin_manager.py
open_with.py
mod_scripting.py
rst3.py
UNL.py

# Enabled by default in Leo 4.4.3. (order is important)
nav_buttons.py
hoist.py
image.py
leo_to_html.py

I left out cleo because it has been reported not to be fully functional with Leo 4.4.3.
</t>
<t tx="ekr.20070611161859">http://sourceforge.net/forum/message.php?msg_id=4356197
</t>
<t tx="ekr.20070614094933">C:\prog&gt;c:\python25\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.5/s/setuptools/setuptools-0.6c6-py2.5.egg
Processing setuptools-0.6c6-py2.5.egg
Copying setuptools-0.6c6-py2.5.egg to c:\python25\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python25\Scripts
Installing easy_install.exe script to c:\python25\Scripts
Installing easy_install-2.5-script.py script to c:\python25\Scripts
Installing easy_install-2.5.exe script to c:\python25\Scripts

Installed c:\python25\lib\site-packages\setuptools-0.6c6-py2.5.egg
Processing dependencies for setuptools==0.6c6
Finished processing dependencies for setuptools==0.6c6

C:\prog&gt;c:\python24\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.4/s/setuptools/setuptools-0.6c6-py2.4.egg
Processing setuptools-0.6c6-py2.4.egg
creating c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Extracting setuptools-0.6c6-py2.4.egg to c:\python24\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python24\Scripts
Installing easy_install.exe script to c:\python24\Scripts
Installing easy_install-2.4-script.py script to c:\python24\Scripts
Installing easy_install-2.4.exe script to c:\python24\Scripts

Installed c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Processing dependencies for setuptools==0.6c6
</t>
<t tx="ekr.20070622090350">Leo 4.4.3 beta 3                                June 23, 2006

Leo 4.4.3 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This release fixes all known bugs and adds several new features.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @openwith nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- @test nodes can now be run from any .leo file.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070622090350.1"></t>
<t tx="ekr.20070622090350.22">http://sourceforge.net/forum/message.php?msg_id=4362825
</t>
<t tx="ekr.20070622090350.42">Selecting a node now never truncates the beadList.
</t>
<t tx="ekr.20070622090350.57">CleanLines was adding a trailing newline.
The fix was to suppress this during unit tests.
</t>
<t tx="ekr.20070622090350.59"></t>
<t tx="ekr.20070622090350.60"></t>
<t tx="ekr.20070622090350.61"></t>
<t tx="ekr.20070622090350.62">Alt-home is now bound to goto-first-visible rather than goto-first.
</t>
<t tx="ekr.20070622090350.65">This script runs all @test nodes as follows:

- Copies all @suite and @tests nodes to dynamicUnitTests.leo.

- Runs leoDynamicTest.py in a separate process. In turn, leoDynamicTest.py
  use the leoBridge module to run dynamicUnitTests.leo.
  (test.leo contains the source code for leoDynamicTest.py.)

Thus, all unit tests will be run with the latest Leo sources.

Allowing @test nodes in leoPy.leo is important: unit tests can be placed near
the code they are intended to test.
</t>
<t tx="ekr.20070622090350.66">The test 'if g.unitTesting:' is a shorter replacement for the test 'if g.app and g.app.unitTesting:'.

Using g.getTestVars eliminates pychecker warnings about undefined c and p variables.
</t>
<t tx="ekr.20070622090350.8"></t>
<t tx="ekr.20070622090350.9"># Created menu-command-key command that just returns 'continue'.
</t>
<t tx="ekr.20070622180342">- Added support for chapters to Leo's core

  Chapters are regions of a Leo outline whose root is an @chapter node. @chapter
  nodes may appear anywhere in an outline, but the create-chapter command (see
  below) creates @chapter nodes as children of a single @chapters node.

  Selecting a chapter shows only then nodes in the selected chapter; in this
  respect, chapters are like hoists. The main chapter represents the entire
  outline and can not be deleted by name. When chapters are in effect, Leo
  creates a hidden @chapters node containing one @chapter node for every chapter
  except the 'main' chapter.

  Associated settings:

  - The @bool use_chapters setting determines whether chapters are enabled.
  - The @bool use_chapter_tabs setting determines whether the chapters
    pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

  When chapters are enabled, the Cmds:Chapters menu shows all available chapter commands:

  - The create-chapter command creates an @chapter node and with a single node.
  - The delete-chapter command deletes the presently selected chapter.
  - The select-chapter command makes only the nodes of the selected chapter visible.
  - The move-node-to-chapter, clone-node-to-chapter and copy-node-to-chapter commands
    add a node (and its descendants) to another chapter.
</t>
<t tx="ekr.20070622212132">::

    activate-cmds-menu
    activate-edit-menu
    activate-file-menu
    activate-help-menu
    activate-outline-menu
    activate-plugins-menu
    activate-window-menu
    add-space-to-lines
    add-tab-to-lines
    clean-lines
    clear-selected-text
    click-click-box
    click-headline
    click-icon-box
    clone-find-all
    contract-and-go-right
    contract-body-pane
    contract-log-pane
    contract-outline-pane
    contract-pane
    double-click-headline
    double-click-icon-box
    dump-all-objects
    dump-new-objects
    expand-body-pane
    expand-log-pane
    expand-outline-pane
    expand-pane
    find-again
    find-all
    find-tab-find command
    find-tab-find-previous
    free-text-widgets
    fully-expand-body-pane
    fully-expand-log-pane
    fully-expand-outline-pane
    fully-expand-pane
    goto-first-sibling
    goto-global-line
    goto-last-sibling
    help
    help-for-command
    hide-body-pane
    hide-find-tab
    hide-log-pane
    hide-minibuffer
    hide-outline-pane
    hide-pane,
    open-find-tab
    open-find-tab
    open-outline-by-name (uses filename completion)
    open-spell-tab
    print-bindings
    print-commands    re-search-backward
    re-search-forward
    remove-space-from-lines
    remove-tab-from-lines
    replace-string
    scroll-down
    scroll-down-extend-selection
    scroll-outline-down-line
    scroll-outline-down-page 
    scroll-outline-up-line
    scroll-outline-up-page
    scroll-up
    scroll-up-extend-selection
    search-backward
    search-forward
    search-with-present-options
    set-find-everywhere
    set-find-node-only
    set-find-suboutline-only
    show-colors
    show-fonts
    show-minibuffer
    show-search-options
    simulate-begin-drag
    simulate-end-drag
    toggle-find-ignore-case-option
    toggle-find-in-body-option,
    toggle-find-in-headline-option
    toggle-find-mark-changes-option
    toggle-find-mark-finds-option
    toggle-find-regex-option
    toggle-find-reverse-option
    toggle-find-word-option and
    toggle-find-wrap-around-option
    toggle-mini-buffer
    verbose-dump-objects
    word-search-backward
    word-search-forward
</t>
<t tx="ekr.20070622212732">- Added @font menu font setting.
- Added support for commands to be executed on entry to a mode.
- Added support for bindings that are active only in command, enter and insert key states.
- Added support for @abbrev nodes in leoSettings.leo.
- Improved check bindings script in leoSettings.leo.
- Allow @mode outside of leoSettings.leo.
- Added warnings about the @bool expanded_click_area setting.
</t>
<t tx="ekr.20070623145346"></t>
<t tx="ekr.20070623145346.1">Leo's setup.py script is intended only to create source distributions. It can't
be used to install Leo because Leo is not a Python package.
</t>
<t tx="ekr.20070623145346.2">Chapters are regions of a Leo outline whose root is an ``@chapter`` node. They
are available in an outline if the ``@bool usechapters`` option is True.
``@chapter`` nodes may appear anywhere in an outline, but the ``create-chapter``
command (see below) creates ``@chapter`` nodes as children of the first
``@chapters`` (note the ``s``) node in the outline.

One selects a chapter with the ``select-chapter`` command, after which Leo shows
only the nodes in the selected chapter; in this respect, chapters are like
hoists. The ``main`` chapter represents the entire outline and can not be
deleted by name. When chapters are in effect, Leo creates an ``@chapters`` node
for the use of ``create-chapter``.

Associated settings:

- The ``@bool use_chapters`` setting determines whether chapters are enabled.
- The ``@bool use_chapter_tabs`` setting determines whether the chapters
  pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

When chapters are enabled, the Cmds-&gt;Chapters menu shows all available chapter commands:

- The ``chapter-create`` command creates an @chapter node and populates it with a single node.
- The ``chapter-remove`` command deletes the currently selected chapter.
- The ``chapter-select`` command prompts for a chapter name and makes only the nodes of the selected chapter visible.
- The ``chapter-move-node-to``, ``chapter-clone-node-to`` and ``chapter-copy-node-to`` commands
  prompt for a chapter name and add the currently selected node (and its descendants) to another chapter.
</t>
<t tx="ekr.20070623150151">The chapter commands provide a good example.  In this file, see the node:

Code--&gt;Core classes...--&gt;@thin leoChapters.py--&gt;class chapterController--&gt;Undo

The general plan is this:

1. The command handler calls a **beforeCommand** method before changing the outline.

The beforeCommand method creates a g.Bunch that contains all the information needed to
restore the outline to its previous state. Typically, the beforeCommand method
will call c.undoer.createCommonBunch(p), where p is, as usual, c.p.

2. After changing the outline the command handler calls an **afterCommand** method.

This method should take as one argument the g.Bunch returned by the
beforeCommand method. In the discussion below, denote this bunch by b. The
afterCommand method adds any information required to redo the operation after
the operation has been undone.

The afterCommand method also sets b.undoHelper and b.redoHelper to two method
that actually perform the undo and redo operations. (Actually, the beforeCommand
method could also set these two entries).

When the afterCommand method has 'filled in' all the entries of b, the
afterCommand method must call u.pushBead(b). This pushes all the undo
operation on a stack managed by the Leo's undoer, i.e., c.commands.undoer.

3. The undoer calls the undoHelper and redoHelper methods to perform the actual undo and redo operations.

The undoer handles most of the housekeeping chores related to undo and redo.  All the undoHelper and redoHelper methods have to do is actually alter Leo's outline.

**Note**: the undoer creates an ivar (instance variable) of the *undoer* class for every entry in the bunch b passed as an argument to u.pushBead(b).  For example, suppose u = c.commands.under and that b has ivars 'a','b' and 'c'.  Then, on entry to the undoHelper and the redoHelper the u.a, u.b and u.c ivars will be defined.  This makes it unnecessary for the undoHelper or the redoHelper to 'unpack' b explicitly.

Writing correct undo and redo helpers is usually a bit tricky.  The code is often subtly different from the original code that implements a command.  That just can't be helped.




</t>
<t tx="ekr.20070626082732">Leo 4.4.3 final                                  June 26, 2006

Leo 4.4.3 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3:
----------------------------
- Added support for chapters in Leo's core.
- Added support for zipped .leo files.
- Added a leoBridge module that allows full access to all of Leo's capabilities
  from programs running outside of Leo.
- Removed all gui-dependent code from Leo's core.
- Better support for the winpdb debugger.
- Added support for @enabled-plugins nodes in settings files.
- Added support for @openwith nodes in settings files.
- Added support for @bool write_strips_blank_lines setting.
- The__wx_gui plugin is now functional.
- Leo can use aspell on Linux when using Python 2.5 or later.
- @test nodes can now be run from any .leo file.
- Many minor improvements, new settings, commands and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070628083442"></t>
<t tx="ekr.20070628083442.1">#####################
Unit testing with Leo
#####################

This chapter describes how you can execute Python unit test from within Leo
outlines.

Leo's **unit test commands** run the unit tests created by @test and @suite
nodes. run-unit-tests and run-unit-tests-locally run all unit tests in the
presently selected part of the Leo outline; run-all-unit-tests and
run-all-unit-tests-locally run all unit tests in the entire Leo outline.

Important: you must `run Leo in a console window`_ to see the output the
unit tests. Leo's unit test commands run all the unit tests using the
standard unittest text test runner, and the output of the unit tests
appears in the console.

test/unitTest.leo contains many examples of using @test and @suite nodes.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20070628083442.2">.. Links

.. _`run Leo in a console window`:      installing.html#running-leo-from-a-console-window
</t>
<t tx="ekr.20070628084351">**@test nodes** are nodes whose headlines start with @test. The unit test
commands convert the body text of @test nodes into a unit test automatically.
That is, Leo's unit test commands automatically create a unittest.TestCase
instances which run the body text of the @test node. For example, let us
consider one of Leo's actual unit tests. The headline is::

    @test consistency of back/next links

The body text is::

    if g.unitTesting:
        c,p = g.getTestVars() # Optional: prevents pychecker warnings.
        for p in c.all_positions():
            back = p.back()
            next = p.next()
            if back: assert(back.getNext() == p)
            if next: assert(next.getBack() == p)

When either of Leo's unit test commands finds this @test node the command will
run a unit test equivalent to the following::

    import leo.core.leoGlobals as g

    class aTestCase (unittest.TestCase):
        def shortDescription():
            return '@test consistency of back/next links'
        def runTest():
            c,p = g.getTestVars()
            for p in c.all_positions():
                back = p.back()
                next = p.next()
                if back: assert(back.getNext() == p)
                if next: assert(next.getBack() == p)

As you can see, using @test nodes saves a lot of typing:

- You don't have to define a subclass of unittest.TestCase.
- Within your unit test, the c, g and p variables are predefined, just like in Leo scripts.
- The entire headline of the @test node becomes the short description of the unit test.

**Important note**: notice that the first line of the body text is a **guard line**::

    if g.unitTesting:

This guard line is needed because this particular @test node is contained in the
file leoNodes.py. @test nodes that appear outside of Python source files do not
need guard lines. The guard line prevents the unit testing code from being
executed when Python imports the leoNodes module; the g.unitTesting variable is
True only while running unit tests.

**New in Leo 4.6**: When Leo runs unit tests, Leo predefines the 'self' variable to
be the instance of the test itself, that is an instance of unittest.TestCase.
This allows you to use methods such as self.assertTrue in @test and @suite nodes.

**Note**: Leo predefines the c, g, and p variables in @test and @suite nodes,
just like in other scripts.  Thus, the line::

    c,p = g.getTestVars()

is not needed.  However, it prevents pychecker warnings that c and p are undefined.
</t>
<t tx="ekr.20070628094515.1">**@suite nodes** are nodes whose headlines start with @suite. @suite nodes allow
you to create and run custom subclasses of unittest.TestCase.

Leo's test commands assume that the body of an suite node is a script that
creates a suite of tests and places that suite in g.app.scriptDict['suite'].
Something like this::

    if g.unitTesting:
        __pychecker__ = '--no-reimport' # Prevents pychecker complaint.
        import unittest
        c,p = g.getTestVars() # Optional.
        suite = unittest.makeSuite(unittest.TestCase)
        &lt;&lt; add one or more tests (instances of unittest.TestCase) to suite &gt;&gt;
        g.app.scriptDict['suite'] = suite

**Note**: as in @test nodes, the guard line, 'if unitTesting:', is needed only if the
@suite node appears in a Python source file.

Leo's test commands first execute the script and then run suite in
g.app.scriptDict.get('suite') using the standard unittest text runner.

You can organize the script in an @suite nodes just as usual using @others,
section references, etc. For example::

    if g.unitTesting:
        __pychecker__ = '--no-reimport'
        import unittest
        c,p = g.getTestVars() # Optional.
        # children define test1,test2..., subclasses of unittest.TestCase.
        @others 
        suite = unittest.makeSuite(unittest.TestCase)
        for test in (test1,test2,test3,test4):
            suite.addTest(test)
        g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20070628094515.2">The run-all-unit-tests-locally and run-unit-tests-locally commands run unit
tests in the process that is running Leo. These commands *can* change the
outline containing the unit tests.

The run-all-unit-tests and run-unit-tests commands run all tests in a separate
process, so unit tests can never have any side effects. These commands never
changes the outline from which the tests were run. These commands do the
following:

1. Copy all @test, @suite, @unit-tests and @mark-for-unit-test nodes
   (including their descendants) to the file test/dynamicUnitTest.leo.

2. Run test/leoDynamicTest.py in a separate process.

   - leoDynamicTest.py opens dynamicUnitTest.leo with the leoBridge module.
     Thus, all unit tests get run with the nullGui in effect.

   - After opening dynamicUnitTest.leo, leoDynamicTest.py runs all unit tests
     by executing the leoTest.doTests function.

   - The leoTests.doTests function searches for @test and @suite nodes and
     processes them generally as described above. The details are a bit
     different from as described, but they usually don't matter. If you *really*
     care, see the source code for leoTests.doTests.
</t>
<t tx="ekr.20070702162421">Leo 4.4.3.1                                 July 3, 2006

Leo 4.4.3.1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.3.1:
----------------------------
- Fixed a few minor bugs reported since Leo 4.4.3 was released.
- Added better support for unit testing in Leo.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070703095207.1"></t>
<t tx="ekr.20070703095207.2"></t>
<t tx="ekr.20070703095207.34">https://sourceforge.net/forum/message.php?msg_id=4385604
</t>
<t tx="ekr.20070703095207.35">Misspelled words were not selected properly on Linux.
</t>
<t tx="ekr.20070703095207.40">http://sourceforge.net/forum/message.php?msg_id=4385699
</t>
<t tx="ekr.20070703095207.41">Moving into a chapters node from the main chapter did an automatic hoist.
</t>
<t tx="ekr.20070703095207.43">- Made inter-outline moves &amp; copies work again.
- Also, warn that inter-outline clones transfer have no effect.
- Note: none of these operations are presently undoable.

In short, this code is no worse than it has ever been.
</t>
<t tx="ekr.20070703095207.5">It's a bit tricky to ensure that leo/src is in sys.path
The code now changes the working directory to leo/src,
and leoDynamicTest.py adds os.getcwd() to sys.path if it is not there.

</t>
<t tx="ekr.20070703095207.50"># Added calls to c,p = g.getTestVars()

(fixed) leoNodes.py:2801: No global (p) found
(fixed) leoNodes.py:2804: No global (c) found

(fixed) leoConfig.py:1739: No global (c) found

(fixed) leoKeys.py:4446: No global (c) found

(fixed) leoEditCommands.py:7823: No global (c) found
(fixed) leoEditCommands.py:8508: No global (e) found
</t>
<t tx="ekr.20070703095207.51"></t>
<t tx="ekr.20070703095207.55"></t>
<t tx="ekr.20070703095207.56"></t>
<t tx="ekr.20070703095207.61">For full details, see Chapter 20: Unit testing with Leo.
</t>
<t tx="ekr.20070703095207.72">It is essential to protect them with::

     if g.unitTesting:

A new unit test ensures that this is so.
</t>
<t tx="ekr.20070806090226.1">The run-unit-tests command now includes *all* @mark-for-unit-test trees.
</t>
<t tx="ekr.20070806090226.14">The old __jEdit_colorizer__.py plugin has been retired.
</t>
<t tx="ekr.20070806090226.15"></t>
<t tx="ekr.20070806090235"></t>
<t tx="ekr.20070806090235.1">Leo 4.4.4 beta 1                                August 10, 2007

Leo 4.4.4 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.4:
----------------------------

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance.

- Support for @auto nodes.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070806095535.1">@auto trees allows people to use Leo in collaborative environments without using
sentinels in the files Leo generates. In contrast to @nosent, @auto trees can
change when the corresponding file changes outside of Leo.

Leo will automatically recreate (import) all @auto trees when reading a .leo
file, and will write all dirty @auto trees when saving a .leo file. There are
two exceptions to this statement:

1. Leo will never read (import) or write an @auto tree if
the root @auto tree is under the influence of an @ignore directive.

2. Saving a .leo file does not save @auto nodes if a) they haven't been changed
or b) they do not contain a **significant** amount of information. An @auto tree
contains a significant amount of information if it has  children or if the
root node contains more than 10 characters.

Leo creates @auto trees by parsing the corresponding external file. Parsers
create descendant nodes of the @auto tree: one node for each class, method and
function in the external file.

Parsers presently exist for C, elisp, Java, Pascal, PHP and Python. Leo
determines the language using the file's extension. If no parser exists for a
language, the entire body of an @auto tree contains a significant amount of
information if it has any children or if the root node contains more than 10
non-blank lines. the external file is copied to the body of the @auto node.

Leo does not write the contents of @auto trees to .leo files. In this respect,
@auto trees work much like @file trees. @auto trees whose root node is under the
scope of an @ignore directive *will* be written to the .leo, just like @file
trees.
</t>
<t tx="ekr.20070806100055">All present parsers are short overrides of a powerful base parser class. Thus,
it would be simple to add support for other languages. See the node::

    @file leoImport.py--&gt;Import--&gt;Scanners for createOutline

in leoPy.leo to see how easy it is to create new parsers.

</t>
<t tx="ekr.20070806101412">Three new commands in the File:Read/Write menu allow you to manually read and
write @auto nodes from the presently selected outline. As always, an @ignore
directive in the @auto node or its ancestors will suppress any of these
commands:

- The Read @auto Nodes (read-at-auto-nodes) command reads all @auto nodes in the
  presently selected outline. An @ignore directive will suppress this import.

- The Write @auto Nodes (write-at-auto-nodes) command writes all @auto nodes. An
  @ignore directive will suppress this import. Caution: the write will occur even
  if Leo has not previously read the @auto node.

- The Write Dirty @auto Nodes (write-dirty-at-auto-nodes) is the same as the
  write-at-auto-nodes command, except that only changed @auto trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles @auto nodes well enough. However, you can use the
read-at-auto-nodes command to update @auto nodes without having to reload the
.leo file.
</t>
<t tx="ekr.20070809141529">Leo performs several checks to ensure that the result of importing an external
file will be equivalent to the file that writing the @auto tree would produce.

These checks can produces **errors** or **warnings**. Errors indicate a
potentially serious problem. Leo inserts an @ignore directive in the @auto tree
if any error is found. This @ignore directive prevents the @auto tree from
modifying the external file. If you @ignore directive, a later write of the
@auto tree will attempt to fix the problems that gave rise to the errors. There
are no guarantees however.

**Strict languages** are languages like Python for which leading whitespace is
especially significant. Before importing a file for a strict language, Leo
**regularizes** the leading whitespace of all lines of the original source file.
That is, Leo converts blanks to tabs or tabs to blanks depending on the value of
the @tabwidth directive in effect for the @auto node. Leo cannot guarantee to
reproduce the original source file exactly if problems are discovered while
regularizing leading whitespace.

After importing a file, Leo verifies that writing the @auto node would create
the same file as the original file. For strict languages, the comparison must be
exact, or nearly so. For non-strict languages, differences in leading whitespace
generate warnings, not errors.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any suspected bugs immediately.

2. Underindented lines in classes, methods or functions in strict languages. An
   **underindented line** is a line that is indented less then the starting line
   of the class, method or function in which it appears. Leo outlines can not
   represent such lines exactly: every line of node implicitly has at least the
   indentation of any unindented line of the node.

Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.
</t>
<t tx="ekr.20070809145744">Leo 4.4.4 contains many important features originally planned for later releases.
The highlights of Leo 4.4.4:

- **The Great Graph Aha**:
  A Leo outline doesn't have to *be* an arbitrary graph in order to *represent* an arbitrary graph.

  That is, simple scripts allow Leo outlines to represent arbitrary
  directed graphs. There is no need for a separate 'graph world'. The graphed.py
  plugin is a direct result of this Aha. It allows you to create general graphs
  from Leo outlines.

- Support for **@auto nodes**.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.

- **@menus trees** in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- **@buttons trees** in settings files create common @button nodes created in all
  Leo outlines.

- A new, faster, **colorizer plugin** replaces the __jEdit_colorizer__ plugin.

- New commands for **resolving cvs conflicts**.

- Leo's core is now compatible with jython.
</t>
<t tx="ekr.20070809145744.4">::

    check-derived-file
    check-leo-file
    compare-leo-outlines
    insert-child
    read-at-auto-nodes
    read-file-into-node
    write-at-auto-nodes
    write-dirty-at-auto-nodes
    write-file-from-node
</t>
<t tx="ekr.20070809145744.5"></t>
<t tx="ekr.20070809145744.6">- The graphed plugin allows users to manipulate parts of Leo outlines as if they
  were general graphs. It is still early days for this exciting plugin.

- The threading_colorizer plugin replaces the __jEdit_colorizer__ plugin. This
  plugin features an elegant new algorithm that has much better performance and
  eliminates almost all flash.
</t>
<t tx="ekr.20070809145744.7">- See the release notes for a list of bugs fixed in Leo 4.4.4.

- Added the 'clear-all-marks' hook.

- Added button font setting. See the node::

    "@settings--&gt;Fonts--&gt;@font button font" in leoSettings.leo.

- Plugins and scripts may call the c.frame.canvas.createCanvas method to create a
  log tab containing a Tk.Canvas widget. Here is an example script::

    log = c.frame.log ; tag = 'my-canvas'
    w = log.canvasDict.get(tag)
    if not w:
        w = log.createCanvas(tag)
        w.configure(bg='yellow')
    log.selectTab(tag)

- Improved the yank and yank-pop commands and added @bool add_ws_to_kill_ring setting.

- Improved the debug command: it now adds the following code to the beginning of debug scripts::

    class G:
        def es(s,c=None):
          pass
    g = G()

- Added the @bool rst3 strip_at_file_prefixes setting.

- Added the g.app.inBridge ivar.

- Added @bool big_outline_pane setting. False (legacy): Top pane contains outline and log panes.
  True: Top pane contains only the outline pane.  Bottom pane contains body and log panes.
</t>
<t tx="ekr.20070814104719" str_atime="1376412994.0">You enable or disable plugins using @enabled-plugins nodes in leoSettings files
(leoSettings.leo, myLeoSettings.leo or the .leo file being loaded). See
`Specifying settings`_ for full details of settings files.

The body text of the @enabled-plugins node contains a list of enabled plugins.
Notes:

- Leo attempts to load all plugins every time an @enabled-plugins node is seen.
   If the plugin has already been loaded, Leo silently ignores the request to
   re-enable the plugin. Leo never attempts to disable a plugin while processing
   enabled plugin strings. Thus, plugins enabled in an @enabled-plugins node in
   leoSettings.leo *will* be enabled regardless of the contents of any other
   @enabled-plugins node.

- g.app.gui.getEnabledPlugins contains the last processed @enabled-plugins node.
</t>
<t tx="ekr.20070816092449">Question and answer from plumloco.

Add the equivalent of::

    import sys 
    leocore = "path/to/leo/core" 
    if leocore not in sys.path: sys.path.append(leocore) 
    import leo.core.leoBridge as leoBridge

at the head of each file that uses leoBridge.

The problem is not importing leoBridge itself but (if I use 'from leo.core') the
importing of plugins, who get a different leoGlobals from leoBridge, without
g.app etc, and so do not work if they rely on dynamic values in g.etc.

&gt; Why can't you simply add leo/core to sys.path in sitecustomize.py?  

Putting leo/core on the python path as you suggest would put forty python modules
in the global module namespace for all python programs when I want just one.
Also, I have a safe working copy of leo and a cvs/testing version. I would wish
to test any programs against the testing version while using the working
version, but both /core directories can't be exposed at the same time.

&gt; Do you need plugins while running from the leoBridge? 

Afraid so, at least the rst3 plugin. The solution I am using now is to place::

    sys.modules['leoGlobals'] = leoGlobals  

in leoBridge after import leo.core.leoGlobals as leoGlobals

This allows my scripts
to be portable over the several computers/platforms I need to use them on, and
makes testing scripts against multiple leo versions easy. It does mean that my
scripts are not portable to other leo users but that is not likely to be a
problem.
</t>
<t tx="ekr.20070915101157.1"></t>
<t tx="ekr.20070915101157.14">http://sourceforge.net/forum/message.php?msg_id=4445685
</t>
<t tx="ekr.20070915101157.16">http://sourceforge.net/forum/message.php?msg_id=4446937
</t>
<t tx="ekr.20070915101157.168">When saving a .leo file, Leo now *reads* an @auto node if

1) the external file exists,
2) an 'insignificant' amount of data exists in the @auto tree, and
3)the @auto node has not been read previously.

This promises to fix some quite awkward use cases.

The 'perfect import' code now is a bit more relaxed, especially for 'non-strict'
languages (all languages except Python):

- Leo leaves leading whitespace alone for non-strict languages.

- Leo complains about intermixed tabs and blanks in leading whitespace only for
strict languages.

- Leo ignores leading whitespace in the perfect import tests for non-strict
languages.

These changes mean that Leo might change a external file if such a change occurs
only in leading whitespace in a non-strict language.
</t>
<t tx="ekr.20070915101157.17"># The code that was removing tags was not working properly.
</t>
<t tx="ekr.20070915101157.18">http://sourceforge.net/forum/message.php?msg_id=4437415
</t>
<t tx="ekr.20070915101157.19">http://sourceforge.net/forum/message.php?msg_id=4462693
</t>
<t tx="ekr.20070915101157.3">Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs&gt; cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
&lt;                             p = g.findNodeInTree(c2,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break
206c209,212
&lt;                             p = g.findNodeInTree(c,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break

</t>
<t tx="ekr.20070915101157.40">http://sourceforge.net/forum/message.php?msg_id=4464980
</t>
<t tx="ekr.20070915101157.45">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4465132
By: terry_n_brown

So I changed all my indentation to multiples of four, having decided I like
the extra line space this buys over aligning with the opening (.

leo said this when it read the file:

@auto did not import the file perfectly

but never mentioned @ignore or anything.  I made a trivial change and saved
and diff could find no difference except my trivial change... which seems perfect
to me...?

@color
</t>
<t tx="ekr.20070915101157.48">https://sourceforge.net/forum/message.php?msg_id=4459798
</t>
<t tx="ekr.20070915101157.5">http://sourceforge.net/forum/message.php?msg_id=4444579
</t>
<t tx="ekr.20070915101157.50">http://sourceforge.net/forum/message.php?msg_id=4509897
</t>
<t tx="ekr.20070915101157.70">http://sourceforge.net/forum/message.php?msg_id=4514130
</t>
<t tx="ekr.20070915101157.81">http://sourceforge.net/forum/message.php?msg_id=4468174
</t>
<t tx="ekr.20070915101157.82"></t>
<t tx="ekr.20070915101216">Leo 4.4.4 beta 2                                September 19, 2007

Leo 4.4.4 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.4:
----------------------------

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance.

- Support for @auto nodes.  Such nodes allow people to collaborate using Leo
  without inserting Leo sentinels in the files Leo generates.

- New commands for resolving cvs conflicts.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20070920092716">The so-called resolve-cvs-conflict project has resolved itself into small,
easily understood commands.

The **read-file-into-node** command prompts for a filename, and creates an node
whose headline is @read-file-into-node &lt;filename&gt; and whose body text is the
entire contents of the file.

The **write-file-from-node** command writes the body text of the selected not to a file.
If the headline of the presently selected node starts with @read-file-into-node
the command use the filename that follows in the headline. Otherwise, the
command prompts for a filename.

When a cvs conflict occurs, the user will:

- read the file into a node using the read-file-into-node command,

- fix the conflict, as with any other editor, and

- write the file with the write-file-from-node command.

Any file can be fixed in this way, including external files and .leo files. The
only complication is that the user must not change sentinel lines. Two new
commands check the contents of a node: The **check-derived-file** and
**check-leo-file** commands tell whether a trial read of the presently selected
node can be done successfully. The check-derived-file command assumes the body
text is a external file; the check-leo-file command assumes the body text is an
entire .leo file.

The **compare-leo-outlines** command prompts for another (presumably similar)
.leo file that will be compared with the presently selected outline file (main
window). It then creates clones of all inserted, deleted and changed nodes.
</t>
<t tx="ekr.20070929125944">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4543089
By: billp9619

from the download page:

If it's the first time you hear about Python, this is the installation for you.
The packages includes complete Orange, Python, Windows Extensions for Python
(PythonWin), Numeric Python, Qt 2.2 non-commercial, PyQt, PyQwt and GraphViz.

Leo should copy this download philosophy.



</t>
<t tx="ekr.20071001052501">@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
</t>
<t tx="ekr.20071001122703">All @buttons tree in a settings file defines global buttons that are created in
the icon area of all .leo files. You define @button nodes in the @buttons tree
as usual.
</t>
<t tx="ekr.20071004101349">Leo 4.4.4 beta 3                            October 23, 2007

Leo 4.4.4 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.4 contains many important features originally planned for later releases.
It's been a good month :-)

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.

- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily.

- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.

- Leo is now compatible with jython.

- The usual assortment of bug fixes and other minor improvements.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071004101443.1"></t>
<t tx="ekr.20071004101443.105">Leo creates its menus using @menus trees. Within @menus trees,
@menu nodes create menus and @item nodes create menu items.

Notes:

- The menu name always follows @menu. If the menu name is 'Plugins', Leo will
  create the Plugins menu and populate the menu by calling the
  'create-optional-menus' hook. This creates the Plugins menu as usual.

- Nested @menu nodes contain submenus.

- The command name follows @item. If the body text of an @item node exists, this
  body text is the menu name. Otherwise, the menu name is the command name.
  However, if the command name starts with a '*', hyphens are removed from the
  menu name.

- Menu names and command names may contain a single ampersand (&amp;). If present,
  the following character is underlined in the name.

- If the command name in an @item node is just a hyphen (-), the item represents
  a menu separator.

- Unicode characters, e.g., Chinese characters *are* allowed.
</t>
<t tx="ekr.20071004101443.178">The c.frame.logcreateCanvas convenience method create a canvas tab in the log pane.
Here is a sample script:

log = c.frame.log ; tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
..w = log.createCanvas(tag)
..w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071004101443.18"></t>
<t tx="ekr.20071004101443.26">http://sourceforge.net/forum/message.php?msg_id=4543844
</t>
<t tx="ekr.20071004101443.29"></t>
<t tx="ekr.20071004101443.30">See the node:

@settings--&gt;Fonts--&gt;@font button font

in leoSettings.leo.
</t>
<t tx="ekr.20071004101443.52">@button nodes in the @buttons tree in settings file define **global buttons** that appear in all Leo outlines.
</t>
<t tx="ekr.20071004103659">The Great Graph Aha is:

A Leo outline doesn't have to *be* an arbitrary graph in order to *represent* an arbitrary graph.

So the graph world is unnecessary because we can use Leo nodes and trees as data
to other graphing packages.** That is, Python scripts can build arbitrary graphs
using Leo's existing nodes and trees. And Python scripts can manipulate those
graphs. And Python scripts could do the reverse: manipulate the Leo outline by
traversing general graphs. So there is no need to complicate Leo's fundamental
data structures. Hurray! Instead, we build on the strengths of already existing
graphing packages.

The Great Graph Aha created the opportunity for immediate action:

1. test.leo contains the essential scripts to implement graphs in Leo files.
   These short, simple, self-contained, easily modifiable scripts make possible
   everything ever envisaged by the (now-defunct) graph world project::

    leo2graph: convert a normal Leo tree to a NetworkX graph. 
    at-graph2graph: convert an @graph tree to a NetworkX graph. 
    at-networkx2graph: convert an @networkx tree to a NetworkX graph 
    at-networkx2at-graph: create an @graph tree from an @networkx tree.

2. The graphed plugin allows users to manipulate parts of Leo outlines as if
they were general graphs. It is still early days for this exciting plugin.
</t>
<t tx="ekr.20071004105000">The graphed plugin allows users to manipulate parts of Leo outlines as if
they were general graphs. It is still early days for this exciting plugin.
</t>
<t tx="ekr.20071004110818">Leo creates its menus from the @menu and @item nodes in the @menus tree. Within
@menus trees, @menu nodes create menus and @item nodes create menu items.

The menu name always follows @menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
@menu nodes define submenus.

The command name follows @item. If the body text of an @item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command name
in an @item node is just a hyphen (-), the item represents a menu separator.
</t>
<t tx="ekr.20071004120359.2">See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
</t>
<t tx="ekr.20071005095907">- Replaced all 'yield' statements with iterators.

- Added 'jyLeo' keyword to leo.run.

- All of Leo's startup code works with the swing gui enabled (jyLeo = True in leo.run).
</t>
<t tx="ekr.20071005100213">Essentially all of Leo's startup code now runs with jython 2.2 and the (unfinished!) swing gui.
</t>
<t tx="ekr.20071006093614">This inserts a child node.
</t>
<t tx="ekr.20071006155647"></t>
<t tx="ekr.20071021111856.124">This should have been done long ago.
</t>
<t tx="ekr.20071021111856.127">http://sourceforge.net/forum/message.php?msg_id=4573990
</t>
<t tx="ekr.20071021111856.20">In some cases the find-previous command did not work.

After much investigation, the cause of the bug was found to be a blunder in backwardsHelper.  Changed:

pattern.lower()

to:

pattern = pattern.lower()
</t>
<t tx="ekr.20071021111856.252">https://sourceforge.net/forum/message.php?msg_id=4576436
</t>
<t tx="ekr.20071021111856.412">Optimized yank, by using yanked leading whitespace if it exists

New option: add-ws-to-kill-ring (or kill-ws-adds-to-kill-ring)
</t>
<t tx="ekr.20071021111856.437">Suppressed doc-part-delims when show_doc_parts_as_paragraphs is True.
</t>
<t tx="ekr.20071021111856.441">The new code is simple and elegant.  Almost all flash is gone.
</t>
<t tx="ekr.20071021111856.458">http://sourceforge.net/forum/message.php?msg_id=4568499
</t>
<t tx="ekr.20071021111856.459">From the documentation at: http://leoeditor.com/rstplugin3.html#options

strip_at_file_prefixes (default: True)

True: remove @auto, @file, @nosent and @thin from the start of headlines.
</t>
<t tx="ekr.20071021111856.461"></t>
<t tx="ekr.20071021111856.476">This is used, at present, by g.getScript.  It is a natural status ivar in any case.
</t>
<t tx="ekr.20071021111856.477">- Use the term 'event handler' for hook.  This is much better terminology.

- Move the discussion of event handlers to the scripting chapter.

- Removed the discussion of all menu convenience routines: they are not needed now that Leo supports @menus nodes.

- The 'writing plugins' chapter is now very simple.
</t>
<t tx="ekr.20071021111856.83">There were at least 3 bugs:

At least three bugs.

- Place cursor on last (blank) line.  Cursor up goes one line too far.
- Place cursor at end of line 1.  Second cursor down does nothing.
- Place cursor at end of xxxx line.  Second cursor down goes one line too far.

xxxxxxxxx
line 1
line 2

The fix was to g.getLine--potentially a major change.
</t>
<t tx="ekr.20071023080957">The run-unit-tests command runs tests using the bridge, which uses a nullGui and a stringTextWidget.

Added a hack to g.getScript so it always gets the script from p.bodyString when
g.app.gui.inBridge is True.
</t>
<t tx="ekr.20071026053825">Leo 4.4.4 beta 4                            October 27, 2007

Leo 4.4.4 beta 4 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This beta 4 version fixes all bugs reported against Leo 4.4.4 beta 3.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.4.4 contains many important features originally planned for later releases.

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.

- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily. **Warning**: for now, please make backup
  copies of files imported with @auto.

- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.

- Leo is now compatible with jython.

- Better support for icons in headlines.

- The usual assortment of bug fixes and other minor improvements.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071026053931.1"></t>
<t tx="ekr.20071026053931.13">http://sourceforge.net/forum/message.php?msg_id=4574271
</t>
<t tx="ekr.20071026053931.156">This should have been done a long time ago.
</t>
<t tx="ekr.20071026053931.157">http://sourceforge.net/forum/message.php?msg_id=4585396

The threading colorizer must be run with interruptible=False when there are multiple body editors.
</t>
<t tx="ekr.20071026053931.219"></t>
<t tx="ekr.20071026053931.220"></t>
<t tx="ekr.20071026053931.221">False (legacy): Top pane contains outline and log panes.
True: Top pane contains only the outline pane.  Bottom pane contains body and log panes.
</t>
<t tx="ekr.20071026053931.234">To allow Python's print statement to print unicode characters properly, you must
change Python's default encoding to something other than 'ascii'. To do this,
put the following in your sitecustomize.py file in Python's Lib folder::

    import sys 
    sys.setdefaultencoding('utf-8') # 'iso-8859-1' is another choice.

You must restart Python after doing this: sys.setdefaultencoding can not be
called after Python starts up.

Leo's g.es_print function attempts to convert incoming arguments to unicode
using the default encoding. For example, the following Leo script always prints
La Peña::

    @first # -*- coding: utf-8 -*-
    # The line above is required for Python 2.5

    for s in (u'La Pe\xf1a','La Peña',u'La Peña'): 
        g.es_print(s)

For still more details, see:

http://www.diveintopython.org/xml_processing/unicode.html 
</t>
<t tx="ekr.20071026055929"></t>
<t tx="ekr.20071026055929.1">First, you must change Python's default encoding to something other than 'ascii'.  To do this, put the following in your sitecustomize.py file in Python's Lib folder::

    import sys 
    sys.setdefaultencoding('utf-8') # 'iso-8859-1' is another choice.

You must restart Python after doing this: sys.setdefaultencoding can not be called after Python starts up. 

Leo's g.es_print and g.pr functions attempts to convert incoming arguments to unicode using the default encoding.
For example, the following Leo script shows various ways of printing La Peña properly::

    @first # -*- coding: utf-8 -*-

    import sys
    e = sys.getdefaultencoding()
    print 'encoding',e
    table = (
        'La Peña',
        unicode('La Peña','utf-8'),
        u'La Peña',
        u'La Pe\\xf1a',
    )

    for s in table:
        print type(s)
        g.es_print('g.es_print',s)
        if type(s) != type(u'a'):
            s = unicode(s,e)
        print 'print     ',s
        print 'repr(s)   ',repr(s)

For still more details, see:
http://www.diveintopython.org/xml_processing/unicode.html 
</t>
<t tx="ekr.20071026075016">This fixes a fairly old crasher in the fastGotoNode plugin.
</t>
<t tx="ekr.20071026092552"></t>
<t tx="ekr.20071026180804">The prototype in test.leo now will use PIL (Python Imaging Library) if
available, so many more kinds of icons can be used. Buttons now exist to add
icons to do the following:

- Add any icon to any node.
- Delete all icons from a single node or the entire tree.
- Print the icon files associated with a node.
- Print the sizes of icons in a directory.

Fixed a bug in the icon handling in the outline widget that caused
duplicate icons not to be drawn properly.
</t>
<t tx="ekr.20071026180804.1">The prototype in test.leo now uses PIL (Python Imaging Library) if available,
so many more kinds of icons can be used.

Buttons now exist to add icons to do the following:

- Add any icon to any node.
- Delete all icons from a single node or the entire tree.
- Print the icon files associated with a node.
- Print the sizes of icons in a directory.

In addition, fixed a bug in the icon handling in the outline widget that caused
duplicate icons not to be drawn properly.
</t>
<t tx="ekr.20071026182824"></t>
<t tx="ekr.20071026183116">Scripts can invoke various dialogs using the following methods of the
g.app.gui object.

Here is a partial list. Use typing completion to get the full list::

    g.app.gui.runAskOkCancelNumberDialog(c,title,message)
    g.app.gui.runAskOkCancelStringDialog(c,title,message)
    g.app.gui.runAskOkDialog(c,title,message=None,text='Ok')
    g.app.gui.runAskYesNoCancelDialog(c,title,message=None,
        yesMessage='Yes',noMessage='No',defaultButton='Yes')
    g.app.gui.runAskYesNoDialog(c,title,message=None)

The values returned are in ('ok','yes','no','cancel'), as indicated by the
method names. Some dialogs also return strings or numbers, again as indicated by
their names.

Scripts can run File Open and Save dialogs with these methods::

    g.app.gui.runOpenFileDialog(title,filetypes,defaultextension,multiple=False)
    g.app.gui.runSaveFileDialog(initialfile,title,filetypes,defaultextension)

For details about how to use these file dialogs, look for examples in Leo's own
source code. The runOpenFileDialog returns a list of file names.
</t>
<t tx="ekr.20071101162646">Leo 4.4.4 Final                           November 2, 2007

Leo 4.4.4 Final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.4.4 contains many important features originally planned for later releases.

The highlights of Leo 4.4.4:
----------------------------

- The Great Graph Aha (tm): simple scripts allow Leo outlines to represent
  arbitrary directed graphs. There is no need for a separate 'graph world'. The
  graphed.py plugin is a direct result of this Aha. The graphed.py plugin allows
  you to create general graphs from Leo outlines.

- @menus trees in settings files create all of Leo's menus.  It is now dead
  easy to make Leo's menus look the way you want.

- @buttons trees in settings files create common @button nodes created in all
  Leo outlines.

- @auto nodes eliminate sentinels in external files, thereby allowing people to
  collaborate using Leo more easily. **Warning**: for now, please make backup
  copies of files imported with @auto.

- New commands for resolving cvs conflicts.

- A threading_colorizer plugin replaces the __jEdit_colorizer__ plugin.
  This plugin features much better performance and a new, elegant algorithm.

- Leo is now compatible with jython.

- Better support for icons in headlines.

- Many bug fixes and other minor improvements.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071101162751"></t>
<t tx="ekr.20071101162751.149">The spell tab now uses the same font as the find tab.
</t>
<t tx="ekr.20071101162751.150">http://sourceforge.net/forum/message.php?msg_id=4596477
</t>
<t tx="ekr.20071101162751.178"></t>
<t tx="ekr.20071101162751.184"></t>
<t tx="ekr.20071101162751.19">The fix doesn't actually remember which chapter was previously selected; it
picks some chapter containing the initially selected node. This works exactly
for non-cloned nodes, but can select the 'wrong' chapter for cloned nodes.
Still, this is a big improvement over the previous code, which would not select
any node if the selected node was not in the main chapters.
</t>
<t tx="ekr.20071101162751.2">http://sourceforge.net/forum/message.php?msg_id=4591494
</t>
<t tx="ekr.20071101162751.28"></t>
<t tx="ekr.20071101162751.32">It is too confusing at present, because it doesn't support @enabled-plugins nodes.
</t>
<t tx="ekr.20071101162751.33"></t>
<t tx="ekr.20071101162751.34"></t>
<t tx="ekr.20071101162751.4"></t>
<t tx="ekr.20071101162751.97">http://sourceforge.net/forum/forum.php?thread_id=1853660&amp;forum_id=10228
</t>
<t tx="ekr.20071101163257"></t>
<t tx="ekr.20071102191642.1">Added the following line to setup.py and setup files.

# -*- coding: utf-8 -*-

The second installation script installs the Emacs Lisp part only.
[snip]
I couldn't get this script to work.  Instead, I just created a pymacs folder at::

    C:\XEmacs\xemacs-packages\lisp\pymacs

For Win32 systems, I created create c:\Windows\pymacs-services.bat containing::

    c:\Python25\python C:\prog\Pymacs-0.22\scripts\pymacs-services

To check that pymacs.el is properly installed, start Emacs and do::

    M-x load-library RET pymacs

You should not receive any error.
(works)

To check that pymacs.py is properly installed, start an interactive Python session and type::

    from Pymacs import lisp

you should not receive any error.
(works)

To check that pymacs-services is properly installed, type the following in a console::

    pymacs-services &lt;/dev/null

You should then get a line ending with (pymacs-version version), and another saying : Protocol error : `&gt;' expected..
(works, mostly: I omitted the &lt;/dev/null

The rest is from Leo's Chapter 18::

    ; Step 1: load leoPymacs if it has not already been loaded.
    (setq reload nil)
    (if (or reload (not (boundp 'leoPymacs)))
        (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
        (message "leoPymacs already loaded")
    )

    ; Step 2: compute the path to leo/test/ut.leo using a Leo script.
    (setq script
        "g.app.scriptResult = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..','test','ut.leo'))"
    )
    (setq fileName (leo-run-script nil script))

    ; Step 3: execute a script in ut.leo.
    (setq c (leo-open fileName))
    (setq script "print 'c',c.shortFileName() ,'current:',c.p.h")
    (leo-run-script c script)
</t>
<t tx="ekr.20071103090504">@killcolor
</t>
<t tx="ekr.20071103090504.1"></t>
<t tx="ekr.20071103090504.10">pymacs-load

Function (pymacs-load module prefix) imports the Python module into Emacs Lisp space.

module is the name of the file containing the module, without any .py or .pyc extension. If the directory part is omitted in module, the module will be looked into the current Python search path. Dot notation may be used when the module is part of a package. Each top-level function in the module produces a trampoline function in Emacs Lisp having the same name, except that underlines in Python names are turned into dashes in Emacs Lisp, and that prefix is uniformly added before the Emacs Lisp name (as a way to avoid name clashes).

prefix may be omitted, in which case it defaults to base name of module with underlines turned into dashes, and followed by a dash.

Whenever pymacs_load_hook is defined in the loaded Python module, pymacs-load calls it without arguments, but before creating the Emacs view for that module. So, the pymacs_load_hook function may create new definitions or even add interaction attributes to functions.

The return value of a successful pymacs-load is the module object. An optional third argument, noerror, when given and not nil, will have pymacs-load to return nil instead of raising an error, if the Python module could not be found.

When later calling one of these trampoline functions, all provided arguments are converted to Python and transmitted, and the function return value is later converted back to Emacs Lisp. It is left to the Python side to check for argument consistency. However, for an interactive function, the interaction specification drives some checking on the Emacs Lisp side. Currently, there is no provision for collecting keyword arguments in Emacs Lisp.
</t>
<t tx="ekr.20071103090504.2">Conversions

Whenever Emacs Lisp calls Python functions giving them arguments, these arguments are Emacs Lisp structures that should be converted into Python objects in some way. Conversely, whenever Python calls Emacs Lisp functions, the arguments are Python objects that should be received as Emacs Lisp structures. We need some conventions for doing such conversions.

Conversions generally transmit mutable Emacs Lisp structures as mutable objects on the Python side, in such a way that transforming the object in Python will effectively transform the structure on the Emacs Lisp side (strings are handled a bit specially however, see below). The other way around, Python objects transmitted to Emacs Lisp often loose their mutability, so transforming the Emacs Lisp structure is not reflected on the Python side.

Pymacs sticks to standard Emacs Lisp, it explicitly avoids various Emacs Lisp extensions. One goal for many Pymacs users is taking some distance from Emacs Lisp, so Pymacs is not overly pushing users deeper into it.
</t>
<t tx="ekr.20071103090504.3">Simple objects

Emacs Lisp nil and the equivalent Emacs Lisp () yield Python None. Python None and the Python empty list [] are returned as nil in Emacs Lisp.

Emacs Lisp numbers, either integer or floating, are converted in equivalent Python numbers. Emacs Lisp characters are really numbers and yield Python numbers. In the other direction, Python numbers are converted into Emacs Lisp numbers, with the exception of long Python integers and complex numbers.

Emacs Lisp strings are usually converted into equivalent Python narrow strings. As Python strings do not have text properties, these are not reflected. This may be changed by setting the pymacs-mutable-strings option : if this variable is not nil, Emacs Lisp strings are then transmitted opaquely. Python strings, except Unicode, are always converted into Emacs Lisp strings.

Emacs Lisp symbols yield the special lisp.symbol or lisp[string] notations on the Python side. The first notation is used when the Emacs Lisp symbol starts with a letter, and contains only letters, digits and hyphens, in which case Emacs Lisp hyphens get replaced by Python underscores. This convention is welcome, as Emacs Lisp programmers commonly prefer using dashes, where Python programmers use underlines. Otherwise, the second notation is used. Conversely, lisp.symbol on the Python side yields an Emacs Lisp symbol with underscores replaced with hyphens, while lisp[string] corresponds to an Emacs Lisp symbol printed with that string which, of course, should then be a valid Emacs Lisp symbol name.
</t>
<t tx="ekr.20071103090504.4">Sequences

The case of strings has been discussed in the previous section.

Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are normally transmitted opaquely to Python. If pymacs-forget-mutability is set, or if Python later asks for these to be expanded, proper Emacs Lisp lists get converted into Python lists, if we except the empty list, which is always converted as Python None. In the other direction, Python lists are always converted into proper Emacs Lisp lists.

Emacs Lisp vectors are normally transmitted opaquely to Python. However, if pymacs-forget-mutability is set, or if Python later asks for these to be expanded, Emacs Lisp vectors get converted into Python tuples. In the other direction, Python tuples are always converted into Emacs Lisp vectors.

Remember the rule : Round parentheses correspond to square brackets!. It works for lists, vectors, tuples, seen from either Emacs Lisp or Python.

The above choices were debatable. Since Emacs Lisp proper lists and Python lists are the bread-and-butter of algorithms modifying structures, at least in my experience, I guess they are more naturally mapped into one another, this spares many casts in practice. While in Python, the most usual idiom for growing lists is appending to their end, the most usual idiom in Emacs Lisp to grow a list is by cons'ing new items at its beginning :

     (setq accumulator (cons 'new-item accumulator))


or more simply :

     (push 'new-item accumulator)


So, in case speed is especially important and many modifications happen in a row on the same side, while order of elements ought to be preserved, some (nreverse ...) on the Emacs Lisp side or .reverse() on the Python side side might be needed. Surely, proper lists in Emacs Lisp and lists in Python are the normal structure for which length is easily modified.

We cannot so easily change the size of a vector, the same as it is a bit more of a stunt to modify a tuple. The shape of these objects is fixed. Mapping vectors to tuples, which is admittedly strange, will only be done if the Python side requests an expanded copy, otherwise an opaque Emacs Lisp object is seen in Python. In the other direction, whenever an Emacs Lisp vector is needed, one has to write tuple(python_list) while transmitting the object. Such transmissions are most probably to be unusual, as people are not going to blindly transmit whole big structures back and forth between Emacs and Python, they would rather do it once in a while only, and do only local modifications afterwards. The infrequent casting to tuple for getting an Emacs Lisp vector seems to suggest that we did a reasonable compromise.

In Python, both tuples and lists have O(1) access, so there is no real speed consideration there. Emacs Lisp is different : vectors have O(1) access while lists have O(N) access. The rigidity of Emacs Lisp vectors is such that people do not resort to vectors unless there is a speed issue, so in real Emacs Lisp practice, vectors are used rather parsimoniously. So much, in fact, that Emacs Lisp vectors are overloaded for what they are not meant : for example, very small vectors are used to represent X events in key-maps, programmers only want to test vectors for their type, or users just like bracketed syntax. The speed of access is hardly an issue then.
</t>
<t tx="ekr.20071103090504.5"></t>
<t tx="ekr.20071103090504.6">Emacs Lisp handles

When a Python function is called from Emacs Lisp, the function arguments have already been converted to Python types from Emacs Lisp types and the function result is going to be converted back to Emacs Lisp.

Several Emacs Lisp objects do not have Python equivalents, like for Emacs windows, buffers, markers, overlays, etc. It is nevertheless useful to pass them to Python functions, hoping that these Python functions will operate on these Emacs Lisp objects. Of course, the Python side may not itself modify such objects, it has to call for Emacs services to do so. Emacs Lisp handles are a mean to ease this communication.

Whenever an Emacs Lisp object may not be converted to a Python object, an Emacs Lisp handle is created and used instead. Whenever that Emacs Lisp handle is returned into Emacs Lisp from a Python function, or is used as an argument to an Emacs Lisp function from Python, the original Emacs Lisp object behind the Emacs Lisp handle is automatically retrieved.

Emacs Lisp handles are either instances of the internal Lisp class, or of one of its subclasses. If object is an Emacs Lisp handle, and if the underlying Emacs Lisp object is an Emacs Lisp sequence, then whenever object[index], object[index] = value and len(object) are meaningful, these may be used to fetch or alter an element of the sequence directly in Emacs Lisp space. Also, if object corresponds to an Emacs Lisp function, object(arguments) may be used to apply the Emacs Lisp function over the given arguments. Since arguments have been evaluated the Python way on the Python side, it would be conceptual overkill evaluating them again the Emacs Lisp way on the Emacs Lisp side, so Pymacs manage to quote arguments for defeating Emacs Lisp evaluation. The same logic applies the other way around.

Emacs Lisp handles have a value() method, which merely returns self. They also have a copy() method, which tries to open the box if possible. Emacs Lisp proper lists are turned into Python lists, Emacs Lisp vectors are turned into Python tuples. Then, modifying the structure of the copy on the Python side has no effect on the Emacs Lisp side.

For Emacs Lisp handles, str() returns an Emacs Lisp representation of the handle which should be eq to the original object if read back and evaluated in Emacs Lisp. repr() returns a Python representation of the expanded Emacs Lisp object. If that Emacs Lisp object has an Emacs Lisp representation which Emacs Lisp could read back, then repr() value is such that it could be read back and evaluated in Python as well, this would result in another object which is equal to the original, but not neccessarily eq.
</t>
<t tx="ekr.20071103090504.7">Python handles

The same as Emacs Lisp handles are useful for handling Emacs Lisp objects on the Python side, Python handles are useful for handling Python objects on the Emacs Lisp side.

Many Python objects do not have direct Emacs Lisp equivalents, including long integers, complex numbers, Unicode strings, modules, classes, instances and surely a lot of others. When such are being transmitted to the Emacs Lisp side, Pymacs use Python handles. These are automatically recovered into the original Python objects whenever transmitted back to Python, either as arguments to a Python function, as the Python function itself, or as the return value of an Emacs Lisp function called from Python.

The objects represented by these Python handles may be inspected or modified using the basic library of Python functions. For example, in :

     (setq matcher (pymacs-eval "re.compile('pattern').match"))
     (pymacs-call matcher argument)


the initial setq above could be decomposed into :

           (setq compiled (pymacs-eval "re.compile('pattern')")
            matcher (pymacs-call "getattr" compiled "match"))


This example shows that one may use pymacs-call with getattr as the function, to get a wanted attribute for a Python object.
</t>
<t tx="ekr.20071103090504.8"></t>
<t tx="ekr.20071103090504.9">
pymacs-eval

Function (pymacs-eval text) gets text evaluated as a Python expression, and returns the value of that expression converted back to Emacs Lisp.

pymacs-call

Function (pymacs-call function argument...) will get Python to apply the given function over zero or more argument. function is either a string holding Python source code for a function (like a mere name, or even an expression), or else, a Python handle previously received from Python, and hopefully holding a callable Python object. Each argument gets separately converted to Python before the function is called. pymacs-call returns the resulting value of the function call, converted back to Emacs Lisp.

pymacs-apply

Function (pymacs-apply function arguments) will get Python to apply the given function over the given arguments. arguments is a list containing all arguments, or nil if there is none. Besides arguments being bundled together instead of given separately, the function acts pretty much like pymacs-call.

We do not expect that pymacs-eval, pymacs-call or pymacs-apply will be much used, if ever. In practice, the Emacs Lisp side of a Pymacs application might call pymacs-load a few times for linking into the Python modules, with the indirect effect of defining trampoline functions for these modules on the Emacs Lisp side, which can later be called like usual Emacs Lisp functions.
</t>
<t tx="ekr.20071103091052"></t>
<t tx="ekr.20071103091052.1">Python setup

Pymacs requires little or no setup in the Python modules which are meant to be used from Emacs, for the simple situations where these modules receive nothing but Emacs nil, numbers or strings, or return nothing but Python None, numbers or strings.

Otherwise, use from Pymacs import lisp. If you need more Pymacs features, like the Let class, write from Pymacs import lisp, Let.
</t>
<t tx="ekr.20071103091052.2">Response mode

When Python receives a request from Emacs in the context of Pymacs, and until it returns the reply, Emacs keeps listening to serve Python requests. Emacs is not listening otherwise. Other Python threads, if any, may not call Emacs without very careful synchronisation.
</t>
<t tx="ekr.20071103091052.3">Emacs Lisp symbols

lisp is a special object which has useful built-in magic. Its attributes do nothing but represent Emacs Lisp symbols, created on the fly as needed (symbols also have their built-in magic).

lisp.nil or lisp["nil"], are the same as None.

Otherwise, lisp.symbol and lisp[string] yield objects of the internal Symbol type. These are genuine Python objects, that could be referred to by simple Python variables. One may write quote = lisp.quote, for example, and use quote afterwards to mean that Emacs Lisp symbol. If a Python function received an Emacs Lisp symbol as an argument, it can check with == if that argument is lisp.never or lisp.ask, say. A Python function may well choose to return lisp.t.

In Python, writing lisp.symbol = value or lisp[string] = value does assign value to the corresponding symbol in Emacs Lisp space. Beware that in such cases, the lisp. prefix may not be [omitted] spared. After result = lisp.result, one cannot hope that a later result = 3 will have any effect in the Emacs Lisp space : this would merely change the Python variable result, which was a reference to a Symbol instance, so it is now a reference to the number 3.

The Symbol class has value() and copy() methods. One can use either lisp.symbol.value() or lisp.symbol.copy() to access the Emacs Lisp value of a symbol, after conversion to some Python object, of course. However, if value() would have given an Emacs Lisp handle, lisp.symbol.copy() has the effect of lisp.symbol.value().copy(), that is, it returns the value of the symbol as opened as possible.

A symbol may also be used as if it was a Python function, in which case it really names an Emacs Lisp function that should be applied over the following function arguments. The result of the Emacs Lisp function becomes the value of the call, with all due conversions of course.
</t>
<t tx="ekr.20071103091052.4">Dynamic bindings

As Emacs Lisp uses dynamic bindings, it is common that Emacs Lisp programs use
let for temporarily setting new values for some Emacs Lisp variables having
global scope. These variables recover their previous value automatically when
the let gets completed, even if an error occurs which interrupts the normal flow
of execution.

Pymacs has a Let class to represent such temporary settings. Suppose for example
that you want to recover the value of lisp.mark() when the transient mark mode
is active on the Emacs Lisp side. One could surely use lisp.mark(lisp.t) to
force reading the mark in such cases, but for the sake of illustration, let's
ignore that, and temporarily deactivate transient mark mode instead. This could
be done this way :

        try :
        let = Let()
        let.push(transient_mark_mode=None)
        ... user code ...
        finally :
        let.pop()

let.push() accepts any number of keywords arguments. Each keyword name is
interpreted as an Emacs Lisp symbol written the Pymacs way, with underlines. The
value of that Emacs Lisp symbol is saved on the Python side, and the value of
the keyword becomes the new temporary value for this Emacs Lisp symbol. A later
let.pop() restores the previous value for all symbols which were saved together
at the time of the corresponding let.push(). There may be more than one
let.push() call for a single Let instance, they stack within that instance. Each
let.pop() will undo one and only one let.push() from the stack, in the reverse
order or the pushes.

When the Let instance disappears, either because the programmer does del let or
let = None, or just because the Python let variable goes out of scope, all
remaining let.pop() get automatically executed, so the try/finally statement may
be omitted in practice. For this omission to work flawlessly, the programmer
should be careful at not keeping extra references to the Let instance.

The constructor call let = Let() also has an implied initial .push() over all
given arguments, so the explicit let.push() may be omitted as well. In practice,
this sums up and the above code could be reduced to a mere :

     let = Let(transient_mark_mode=None)
     ... user code ...

Be careful at assigning the result of the constructor to some Python variable.
Otherwise, the instance would disappear immediately after having been created,
restoring the Emacs Lisp variable much too soon.

Any variable to be bound with Let should have been bound in advance on the Emacs
Lisp side. This restriction usually does no kind of harm. Yet, it will likely be
lifted in some later version of Pymacs.

The Let class has other methods meant for some macros which are common in Emacs
Lisp programming, in the spirit of let bindings. These method names look like
push_* or pop_*, where Emacs Lisp macros are save-*. One has to use the matching
pop_* for undoing the effect of a given push_* rather than a mere .pop() : the
Python code is clearer, this also ensures that things are undone in the proper
order. The same Let instance may use many push_* methods, their effects nest.

push_excursion() and pop_excursion() save and restore the current buffer, point
and mark. push_match_data() and pop_match_data() save and restore the state of
the last regular expression match. push_restriction() and pop_restriction() save
and restore the current narrowing limits. push_selected_window() and
pop_selected_window() save and restore the fact that a window holds the cursor.
push_window_excursion() and pop_window_excursion() save and restore the current
window configuration in the Emacs display.

As a convenience, let.push() and all other push_* methods return the Let
instance. This helps chaining various push_* right after the instance
generation. For example, one may write :

         let = Let().push_excursion()
         if True :
         ... user code ...
         del let

The if True: (use if 1: with older Python releases, some people might prefer
writing if let: anyway), has the only goal of indenting user code, so the scope
of the let variable is made very explicit. This is purely stylistic, and not at
all necessary. The last del let might be omitted in a few circumstances, for
example if the excursion lasts until the end of the Python function.
</t>
<t tx="ekr.20071103091052.5">Raw Emacs Lisp expressions

Pymacs offers a device for evaluating a raw Emacs Lisp expression, or a sequence of such, expressed as a string. One merely uses lisp as a function, like this :

     lisp("""
     ...
     possibly-long-sequence-of-lisp-expressions
     ...
     """)


The Emacs Lisp value of the last or only expression in the sequence becomes the value of the lisp call, after conversion back to Python.
</t>
<t tx="ekr.20071103091052.6">User interaction

Emacs functions have the concept of user interaction for completing the specification of their arguments while being called. This happens only when a function is interactively called by the user, it does not happen when a function is programmatically called by another. As Python does not have a corresponding facility, a bit of trickery was needed to retrofit that facility on the Python side.

After loading a Python module but prior to creating an Emacs view for this
module, Pymacs decides whether loaded functions will be interactively callable
from Emacs, or not. Whenever a function has an interaction attribute, this
attribute holds the Emacs interaction specification for this function. The
specification is either another Python function or a string. In the former case,
that other function is called without arguments and should, maybe after having
consulted the user, return a list of the actual arguments to be used for the
original function. In the latter case, the specification string is used verbatim
as the argument to the (interactive ...) function on the Emacs side. To get a
short reminder about how this string is interpreted on the Emacs side, try C-h f
interactive within Emacs. Here is an example where an empty string is used to
specify that an interactive has no arguments::

    from Pymacs import lisp

    def hello_world() :
        "`Hello world' from Python."
        lisp.insert("Hello from Python!")
        hello_world.interaction = ''

Versions of Python released before the integration of PEP 232 do not allow users
to add attributes to functions, so there is a fallback mechanism. Let's presume
that a given function does not have an interaction attribute as explained above.
If the Python module contains an interactions global variable which is a
dictionary, if that dictionary has an entry for the given function with a value
other than None, that function is going to be interactive on the Emacs side.
Here is how the preceeding example should be written for an older version of
Python, or when portability is at premium::

    from Pymacs import lisp
    interactions = {}

    def hello_world() :
        "`Hello world' from Python."
        lisp.insert("Hello from Python!")
        interactions[hello_world] = ''

One might wonder why we do not merely use lisp.interactive(...) from within
Python. There is some magic in the Emacs Lisp interpreter itself, looking for
that call before the function is actually entered, this explains why
(interactive ...) has to appear first in an Emacs Lisp defun. Pymacs could try
to scan the already compiled form of the Python code, seeking for
lisp.interactive, but as the evaluation of lisp.interactive arguments could get
arbitrarily complex, it would a real challenge un-compiling that evaluation into
Emacs Lisp.
</t>
<t tx="ekr.20071103091052.7">Keybindings

An interactive function may be bound to a key sequence.

To translate bindings like C-x w, say, one might have to know a bit more how
Emacs Lisp processes string escapes like \C-x or \M-\C-x in Emacs Lisp, and
emulate it within Python strings, since Python does not have such escapes. \C-L,
where L is an upper case letter, produces a character which ordinal is the
result of subtracting 0x40 from ordinal of L. \M- has the ordinal one gets by
adding 0x80 to the ordinal of following described character. So people can use
self-inserting non-ASCII characters, \M- is given another representation, which
is to replace the addition of 0x80 by prefixing with `ESC', that is 0x1b.

So \C-x in Emacs is '\x18' in Python. This is easily found, using an interactive
Python session, by givin it : chr(ord('X') - ord('A') + 1). An easier way would
be using the kbd function on the Emacs Lisp side, like with lisp.kbd('C-x w') or
lisp.kbd('M-&lt;f2&gt;').

To bind the F1 key to the helper function in some module :

     lisp.global_set_key((lisp.f1,), lisp.module_helper)

(item,) is a Python tuple yielding an Emacs Lisp vector. lisp.f1 translates to
the Emacs Lisp symbol f1. So, Python (lisp.f1,) is Emacs Lisp [f1]. Keys like
[M-f2] might require some more ingenuity, one may write either (lisp['M-f2'],)
or (lisp.M_f2,) on the Python side.
</t>
<t tx="ekr.20071103092153"></t>
<t tx="ekr.20071103092153.1">The *Pymacs* buffer

Emacs and Python are two separate processes (well, each may use more than one process). Pymacs implements a simple communication protocol between both, and does whatever needed so the programmers do not have to worry about details. The main debugging tool is the communication buffer between Emacs and Python, which is named *Pymacs*. As it is sometimes helpful to understand the communication protocol, it is briefly explained here, using an artificially complex example to do so. Consider :

     (pymacs-eval "lisp('(pymacs-eval \"`2L**111`\")')")
     "2596148429267413814265248164610048L"

Here, Emacs asks Python to ask Emacs to ask Python for a simple bignum computation. Note that Emacs does not natively know how to handle big integers, nor has an internal representation for them. This is why I use backticks, so Python returns a string representation of the result, instead of the result itself. Here is a trace for this example. The &lt; character flags a message going from Python to Emacs and is followed by an expression written in Emacs Lisp. The &gt; character flags a message going from Emacs to Python and is followed by a expression written in Python. The number gives the length of the message.

     &lt;22   (pymacs-version "0.3")
     &gt;49   eval("lisp('(pymacs-eval \"`2L**111`\")')")
     &lt;25   (pymacs-eval "`2L**111`")
     &gt;18   eval("`2L**111`")
     &lt;47   (pymacs-reply "2596148429267413814265248164610048L")
     &gt;45   reply("2596148429267413814265248164610048L")
     &lt;47   (pymacs-reply "2596148429267413814265248164610048L")

Python evaluation is done in the context of the Pymacs.pymacs module, so for example a mere reply really means Pymacs.pymacs.reply. On the Emacs Lisp side, there is no concept of module namespaces, so we use the pymacs- prefix as an attempt to stay clean. Users should ideally refrain from naming their Emacs Lisp objects with a pymacs- prefix.

reply and pymacs-reply are special functions meant to indicate that an expected result is finally transmitted. error and pymacs-error are special functions that introduce a string which explains an exception which recently occurred. pymacs-expand is a special function implementing the copy() methods of Emacs Lisp handles or symbols. In all other cases, the expression is a request for the other side, that request stacks until a corresponding reply is received.

Part of the protocol manages memory, and this management generates some extra-noise in the *Pymacs* buffer. Whenever Emacs passes a structure to Python, an extra pointer is generated on the Emacs side to inhibit garbage collection by Emacs. Python garbage collector detects when the received structure is no longer needed on the Python side, at which time the next communication will tell Emacs to remove the extra pointer. It works symmetrically as well, that is, whenever Python passes a structure to Emacs, an extra Python reference is generated to inhibit garbage collection on the Python side. Emacs garbage collector detects when the received structure is no longer needed on the Emacs side, after which Python will be told to remove the extra reference. For efficiency, those allocation-related messages are delayed, merged and batched together within the next communication having another purpose.

Variable pymacs-trace-transit may be modified for controlling how and when the *Pymacs* buffer, or parts thereof, get erased.
</t>
<t tx="ekr.20071103092153.2">Emacs usual debugging

If cross-calls between Emacs Lisp and Python nest deeply, an error will raise
successive exceptions alternatively on both sides as requests unstack, and the
diagnostic gets transmitted back and forth, slightly growing as we go. So,
errors will eventually be reported by Emacs. I made no kind of effort to
transmit the Emacs Lisp backtrace on the Python side, as I do not see a purpose
for it : all debugging is done within Emacs windows anyway.

On recent Emacses, the Python backtrace gets displayed in the mini-buffer, and
the Emacs Lisp backtrace is simultaneously shown in the *Backtrace* window. One
useful thing is to allow to mini-buffer to grow big, so it has more chance to
fully contain the Python backtrace, the last lines of which are often especially
useful. Here, I use :

         (setq resize-mini-windows t
          max-mini-window-height .85)

in my .emacs file, so the mini-buffer may use 85% of the screen, and quickly
shrinks when fewer lines are needed. The mini-buffer contents disappear at the
next keystroke, but you can recover the Python backtrace by looking at the end
of the *Messages* buffer. In which case the ffap package in Emacs may be yet
another friend! From the *Messages* buffer, once ffap activated, merely put the
cursor on the file name of a Python module from the backtrace, and C-x C-f RET
will quickly open that source for you.
</t>
<t tx="ekr.20071103092153.3">Auto-reloading on save

I found useful to automatically pymacs-load some Python files whenever they get
saved from Emacs. This can be decided on a per-file or per-directory basis. To
get a particular Python file to be reloaded automatically on save, add the
following lines at the end :

     # Local Variables :
     # pymacs-auto-reload : t
     # End :

Here is an example of automatic reloading on a per-directory basis. The code
below assumes that Python files meant for Pymacs are kept in
~/share/emacs/python.

    (defun fp-maybe-pymacs-reload ()
        (let ((pymacsdir (expand-file-name "~/share/emacs/python/")))
         (when (and (string-equal (file-name-directory buffer-file-name)
                  pymacsdir)
              (string-match "\\.py\\'" buffer-file-name))
          (pymacs-load (substring buffer-file-name 0 -3)))))
         (add-hook 'after-save-hook 'fp-maybe-pymacs-reload)
</t>
<t tx="ekr.20071103092153.4">@language rest

Let's say I have a a module, call it manglers.py, containing this simple python
function::

    def break_on_whitespace(some_string) :
         words = some_string.split()
         return '\n'.join(words)

The goal is telling Emacs about this function so that I can call it on a region
of text and replace the region with the result of the call. We shall also bind
this function to the key [f7].

Here is the Python side::

    from Pymacs import lisp
    interactions = {}

    def break_on_whitespace():
        # start and end may be given in any order.
        start,end = lisp.point(),lisp.mark(lisp.t)
        words = lisp.buffer_substring(start, end).split()
        lisp.delete_region(start,end)
        lisp.insert('\n'.join(words))

    interactions[break_on_whitespace] = ''

Here is the emacs side::

    (pymacs-load "manglers")
    (global-set-key [f7] 'manglers-break-on-whitespace)
</t>
<t tx="ekr.20071103093725">For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box by hand, as needed. This piece of
Python code eases my life on this. It may be used interactively from within
Emacs through the Pymacs interface, or in batch as a script which filters a
single region to be reformatted.

In batch mode, the reboxing is driven by command options and arguments and expects a
complete, self-contained boxed comment from a file.

Emacs function rebox-region also presumes that the region encloses a single
boxed comment.

Emacs rebox-comment is different, as it has to chase itself the extent of the
surrounding boxed comment.

</t>
<t tx="ekr.20071103093725.1">@color
@language python
@tabwidth -4

@others
&lt;&lt; templates &gt;&gt;

if __name__ == '__main__':
    apply(main, sys.argv[1:])
</t>
<t tx="ekr.20071103093725.10">def emacs_engine(self, flag, find_limits):
    """\
Rebox text while obeying FLAG.  Call FIND_LIMITS to discover the extent
of the boxed comment.
"""
    # `C-u -' means that box style is to be decided interactively.
    if flag == lisp['-']:
        flag = self.ask_for_style()
    # If FLAG is zero or negative, only change default box style.
    if type(flag) is type(0) and flag &lt;= 0:
        self.default_style = -flag
        lisp.message("Default style set to %d" % -flag)
        return
    # Decide box style and refilling.
    if flag is None:
        style = self.default_style
        refill = 1
    elif type(flag) == type(0):
        if self.default_style is None:
            style = flag
        else:
            style = merge_styles(self.default_style, flag)
        refill = 1
    else:
        flag = flag.copy()
        if type(flag) == type([]):
            style = self.default_style
            refill = 0
        else:
            lisp.error("Unexpected flag value %s" % flag)
    # Prepare for reboxing.
    lisp.message("Reboxing...")
    checkpoint = lisp.buffer_undo_list.value()
    start, end = find_limits()
    text = lisp.buffer_substring(start, end)
    width = lisp.fill_column.value()
    tabify = lisp.indent_tabs_mode.value() is not None
    point = lisp.point()
    if start &lt;= point &lt; end:
        position = point - start
    else:
        position = None
    # Rebox the text and replace it in Emacs buffer.
    old_style, new_style, text, position = engine(
        text, style=style, width=width,
        refill=refill, tabify=tabify, position=position)
    if text is None:
        lisp.error("Cannot rebox to style %d" % new_style)
    lisp.delete_region(start, end)
    lisp.insert(text)
    if position is not None:
        lisp.goto_char(start + position)
    # Collapse all operations into a single one, for Undo.
    self.clean_undo_after(checkpoint)
    # We are finished, tell the user.
    if old_style == new_style:
        lisp.message("Reboxed with style %d" % old_style)
    else:
        lisp.message("Reboxed from style %d to %d"
                     % (old_style, new_style))

</t>
<t tx="ekr.20071103093725.11">def ask_for_style(self):
    """\
Request the style interactively, using the minibuffer.
"""
    language = quality = type = None
    while language is None:
        lisp.message("\
Box language is 100-none, 200-/*, 300-//, 400-#, 500-;, 600-%%")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('6'):
            language = key - ord('0')
    while quality is None:
        lisp.message("\
Box quality/width is 10-simple/1, 20-rounded/2, 30-starred/3 or 40-starred/4")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('4'):
            quality = key - ord('0')
    while type is None:
        lisp.message("\
Box type is 1-opened, 2-half-single, 3-single, 4-half-double or 5-double")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('5'):
            type = key - ord('0')
    return 100*language + 10*quality + type

</t>
<t tx="ekr.20071103093725.12">def find_region(self):
    """\
Return the limits of the region.
"""
    return lisp.point(), lisp.mark(lisp.t)

</t>
<t tx="ekr.20071103093725.13">def find_comment(self):
    """\
Find and return the limits of the block of comments following or enclosing
the cursor, or return an error if the cursor is not within such a block
of comments.  Extend it as far as possible in both directions.
"""
    let = Let()
    let.push_excursion()
    # Find the start of the current or immediately following comment.
    lisp.beginning_of_line()
    lisp.skip_chars_forward(' \t\n')
    lisp.beginning_of_line()
    if not language_matcher[0](self.remainder_of_line()):
        temp = lisp.point()
        if not lisp.re_search_forward('\\*/', None, lisp.t):
            lisp.error("outside any comment block")
        lisp.re_search_backward('/\\*')
        if lisp.point() &gt; temp:
            lisp.error("outside any comment block")
        temp = lisp.point()
        lisp.beginning_of_line()
        lisp.skip_chars_forward(' \t')
        if lisp.point() != temp:
            lisp.error("text before start of comment")
        lisp.beginning_of_line()
    start = lisp.point()
    language = guess_language(self.remainder_of_line())
    # Find the end of this comment.
    if language == 2:
        lisp.search_forward('*/')
        if not lisp.looking_at('[ \t]*$'):
            lisp.error("text after end of comment")
    lisp.end_of_line()
    if lisp.eobp():
        lisp.insert('\n')
    else:
        lisp.forward_char(1)
    end = lisp.point()
    # Try to extend the comment block backwards.
    lisp.goto_char(start)
    while not lisp.bobp():
        if language == 2:
            lisp.skip_chars_backward(' \t\n')
            if not lisp.looking_at('[ \t]*\n[ \t]*/\\*'):
                break
            if lisp.point() &lt; 2:
                break
            lisp.backward_char(2)
            if not lisp.looking_at('\\*/'):
                break
            lisp.re_search_backward('/\\*')
            temp = lisp.point()
            lisp.beginning_of_line()
            lisp.skip_chars_forward(' \t')
            if lisp.point() != temp:
                break
            lisp.beginning_of_line()
        else:
            lisp.previous_line(1)
            if not language_matcher[language](self.remainder_of_line()):
                break
        start = lisp.point()
    # Try to extend the comment block forward.
    lisp.goto_char(end)
    while language_matcher[language](self.remainder_of_line()):
        if language == 2:
            lisp.re_search_forward('[ \t]*/\\*')
            lisp.re_search_forward('\\*/')
            if lisp.looking_at('[ \t]*$'):
                lisp.beginning_of_line()
                lisp.forward_line(1)
                end = lisp.point()
        else:
            lisp.forward_line(1)
            end = lisp.point()
    return start, end

</t>
<t tx="ekr.20071103093725.14">def remainder_of_line(self):
    """\
Return all characters between point and end of line in Emacs buffer.
"""
    return lisp('''\
(buffer-substring (point) (save-excursion (skip-chars-forward "^\n") (point)))
''')

</t>
<t tx="ekr.20071103093725.15">def clean_undo_after_old(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    # Declare some LISP functions.
    car = lisp.car
    cdr = lisp.cdr
    eq = lisp.eq
    setcdr = lisp.setcdr
    # Remove any `nil' delimiter recently added to the Undo list.
    cursor = lisp.buffer_undo_list.value()
    if not eq(cursor, checkpoint):
        tail = cdr(cursor)
        while not eq(tail, checkpoint):
            if car(tail):
                cursor = tail
                tail = cdr(cursor)
            else:
                tail = cdr(tail)
                setcdr(cursor, tail)

</t>
<t tx="ekr.20071103093725.16">def clean_undo_after(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    lisp("""
(let ((undo-list %s))
(if (not (eq buffer-undo-list undo-list))
  (let ((cursor buffer-undo-list))
(while (not (eq (cdr cursor) undo-list))
  (if (car (cdr cursor))
      (setq cursor (cdr cursor))
    (setcdr cursor (cdr (cdr cursor)))))))
nil)
"""
         % (checkpoint or 'nil'))

</t>
<t tx="ekr.20071103093725.17">def engine(text, style=None, width=79, refill=1, tabify=0, position=None):
    """\
Add, delete or adjust a boxed comment held in TEXT, according to STYLE.
STYLE values are explained at beginning of this file.  Any zero attribute
in STYLE indicates that the corresponding attribute should be recovered
from the currently existing box.  Produced lines will not go over WIDTH
columns if possible, if refilling gets done.  But if REFILL is false, WIDTH
is ignored.  If TABIFY is true, the beginning of produced lines will have
spaces replace by TABs.  POSITION is either None, or a character position
within TEXT.  Returns four values: the old box style, the new box style,
the reformatted text, and either None or the adjusted value of POSITION in
the new text.  The reformatted text is returned as None if the requested
style does not exist.
"""
    last_line_complete = text and text[-1] == '\n'
    if last_line_complete:
        text = text[:-1]
    lines = string.split(string.expandtabs(text), '\n')
    # Decide about refilling and the box style to use.
    new_style = 111
    old_template = guess_template(lines)
    new_style = merge_styles(new_style, old_template.style)
    if style is not None:
        new_style = merge_styles(new_style, style)
    new_template = template_registry.get(new_style)
    # Interrupt processing if STYLE does not exist.
    if not new_template:
        return old_template.style, new_style, None, None
    # Remove all previous comment marks, and left margin.
    if position is not None:
        marker = Marker()
        marker.save_position(text, position, old_template.characters())
    lines, margin = old_template.unbuild(lines)
    # Ensure only one white line between paragraphs.
    counter = 1
    while counter &lt; len(lines) - 1:
        if lines[counter] == '' and lines[counter-1] == '':
            del lines[counter]
        else:
            counter = counter + 1
    # Rebuild the boxed comment.
    lines = new_template.build(lines, width, refill, margin)
    # Retabify to the left only.
    if tabify:
        for counter in range(len(lines)):
            tabs = len(re.match(' *', lines[counter]).group()) / 8
            lines[counter] = '\t' * tabs + lines[counter][8*tabs:]
    # Restore the point position.
    text = string.join(lines, '\n')
    if last_line_complete:
        text = text + '\n'
    if position is not None:
        position = marker.get_position(text, new_template.characters())
    return old_template.style, new_style, text, position

</t>
<t tx="ekr.20071103093725.18">def guess_language(line):
    """\
Guess the language in use for LINE.
"""
    for language in range(len(language_matcher) - 1, 1, -1):
        if language_matcher[language](line):
            return language
    return 1

</t>
<t tx="ekr.20071103093725.19">def guess_template(lines):
    """\
Find the heaviest box template matching LINES.
"""
    best_template = None
    for template in template_registry.values():
        if best_template is None or template &gt; best_template:
            if template.match(lines):
                best_template = template
    return best_template

</t>
<t tx="ekr.20071103093725.2">#!/usr/bin/env python
# Copyright © 1991-1998, 2000, 2002 Progiciels Bourbeau-Pinard inc.
# François Pinard &lt;pinard@iro.umontreal.ca&gt;, April 1991.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""\
Handling of boxed comments in various box styles.

Introduction
------------

For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box "by hand", as needed.  This piece
of Python code eases my life on this.  It may be used interactively from
within Emacs through the Pymacs interface, or in batch as a script which
filters a single region to be reformatted.  I find only fair, while giving
all sources for a package using such boxed comments, to also give the
means I use for nicely modifying comments.  So here they are!

Box styles
----------

Each supported box style has a number associated with it.  This number is
arbitrary, yet by _convention_, it holds three non-zero digits such the the
hundreds digit roughly represents the programming language, the tens digit
roughly represents a box quality (or weight) and the units digit roughly
a box type (or figure).  An unboxed comment is merely one of box styles.
Language, quality and types are collectively referred to as style attributes.

When rebuilding a boxed comment, attributes are selected independently
of each other.  They may be specified by the digits of the value given
as Emacs commands argument prefix, or as the `-s' argument to the `rebox'
script when called from the shell.  If there is no such prefix, or if the
corresponding digit is zero, the attribute is taken from the value of the
default style instead.  If the corresponding digit of the default style
is also zero, than the attribute is recognised and taken from the actual
boxed comment, as it existed before prior to the command.  The value 1,
which is the simplest attribute, is ultimately taken if the parsing fails.

A programming language is associated with comment delimiters.  Values are
100 for none or unknown, 200 for `/*' and `*/' as in plain C, 300 for `//'
as in C++, 400 for `#' as in most scripting languages, 500 for `;' as in
LISP or assembler and 600 for `%' as in TeX or PostScript.

Box quality differs according to language. For unknown languages (100) or
for the C language (200), values are 10 for simple, 20 for rounded, and
30 or 40 for starred.  Simple quality boxes (10) use comment delimiters
to left and right of each comment line, and also for the top or bottom
line when applicable. Rounded quality boxes (20) try to suggest rounded
corners in boxes.  Starred quality boxes (40) mostly use a left margin of
asterisks or X'es, and use them also in box surroundings.  For all others
languages, box quality indicates the thickness in characters of the left
and right sides of the box: values are 10, 20, 30 or 40 for 1, 2, 3 or 4
characters wide.  With C++, quality 10 is not useful, it is not allowed.

Box type values are 1 for fully opened boxes for which boxing is done
only for the left and right but not for top or bottom, 2 for half
single lined boxes for which boxing is done on all sides except top,
3 for fully single lined boxes for which boxing is done on all sides,
4 for half double lined boxes which is like type 2 but more bold,
or 5 for fully double lined boxes which is like type 3 but more bold.

The special style 221 is for C comments between a single opening `/*'
and a single closing `*/'.  The special style 111 deletes a box.

Batch usage
-----------

Usage is `rebox [OPTION]... [FILE]'.  By default, FILE is reformatted to
standard output by refilling the comment up to column 79, while preserving
existing boxed comment style.  If FILE is not given, standard input is read.
Options may be:

  -n         Do not refill the comment inside its box, and ignore -w.
  -s STYLE   Replace box style according to STYLE, as explained above.
  -t         Replace initial sequence of spaces by TABs on each line.
  -v         Echo both the old and the new box styles on standard error.
  -w WIDTH   Try to avoid going over WIDTH columns per line.

So, a single boxed comment is reformatted by invocation.  `vi' users, for
example, would need to delimit the boxed comment first, before executing
the `!}rebox' command (is this correct? my `vi' recollection is far away).

Batch usage is also slow, as internal structures have to be reinitialised
at every call.  Producing a box in a single style is fast, but recognising
the previous style requires setting up for all possible styles.

Emacs usage
-----------

For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file:

     (add-hook 'c-mode-hook 'fp-c-mode-routine)
     (defun fp-c-mode-routine ()
       (local-set-key "\M-q" 'rebox-comment))
     (autoload 'rebox-comment "rebox" nil t)
     (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

     (pymacs-load "Pymacs.rebox")

Install Pymacs from `http://www.iro.umontreal.ca/~pinard/pymacs.tar.gz'.

The Emacs function `rebox-comment' automatically discovers the extent of
the boxed comment near the cursor, possibly refills the text, then adjusts
the box style.  When this command is executed, the cursor should be within
a comment, or else it should be between two comments, in which case the
command applies to the next comment.  The function `rebox-region' does
the same, except that it takes the current region as a boxed comment.
Both commands obey numeric prefixes to add or remove a box, force a
particular box style, or to prevent refilling of text.  Without such
prefixes, the commands may deduce the current box style from the comment
itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

If you use the `rebox' script rather than Emacs, the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

On average, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.

History
-------

I first observed rounded corners, as in style 223 boxes, in code from
Warren Tucker, a previous maintainer of the `shar' package, circa 1980.

Except for very special files, I carefully avoided boxed comments for
real work, as I found them much too hard to maintain.  My friend Paul
Provost was working at Taarna, a computer graphics place, which had boxes
as part of their coding standards.  He asked that we try something to get
him out of his misery, and this how `rebox.el' was originally written.
I did not plan to use it for myself, but Paul was so enthusiastic that I
timidly started to use boxes in my things, very little at first, but more
and more as time passed, still in doubt that it was a good move.  Later,
many friends spontaneously started to use this tool for real, some being very
serious workers.  This convinced me that boxes are acceptable, after all.

I do not use boxes much with Python code.  It is so legible that boxing
is not that useful.  Vertical white space is less necessary, too.  I even
avoid white lines within functions.  Comments appear prominent enough when
using highlighting editors like Emacs or nice printer tools like `enscript'.

After Emacs could be extended with Python, in 2001, I translated `rebox.el'
into `rebox.py', and added the facility to use it as a batch script.
"""

## Note: This code is currently compatible down to Python version 1.5.2.
## It is probably worth keeping it that way for a good while, still.

## Note: a double hash comment introduces a group of functions or methods.

import re, string, sys

</t>
<t tx="ekr.20071103093725.20">def left_margin_size(lines):
    """\
Return the width of the left margin for all LINES.  Ignore white lines.
"""
    margin = None
    for line in lines:
        counter = len(re.match(' *', line).group())
        if counter != len(line):
            if margin is None or counter &lt; margin:
                margin = counter
    if margin is None:
        margin = 0
    return margin

</t>
<t tx="ekr.20071103093725.21">def merge_styles(original, update):
    """\
Return style attributes as per ORIGINAL, in which attributes have been
overridden by non-zero corresponding style attributes from UPDATE.
"""
    style = [original / 100, original / 10 % 10, original % 10]
    merge = update / 100, update / 10 % 10, update % 10
    for counter in range(3):
        if merge[counter]:
            style[counter] = merge[counter]
    return 100*style[0] + 10*style[1] + style[2]

</t>
<t tx="ekr.20071103093725.22">def refill_lines(lines, width):
    """\
Refill LINES, trying to not produce lines having more than WIDTH columns.
"""
    # Try using GNU `fmt'.
    import tempfile, os
    name = tempfile.mktemp()
    open(name, 'w').write(string.join(lines, '\n') + '\n')
    process = os.popen('fmt -cuw %d %s' % (width, name))
    text = process.read()
    os.remove(name)
    if process.close() is None:
        return map(string.expandtabs, string.split(text, '\n')[:-1])
    # If `fmt' failed, do refilling more naively, wihtout using the
    # Knuth algorithm, nor protecting full stops at end of sentences.
    lines.append(None)
    new_lines = []
    new_line = ''
    start = 0
    for end in range(len(lines)):
        if not lines[end]:
            margin = left_margin_size(lines[start:end])
            for line in lines[start:end]:
                counter = len(re.match(' *', line).group())
                if counter &gt; margin:
                    if new_line:
                        new_lines.append(' ' * margin + new_line)
                        new_line = ''
                    indent = counter - margin
                else:
                    indent = 0
                for word in string.split(line):
                    if new_line:
                        if len(new_line) + 1 + len(word) &gt; width:
                            new_lines.append(' ' * margin + new_line)
                            new_line = word
                        else:
                            new_line = new_line + ' ' + word
                    else:
                        new_line = ' ' * indent + word
                        indent = 0
            if new_line:
                new_lines.append(' ' * margin + new_line)
                new_line = ''
            if lines[end] is not None:
                new_lines.append('')
                start = end + 1
    return new_lines

</t>
<t tx="ekr.20071103093725.23">class Marker:
    @others
</t>
<t tx="ekr.20071103093725.24">
## Heuristic to simulate a marker while reformatting boxes.

def save_position(self, text, position, ignorable):
    """\
Given a TEXT and a POSITION in that text, save the adjusted position
by faking that all IGNORABLE characters before POSITION were removed.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    for character in text[:position]:
        if character in ignore:
            counter = counter + 1
    self.position = position - counter

</t>
<t tx="ekr.20071103093725.25">def get_position(self, text, ignorable, latest=0):
    """\
Given a TEXT, return the value that would yield the currently saved position,
if it was saved by `save_position' with IGNORABLE.  Unless the position lies
within a series of ignorable characters, LATEST has no effect in practice.
If LATEST is true, return the biggest possible value instead of the smallest.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    position = 0
    if latest:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                if position == self.position:
                    break
                position = position + 1
    elif self.position &gt; 0:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                position = position + 1
                if position == self.position:
                    break
    return position + counter

</t>
<t tx="ekr.20071103093725.26">## Template processing.

class Template:
    @others
</t>
<t tx="ekr.20071103093725.27">
def __init__(self, style, weight, lines):
    """\
Digest and register a single template.  The template is numbered STYLE,
has a parsing WEIGHT, and is described by one to three LINES.
STYLE should be used only once through all `declare_template' calls.

One of the lines should contain the substring `box' to represent the comment
to be boxed, and if three lines are given, `box' should appear in the middle
one.  Lines containing only spaces are implied as necessary before and after
the the `box' line, so we have three lines.

Normally, all three template lines should be of the same length.  If the first
line is shorter, it represents a start comment string to be bundled within the
first line of the comment text.  If the third line is shorter, it represents
an end comment string to be bundled at the end of the comment text, and
refilled with it.
"""
    assert style not in template_registry, \
           "Style %d defined more than once" % style
    self.style = style
    self.weight = weight
    # Make it exactly three lines, with `box' in the middle.
    start = string.find(lines[0], 'box')
    if start &gt;= 0:
        line1 = None
        line2 = lines[0]
        if len(lines) &gt; 1:
            line3 = lines[1]
        else:
            line3 = None
    else:
        start = string.find(lines[1], 'box')
        if start &gt;= 0:
            line1 = lines[0]
            line2 = lines[1]
            if len(lines) &gt; 2:
                line3 = lines[2]
            else:
                line3 = None
        else:
            assert 0, "Erroneous template for %d style" % style
    end = start + len('box')
    # Define a few booleans.
    self.merge_nw = line1 is not None and len(line1) &lt; len(line2)
    self.merge_se = line3 is not None and len(line3) &lt; len(line2)
    # Define strings at various cardinal directions.
    if line1 is None:
        self.nw = self.nn = self.ne = None
    elif self.merge_nw:
        self.nw = line1
        self.nn = self.ne = None
    else:
        if start &gt; 0:
            self.nw = line1[:start]
        else:
            self.nw = None
        if line1[start] != ' ':
            self.nn = line1[start]
        else:
            self.nn = None
        if end &lt; len(line1):
            self.ne = string.rstrip(line1[end:])
        else:
            self.ne = None
    if start &gt; 0:
        self.ww = line2[:start]
    else:
        self.ww = None
    if end &lt; len(line2):
        self.ee = line2[end:]
    else:
        self.ee = None
    if line3 is None:
        self.sw = self.ss = self.se = None
    elif self.merge_se:
        self.sw = self.ss = None
        self.se = string.rstrip(line3)
    else:
        if start &gt; 0:
            self.sw = line3[:start]
        else:
            self.sw = None
        if line3[start] != ' ':
            self.ss = line3[start]
        else:
            self.ss = None
        if end &lt; len(line3):
            self.se = string.rstrip(line3[end:])
        else:
            self.se = None
    # Define parsing regexps.
    if self.merge_nw:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '.*$')
    elif self.nw and not self.nn and not self.ne:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '$')
    elif self.nw or self.nn or self.ne:
        self.regexp1 = re.compile(
            ' *' + regexp_quote(self.nw) + regexp_ruler(self.nn)
            + regexp_quote(self.ne) + '$')
    else:
        self.regexp1 = None
    if self.ww or self.ee:
        self.regexp2 = re.compile(
            ' *' + regexp_quote(self.ww) + '.*'
            + regexp_quote(self.ee) + '$')
    else:
        self.regexp2 = None
    if self.merge_se:
        self.regexp3 = re.compile('.*' + regexp_quote(self.se) + '$')
    elif self.sw and not self.ss and not self.se:
        self.regexp3 = re.compile(' *' + regexp_quote(self.sw) + '$')
    elif self.sw or self.ss or self.se:
        self.regexp3 = re.compile(
            ' *' + regexp_quote(self.sw) + regexp_ruler(self.ss)
            + regexp_quote(self.se) + '$')
    else:
        self.regexp3 = None
    # Save results.
    template_registry[style] = self

</t>
<t tx="ekr.20071103093725.28">def __cmp__(self, other):
    return cmp(self.weight, other.weight)

</t>
<t tx="ekr.20071103093725.29">def characters(self):
    """\
Return a string of characters which may be used to draw the box.
"""
    characters = ''
    for text in (self.nw, self.nn, self.ne,
                 self.ww, self.ee,
                 self.sw, self.ss, self.se):
        if text:
            for character in text:
                if character not in characters:
                    characters = characters + character
    return characters

</t>
<t tx="ekr.20071103093725.3">def main(*arguments):
    refill = 1
    style = None
    tabify = 0
    verbose = 0
    width = 79
    import getopt
    options, arguments = getopt.getopt(arguments, 'ns:tvw:', ['help'])
    for option, value in options:
        if option == '--help':
            sys.stdout.write(__doc__)
            sys.exit(0)
        elif option == '-n':
            refill = 0
        elif option == '-s':
            style = int(value)
        elif option == '-t':
            tabify = 1
        elif option == '-v':
            verbose = 1
        elif option == '-w':
            width = int(value)
    if len(arguments) == 0:
        text = sys.stdin.read()
    elif len(arguments) == 1:
        text = open(arguments[0]).read()
    else:
        sys.stderr.write("Invalid usage, try `rebox --help' for help.\n")
        sys.exit(1)
    old_style, new_style, text, position = engine(
        text, style=style, width=width, refill=refill, tabify=tabify)
    if text is None:
        sys.stderr.write("* Cannot rebox to style %d.\n" % new_style)
        sys.exit(1)
    sys.stdout.write(text)
    if verbose:
        if old_style == new_style:
            sys.stderr.write("Reboxed with style %d.\n" % old_style)
        else:
            sys.stderr.write("Reboxed from style %d to %d.\n"
                             % (old_style, new_style))

</t>
<t tx="ekr.20071103093725.30">def match(self, lines):
    """\
Returns true if LINES exactly match this template.
"""
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        if start == end or not self.regexp1.match(lines[start]):
            return 0
        start = start + 1
    if self.regexp3 is not None:
        if end == 0 or not self.regexp3.match(lines[end-1]):
            return 0
        end = end - 1
    if self.regexp2 is not None:
        for line in lines[start:end]:
            if not self.regexp2.match(line):
                return 0
    return 1

</t>
<t tx="ekr.20071103093725.31">def unbuild(self, lines):
    """\
Remove all comment marks from LINES, as hinted by this template.  Returns the
cleaned up set of lines, and the size of the left margin.
"""
    margin = left_margin_size(lines)
    # Remove box style marks.
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        lines[start] = unbuild_clean(lines[start], self.regexp1)
        start = start + 1
    if self.regexp3 is not None:
        lines[end-1] = unbuild_clean(lines[end-1], self.regexp3)
        end = end - 1
    if self.regexp2 is not None:
        for counter in range(start, end):
            lines[counter] = unbuild_clean(lines[counter], self.regexp2)
    # Remove the left side of the box after it turned into spaces.
    delta = left_margin_size(lines) - margin
    for counter in range(len(lines)):
        lines[counter] = lines[counter][delta:]
    # Remove leading and trailing white lines.
    start = 0
    end = len(lines)
    while start &lt; end and lines[start] == '':
        start = start + 1
    while end &gt; start and lines[end-1] == '':
        end = end - 1
    return lines[start:end], margin

</t>
<t tx="ekr.20071103093725.32">def build(self, lines, width, refill, margin):
    """\
Put LINES back into a boxed comment according to this template, after
having refilled them if REFILL.  The box should start at column MARGIN,
and the total size of each line should ideally not go over WIDTH.
"""
    # Merge a short end delimiter now, so it gets refilled with text.
    if self.merge_se:
        if lines:
            lines[-1] = lines[-1] + '  ' + self.se
        else:
            lines = [self.se]
    # Reduce WIDTH according to left and right inserts, then refill.
    if self.ww:
        width = width - len(self.ww)
    if self.ee:
        width = width - len(self.ee)
    if refill:
        lines = refill_lines(lines, width)
    # Reduce WIDTH further according to the current right margin,
    # and excluding the left margin.
    maximum = 0
    for line in lines:
        if line:
            if line[-1] in '.!?':
                length = len(line) + 1
            else:
                length = len(line)
            if length &gt; maximum:
                maximum = length
    width = maximum - margin
    # Construct the top line.
    if self.merge_nw:
        lines[0] = ' ' * margin + self.nw + lines[0][margin:]
        start = 1
    elif self.nw or self.nn or self.ne:
        if self.nn:
            line = self.nn * width
        else:
            line = ' ' * width
        if self.nw:
            line = self.nw + line
        if self.ne:
            line = line + self.ne
        lines.insert(0, string.rstrip(' ' * margin + line))
        start = 1
    else:
        start = 0
    # Construct all middle lines.
    for counter in range(start, len(lines)):
        line = lines[counter][margin:]
        line = line + ' ' * (width - len(line))
        if self.ww:
            line = self.ww + line
        if self.ee:
            line = line + self.ee
        lines[counter] = string.rstrip(' ' * margin + line)
    # Construct the bottom line.
    if self.sw or self.ss or self.se and not self.merge_se:
        if self.ss:
            line = self.ss * width
        else:
            line = ' ' * width
        if self.sw:
            line = self.sw + line
        if self.se and not self.merge_se:
            line = line + self.se
        lines.append(string.rstrip(' ' * margin + line))
    return lines

</t>
<t tx="ekr.20071103093725.33">def regexp_quote(text):
    """\
Return a regexp matching TEXT without its surrounding space, maybe
followed by spaces.  If STRING is nil, return the empty regexp.
Unless spaces, the text is nested within a regexp parenthetical group.
"""
    if text is None:
        return ''
    if text == ' ' * len(text):
        return ' *'
    return '(' + re.escape(text.strip() + ') *'

</t>
<t tx="ekr.20071103093725.34">def regexp_ruler(character):
    """\
Return a regexp matching two or more repetitions of CHARACTER, maybe
followed by spaces.  Is CHARACTER is nil, return the empty regexp.
Unless spaces, the ruler is nested within a regexp parenthetical group.
"""
    if character is None:
        return ''
    if character == ' ':
        return '  +'
    return '(' + re.escape(character + character) + '+) *'

</t>
<t tx="ekr.20071103093725.35">def unbuild_clean(line, regexp):
    """\
Return LINE with all parenthetical groups in REGEXP erased and replaced by an
equivalent number of spaces, except for trailing spaces, which get removed.
"""
    match = re.match(regexp, line)
    groups = match.groups()
    for counter in range(len(groups)):
        if groups[counter] is not None:
            start, end = match.span(1 + counter)
            line = line[:start] + ' ' * (end - start) + line[end:]
    return string.rstrip(line)

</t>
<t tx="ekr.20071103093725.36">## Template data.

# Matcher functions for a comment start, indexed by numeric LANGUAGE.
language_matcher = []
for pattern in (r' *(/\*|//+|#+|;+|%+)',
                r'',            # 1
                r' */\*',       # 2
                r' *//+',       # 3
                r' *#+',        # 4
                r' *;+',        # 5
                r' *%+'):       # 6
    language_matcher.append(re.compile(pattern).match)

# Template objects, indexed by numeric style.
template_registry = {}

def make_generic(style, weight, lines):
    """\
Add various language digit to STYLE and generate one template per language,
all using the same WEIGHT.  Replace `?' in LINES accordingly.
"""
    for language, character in ((300, '/'),  # C++ style comments
                                (400, '#'),  # scripting languages
                                (500, ';'),  # LISP and assembler
                                (600, '%')): # TeX and PostScript
        new_style = language + style
        if 310 &lt; new_style &lt;= 319:
            # Disallow quality 10 with C++.
            continue
        new_lines = []
        for line in lines:
            new_lines.append(string.replace(line, '?', character))
        Template(new_style, weight, new_lines)

</t>
<t tx="ekr.20071103093725.37">
make_generic(11, 115, ('? box',))

make_generic(12, 215, ('? box ?',
                       '? --- ?'))

make_generic(13, 315, ('? --- ?',
                       '? box ?',
                       '? --- ?'))

make_generic(14, 415, ('? box ?',
                       '???????'))

make_generic(15, 515, ('???????',
                       '? box ?',
                       '???????'))

make_generic(21, 125, ('?? box',))

make_generic(22, 225, ('?? box ??',
                       '?? --- ??'))

make_generic(23, 325, ('?? --- ??',
                       '?? box ??',
                       '?? --- ??'))

make_generic(24, 425, ('?? box ??',
                       '?????????'))

make_generic(25, 525, ('?????????',
                       '?? box ??',
                       '?????????'))

make_generic(31, 135, ('??? box',))

make_generic(32, 235, ('??? box ???',
                       '??? --- ???'))

make_generic(33, 335, ('??? --- ???',
                       '??? box ???',
                       '??? --- ???'))

make_generic(34, 435, ('??? box ???',
                       '???????????'))

make_generic(35, 535, ('???????????',
                       '??? box ???',
                       '???????????'))

make_generic(41, 145, ('???? box',))

make_generic(42, 245, ('???? box ????',
                       '???? --- ????'))

make_generic(43, 345, ('???? --- ????',
                       '???? box ????',
                       '???? --- ????'))

make_generic(44, 445, ('???? box ????',
                       '?????????????'))

make_generic(45, 545, ('?????????????',
                       '???? box ????',
                       '?????????????'))

# Textual (non programming) templates.

Template(111, 113, ('box',))

Template(112, 213, ('| box |',
                    '+-----+'))

Template(113, 313, ('+-----+',
                    '| box |',
                    '+-----+'))

Template(114, 413, ('| box |',
                    '*=====*'))

Template(115, 513, ('*=====*',
                    '| box |',
                    '*=====*'))

Template(121, 123, ('| box |',))

Template(122, 223, ('| box |',
                    '`-----\''))

Template(123, 323, ('.-----.',
                    '| box |',
                    '`-----\''))

Template(124, 423, ('| box |',
                    '\\=====/'))

Template(125, 523, ('/=====\\',
                    '| box |',
                    '\\=====/'))

Template(141, 143, ('| box ',))

Template(142, 243, ('* box *',
                    '*******'))

Template(143, 343, ('*******',
                    '* box *',
                    '*******'))

Template(144, 443, ('X box X',
                    'XXXXXXX'))

Template(145, 543, ('XXXXXXX',
                    'X box X',
                    'XXXXXXX'))
# C language templates.

Template(211, 118, ('/* box */',))

Template(212, 218, ('/* box */',
                    '/* --- */'))

Template(213, 318, ('/* --- */',
                    '/* box */',
                    '/* --- */'))

Template(214, 418, ('/* box */',
                    '/* === */'))

Template(215, 518, ('/* === */',
                    '/* box */',
                    '/* === */'))

Template(221, 128, ('/* ',
                    '   box',
                    '*/'))

Template(222, 228, ('/*    .',
                    '| box |',
                    '`----*/'))

Template(223, 328, ('/*----.',
                    '| box |',
                    '`----*/'))

Template(224, 428, ('/*    \\',
                    '| box |',
                    '\\====*/'))

Template(225, 528, ('/*====\\',
                    '| box |',
                    '\\====*/'))

Template(231, 138, ('/*    ',
                    ' | box',
                    ' */   '))

Template(232, 238, ('/*        ',
                    ' | box | ',
                    ' *-----*/'))

Template(233, 338, ('/*-----* ',
                    ' | box | ',
                    ' *-----*/'))

Template(234, 438, ('/* box */',
                    '/*-----*/'))

Template(235, 538, ('/*-----*/',
                    '/* box */',
                    '/*-----*/'))

Template(241, 148, ('/*    ',
                    ' * box',
                    ' */   '))

Template(242, 248, ('/*     * ',
                    ' * box * ',
                    ' *******/'))

Template(243, 348, ('/******* ',
                    ' * box * ',
                    ' *******/'))

Template(244, 448, ('/* box */',
                    '/*******/'))

Template(245, 548, ('/*******/',
                    '/* box */',
                    '/*******/'))

Template(251, 158, ('/* ',
                    ' * box',
                    ' */   '))

</t>
<t tx="ekr.20071103093725.4">def pymacs_load_hook():
    global interactions, lisp, Let, region, comment, set_default_style
    from Pymacs import lisp, Let
    emacs_rebox = Emacs_Rebox()
    # Declare functions for Emacs to import.
    interactions = {}
    region = emacs_rebox.region
    interactions[region] = 'P'
    comment = emacs_rebox.comment
    interactions[comment] = 'P'
    set_default_style = emacs_rebox.set_default_style

</t>
<t tx="ekr.20071103093725.5">class Emacs_Rebox:
    @others
</t>
<t tx="ekr.20071103093725.6">
def __init__(self):
    self.default_style = None

</t>
<t tx="ekr.20071103093725.7">def set_default_style(self, style):
    """\
Set the default style to STYLE.
"""
    self.default_style = style

</t>
<t tx="ekr.20071103093725.8">def region(self, flag):
    """\
Rebox the boxed comment in the current region, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_region)

</t>
<t tx="ekr.20071103093725.9">def comment(self, flag):
    """\
Rebox the surrounding boxed comment, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_comment)

</t>
<t tx="ekr.20071103094355">Design notes for rebox.py:

Pymacs specific features are used exclusively from within the pymacs_load_hook
function and the Emacs_Rebox class. In batch mode, Pymacs is not even imported.

In batch mode, as well as with rebox-region, the text to handle is turned over
to Python, and fully processed in Python, with practically no Pymacs interaction
while the work gets done. On the other hand, rebox-comment is rather Pymacs
intensive: the comment boundaries are chased right from the Emacs buffer, as
directed by the function Emacs_Rebox.find_comment. Once the boundaries are
found, the remainder of the work is essentially done on the Python side.

Once the boxed comment has been reformatted in Python, the old comment is
removed in a single delete operation, the new comment is inserted in a second
operation. This occurs in Emacs_Rebox.process_emacs_region. But by doing so, if
point was within the boxed comment before the reformatting, its precise position
is lost. To well preserve point, Python might have driven all reformatting
details directly in the Emacs buffer. We really preferred doing it all on the
Python side : as we gain legibility by expressing the algorithms in pure Python,
the same Python code may be used in batch or interactively, and we avoid the
slowdown that would result from heavy use of Emacs services.

To avoid completely loosing point, I kludged a Marker class, which goal is to
estimate the new value of point from the old. Reformatting may change the amount
of white space, and either delete or insert an arbitrary number characters meant
to draw the box. The idea is to initially count the number of characters between
the beginning of the region and point, while ignoring any problematic character.
Once the comment has been reboxed, point is advanced from the beginning of the
region until we get the same count of characters, skipping all problematic
characters. This Marker class works fully on the Python side, it does not
involve Pymacs at all, but it does solve a problem that resulted from my choice
of keeping the data on the Python side instead of handling it directly in the
Emacs buffer.

We want a comment reformatting to appear as a single operation, in the context
of Emacs Undo. The method Emacs_Rebox.clean_undo_after handles the general case
for this. Not that we do so much in practice : a reformatting implies one
delete-region and one insert, and maybe some other little adjustements at
Emacs_Rebox.find_comment time. Even if this method scans and mofifies an Emacs
Lisp list directly in the Emacs memory, the code doing this stays neat and
legible. However, I found out that the undo list may grow quickly when the Emacs
buffer use markers, with the consequence of making this routine so Pymacs
intensive that most of the CPU is spent there. I rewrote that routine in Emacs
Lisp so it executes in a single Pymacs interaction.

Function Emacs_Rebox.remainder_of_line could have been written in Python, but it
was probably not worth going away from this one-liner in Emacs Lisp. Also, given
this routine is often called by find_comment, a few Pymacs protocol interactions
are spared this way. This function is useful when there is a need to apply a
regexp already compiled on the Python side, it is probably better fetching the
line from Emacs and do the pattern match on the Python side, than transmitting
the source of the regexp to Emacs for it to compile and apply it.

For refilling, I could have either used the refill algorithm built within in
Emacs, programmed a new one in Python, or relied on Ross Paterson's fmt,
distributed by GNU and available on most Linuxes. In fact, refill_lines prefers
the latter. My own Emacs setup is such that the built-in refill algorithm is
already overridden by GNU fmt, and it really does a much better job. Experience
taught me that calling an external program is fast enough to be very bearable,
even interactively. If Python called Emacs to do the refilling, Emacs would
itself call GNU fmt in my case, I preferred that Python calls GNU fmt directly.
I could have reprogrammed GNU fmt in Python. Despite interesting, this is an
uneasy project : fmt implements the Knuth refilling algorithm, which depends on
dynamic programming techniques; Ross did carefully fine tune them, and took care
of many details. If GNU fmt fails, for not being available, say, refill_lines
falls back on a dumb refilling algorithm, which is better than none.
</t>
<t tx="ekr.20071103094355.1">For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file::

    (add-hook 'c-mode-hook 'fp-c-mode-routine)
    (defun fp-c-mode-routine ()
        (local-set-key "\M-q" 'rebox-comment))
    (autoload 'rebox-comment "rebox" nil t)
    (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

    (pymacs-load "Pymacs.rebox")

The Emacs function `rebox-comment' automatically discovers the extent of the
boxed comment near the cursor, possibly refills the text, then adjusts the box
style. When this command is executed, the cursor should be within a comment, or
else it should be between two comments, in which case the command applies to the
next comment.

The Emacs function `rebox-region' does the same, except that it takes the
current region as a boxed comment. Both commands obey numeric prefixes to add or
remove a box, force a particular box style, or to prevent refilling of text.
Without such prefixes, the commands may deduce the current box style from the
comment itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

In batch mode [If you use the `rebox' script rather than Emacs], the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

Usually, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.
</t>
<t tx="ekr.20071104222805"></t>
<t tx="ekr.20071115102156">Leo 4.4.5 beta 1                          November 16, 2007

Leo 4.4.5 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071115102156.11">http://sourceforge.net/forum/message.php?msg_id=3525277

The atFile read logic only **adds** nodes, it never deletes nodes. Thus,
the 'changed2' node 'survived' the atFile read logic. The 'changed2' node became
a 'vampire' node that couldn't be killed.

The fix will require some care. The present atFile.read logic is robust because
it *doesn't* delete nodes. I suspect the solutions will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes initially,
because it doesn't know whether there will be read errors later. If there are
read errors absolutely nothing must change. This ensures that read errors never
destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not actually
read from the external file. I think (but haven't proven) that all descendants of
vampire nodes are also vampire nodes. If that is so the post-pass will simply
delete vampire nodes without worrying about whether they have descendants.
</t>
<t tx="ekr.20071115102156.123">http://sourceforge.net/forum/message.php?msg_id=4615931
</t>
<t tx="ekr.20071115102156.124">http://sourceforge.net/forum/message.php?msg_id=4618014
</t>
<t tx="ekr.20071115102156.141">http://sourceforge.net/forum/message.php?msg_id=4620890
</t>
<t tx="ekr.20071115102156.146">From email from Terry Brown

python /home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py /home/tbrown/.tnb.leo

(should be all on one line, i.e. run and open /home/tbrown/.tnb.leo)

gives the traceback below.  Opening the file from within Leo works fine.

Bah - I just now looked at it closely enough to realize it's the evil
pickled Tk classes in cleo uAs.  So I don't know whether you want to
fix that or not, it makes sense Leo would read the file specified on
the command line before Tk is initialized - if it's just scanning for
settings maybe it could catch and ignore failed uA reads at that time?

At some point I want to take pickled Tk vars out of cleo, I was
thinking when that guy was working on the wx gui would be a good time,
too bad he got sick.

reading settings in /mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/config/leoSettings.leo
reading settings in /home/tbrown/leoSettings.leo
reading settings in /home/tbrown/myLeoSettings.leo
reading settings in /home/tbrown/.tnb.leo
Traceback (most recent call last):
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 398, in &lt;module&gt;
    run(fileName)
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 118, in run
    g.app.config.readSettingsFiles(fileName,verbose)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1649, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1674, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 892, in open
    silent=silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 779, in getLeoFile
    self.getAllLeoElements(fileName,silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1317, in getAllLeoElements
    self.getVnodes()
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1898, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1738, in getVnode
    attr,val = self.getUa("vnode")
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1658, in getUa
    val2 = pickle.loads(binString)
  File "/usr/lib/python2.5/pickle.py", line 1374, in loads
    return Unpickler(file).load()
  File "/usr/lib/python2.5/pickle.py", line 858, in load
    dispatch[key](self)
  File "/usr/lib/python2.5/pickle.py", line 1217, in load_build
    setstate(state)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/cleo.py", line 130, in __setstate__
    Tk.Variable.__init__(self)
  File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 188, in __init__
    self._tk = master.tk
AttributeError: 'NoneType' object has no attribute 'tk'
Exception exceptions.AttributeError: "TkPickleVar instance has no attribute '_tk'" in &lt;bound method TkPickleVar.__del__ of &lt;cleo.TkPickleVar instance at 0xb73a876c&gt;&gt; ignored
</t>
<t tx="ekr.20071115102156.148"></t>
<t tx="ekr.20071115102156.149"></t>
<t tx="ekr.20071115102156.2"></t>
<t tx="ekr.20071115102156.21">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

** Also, no ignore inserted.

Current CVS, ubuntu

From the code below I get:

reading: /mnt/removable/bkup_proj/Mammals/mammaldb/mammaldb.leo
*** first mismatch at line 119
original line:      def provide(self, what):
generated line: def provide(self, what):
@auto did not import the file perfectly
first mismatched line: 119
u'def provide(self, what):\n'
inserting @ignore
Errors inhibited read
@auto /mnt/removable/bkup_proj/Mammals/mammaldb/mammalShow.py

In the code below line 119 is not the first "def provide(self, what):"
but the second, the one in class mainPages - I've included the preceding
class def because context seems to be important.

@color
</t>
<t tx="ekr.20071115102156.237">This option has effect only when importing so-called non-strict languages,
for which leading whitespace is not terribly significant.

True: @auto warns about mismatches that occur solely in leading whitespace.
</t>
<t tx="ekr.20071115102156.238"></t>
<t tx="ekr.20071115102156.256">Added sort-lines-ignoring-case, reverse-sort-lines and reverse-sort-lines-ignoring-case.
</t>
<t tx="ekr.20071115102156.289">There is also an @bool trace_plugins setting.
</t>
<t tx="ekr.20071115102156.301">And reorganized the unit tests by Leo source file.
</t>
<t tx="ekr.20071115102156.302">http://sourceforge.net/forum/message.php?msg_id=4622384

vim.py does not open url nodes if the new setting: 

@bool vim_plugin_opens_url_nodes 

is False (or does not exist). 
</t>
<t tx="ekr.20071115102156.303">The code now remembers the relative file name as well as the full path name.
This allows Leo to find the icon when multiple machines are involved.
</t>
<t tx="ekr.20071115102156.320">http://sourceforge.net/forum/message.php?msg_id=4614081
</t>
<t tx="ekr.20071115102156.321">http://tango.freedesktop.org/Tango_Icon_Library

These icons are now part of Leo's distribution.
</t>
<t tx="ekr.20071115102156.5"></t>
<t tx="ekr.20071115102156.6">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3768494
By: ktenney

I'm using current CVS, W2k

1 open a Leo file (I'm using a batch file / console)

2 click Edit-&gt;Open   &lt;-- Having this dialog open is the problem.

3 return focus to the Leo window

4 click Help-&gt;Open leoDocs.leo

Zombie!

@color
</t>
<t tx="ekr.20071115102156.78">@nocolor

In the following code:

extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}

produces the following in the log window:

Leo Log Window...
Leo 4.4.4 final, build  1.216 , November 2, 2007
Python 2.5.1, Tk 8.4.14, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = rshanley (in C:\)
global config dir: C:\Program Files\Leo\config
home dir: C:\
reading settings in C:\Program Files\Leo\config\leoSettings.leo
*** first mismatch at line 2
original line:  {
generated line:
import command did not import the file perfectly
first mismatched line: 2
u'\n'
input...
  0 extern  "C"
  1 {
  2 #include "stuff.h"
  3 void    init(void);
  4 #include "that.h"
  5 }
output...
  0 extern  "C"
  1
inserting @ignore
imported C:/test/aa.cc

@color
</t>
<t tx="ekr.20071115102156.79">@bool at_auto_warns_about_leading_whitespace
</t>
<t tx="ekr.20071115102156.81">http://sourceforge.net/forum/message.php?msg_id=4464649
By: terry_n_brown

An argument I'm always having with leo has to do with its conversion of file
paths to 'absolute' forms.

In the file browser I select '/home/tbrown/misc/foo.leo'.
Leo reinterprets this as '/media/hda2/usr1/home/tbrown/misc/foo.leo'

Then I switch machines, and while
'/home/tbrown/misc/foo.leo' would still be valid,
'/media/hda2/usr1/home/tbrown/misc/foo.leo' isn't - on the other machine it
would be '/media/hdb1/home/tbrown/misc/foo.leo'.

I end up with the two entries in recent files, having to identify the right one.

If the Tk dialog is returning '/home/tbrown/misc/foo.leo', which I assume it is
because that's what it's displaying, I wish leo would use and store that.
</t>
<t tx="ekr.20071115102421"></t>
<t tx="ekr.20071116062917"></t>
<t tx="ekr.20071116062917.18">::

    delete-all-icons
    delete-first-icon
    delete-last-icon
    delete-node-icons
    insert-icon
    reverse-sort-lines
    reverse-sort-lines-ignoring-case.
    sort-lines-ignoring-case
    toggle-collapse_nodes_during_finds
</t>
<t tx="ekr.20071116062917.2">.. Links used in this document.
.. _`leoBridge`:            leoBridge.html
.. _`debugging with Leo`:   debuggers.html
.. _`Using @shadow`:        atShadow.html
.. _`Python's gettext`:     http://docs.python.org/lib/module-gettext.html
.. _Emacs:                  http://www.xemacs.org/
.. _pymacs:                 http://pymacs.progiciels-bpi.ca/index.html
.. _`Leo and Emacs`:        emacs.html


</t>
<t tx="ekr.20071116062917.3">- Leo now supports all directives in headlines.

- Moved all unit tests to unitTest.leo and reorganized the unit tests by Leo source file.

- Installed small icon set from Tango library.

- The rst3 plugin now supports @rst-preformat nodes.
</t>
<t tx="ekr.20071116063202">.. _`zombie`: http://sourceforge.net/forum/message.php?msg_id=3768494

.. _`vampire`: http://sourceforge.net/forum/message.php?msg_id=3525277

- Fixed hung (`zombie`_) windows.

- Fixed resurrected (`vampire`_) nodes.
</t>
<t tx="ekr.20071116063649">- @bool at_auto_warns_about_leading_whitespace

  This option has effect only when importing so-called non-strict languages, for
  which leading whitespace is not terribly significant.

- @bool warn_when_plugins_fail_to_load

  There is also an @bool trace_plugins setting.

- @bool vim_plugin_opens_url_nodes

  vim.py does not open url nodes if this setting is False.
</t>
<t tx="ekr.20071116081521"></t>
<t tx="ekr.20071116081521.1"></t>
<t tx="ekr.20071206093323.1"></t>
<t tx="ekr.20071206093323.2">pylint reported the following errors:

E1101:1877:atFile.readEndNode: Instance of 'atFile' has no 'correctedLines' member
E1101:2725:atFile.norefWrite:  Instance of 'atFile' has no 'putBuffered' member
</t>
<t tx="ekr.20071206093323.29">http://sourceforge.net/forum/message.php?msg_id=4646055
</t>
<t tx="ekr.20071206093323.3"></t>
<t tx="ekr.20071206093323.30">https://sourceforge.net/forum/message.php?msg_id=4643992
</t>
<t tx="ekr.20071206093323.31">The init base classes can now be inited in a more standard way.
</t>
<t tx="ekr.20071206093323.4">http://sourceforge.net/forum/message.php?msg_id=4632695
</t>
<t tx="ekr.20071206093323.59">http://sourceforge.net/forum/message.php?msg_id=4639872
</t>
<t tx="ekr.20071206093323.72">Several problems still remain:

- Files that contain what look like section references.

- Underindented docstrings.
</t>
<t tx="ekr.20071206093323.76"></t>
<t tx="ekr.20071206093323.80">http://sourceforge.net/forum/message.php?msg_id=4652514
</t>
<t tx="ekr.20071206093323.87">http://sourceforge.net/forum/message.php?msg_id=4654762
</t>
<t tx="ekr.20071206093323.96">@nocolor

I have clones that traverse chapters.

Given the following Chapters:

&gt; Main
&gt; Big Picture
&gt; Smaller Chunk

I have in Main, my organization, with my group in it.  It's also cloned around
all the other views (really, everything starts in the Big Picture).

This is the layout of my clone:

1:  Chapter:Main &gt; me
2:  Chapter:Main &gt; MyOrg &gt; me
3:  Chapter:Big Picture &gt; CEO &gt; Some Big Honcho &gt; MyOrg &gt; me
4:  Chapter:Smaller Chunk &gt; Some Big Honcho &gt; MyOrg &gt; me

If I Go-To-Next-Clone  (ALT-N) from (1), focus will move to the selected node
in Chapter:Main, namely (2).

So here's the issue: 

Let each successive line below represent a starting focus, and the next line
the node that ALT-N selects.  If focus changes in the Outline pane (including
Chapter pane change) to match the Node, that case is marked with [f] - a successful
focus transition.

The issue are the lines w/o [f];  Here's a couple of test runs.

1: [f] (starting node / focus)
2: [f]
3:
4:
1: [f]

Next test:

3: [f]
1: [f]
1: [f]
4:
3:
1: [f]

Next test:

4: [f]
3:
1: [f]
2: [f]
4:
3:
1: [f]
2: [f]
... and so on...

In cases with NO [f], the outline pane seems moved to the "end", but no node
selected.

Not a show stopper, but a bug nonetheless.

@color
</t>
<t tx="ekr.20071206093346">Leo 4.4.5 beta 2                          December 7, 2007

Leo 4.4.5 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This beta 2 release fixes several recently reported bugs.  A final release
is due in about a week.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071210094621">This following is adapted from Terry Brown's entry in Leo's wiki.

You can not just run leoBridge from Leo, because the leoBridge module is designed
to run a separate copy of Leo. However, it is possible to run leoBridge from a
separate process. That turned out to be more, um, interesting than anticipated,
so I'm recording the results here.

The idea is that script A running in Leo (i.e. in a regular GUI Leo session)
calls script B through subprocess.Popen(), script B uses LeoBridge to do
something (parse unloaded Leo files), and returns the result to script A.
Passing the result back via the clipboard seemed like a possibility, but
XWindows clipboard madness being what it is, that didn't seem to work.

First trick, calling script B from script A::

    import subprocess
    p = subprocess.Popen(('python',
        path_to_script_B,
        parameter_for_script_B,),
        stdout=subprocess.PIPE,
        env={'PYTHONPATH': g.app.loadDir,'USER': g.app.leoID},
    )
    p.wait()

Setting PYTHONPATH in the environment seemed like the easiest way to let
script B find leoBridge.py (which it needs to import).  But by setting the
env parameter you limit script B's environment to be **only** PYTHONPATH,
which causes leoBridge to fail because, in unix at least, it depends
on USER in the environment.  So you need to pass that through, too.

Now, because passing stuff back on the clipboard seems unreliable, at least
in XWindows, script B passes results back to script A via stdout (print),
but there's some Leo initialization chatter you want to avoid.  So put a
sentinel, 'START_CLIPBOARD', in the output, and collect it like this::

    response = p.stdout.readlines()
    while response and 'START_CLIPBOARD' not in response[0]:
        del response[0]
    del response[0]  # delete the sentinel as well
    response = ''.join(response)

This is the basic mechanism.  What I *actually* wanted to do was have script
B generate a branch of nodes and pass that back to script A for insertion in
the tree script A is running in.  That's relatively easy if you use::

    c.setCurrentPosition(pos_of_branch_to_return)
    c.copyOutline()
    print '&lt;!-- START_CLIPBOARD --&gt;'
    print g.app.gui.getTextFromClipboard()
    print '&lt;!-- END_CLIPBOARD --&gt;'

at the end of script B. Back in script A, after you've rebuilt
`response` as shown above, do::

    g.app.gui.replaceClipboardWith(response)
    c.pasteOutline()
</t>
<t tx="ekr.20071211083251">Leo 4.4.5 final                               December 11, 2007

Leo 4.4.5 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.5 fixes several long-delayed bug fixes and adds several new features.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.5:
----------------------------

- Fixes all known bugs.
- Leo now recognizes directives in headlines.
- Adds 3 new sort-lines commands.
- Adds commands to insert and delete icons from headlines.
- Adds all the Tango 16x16 icons to Leo's icon library.
- Adds support for @rst-preformat nodes to the rst3 plugin.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071217092203.1"></t>
<t tx="ekr.20071217092203.127">The last char was not colored in the following doc part:

@

&lt;tag /&gt;
</t>
<t tx="ekr.20071217092203.128">http://sourceforge.net/forum/message.php?msg_id=4676037
</t>
<t tx="ekr.20071217092203.130">This prevents over-long traces.
</t>
<t tx="ekr.20071217092203.131"></t>
<t tx="ekr.20071217092203.136"></t>
<t tx="ekr.20071217092203.137"></t>
<t tx="ekr.20071217092203.138">The patch attached against leoConfig.py (current CVS) adds a machine
specific config file to the config files Leo loads.

I synchronize files between multiple (3) machines. This means I can't
use different myLeoSettings files on each.

Tk fonts are screen dpi sensitive.  But (in Linux at least)
Tk's attempts to switch a font you picked to something equivalent at a
different dpi always result in a font that looks terrible.

So every time I switch machines I edit ~/myLeoSettings.leo to move the
font defs I picked for the current machine to the bottom of the body
text for the appropriate settings node, and then restart Leo.

This patch means I don't have to do that any more.  I'm sure there are
other uses for it.  Python doesn't seem to have a generic machine name
finding function, hence the sequence of alternatives.
</t>
<t tx="ekr.20071217092203.145">The version of plugins_menu.py at http://leo.zwiki.org/Plumloco separates out
the gui dependent dialogs (the menus are already gui independent) and made them
general purpose dialogs available to all plugins.

I have also slightly enhanced the dialogs to provide user defined buttons. 
</t>
<t tx="ekr.20071217092203.146"></t>
<t tx="ekr.20071217092203.147">The finds the next cloned node, regardless of whether the presently selected node is a clone or not.
</t>
<t tx="ekr.20071217092203.149">The command toggles whether moving a node left collapses the outline.
</t>
<t tx="ekr.20071217092203.152"></t>
<t tx="ekr.20071217092203.154">Use @data import_xml_tags setting to specify the xml tags that act as organizers.
</t>
<t tx="ekr.20071217092203.161">This fixes a focus problem.
</t>
<t tx="ekr.20071217092203.163">Javascript regexps that look like section references cause problems, but that can not be helped.
</t>
<t tx="ekr.20071217092203.2">http://sourceforge.net/forum/message.php?msg_id=4668960

It seems in external files you can delete some text and save, causing the derived
file to be written and all dirty flags cleared.  But then undo makes the text
come back, as expected, but save only saves the outline, because the dirty flag
wasn't set on the node in which the text was restored by undo.
</t>
<t tx="ekr.20071217092203.30"></t>
<t tx="ekr.20071217092203.31">Added k.overrideCommand.
</t>
<t tx="ekr.20071217092203.45">http://sourceforge.net/forum/message.php?msg_id=4671771
</t>
<t tx="ekr.20071217092203.51">http://sourceforge.net/forum/message.php?msg_id=4667105
</t>
<t tx="ekr.20071217092203.52">The command now clears all .leoRecentFiles.txt files and write a message.
</t>
<t tx="ekr.20071217092203.64">This was a very long-standing bug: the most annoying in all of Leo.
</t>
<t tx="ekr.20071217092250">Leo 4.4.6 beta 1                           December 17, 2007

Leo 4.4.6 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20071217093444"></t>
<t tx="ekr.20071217093444.5">::

    find-next-clone
    toggle-sparse-move

Replaced the delete-all-icons command with a script in scripts.leo.  This command was too dangerous.
</t>
<t tx="ekr.20071217093444.6">- Added support for @data nodes in settings files.

- The @data import_xml_tags setting specifies the xml tags that act as organizers.
  This settings is used by @auto when importing xml files.
</t>
<t tx="ekr.20080106114203.1">http://sourceforge.net/forum/message.php?msg_id=4682598
</t>
<t tx="ekr.20080106114203.2">http://sourceforge.net/forum/message.php?msg_id=4681175

- There was a horrendous bug in the match_seq_regexp matcher which could cause the colorizer to loop.
- There was another horrendous bug in match_regexp_helper that cause spurious matches.
- Added some more defensive code to have the colorizer recover more gracefully in this case. 
- The jedit2py script was not associating regexp rules whose regex starts with
  '\' with the proper character. The proper character is the hash_char
  character, not the '\' character. As a result, regexp's that start with '\'
  never got matched.

The following colorizers are affected by the change:

modes/apacheconf.py
modes/erlang.py
modes/moin.py
modes/perl.py
modes/php.py
modes/pl1.py
modes/rest.py
modes/shell.py
modes/shellscript.py
</t>
<t tx="ekr.20080106114203.3"></t>
<t tx="ekr.20080106114203.4">http://sourceforge.net/forum/message.php?msg_id=4687706
</t>
<t tx="ekr.20080106114225">Leo 4.4.6 beta 2                           January 15, 2008

Leo 4.4.6 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080106114331"></t>
<t tx="ekr.20080106114648"></t>
<t tx="ekr.20080109074102">You can add an icon to the presently selected node with
c.editCommands.insertIconFromFile(path). path is an absolute path or a path
relative to the leo/Icons folder. A relative path is recommended if you plan to
use the icons on machines with different directory structures.

For example::

    path = 'rt_arrow_disabled.gif' 
    c.editCommands.insertIconFromFile(path) 

Scripts can delete icons from the presently selected node using the following methods::

    c.editCommands.deleteFirstIcon() 
    c.editCommands.deleteLastIcon() 
    c.editCommands.deleteNodeIcons() 
</t>
<t tx="ekr.20080110082845">Python code completion module

From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 20:57:18 +0300

I've been developing IDLE over the past 2 years or so. Even before
that, I helped a friend of mine, Noam Raphael, write IDLE's
auto-completion, which is included in recent versions of IDLE.

Noam wrote the original completion code from scratch, and AFAIK every
Python IDE which features code completion has done the same. Surely
there is -some- functionality which could be useful cross-IDE?
Retrieving possible completions from the namespace, for example. And
we should be learning from each-others' ideas and experiences.

So how about we design a generic Python completion module, that
each IDE could extend, and use for the completion logic?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:06:01 +0100

I am very keen for this. I will help where it is required. PIDA
currently has no code completion (outside what vim/emacs provide),



From: "phil jones" &lt;inters...@gmail.com&gt;
Date: Wed, 6 Jun 2007 11:07:33 -0700

What functions would we ask for a code completion module?

Presumably recognition of the beginnings of
- a) python keywords
- b) classes and functions defined earlier in this file?
- c) in scope variables?

As python is dynamically typed, I guess we can't expect to know the
names of methods of objects?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:13:10 +0100

&gt; Presumably recognition of the beginnings of
&gt; - a) python keywords
&gt; - b) classes and functions defined earlier in this file?
&gt; - c) in scope variables?

does c) include: d) imported modules



From: Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
Date: Wed, 6 Jun 2007 20:17:30 +0200

&gt; &gt;Presumably recognition of the beginnings of
&gt; &gt;- a) python keywords
&gt; &gt;- b) classes and functions defined earlier in this file?
&gt; &gt;- c) in scope variables?

&gt; does c) include: d) imported modules

For code-completion, I suppose astng[1] could be useful.

1: http://www.logilab.org/project/eid/856


From: Stani's Python Editor &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 20:48:41 +0200

A good point. I think we all have been thinking about this. Important
issues for the design is the extraction method and the sources.

*the method*
Importing is a lazy, but accurate way of importing, but is security wise
not such a good idea. Parsing throught an AST compiler is better,
however more difficult. Here are two options.

From version 2.5 the standard Python compiler converts internally the
source code to an abstract syntax tree (AST) before producing the
bytecode. So probably that is a good way to go as every python
distribution has this battery included.

As Nicolas suggested earlier on this mailing list, there is another
option: the AST compiler in python or PyPy:

On Mar 14 2006, 12:16 am, Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
wrote:

&gt; &gt; WingIDE use anASTgenerator written in C (but cross-platform),
&gt; &gt; lightningly quick, and open sourced. This could be a potential
&gt; &gt; starting point.

&gt; &gt; Additionally isn't Python2.5 planned to have a C-written compiler?

&gt; PyPy also produced an improved parser/compiler.

&gt; http://codespeak.net/pypy/dist/pypy/doc/index.html
&gt; http://codespeak.net/pypy/dist/pypy/module/recparser/

But if it could be done with the standard one it is one dependency less.

*the sources*
In the design we could define first the sources:
1 external imported modules from the pythonpath
2 local modules relative to the current file or context dependent
(Blender, Gimp, ...)
3 inner code

For 1:
It might be a good idea to have a function which scans all the modules
from the pythonpath or one specific module to cache all autocompletion
and calltip information of all classes, methods and doc strings. Why?
Modules in the pythonpath don't change so often. With some criteria
(file name, time stamp, size, ...) you could check if updates are
necessary at startup. Having a readymade 'database' (could be python
dictionary or sqlite database) for autocompletion/call tips would speed
up things (and is also more secure if you are importing rather than
parsing. For example trying to provide gtk autocompletion in a wxPython
by importing is problematic).

For 2:
Here you load the parser on demand. Autocompletion/calltip information
can be added to the database.

For 3:
A different kind of parser needs to be used here as per definition code
you edit contains errors while typing. External modules are retrieved
from 1 and 2, for internal code you can scan all the words and add them
to the autocomplete database. As a refinement you can give special
attention to 'self'. Also for calltips you can inherit when there are
assignments, eg
frame = Frame()
than frame inherits autocomplete &amp; calltip information from Frame.

So autocompletion &amp; calltips deals with two steps: extraction and
'database'. If someone has a good parser already, we could use it.
Otherwise we can define an API for the extraction and maybe lazily
implement it first with importing and concentrate first on the
'database'. When the database is ready we can implement the parsing. You
could also implement the parsing first, but than it takes longer before
you have results. Of course the library is GUI independent, it only
works with strings or lists.

What concerns SPE, it uses importing for autocompletion (1+2) and does
internal code analysis for local code (however without the inheriting).

Tal, how does IDLE's autocompletion works?

Stani



From: Stani's Python Editor &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 20:53:10 +0200

Nicolas Chauvat wrote:
&gt; On Wed, Jun 06, 2007 at 07:13:10PM +0100, Ali Afshar wrote:
&gt;&gt;&gt; Presumably recognition of the beginnings of
&gt;&gt;&gt; - a) python keywords
&gt;&gt;&gt; - b) classes and functions defined earlier in this file?
&gt;&gt;&gt; - c) in scope variables?
&gt;&gt; does c) include: d) imported modules

&gt; For code-completion, I suppose astng[1] could be useful.

&gt; 1: http://www.logilab.org/project/eid/856

How dependent/independent is this from the standard AST compiler or
PyPy? Is it more IDE friendly? Is it based on it or a total independent
implementation?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:59:13 +0100

&gt; A good point. I think we all have been thinking about this. Important
&gt; issues for the design is the extraction method and the sources.

&gt; *the method*
&gt; Importing is a lazy, but accurate way of importing, but is security wise
&gt; not such a good idea. Parsing throught an AST compiler is better,
&gt; however more difficult. Here are two options.

&gt; From version 2.5 the standard Python compiler converts internally the
&gt; source code to an abstract syntax tree (AST) before producing the
&gt; bytecode. So probably that is a good way to go as every python
&gt; distribution has this battery included.

&gt; As Nicolas suggested earlier on this mailing list, there is another
&gt; option: the AST compiler in python or PyPy:

What concerns me about these is whether they would work in a module
which has a syntax error.

I believe Wing's compiler bit of their code completion is open source.
I remember having seen the code.



From: Stani &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 12:08:00 -0700

&gt; What concerns me about these is whether they would work in a module
&gt; which has a syntax error.

&gt; I believe Wing's compiler bit of their code completion is open source.
&gt; I remember having seen the code.

It is indeed, but is implemented in C, which means an extra dependency
and not a 100% python solution. Normally modules (especially in the
pythonpath) which you import don't have syntax errors. Maybe logilabs
implementation handles syntax errors well as it is developed for
PyLint. Nicolas?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 22:34:41 +0300

&gt; As python is dynamically typed, I guess we can't expect to know the
&gt; names of methods of objects?

Well, the dir() builtin does just that, though there can be attributes
which won't be included therein. However, the builtin dir() can be
overridden... and ignoring it can break libraries like RPyC which
define a custom dir() function just for this purpose.

This issue has already been run in to by RPyC (an Python RPC lib). The
main developr went ahead and suggested adding a __dir__ method which
will return a list of attributes, and IIRC he has already implemented
a patch for this, and it will likely enter Python2.6.

Until then, I guess we're going to have to rely on dir for this.



From: "Josiah Carlson" &lt;josiah.carl...@gmail.com&gt;
Date: Wed, 6 Jun 2007 12:42:01 -0700

For reference, PyPE auto-parses source code in the background, generating
(among other things) a function/class/method hierarchy.  Its autocomplete
generally sticks to global functions and keywords, but when doing
self.method lookups, it checks the current source code line, looks up in its
index of classes/methods, and trims the results based on known methods in
the current class in the current source file.

It certainly isn't complete (it should try to check base classes of the
class in the same file, it could certainly pay attention to names assigned
in the current scope, the global scope, imports, types of objects as per
WingIDE's assert isinstance(obj, type), etc.), but it also makes the
computation fairly straightforward, fast, and only in reference to the
current document.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 22:52:08 +0300

&gt; Tal, how does IDLE's autocompletion works?

Much like Stani said, since Python is interpreted, collection of
possible completions splits into two methods:
1) source code analysis
2) dynamic introspection

Of course, we could do either or a combination of both.

IDLE just uses introspection: since IDLE always has a python shell
running, it just completes according to the shell's state (plus
built-in keywords and modules). This is a very simple method,
obviously lacking. It does allow the user some control of the
completion, though - just import whatever you want to be completable
in the shell. However, introspection is all that is needed in a Python
shell, which is the major reason this is the method used in IDLE.



From: Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
Date: Wed, 6 Jun 2007 23:59:32 +0200


&gt; How dependent/independent is this from the standard AST compiler or
&gt; PyPy? Is it more IDE friendly? Is it based on it or a total independent
&gt; implementation?

It is independent from PyPy.

The above web page says:

"""
Python Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.Python
Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.
"""

From: "Sylvain Thénault" &lt;thena...@gmail.com&gt;
Date: Wed, 13 Jun 2007 10:51:04 +0200

&gt; Please let me involve Sylvain in the discussion. As the main author of
&gt; pylint and astng, he will provide better answers.

well logilab-astng is basically a big monkey patching of the compiler
package from the stdlib, so you can't get an astng representation from a
module with syntax errors in. However inference and most others
navigation methods (which are basically the value added by astng) are
"syntax error resilient" : if a dependency module (direct or indirect)
contains a syntax error, you don't get any exception, though since some
information is missing you can miss some results you'ld get if the
faulting module were parseable.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 10:33:33 +0300

Since astng already does some inference (which we definitely want!)
and is based on the standard Python AST compiler, it sounds like our
#1 candidate. I think we should give the code a serious once-over and
see how well it fits our requirements, and if it can be adapted to
better handle errors. Any volunteers?

Also, has anyone used astng for completion, calltips, or something
similar? Or the standard AST compiler, for that matter?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 10:40:11 +0300

How does PyPE parse code? Home-rolled, standard AST compiler, something else?

It seems to me we should try to come up with an algorithm for parsing,
before getting to the code. All of the details you mentioned -
noticing assignments, using base-class methods, etc. - could be better
defined and organized this way. Perhaps we could brainstorm on this in
a wiki?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 11:38:40 +0300

Sorry for being away for such a long time. I hope we can get this
conversation rolling again, and get started with the actual work.

I'll try to sum up what has been said so far, and how I see things.

== Top Priorities ==
* Can we implement a parser based on the standard Python AST compiler
(or astng)? For example, can syntax errors be handled well?
* Is importing reasonable security-wise? If not, can it be made secure?

== General issues ==
* Do we aim for just completion, or also calltips? Perhaps also other
meta-data, e.g. place defined, source code, ... (see IPython's '??')
* Dependencies - do we want to allow C-extensions, or are we going for
a Python-only solution? (IDLE would only use such a Python-only tool.)
It seems that we want to pre-process most of the data in the
background, so I don't see why we would want to do this in C for
efficiency reasons.

== Completion sources ==
1) Importing "external" modules
2) Importing/Parsing "local" modules
3) Parsing the current file
4) Using objects/modules from the shell (e.g. IDLE has both editor
windows and a Python shell)

== Importing ==
* Stani mentioned that importing is problematic from a security point
of view. What are the security issues? Are they really an issue for an
IDE? If so, perhaps we could overcome this by importing in some kind
of "sandbox"?
* What are the pros and cons of Importing vs. Parsing?
* If importing is always preferable to parsing unless there's a syntax
error, perhaps try to import and parse on failure?

== Parsing ==
* This is going to be the most complex method - I think we should have
a general idea of how this should work before starting an
implementation. I suggest hashing ideas out on a wiki, since there a
lot of details to consider.
* Can a parser based on the standard AST compiler (or astng) work? Is
there a way to deal with errors? (HIGH PRIORITY!)
* There are other existing, open-source implementations out there -
WingIDE, PyPE have been mentioned. Any others? We should collect these
so we can use the code for learning, and perhaps direct use (if
possible license-wise).

== Shell ==
This is relatively straight-forward - just use dir(). This should be
optional, for use by IDEs which have a shell (support multiple
shells?).

Some known issues from IDLE and PyCrust:
* Handle object proxies such as RPC proxies (e.g. RPyC)
* Handle ZODB "ghost" objects
* Watch out for circular references
* Watch out for objects with special __getattr__/__hasattr__
implementations (for example xmlrpc, soap)

== Persistence ==
* Stani mentioned a 'database'. I feel Sqlite should be at most
optional, to reduce dependencies.
* Do we really want to have the data persistent (between IDE
sessiosns)? If so, we need to support simultaneous instances of the
IDE so they don't corrupt the data. Any other issues? (I have a
feeling this would better be left for later stages of development.)



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 12:22:59 +0300

One more note: We should distinguish between completion in an editor
and completion in a shell. The conversation up until now has focused
on editors, which is reasonable since that is the problematic scene. I
think a generic Python completion library should support completion in
both contexts, especially if it uses can use a shell's namespace for
completion in the editor.



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Tue, 31 Jul 2007 11:20:19 +0100

I have just implemented a completion mockup using Rope (which is a
refactoring library). It works quite nicely, and definitely worth a
look.

http://rope.sourceforge.net/

It even achieves this kind of completion:

class Banana(object):
    def do_something(self):
         return

def foo():
    return [Banana(), Banana()]

foo()[0].&lt;complete&gt; includes do_something

Which seems pretty impressive to me.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 20:12:50 +0300

Wow, Rope does look very impressive! A quick look at the code tells me
that a lot of work has been invested in it.

So we have one existing Python-only solution. We should evaluate it -
see what it can and can't do, and perhaps take a look at the overall
design.

I'm CC-ing Rope's developer, Ali. Hopefully Ali can help us quickly
understand Rope's code analysis capabilities.

Ali, could you elaborate a bit on what kinds of completion Rope can
do, and the methods it uses? We would especially like to know how your
static and dynamic inference work, what they can accomplish, and what
their limitations are.



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Tue, 31 Jul 2007 19:45:15 +0100

&gt; Ali, could you elaborate a bit on what kinds of completion Rope can
&gt; do, and the methods it uses? We would especially like to know how your
&gt; static and dynamic inference work, what they can accomplish, and what
&gt; their limitations are.

Well, I haven't really looked at the code. But I can tell you this:

from rope.ide.codeassist import PythonCodeAssist
from rope.base.project import Project
for compl in PythonCodeAssist(Project(package_root)).assist(buffer,
offset).completions:
    print compl

And that is as far as I really got. I expect to get a better look at
it later in the week though...


From: "Josiah Carlson" &lt;josiah.carl...@gmail.com&gt;
Date: Wed, 1 Aug 2007 00:26:14 -0700

&gt; How does PyPE parse code? Home-rolled, standard AST compiler, something else?

The compiler for syntactically correct Python, a line-based compiler
for broken Python.  TO generate a method list for self.methods, using
the current line number, I discover the enclosing class, check the
listing of methods for that class (generated by the compiler or
line-based parsers), and return a valid list for the specified prefix.
 It doesn't walk the inheritance tree, it doesn't do imports, etc.

&gt; It seems to me we should try to come up with an algorithm for parsing,
&gt; before getting to the code. All of the details you mentioned -
&gt; noticing assignments, using base-class methods, etc. - could be better
&gt; defined and organized this way. Perhaps we could brainstorm on this in
&gt; a wiki?

A wiki would be fine, the one for this mailing list would likely be
best (if it is still up and working).  Then again, Rope looks quite
nifty.  I may have to borrow some of that source ;)


Discussion subject changed to "Fwd: Python code completion module" by Tal Einat

From: Ali Gholami Rudi &lt;aligr...@gmail.com&gt;
Date: Aug 1, 2007 5:50 PM

First of all I should note that rope's main goal was being a
refactoring tool and a refactoring tool needs to know a lot about
python modules.  `rope.base` package provides information about python
modules.

Actually what ropeide provides as auto-completion is defined in
`rope.ide.codeassist` module.  This module almost does nothing but use
`rope.base`.  Since `rope.ide` package is not included in the rope
library (which has been separated from ropeide since 0.6m4) it lacks
good documentation and the API might not be easy to use (most of it is
written in the first months of rope's birth).

&gt; ..., could you elaborate a bit on what kinds of completion Rope can
&gt; do, ...

I don't know what to say here.  Well, actually it tries to use the
source code as much as possible and infer things from it.  So I can
say that it can complete any obvious thing that can be inferred by a
human.  Like this is the first parameter of a method and after dots
its attributes can appear or these modules are imported so their names
and contents are available or this is an instance of some known type
and we know its attributes and ... .  Try ropeide (it uses emacs-like
keybinding, C-/ for completion; see ~/.rope if you want to change
that); it completes common cases (and sometimes completes things you
don't expect it to!).

&gt; ..., and the methods it uses?

Rope analyzes python source code and AST.  Rope used to use the
`compiler` module till 0.5 and now it uses `_ast` module.

&gt; We would especially like to know how your
&gt; static and dynamic inference work, what they can accomplish

There are a few examples in docs/overview.txt.  Unit-test modules like
`ropetest.base.objectinfertest` and `advanced_oi_test` might help,
too.  Also have a look at `rope.base.oi.__init__` pydoc for an
overview of how they work; (I'm afraid it is a bit out of date and
carelessly written.)  The idea behind rope's object inference is to
guess what references (names in source-code) hold.  They collect
information about code when they can and use them later.

&gt;..., and what their limitations are.

Many things in rope are approximations that might be exact if some
conditions hold.  For instance rope might assume that every normal
reference in module scope holds only one kind of object.  Apart from
these assumptions both SOI and DOI have their own disadvantages; For
instance SOI fails when dynamic code is evaluated while DOI does not.
Or DOI is slower than SOI.  (Well, after recent enhancements to rope's
SOI I rarely use DOI).

I tried to answer as short as possible.  If there are questions on
specific parts of rope, I'll be happy to answer.

By the way, I tried to reply this mail to the group, but it seems that
your group requires subscription for posting, so I've sent it to you,
instead.
</t>
<t tx="ekr.20080115093848.18">See http://leoeditor.com/scripting.html#inserting-and-deleting-icons
</t>
<t tx="ekr.20080115093848.19">http://sourceforge.net/forum/message.php?msg_id=4712329
</t>
<t tx="ekr.20080115093848.23">http://sourceforge.net/forum/message.php?msg_id=4714779
</t>
<t tx="ekr.20080116071239">- Added support for @auto xml and @auto javascript.
  Use @data import_xml_tags setting to specify the xml tags that act as organizers.
  Javascript regexps that look like section references cause problems, but that can not be helped.
</t>
<t tx="ekr.20080126090039">Leo 4.4.6 final                           January 26, 2008

Leo 4.4.6 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.4.6 fixes several recently reported bugs, all minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.6:
----------------------------
- Fixes all known bugs.
- Added @auto importers for javascript and xml files.
- Added find-next-clone and toggle-sparse-move commands.

Links:
------
Leo:      http://leoeditor.com
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080203101507"></t>
<t tx="ekr.20080203101507.1">##########################
ILeo: Leo's IPython Bridge
##########################

.. contents::
    :depth: 2
</t>
<t tx="ekr.20080203101507.2">.. Links

.. _ipython:                http://ipython.scipy.org/
.. _IPython:                http://ipython.scipy.org/
.. _`IPython Notebook`:     http://projects.scipy.org/ipython/ipython/wiki/NoteBook
.. _extensionAPI:           http://ipython.scipy.org/moin/IpythonExtensionApi
.. _`The Ipython Extension API`: extensionAPI_
.. _`Scripting Leo with Python`:    tutorial-scripting.html

.. _`run Leo in a console window`:  installing.html#running-leo-from-a-console-window
.. _`console window`:               installing.html#running-leo-from-a-console-window

</t>
<t tx="ekr.20080212221711.1"></t>
<t tx="ekr.20080212221711.15">http://groups.google.com/group/leo-editor/browse_thread/thread/4fa4709969fc04d
</t>
<t tx="ekr.20080212221711.2"></t>
<t tx="ekr.20080212221711.26">When reading an @auto tree, createOutline now does the following:

1. When importing Python files, createOutline uses the encoding implied by
Python's # -*- coding line. This line must be the first line of the imported file.

2. Otherwise, createOutline scans the @auto node and its ancestors for Leo's @encoding directive.

3. If no such @encoding directive is found, createOutline uses the encoding specified by the setting: @string default_at_auto_file_encoding = utf-8

4. If this setting does not exist, the utf-8 encoding is used.
</t>
<t tx="ekr.20080212221711.32"></t>
<t tx="ekr.20080212221711.33"></t>
<t tx="ekr.20080212221711.34"></t>
<t tx="ekr.20080212221711.35"></t>
<t tx="ekr.20080212221711.4"></t>
<t tx="ekr.20080212221711.47">If the @bool open_with_save_on_update setting is True,
Leo will automatically save the outline whenever an external editor
changes the outline.
</t>
<t tx="ekr.20080212221734">Leo 4.4.7 beta 1                           February 12, 2008

Leo 4.4.7 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features the ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo's main discussion is now at: http://groups.google.com/group/leo-editor

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.7:
----------------------------
- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Improved handling of unicode encodings in @auto files.
- All import commands now support @path directives in ancestor nodes.
- Fixed several minor bugs.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080213094948.1">There appear to be problems with Python's subprocess module on Ubuntu.
</t>
<t tx="ekr.20080213094948.4">The version of PIL that ships with Ubuntu (and presumably Debian and maybe some
other distributions) no longer includes the ImageTk module. ImageTk is now
located in the python- imaging-tk package.
</t>
<t tx="ekr.20080218153931">Leo 4.4.7 final                           February 18, 2008

Leo 4.4.7 final is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.7:
----------------------------
- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Improved handling of unicode encodings in @auto files.
- All import commands now support @path directives in ancestor nodes.
- Fixed several minor bugs.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://leo.tigris.org/source/browse/leo/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080218153931.1"></t>
<t tx="ekr.20080218153931.10"></t>
<t tx="ekr.20080218153931.11">If the @bool open_with_save_on_update setting is True,
Leo will automatically save the outline whenever an external editor
changes the outline.
</t>
<t tx="ekr.20080218153931.12">When reading an @auto tree, createOutline now does the following:

1. When importing Python files, createOutline uses the encoding implied by
Python's # -*- coding line. This line must be the first line of the imported file.

2. Otherwise, createOutline scans the @auto node and its ancestors for Leo's @encoding directive.

3. If no such @encoding directive is found, createOutline uses the encoding specified by the setting: @string default_at_auto_file_encoding = utf-8

4. If this setting does not exist, the utf-8 encoding is used.
</t>
<t tx="ekr.20080218153931.2"></t>
<t tx="ekr.20080218153931.3"></t>
<t tx="ekr.20080218153931.4">http://groups.google.com/group/leo-editor/browse_thread/thread/4fa4709969fc04d
</t>
<t tx="ekr.20080218153931.5"></t>
<t tx="ekr.20080218153931.6">There appear to be problems with Python's subprocess module on Ubuntu.
</t>
<t tx="ekr.20080218153931.7">The version of PIL that ships with Ubuntu (and presumably Debian and maybe some
other distributions) no longer includes the ImageTk module. ImageTk is now
located in the python- imaging-tk package.
</t>
<t tx="ekr.20080218153931.8"></t>
<t tx="ekr.20080218153931.9"></t>
<t tx="ekr.20080218154129"></t>
<t tx="ekr.20080218154129.1"></t>
<t tx="ekr.20080304112802.1">http://mail.google.com/mail/#inbox/1184b70ea10f5aa3

Leo now contains minimal support for arguments to minibuffer commands.

- k.simulateCommand now puts arguments following the command name in k.givenArgs.
  Whitespace separates arguments.

- k.simulateCommand knows nothing about what the arguments mean. That is up to
  the individual commands.

- At present, only the following minibuffer commands now support k.givenArgs:
  open-outline, open-outline-by-name, save-file, save-file-as,
  save-file-as-unzipped and save-file-as-zipped.

  These commands use ''.join(k.givenArgs) to get the file name,
  which may cause problems if the file name contains whitespace.

- At present, the repeat-complex-command command does not support arguments.
</t>
<t tx="ekr.20080304112802.25"></t>
<t tx="ekr.20080304112808">Leo 4.4.8 beta 1                           March 5, 2008

Leo 4.4.8 beta 1 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr.
  See the Bzr link below.
- Leo's discussion is now hosted by Google Groups:
  See the Forum link below.
- The first, third, fifth etc. arguments to g.es and g.es_print
  can now be translated using Python's gettext.gettext function.
- Completed ILeo: a bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Added support for arguments to minibuffer commands.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080310093038.4">.. _gettext: http://docs.python.org/lib/module-gettext.html

It is easy to translate Leo's menu strings: simply create an @menus tree in
leoSettings.leo or myLeoSettings.leo that contains the translated menu names.

**New in Leo 4.4.8**:
Leo now contains support for translating messages sent to Leo's log:

- Rather than using an '_' function to denote strings to be translated, Leo's
  g.es and g.es_print functions translate "odd" (first, third, fifth) arguments,
  leaving "even" arguments untranslated. Keyword arguments, color, newline, etc.
  are never translated.

- All calls to g.es and g.es_print in Leo's core follow this convention.

- g.translateString does the actual translation using Python's `gettext`_ module.

- You can use the script in the node "@button print g.es stats" in scripts.leo
  to create catalogs of all scripts that need to be translated. Such catalogs
  are used by Python's gettext module. (This script was also used to check that
  the proper arguments to g.es and g.es_print were translated.)
</t>
<t tx="ekr.20080311060457.1">Leo 4.4.8 beta 2                           March 14, 2008

Leo 4.4.8 beta 2 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr.
  See the Bzr link below.
- Leo's discussion is now hosted by Google Groups:
  See the Forum link below.
- The first, third, fifth etc. arguments to g.es and g.es_print
  can now be translated using Python's gettext.gettext function.
- Completed ILeo: a bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Added support for arguments to minibuffer commands.
- @menu trees can now refer to commands created by
  @command and @button nodes
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080311060457.125"></t>
<t tx="ekr.20080311060457.128"></t>
<t tx="ekr.20080311060457.188">http://sourceforge.net/forum/message.php?msg_id=4677335
</t>
<t tx="ekr.20080311060457.198">This allows @menu items to refer to commands created by @button.
</t>
<t tx="ekr.20080311060457.2"></t>
<t tx="ekr.20080311060457.210"></t>
<t tx="ekr.20080311060457.211">http://mail.google.com/mail/#inbox/1184b70ea10f5aa3

Leo now contains minimal support for arguments to minibuffer commands.

- k.simulateCommand now puts arguments following the command name in k.givenArgs.
  Whitespace separates arguments.

- k.simulateCommand knows nothing about what the arguments mean. That is up to
  the individual commands.

- At present, only the following minibuffer commands now support k.givenArgs:
  open-outline, open-outline-by-name, save-file, save-file-as,
  save-file-as-unzipped and save-file-as-zipped.

  These commands use ''.join(k.givenArgs) to get the file name,
  which may cause problems if the file name contains whitespace.

- At present, the repeat-complex-command command does not support arguments.
</t>
<t tx="ekr.20080311060457.212"></t>
<t tx="ekr.20080311060457.213">.. _gettext: http://docs.python.org/lib/module-gettext.html

It is easy to translate Leo's menu strings: simply create an @menus tree in
leoSettings.leo or myLeoSettings.leo that contains the translated menu names.

**New in Leo 4.4.8**:
Leo now contains support for translating messages sent to Leo's log:

- Rather than using an '_' function to denote strings to be translated, Leo's
  g.es and g.es_print functions translate "odd" (first, third, fifth) arguments,
  leaving "even" arguments untranslated. Keyword arguments, color, newline, etc.
  are never translated.

- All calls to g.es and g.es_print in Leo's core follow this convention.

- g.translateString does the actual translation using Python's `gettext`_ module.

- You can use the script in the node "@button print g.es stats" in scripts.leo
  to create catalogs of all scripts that need to be translated. Such catalogs
  are used by Python's gettext module. (This script was also used to check that
  the proper arguments to g.es and g.es_print were translated.)
</t>
<t tx="ekr.20080311060457.214"></t>
<t tx="ekr.20080311060457.215"></t>
<t tx="ekr.20080311060457.216"></t>
<t tx="ekr.20080311060457.28"></t>
<t tx="ekr.20080311060457.3">@nocolor

Eureka! I have just discovered an elegant solution to this problem!

The Aha is this:  we can create a "base" timestamp just *once*, when
the commander (i.e. the NodeIndices class) is created.  Thereafter,
code that writes gnx's simply calls NodeIndices.getIndex if the node
doesn't already have an index (or if indices are being reassigned in a
copied tree).

In other words, there is no need to be picky about timestamps, the
base timestamp will do, so there is no need to assign indices before
writing nodes!

I didn't see this before because computing timestamps is quite time
consuming.  In fact, we can't do so "on the fly".  That being so, the
old code computed the "new" timestamp once in assignFileIndices, which
lead me away from getting gnx's as needed.  But if there is only *one*
timestamp everything becomes easy.  There is no need to "batch" the
computation of gnx's.  In other words, timestamps don't have to be up-
to-the-second accurate.  They simply guarantee that two nodes (in a
particular outline) created by the *same* person can't collide.

This is the way it is written in "The Book". All calls to
assignFileIndices disappear!  All the code I wrote this morning that
remembers whether indices have been assigned disappears.  I'll keep a
do-nothing assignFileIndices around for compatibility with old
scripts.

This is *so* important.  It eliminates forever a source of serious
file write problems.  Furthermore, NodeIndices.getIndex becomes
substantially simpler. Even though the code was short, it implied some
very tricky assumptions.  Every time I read it I had to recreate why
it worked.  Those mental gymnastics should disappear.

A great day for Leo. 

@color
</t>
<t tx="ekr.20080311060457.38"># This should have been done long ago.
</t>
<t tx="ekr.20080311135649.2">@nocolor

On Tue, Mar 11, 2008 at 7:03 AM, Kent Tenney &lt;kten...@gmail.com&gt; wrote:

&gt; On 3/11/08, derwisch &lt;johannes.hues...@med.uni-heidelberg.de&gt; wrote:

&gt; &gt;  On 11 Mrz., 08:03, "Ville M. Vainio" &lt;vivai...@gmail.com&gt; wrote:
&gt; &gt;  &gt; It could also be argued that

&gt; &gt;  &gt; - Referring to previous cloned vnodes explicitly in XML does not
&gt; &gt;  &gt; necessarily obscure DAG - it follows the "do not repeat yourself"
&gt; rule
&gt; &gt;  &gt; - It will speed up reading
&gt; &gt;  &gt; - Wouldn't it be better for preserving the integrity of the XML file?

&gt; &gt; I would lean towards this line of argumentation. A couple of days I
&gt; &gt;  had my Leo extension destroy the Leo ODM file (which was still valid
&gt; &gt;  according to Leo, but unreadable wrt the extension and broken uAs). I
&gt; &gt;  resorted to editing the Leo file with Emacs, and was quite surprised
&gt; &gt;  to see that the headStrings were attributes of vnodes.

&gt; I'll chime in with my pet peeve re: .leo file structure::

&gt; I think that putting the headstrings on vnodes and body strings on tnodes
&gt; obscures the informational content of the .leo file, and makes the .leo
&gt; file
&gt; format less attractive as a generalized solution to the problem of how to
&gt; manage head/body pairs which live in a hierarchal structure.

&gt; Thanks,
&gt; Kent

&gt; &gt;  I think that
&gt; &gt;  editing the file might have been a bit easier if there had been no
&gt; &gt;  such redundancy. But this is more a feeling rather than a qualified
&gt; &gt;  opinion.

Thanks for all these comments.  I'll respond to them all here.

Clearly, we should be using a standard xml parser to read .leo files.

My present thoughts:

- I personally like human-readable headlines in &lt;v&gt; elements.

- I am open to putting headlines in &lt;t&gt; elements, as an indication that
tnodes do indeed contain headlines and body text.

- I am willing to consider only writing shared subtrees once.

Oh! (An Aha)  All these are preferences.  We can allow any combination of
these provided that headlines appear somewhere.

So that's clean.  This will happen in Leo 4.5. 
</t>
<t tx="ekr.20080314081157.1">- Added show-marks-dialog and show-recent-sections-dialog commands.
- Select an item initially.
- Added bindings for up and down arrows.
</t>
<t tx="ekr.20080314081157.124">- Better support for unicode in \@auto trees.

- All import commands now honor \@path

- Leo now supports arguments to minibuffer commands.

- Leo can now translate messages sent to Leo's log. Rather than using an '_'
  function to denote strings to be translated, Leo's g.es and g.es_print
  functions translate "odd" (first, third, fifth) arguments, leaving "even"
  arguments untranslated. Keyword arguments, color, newline, etc. are never
  translated. g.translateString does the actual translation using
  `Python's gettext`_ module.

- \@menu items may not refer to commands created by @button and @command nodes.
</t>
<t tx="ekr.20080314081157.125">- Added support for @commands trees in leoSettings files.

- Added support for @bool open_with_save_on_update setting. If True, Leo will
  automatically save the outline whenever an external editor changes the
  outline.
</t>
<t tx="ekr.20080314081157.127"></t>
<t tx="ekr.20080314081157.128">- The ipython plugin creates a simple, powerful, effective bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html

- Improved marks/recent buttons plugin.
</t>
<t tx="ekr.20080314081157.2"></t>
<t tx="ekr.20080315115427.568">This series of releases featured **hundreds** of improvements.  The highlights were truly significant:

- Added the leoBridge module. See `Embedding Leo with the leoBridge Module`_.

- Added support for @enabled-plugins and @openwith (formerly @open-with) nodes in settings files.

- Added support for ZODB. See `Using ZODB with Leo`_.

- Added leoPymacs module. See `Leo and Emacs`_.

- Added perfect import of external files with @auto nodes.

- Used the sax parser to .leo files. This allows the format of .leo files to be
  expanded easily.

- Added support for myLeoSettings.leo.

- Supported multiple editors in body pane.

- Added the jEdit_colorizer plugin. See `Controlling Syntax Coloring`_.

- Many other new plugins.

For a complete list, see the `What's New`_ chapter.
</t>
<t tx="ekr.20080328074117.12">http://groups.google.com/group/leo-editor/browse_thread/thread/62fe73901d14f6c3
</t>
<t tx="ekr.20080328074117.135">The new setting is @string target_language, not @language default_target_language.
</t>
<t tx="ekr.20080328074117.2"></t>
<t tx="ekr.20080328074117.215">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/6a5087a59d6d23

- Changed menu1 to menu2 in several plugins.
- Changed menu2 to menu-update.
- Moved after-create-leo-frame to after menu2.
</t>
<t tx="ekr.20080328074117.216"></t>
<t tx="ekr.20080328074117.217">This hugely speeds up spelling when there are lots of misspelled words.
</t>
<t tx="ekr.20080328074117.220"></t>
<t tx="ekr.20080328074117.262">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/62fe73901d14f6c3

And, while you're looking at the editor code :-) - in linux when you paste in
text to a body editor with a middle mouse button click, it's not stored unless
you follow that with a key stroke or some other action in the body editor. If
you instead middle button paste to the editor and then click on another node in
the tree, the text's forgotten.

To do--&gt;@thin ../doc/leoToDoLater.txt--&gt;Can't or won't--&gt;Known Bugs: can't be fixed or can wait--&gt;Bug: can't be fixed--&gt;Cut/paste bug on X windows (waiting for help)

@color
</t>
<t tx="ekr.20080328074117.297"></t>
<t tx="ekr.20080328074117.3"></t>
<t tx="ekr.20080328074117.30">http://groups.google.com/group/leo-editor/browse_thread/thread/f802b083dee96312
</t>
<t tx="ekr.20080328074117.340">Leo 4.4.8 beta 3                           March 28, 2008

Leo 4.4.8 beta 3 is available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080328074117.4">This fixes a bug that can corrupt .leo files.
</t>
<t tx="ekr.20080328074117.76">http://mail.google.com/mail/#inbox/11899019a43f74ca

When you have two editors open on the same node most actions show up in both
editors, however, if you do an undo the change only show up in the selected
editor. (The change shows up in the other editor when you select it).
</t>
<t tx="ekr.20080328074117.77">http://groups.google.com/group/leo-editor/browse_thread/thread/71822f48720e71bc/6e0fd1c72fa39817#6e0fd1c72fa39817
</t>
<t tx="ekr.20080403065258.10">Leo 4.4.8 rc1                        April 3, 2008

Leo 4.4.8 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080403065258.6">http://groups.google.com/group/leo-editor/browse_thread/thread/ed5d82429e1ec821

The following sequence of commands caused problems:

add-editor
add-editor
delete-editor
delete-editor
add-editor
</t>
<t tx="ekr.20080405074410.38"></t>
<t tx="ekr.20080405074410.4">Leo 4.4.8 final                        April 6, 2008

Leo 4.4.8 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

This version features a new ipython plugin that provides a two-way bridge
between Leo and IPython.  See http://leoeditor.com/IPythonBridge.html

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.4.8:
----------------------------
- Leo's source code is now managed by bzr: see link below.
- Leo's discussion is now hosted by Google Groups: see link below.
- Arguments to g.es and g.es_print can be translated using gettext.
- Completed ILeo: a bridge between IPython and Leo.
  See http://leoeditor.com/IPythonBridge.html
- Minibuffer commands may have arguments.
- @menu trees can now refer to commands created by
  @command and @button nodes.
- Added support for common @commands nodes in settings files.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080405074410.7"></t>
<t tx="ekr.20080405074410.9"></t>
<t tx="ekr.20080411111008.1">Leo ignores any subtree of an @settings tree whose headline starts with @ignore.

You can use several other kinds of nodes to cause Leo to ignore parts of  an @settings tree:

- @if *expression*

  A node whose headline starts with @if *expression* acts like an organizer node if the expression evaluates to True,    
  otherwise acts like an @ignore node.
  If the expression is empty the body text should contain a script that will be evaluated (in an empty context).

- @ifplatform *platform-name*

  Same as @if sys.platform == "platform-name": except that it isn't necessary to import sys.

- @ifhostname *hostA,!hostB*

  Evaluates to True if and only if: h=g.computeMachineName(); h==hostA and h!=hostB.
  The "!" version allows matching to every machine name except the given one
  to allow differing settings on only a few machines.
</t>
<t tx="ekr.20080412124815.1"></t>
<t tx="ekr.20080429051644.1"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
</t>
<t tx="ekr.20080527063511.1">I had a need to figure out why a part of some python code I had written
was taking too long.

I pulled the code into Leo and the relevant part of the outline looked
something like this::

    + Main module
    -- Generate cryptographic key
    -- Hashing algorithm

etc. So I cloned just the segment I wanted to profile and pulled it under a new
section::

    + Main module
    -- [clone] Generate cryptographic key
    -- Hashing algorithm

    + Profiling Experiment
    -- [clone] Generate cryptographic key

And in the body of the "Profiling experiment", I used this code::

    code_under_here = """
    @others
    """

    from timeit import Timer
    t = Timer("print my_key_generator()", code_under_here)
    print t.timeit(number = 10)

And then I hit Control-B to execute the Profiling Experiment body. This
let me make adjustments to the code in the clone body and keep hitting
Control-B to execute the code with the timeit module to see immediately
if what I had done was making a difference.

The great thing about this was that I just used the Leo @others construct
to create a wrapper around the code and did not need to litter my code
with debug or profiling statements.---Kayvan
</t>
<t tx="ekr.20080603124653.1">Many users will want to track the development version of Leo, in order to stay
on top of the latest features and bug fixes. Running the development version is
quite safe and easy, and it's also a requirement if you want to contribute to
Leo.

1. First, you need to get git from http://git-scm.com/.

2. Get Leo from GitHub by doing::

        git clone https://github.com/leo-editor/leo-editor (http access)
    
   or::
   
        git clone git@github.com:leo-editor/leo-editor.git (ssh access)

And that's it! You can run the launchLeo script (in the top-level branch directory) directly.
When you want to refresh the code with latest modifications from GitHub, 'run git pull'.

..  If you make modifications to Leo (with the interest in sharing them with the Leo
..  community), you can check them in to your local branch by doing 'bzr checkin'.
..  Now, to actually request your changes to be merged to Leo trunk, you need a
..  Launchpad account with RSA keys in place. There is showmedo video about how to
..  accomplish this on Windows using puttygen and pageant at
..  http://showmedo.com/videos/video?name=1510070&amp;fromSeriesID=151.

..  After your Launchpad account is set up, go to
..  https://launchpad.net/leo-editor, choose Code tab -&gt; Register Branch, select
..  Branch type "Hosted" and fill in descriptive details about the branch. After
..  that, go to the branch home page from Code tab again, and copy-paste the push
..  command line to terminal. For example, for branch::

 ..  https://code.launchpad.net/~leo-editor-team/leo-editor/my_branch

..  The push command is::

 ..  bzr push bzr+ssh://my_name@bazaar.launchpad.net/~leo-editor-team/leo-editor/my_branch

..  You may wish to add --remember command line option to bzr push, to direct all
..  future pushes to that location. Then, you only need to execute 'bzr push'.

..  After your branch is pushed, you can email the Leo mailing list and request it
..  to be reviewed and merged to trunk.

..  -- Ville M. Vainio - vivainio.googlepages.com
</t>
<t tx="ekr.20080616110054.2">The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.  

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
</t>
<t tx="ekr.20080624093059.1">Leo 4.5 beta 1                      June 28, 2008

Leo 4.5 beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------
- A major revision of Leo's node structures, compatible with so-called unified nodes.
- A major revision of Leo's key-handling code.  Most per-pane key bindings have been eliminated.
- A major revision of Leo's outline drawing and focus handling code.
  Calls to c.beginUpdate and c.endUpdate simply request later redrawing in c.outerUpdate.
- The beginning of usable vim-like bindings.  More support is coming.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080624093059.10"></t>
<t tx="ekr.20080624093059.11">Leo's running, so I create a new outline with File-&gt;New

Then I save as in a location where foo.py exists.

The I create a node '@auto foo.py'

Then I use File-&gt;Read/Write-&gt;Read @auto (with that node selected)

Leo says it can't read it.

I close the leo file, re-open in from the recent files menu of the
outline that spawned it, and the @auto file is read no problems.
</t>
<t tx="ekr.20080624093059.12">http://groups.google.com/group/leo-editor/browse_thread/thread/c6c4faf6fdead672
</t>
<t tx="ekr.20080624093059.14">findAll now just creates undo info for clone-find-all for one inserted node.
</t>
<t tx="ekr.20080624093059.15"></t>
<t tx="ekr.20080624093059.16"></t>
<t tx="ekr.20080624093059.17">exception executing command
Traceback (most recent call last):
 File "C:\_Proj\Leo\key-handling\leo\src\leoCommands.py", line 298, in doCommand
   val = command(event)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 2946, in insertNewLine
   self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 3104, in insertNewlineHelper
   w.setInsertPoint(i+1)
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
truncating headline to one line
</t>
<t tx="ekr.20080624093059.18"></t>
<t tx="ekr.20080624093059.19"></t>
<t tx="ekr.20080624093059.2"></t>
<t tx="ekr.20080624093059.20"></t>
<t tx="ekr.20080624093059.21"></t>
<t tx="ekr.20080624093059.22">http://groups.google.com/group/leo-editor/browse_thread/thread/35a8ea2024036623s
</t>
<t tx="ekr.20080624093059.23">http://sourceforge.net/forum/forum.php?thread_id=1858451&amp;forum_id=10228
</t>
<t tx="ekr.20080624093059.24">http://groups.google.com/group/leo-editor/browse_thread/thread/d2a9aeac0d0082f6
</t>
<t tx="ekr.20080624093059.25"></t>
<t tx="ekr.20080624093059.26"></t>
<t tx="ekr.20080624093059.27">Changed c.outerUpdate and added c.bind and c.bind2.
</t>
<t tx="ekr.20080624093059.28"></t>
<t tx="ekr.20080624093059.29">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 311, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoEditCommands.py", line 4781, in selectAllText
    return w.selectAllText()
AttributeError: Canvas instance has no attribute 'selectAllText'
</t>
<t tx="ekr.20080624093059.3"></t>
<t tx="ekr.20080624093059.30"></t>
<t tx="ekr.20080624093059.31">http://groups.google.com/group/leo-editor/browse_thread/thread/8edc4e7b809189cf
</t>
<t tx="ekr.20080624093059.32"></t>
<t tx="ekr.20080624093059.33"></t>
<t tx="ekr.20080624093059.34"></t>
<t tx="ekr.20080624093059.35">- Made t arg optional in vnode ctor.

- Removed the t arg from insertAsX.  Affects these plugins:

wrote:     base64Packager.py
wrote:     macros.py
wrote:     table.py
wrote:     templates.py
wrote:     xsltWithNodes.py

Search for tnode.
</t>
<t tx="ekr.20080624093059.36">Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.
</t>
<t tx="ekr.20080624093059.37">Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. 
</t>
<t tx="ekr.20080624093059.38">This allows substantially simpler key bindings. Indeed, most per-pane bindings
have been eliminate.
</t>
<t tx="ekr.20080624093059.39"></t>
<t tx="ekr.20080624093059.4">On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob &lt;bhossley@ieee.org&gt; wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
</t>
<t tx="ekr.20080624093059.40"># Added ')' at end.
</t>
<t tx="ekr.20080624093059.41"></t>
<t tx="ekr.20080624093059.42">This is necessary to simulate operation as a package.
</t>
<t tx="ekr.20080624093059.43">This code appears to have been reverted in such a way that it never got pushed to launchpad.
</t>
<t tx="ekr.20080624093059.44">This is a Python 'debugger' that computes a call graph.

To trace a function and its callers, put the following at the function's start::

    g.startTracer()
</t>
<t tx="ekr.20080624093059.45"></t>
<t tx="ekr.20080624093059.46">This determines whether cleo colors @ignore headlines. The default is True.
</t>
<t tx="ekr.20080624093059.47">This affect the following commands:

open, save, save-as, save-to, read-outline-only, read-file-into-node, write-file-from-node and all the import/export commands.
</t>
<t tx="ekr.20080624093059.48">Headline pane:

- Prevented "--&gt; exit-named-modes" from switching focus to the Body pane.
    Removed 'c.frame.log.deleteTab('Mode') from endMode

Body pane:

- Enabled search for 'space' character in text
    Removed 'if ch.isspace(): return' in zapToCharacter:

- Eliminated delete-word from removing trailing white space
    Removed 'self.killWs(event)' in killWord and backwardKillWord

- Put zapped text to clipboard
    Added 'g.app.gui.replaceClipboardWith(s[ins:i])' after 'sel.addToKillBuffer(s[ins:i])' in zapToCharacter

@nocolor
</t>
<t tx="ekr.20080624093059.49">Leo Configuration:
    | The following configuration was used for all testing:
        @strings  top_level_unbound_key_action = command
        @bool stayInTreeAfterEditHeadline = True
        @bool stayInTreeAfterSelect = True
        @bool outline_pane_has_initial_focus = True

Leo's Panes:
    | A "pane" is a area of the screen containing a user interface
    | dedicated to supporting a common set of tasks.  Vi key mappings are
    | associated with the Outline pane, the Body pane, or to the Leo
    | program.  See the no pane (see "General Commands" below). (Outline
    | pane, Body pane)

Leo's Command/Insert States:
    Command state - Denoted by a blue background color (Outline,Body pane)
        | Keys are mapped to commands.
    Insert state - Denoted by a red background color (Outline,Body pane)
        | Keys pressed are inserted into the text.
    Grayed state - Denoted by a gray background color (Outline pane)
        | Keys pressed will cause the next node with a headline starting
        | with that key to be selected.  This "select node by first
        | character" feature is built into Leo. It is not part of the vi
        | support.
        | 
        | This state is intentionally avoided in the vi based outline key
        | mappings. If in the "Grayed" state, enter Ctrl-i to switch to the
        | "Command" state.  The "Grayed" state can be entered from the
        | outline's "Command" state by pressing the Ctrl-] key.

Leo's modes:
| Most vi commands are implemented using Leo's "mode" functionality.
| Modes beginning with "vi-" denote a vi command for the body pane.
| Modes beginning with "tree-" denote a vi-like command for the outline.
| Modes beginning with "body-" denote outline commands that can be called
| from the body pane (and return focus back to the body pane)
| 
| Modes are used both for managing multi-key vi commands and for defining
| macros.

    Multi-key command modes:
    | Vi has many commands that require multiple keys to invoke.  Each key
    | accept the last in the command are assigned to a mode that, when
    | executed, maps the subsequent allowed keys in the command sequence.
    | The last key in the sequence is mapped directly to a Leo command or
    | to a "Macro" mode (see below). Any modes mapped to a key by another
    | mode are located in a child node of the mode node doing the mapping.
    | 
    | Example:
    |     dtw = Delete To the 'W' character (note the capital letters)
    |   The 'd' key is mapped to vi-delete-object
    |   vi-delete-object maps the 't' key to vi-delete-to-char
    |   vi-delete-to-char contains Leo commands to perform the vi command.

    Macros modes:
    | Most vi commands do not have an equivalent Leo command.  Instead, a
    | series of Leo commands must be issued to emulate the vi command.
    | The Leo commands needed to emulate a vi command are placed in a
    | single @mode node.

Code limitations:
    Current character:
    | Vi implementation normally use two different "current character"
    | designators depending on the current state.

        Insert state:
        | In the Insert state, a vertical bar is placed between two
        | characters to indicate where the next key will be inserted.
        | Leo's cursor is of this type.

        Command state: 
        | In the Command state, vi expects that the cursor is highlighting
        | a current character and provides commands to enter the insert
        | state or paste text either before or after that current
        | character.  Leo's vi emulation currently does not support a
        | "current character" cursor. As a result, inserting and pasting
        | before or after is replaced by inserting or pasting "at" the
        | current cursor location.  For example, the 'i' and 'a' command
        | are both mapped to enter the insert state at the current cursor
        | location.

    Conditional code execution:
    | No conditional command invocation exits.  Instead, conditional
    | branching is replace by setup commands that insure that, regardless
    | of current state, the command performs correctly.  For example,
    | Beginning-of-line command will go to previous line if called when
    | cursor is at beginning of line.  Vi requires that '|' always goes to
    | beginning of current line.  Problme is solved by issueing
    | forward-char command to insure cursor is moved off of the beginning
    | of the line before beginning-of-line command is issued.

    Commands requesting user input:
    | Commands getting user input must be the last command within the
    | mode.  See "Commands getting user input" in Problems section below.

    Edit headings using modes:
    | Commands modifying or selecting headline text do not work correctly
    | within a mode.  See "Editing headlines within modes" in Problems
    | section below.  This eliminates accurate implementation of vi's
    | delete/change/substitute/yank object commands.  Instead, the
    | commands are modified to only select text.
</t>
<t tx="ekr.20080624093059.5"></t>
<t tx="ekr.20080624093059.50">Binding numeric keys:
| Mapping a number to a command or mode prevents the number from being
| entered as text while in the insert state.

Binding '?' key:
| No response when key pressed.

Binding 'bksp' key:
| Binding 'bksp' key to back-char to move back a character in command mode
| prevents 'bksp' from deleting characters in text edit mode.

Commands getting user input:
| Commands requesting user input must be the last command executed.  These
| commands include: find-character and zap-to-character.

Editing headlines within modes:
| Text editing commands do not work within modes assigned to outline key
| mappings.

Undo command:
| The 'undo' command sometimes does not work when returning to a node's
| command mode.  Moving to another node fixes the problem.(i.e. delete-char, set-insert-state, ...)

Matching bracket command:
| Performs bracket matching on Body text when in node's headline command
| state.

Word definition:
| "Word" related commands determine boundries of a word differently.

Toggle case:
| Leo provides support for switching to upper or lower case but no method |
| exists to toggle between cases.

Find settings
| Leo commands only allow toggling of search settings.  If specific "set"
| and "clear" search setting commands were available then searches from the
| body pane could be restricted to the body pane and searches from the
| outline could be restricted to the outline.
Forward and backward sentences:
| Leo's forwardSentenceHelper and backSentenceHelper functions do not stop
| at empty lines nor do they skip over periods within words nor do they stop
| at sentences ending in non-periods nor do they stop at the end or
| beginning of the buffer.

Focus to Body pane:
| Leo functions exist which unconditionally set focus to the body pane
| regardless of the active pane.
    deleteTab() function:
        | Issuing "--&gt; exit-named-mode" calls "endMode" function which calls
        | "c.frame.log.deleteTab('Mode')" function which sets the focus to the
        | body pane.  

Displaying mode help:
| The "--&gt; mode-help" command displays all mapped keys using a capitol
| letter regardless of the actual binding.
    Recommendations:
    | To better support narrow tab cards, display the mode's label without
    | the "enter-" and "-mode" text and place key label before mode label.
    | Results in change from:
    |                enter-vi-delete-line-mode D
    |    enter-vi-delete-to-begin-of-word-mode B 
    | to:
    |    D : vi-delete-line
    |    B : vi-delete-to-begin-of-word
</t>
<t tx="ekr.20080624093059.51">Yank vs. Yank
| A vi "yank" operation copies the selected text TO the clipboard.
| A Leo "yank" operation inserts text FROM the clipboard.

copy-text in modes:
| Leo's copy-text does not work within a mode.  As a result, all "copy to
| clipboard" capability is being implemented using kill-&lt;object&gt; command
| followed by a "yank" command.

paste-text in modes:
| paste-text in modes does not work.  Use Leo's "yank" instead.

delete-node does not copy node to clipboard:
| Issue copy-node command followed by delete-node
</t>
<t tx="ekr.20080624093059.52"></t>
<t tx="ekr.20080624093059.53">These are now treated much like empty @auto nodes
</t>
<t tx="ekr.20080624093059.6">http://groups.google.com/group/leo-editor/browse_thread/thread/294866696257802e
</t>
<t tx="ekr.20080624093059.7">Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.
</t>
<t tx="ekr.20080624093059.8">find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-character
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.
</t>
<t tx="ekr.20080624093059.9">http://groups.google.com/group/leo-editor/browse_thread/thread/b068e88a577a0547
</t>
<t tx="ekr.20080626081829.2">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/eb718b4c6d478ac0

I'm just getting started learning how to use Leo. Now, I'd like to use
it for some of my projects, but there's no chance that I can convert
everyone at work to using it, so putting sentinel-filled files in our
repository is out of the question. At the same time, my code looks
awfully bare without sentinels because the documentation ends up in
the section names, not the comments!

So, I was wondering if there's a convenient way to pull the section
names into a comment at the start of each section?

===============

Interesting question.  Am I correct in assuming you are using @nosent trees
to generate your files?  If so, it would be easy to add support for the
following options:

@bool write_section_comments_in_at_nosent_trees
@bool write_node_name_comments_in_at_nosent_trees

The first would write a sentinel consisting of only the section name;
the second would write a sentinel consisting only of the node's headline
(for nodes whose headline is not a section name).

These seem like they would be useful additions.  One can even imagine
corresponding Leo directives so that the comments could be turned on or off
within an @nosent tree.

What do you think?

=====================

&gt; Interesting question.  Am I correct in assuming you are using @nosent trees
&gt; to generate your files?  If so, it would be easy to add support for the
&gt; following options:

&gt; @bool write_section_comments_in_at_nosent_trees
&gt; @bool write_node_name_comments_in_at_nosent_trees

&gt; The first would write a sentinel consisting of only the section name;
&gt; the second would write a sentinel consisting only of the node's headline
&gt; (for nodes whose headline is not a section name).

&gt; These seem like they would be useful additions.  One can even imagine
&gt; corresponding Leo directives so that the comments could be turned on or off
&gt; within an @nosent tree.

That sounds like an excellent solution. Particularly the last bit --
if you could turn section-comments on and off as required, it would
become very convenient to use Leo to produce source that is intended
to also be read by non Leo users. 
</t>
<t tx="ekr.20080628062747.69">http://groups.google.com/group/leo-editor/browse_thread/thread/794ca596f7c58ae5

The fix was to call c.redraw_now in undo() and redo().  This allows the undo interlock to work.
</t>
<t tx="ekr.20080628062747.70">Minor nit - insert-file to load a file into a node, text appears in the
body pane.  Without doing anything else to the body pane click on
another node.  Inserted text is lost - body for node is empty.  As long
as you move the cursor into the body frame and press a key after
inserting the contents, it's retained.
</t>
<t tx="ekr.20080628062747.71">@nocolor

c.beginUpdate()
try:
 add / change icons on some nodes
 c.setChanged(True)
finally:
 c.endUpdate()

seems not to give a redraw *after* a script button is pressed.

It does give one before the action is taken, so pressing the button
twice shows the change.

EKR: The fix was to mod_scripting.py.

@color
</t>
<t tx="ekr.20080628062747.72">The fix was a major addition to p._adjustPositionBeforeUnlink.

Report:

Run this script:

t = p.insertAfter()
c.setHeadString(t, 'test node 1')
t = t.insertAfter()
c.setHeadString(t, 'test node 2')
t = t.insertAfter()
c.setHeadString(t, 'test area')
for i in range(200):
   n = t.insertAsLastChild()
   c.setHeadString(n, str(i))
   if i == 3: x = n

for i in range(100):
   n = x.insertAsLastChild()
   c.setHeadString(n, str(i+500))

t.expand()

It creates an outline, you might need to click on the node from which
the script was run to see what was added.  It should look like this:

test node 1
test node 2
test area
   1
   2
  +3
   4
   5
   etc.

Now, use the mouse to drag test node 1 down to a position after node
4... for me at least this results in the outline view leaping to the
bottom of the tree, which it shouldn't do.

Scroll back up to the top, and drag test node 2 down to a position
after node 4, this time no leap.

It appears that the first time you drag something into the test area it
reacts as if 3 is expanded and repositions to allow for all those
actually not visible lines, but the second time you drag something in
it's ok, as if it has an accurate count on visible lines now.
</t>
<t tx="ekr.20080628095358.1">http://groups.google.com/group/leo-editor/browse_thread/thread/5688ed9aaa39be2e#

@nocolor

The main difficulty I see in the migration is creating the tables in the getPublicCommands methods in the various classes in leoEditCommands.py.  At present, these tables associate command names (strings) with corresponding methods.  The form of getPublicCommands is always:

def getPublicCommands (self):
  return {
    'command-name1': self.methodName1,
    'command-name2': self.methodName2,
    ...
  }

Thinking out loud, let's see whether the migration can be done easily.  We would change the entry:

    'command-name1': self.methodNameN,

to:

    'command-name1': self.classNameN(self),

That is, the table creates an instance of the class by calling the class's ctor, with self (the container object) as the ctor's only argument.  To make this work, all we need to do is give the class a __call__ method whose signature matches the signature of methodNameN, that is, the signature used to call methods previously.

Well, isn't this nice.  We can transition gradually, as needed.  No need *ever* to do a mass migration.  It should be easy to verify this scheme with one or two examples.  Please report your experiences if you decide to play around with this.

Edward

P.S.  I think it would be good style to append "Class" to the name of each command class. This makes it clear that self.myCommandClass(self) is a ctor.
</t>
<t tx="ekr.20080729064227.6">The timit button in unitTest.leo allows you to apply Python's timeit module.
See http://docs.python.org/lib/module-timeit.html.
The contents of @button timer is::

    import leo.core.leoTest as leoTest
    leoTest.runTimerOnNode(c,p,count=100)

runTimerOnNode executes the script in the presently selected node using timit.Timer and prints the results.
</t>
<t tx="ekr.20080729064227.7">The profile button in unitTest.leo allows you to profile nodes using Python's profiler module.
See http://docs.python.org/lib/module-profile.html
The contents of @button profile is::

    import leo.core.leoTest as leoTest
    leoTest.runProfileOnNode(p,outputPath=None) # Defaults to leo\test\profileStats.txt

runProfileOnNode runs the Python profiler on the script in the selected node, then reports the stats.
</t>
<t tx="ekr.20080730095710.1"></t>
<t tx="ekr.20080730095710.2">Leo 4.5 beta 2                      August 7, 2008

Leo 4.5 beta 2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080730212711.14"></t>
<t tx="ekr.20080730212711.15">#############
Using @shadow
#############

This chapter describes an important new feature that debuted in Leo 4.5 b2: @shadow trees.
These trees combine the benefits of @auto, @file and @nosent trees:

- The (public) files created by @shadow trees contain no sentinels, but
- Leo is able to update @shadow trees in the Leo outline based on changes made
  to public files outside of Leo.

@shadow trees are often useful for studying or editing source files from projects that don't use Leo. 
In such situations, it is convenient to import the @shadow tree from the (public) sources.
As discussed below, Leo can import @shadow trees automatically,
using the same algorithms used by `@auto trees`_.

The crucial ideas and algorithms underlying @shadow trees are the invention of Bernhard Mulder.

.. contents::
    :depth: 2

</t>
<t tx="ekr.20080730212711.16">.. Links
.. _`@auto trees`:          directives.html#auto    
</t>
<t tx="ekr.20080730212711.39">Using @shadow trees is the best choice when you want to have the full power of
Leo's outlines, but wish to retain the source files in their original format,
without Leo sentinels (markup) in comments in the source file. 

Leo's @file trees create external files containing comments called sentinels.
These sentinel lines allow Leo to recreate the outlines structure of @file
trees. Alas, many people and organizations find these added sentinel lines
unacceptable. \@nosent nodes create external files without sentinels, but at a
cost: Leo can not update \@nosent trees when the corresponding external file is
changed outside of Leo.

\@shadow trees provide a way around this dilemma. When Leo saves an \@shadow
tree, it saves two copies of the tree: a **public** file without sentinels, and
a **private** file containing sentinels. Using Bernhard Mulder's brilliant
**update algorithm**, Leo is able to update @shadow trees in the Leo outline
based *solely* on changes to public files.

Leo writes private files to a subfolder of the folder containing the public file:
by default this folder is called .leo_shadow.
You can change the name of this folder using the @string shadow_subdir setting.
Note that private files need not be known to source code control systems such as bzr or git.

That's *almost* all there is to it.  The following sections discuss important details:

- How to create @shadow trees.
- How @shadow works.
- Why the update algorithm is sound.
</t>
<t tx="ekr.20080730212711.40">Suppose our @shadow tree is @shadow a.py. When Leo writes this tree it creates a
public file, a.py, and a private file, .leo_shadow/xa.p (or just xa.p for
short). Public files might can committed to a source code control system such as
bzr or git. Private files should *not* be known to bzr or git.

Now suppose a.py has been changed outside of Leo, say as the result of a bzr
merge. The corresponding private file, xa.p, will *not* have been changed.
(Private files should *never* change outside of Leo.

When Leo reads the *new* (and possibly updated) public file it does the
following:

1. Recreates the *old* public file by removing sentinels from the (unchanged!) *private* file.
2. Creates a set of diffs between the old and new *public* files.
3. Uses the diffs to create a new version of the *private* file.
4. Creates the @shadow tree using  the new *private* file.

**Important**: The update algorithm never changes sentinels. This means that the
update algorithm never inserts or deletes nodes. The user is responsible for
creating nodes to hold new lines, or for deleting nodes that become empty as the
result of deleting lines.

Step 3 is the clever part. To see all the details of how the algorithm works,
please study the x.propagate_changed_lines method in leoShadow.py. This code is
heavily commented.
</t>
<t tx="ekr.20080730212711.42">The first step in creating an @shadow tree is to create a node whose
headline is @shadow *&lt;filename&gt;*.

Thus, you can create an @shadow node and save your outline, regardless of
whether the original file exists. The next time Leo reads the @shadow node, Leo
will **create** the entire @shadow tree using the same logic as for `@auto
trees`_. You can cause Leo to read the @shadow node in two ways: 1) by closing
and reloading the Leo outline or 2) by selecting the @shadow node and executing
the File:Read/Write:Read @shadow Node command.

**Important**: Leo imports the private file into the @shadow tree only if

a) the public file exists and
b) the private file does *not* exist.

Thus, Leo will import code into each @shadow node at most once. After the first
import, updates are made using the update algorithm.

**Note**: just as for @auto, Leo will never read (import) or write an @shadow
tree if the @shadow node is under the influence of an \@ignore directive.

**Important**: At present, Leo puts all nodes included by @others at the
same outline level. This could fairly be called a bug. See:
https://bugs.launchpad.net/leo-editor/+bug/1226353 The workaround is to
place an @others directive at the end of any node with children.
</t>
<t tx="ekr.20080730212711.52">There are several boundary cases that the update algorithm can not resolve.
For example, if a line is inserted at the boundary between nodes,
the updated algorithm can not determine whether the line should be inserted
at the end of one node of the start of the next node.

Happily, the inability of the update algorithm to distinguish between
these two cases **does not matter**, for three very important reasons:

1. No matter which choice is made, the *public* file that results is the same.
   **The choice doesn't matter**, so the update algorithm is completely and
   absolutely safe.

2. Leo reports any nodes that were changed as the result of the update
   algorithm. In essence, these reports are exactly the same as the reports Leo
   makes when @file trees were changed as the result of changes made externally
   to Leo. It is as easy for the user to review changes to @shadow trees as it
   is to review changes to @thin or @file trees.

3. Suppose the user moves a line from the end of one node to the beginning of
   the following node, or vice versa. Once the user saves the file, the
   *private* file records the location of the moved line. The next time the user
   reads the @shadow file, the line will *not* be subject to the update
   algorithm because the line has not been changed externally. The location of
   the line (on the boundary) will be completely determined and it will never
   need to be moved across the boundary.

Understanding these three reasons finally convinced me that @shadow could be
made to work reliably.
</t>
<t tx="ekr.20080802070659.11"></t>
<t tx="ekr.20080806211440.185"></t>
<t tx="ekr.20080806211440.188">.. _`v.uA's`: http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b

- Added support for @shadow files.
  This is a major breakthrough.
  See the `Using @shadow`_ chapter for full details.

- Added much improved support for vim bindings.

- Allow `v.uA's`_ in @file and @shadow nodes.
</t>
<t tx="ekr.20080806211440.189">- The default settings for @shadow files are now located in leoSettings.leo in the node::

        @settings--&gt;File options--&gt;Shadow files

    The defaults for these settings are::

        @string shadow_prefix = x
        @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option.

    Leo suppresses marks, expansion state, orphan bits and current position bits
    when writing fixed .leo files. As a result, all nodes will be collapsed and
    the root node will always be selected when Leo opens a fixed .leo file.

    You can optionally specify the size and position on the screen of fixed .leo
    files by putting an '@data fixedWindowPosition' node in the
    \@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
    **not** put such a node in the fixed .leo file itself--everyone who
    opens the file would get that fixed position.

    The body of the '@data fixedWindowPosition' node should contain
    something like this::

        # Must be four entries: width,height,left,top.
        # Put this in myLeoSettings.leo, **not** in individual .leo files.

        1200
        800
        50
        50

- Added @bool cleo_color_ignore = True

    This determines whether cleo colors @ignore headlines. The default is True.
</t>
<t tx="ekr.20080806211440.253">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080806211440.256">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.
  Leo uses os.path.expanduser("~") if there is no home setting.
</t>
<t tx="ekr.20080813064908.2">In version 4.5, Leo changed to using a sax parser for .leo files. This can cause
problems if your .leo file contains invalid characters.
Bugs in previous versions of Leo permitted these bad characters to appear.

The sax parser complains that these characters are not valid in .xml files.
Remove these invalid characters as follows:

1. `run Leo in a console window`_, and load the .leo file.
   Near the bottom of the error message you will see a line like::

    SAXParseException: &lt;unknown&gt;:123:25: not well-formed (invalid token)

   This line reports a bad character at character 25 of line 123.

2. Open the .leo file in an external editor.
   The Scite editor, http://www.scintilla.org/SciTE.html,
   is a good choice because it clearly shows non-printing characters.
   Remove the invalid character, save the .leo file.

Repeat steps 1 and 2 until all invalid characters are gone.
</t>
<t tx="ekr.20080814134319.1">C:\leo.repo\trunk&gt;bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

C:\leo.repo\trunk&gt;bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

</t>
<t tx="ekr.20080815093141.89">Leo 4.5 beta 3                      August 15, 2008

Leo 4.5 beta 3 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080815093141.90">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.

- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080815093141.91">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080815093141.92">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Create myLeoSettings.leo if it does not exist.
  Leo create a simple template myLeoSettings.leo in the home directory if no other
  copy of myLeoSettings.leo exists.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.

</t>
<t tx="ekr.20080815093141.93">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files

  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.

  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.

    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.

- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.
</t>
<t tx="ekr.20080815174457.5">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/e86796831635311b

I was wondering whether it would be a good idea to have leo
automatically delete the corresponding shadow file when a @shadow node
is deleted? Ditto for deleting the .leo_shadow dir when it is empty.

Answer:

My second thought is that this is too dangerous--shadow files might
turn out to be useful emergency backups.  I would prefer to have Leo
mess with the file system as little as possible.
</t>
<t tx="ekr.20080827175609.55">Leo 4.5 release candidate 1                      August 28, 2008

Leo 4.5 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080827175609.56">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.

- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080827175609.57">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080827175609.58">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.

- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.
</t>
<t tx="ekr.20080827175609.59">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files

  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.

  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.

    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.

- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.
</t>
<t tx="ekr.20080830082008.1">Leo 4.5 release candidate 2                     August 30, 2008

Leo 4.5 rc2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5 contains many important new features.  See below for details.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080830082008.2">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.

- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080830082008.3">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080830082008.4">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.

- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.
</t>
<t tx="ekr.20080830082008.5">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files

  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.

  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.

    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.

- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.
</t>
<t tx="ekr.20080902080930.2">Leo 4.5 final                                  September 2, 2008

Leo 4.5 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Quote of the month:
-------------------
Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080902080930.3">- Added support for @shadow files.
  This is a major breakthrough.
  See `Chapter 23`_ for full details.

- Added much improved support for vim bindings.

- Allow v.uA's in @thin and @shadow nodes.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/750bb3099090f5b
</t>
<t tx="ekr.20080902080930.4">- Leo now uses a sax-based parser to read .leo files.
  This makes it possible to extend Leo's file format without invalidating previous versions of Leo.

- Leo now supports the so-called 'Graph World'.
  When g.unified_nodes is True, Leo moves all information from tnodes into vnodes.

- Leo now uses a new key binding scheme.
  This allows substantially simpler key bindings. Indeed, most per-pane bindings
  have been eliminated.
  Added support for kill bindings.

- Leo is now an installable package.
  To make this work, Leo adds os.curdir to sys.path if needed on startup.

- Reorganized Leo's drawing and focus code.
  As a result, calls to c.beginUpdate and c.endUpdate are no longer needed.

- Leo is now ready for Python 3.x:
  Change most print statements to calls to g.pr.
</t>
<t tx="ekr.20080902080930.5">- Added g.Tracer class.  This is a Python 'debugger' that computes a call graph.
  To trace a function and its callers, put the following at the function's start::

    g.startTracer()

- The find-character command now finds characters across line boundaries.

- Set cwd in read/write commands. This affect the following commands:
  open, save, save-as, save-to, read-outline-only, read-file-into-node,
  write-file-from-node and all the import/export commands.

- Added support for @args list for @button nodes.
  See the docstring for the mod_scripting plugin for details.

- Leo creates the .leo folder in the user's HOME directory, and puts several configuration files there.
  Leo looks for myLeoSettings.leo in HOME/.leo.
</t>
<t tx="ekr.20080902080930.6">- The default settings for @shadow files are now located in leoSettings.leo in the node::

    @settings--&gt;File options--&gt;Shadow files

  The defaults for these settings are::

    @string shadow_prefix = x
    @string shadow_subdir = .leo_shadow

- Added support for @bool fixedWindow option. Leo suppresses marks, expansion
  state, orphan bits and current position bits when writing fixed .leo files. As
  a result, all nodes will be collapsed and the root node will always be
  selected when Leo opens a fixed .leo file.

  You can optionally specify the size and position on the screen of fixed .leo
  files by putting an '@data fixedWindowPosition' node in the
  @settings tree of myLeoSettings.leo or leoSettings.leo.  You should
  **not** put such a node in the fixed .leo file itself--everyone who
  opens the file would get that fixed position.

  The body of the '@data fixedWindowPosition' node should contain
  something like this::

    # Must be four entries: width,height,left,top.
    # Put this in myLeoSettings.leo, **not** in individual .leo files.

    1200
    800
    50
    50

- Added @bool cleo_color_ignore = True
  This determines whether cleo colors @ignore headlines. The default is True.

- Added @bool suppress_import_parsing setting
  When True, @auto and @shadow import the entire file into a single node.
</t>
<t tx="ekr.20080912143702.137">Leo 4.5.1 final                                  September 14, 2008

Leo 4.5.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.5.1 final fixes several important bugs in Leo 4.5 final:

- Eliminated spurious error messages in the goto-global-line command.
- @shadow files with unknown file extensions now work properly.
- Improved Leo's installer.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.5:
--------------------------

- Full support for @shadow files in Leo's core.
- Major improvements to Leo's key binding code.
- The beginning of usable vim-like bindings.
- uA's may now be associated with vnodes in @thin and @shadow files.
- Several major reorganizations of Leo's code:
  including sax-based parsing, support for the Graph world (unified nodes),
  and simplified drawing code.
- Leo is now an installable package.
- Prepared code to be ready for Python 3.0.
- Many small improvements and bug fixes.

Quote of the month:
-------------------
Squeak and Leo have been two of the most significant technologies to
redefine my personal computer experience and the ideas behind computing.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20080912143702.138"># goToLineNumber was always complaining about a missing private shadow file.
</t>
<t tx="ekr.20080912143702.139">@

adjustTargetLanguage, a helper of writeOneAtShadowNode, no longer sets
c.target_language to 'unknown_language' when the file extension is unknown.
</t>
<t tx="ekr.20080912143702.140">The script failed for paths such as c:\xp\python25\python.exe
for which python was not the top-most directory.
</t>
<t tx="ekr.20080917153158.10">How to create launchpad key pairs
=================================

http://help.launchpad.net/YourAccount/CreatingAnSSHKeyPair

How to create/use branches
=========================

pushes a branch after it has been created on launchpad::

    bzr push --use-existing-dir lp:leo-editor/whatever (private)

    bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever (private)

remembers the push::

    bzr push --remember bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever

creates branch on local machine: do this from leo.repo directory::

    bzr branch old-branch-name new-branch-name

    bzr branch lp:leo-editor new-branch-name 

    bzr branch bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever new-branch-name

To resolve conflicts
====================

kdiff3 file1 file2 file3 -m


Docs
====
- http://doc.bazaar-vcs.org/latest/en/user-guide/index.html
    - http://bazaar-vcs.org/BzrWhy (referenced in sec 1.1.3 of the guide)
        - http://ianclatworthy.files.wordpress.com/2007/10/dvcs-why-and-how3.pdf
        - PQM: https://launchpad.net/pqm (google)
        - BB Bundle buggy: http://bundlebuggy.aaronbentley.com/help (google)
        - Spike solution: http://www.extremeprogramming.org/rules/spike.html (google)
- My log was at: http://bzr.arbash-meinel.com/irc_log/bzr/2008/02/bzr-2008-02-25.html


Configuration files
===================

.bzrignore in each repository contains the patterns to ignore.

EKR:  do ed-bzr

Windows: c:\Users\edreamleo\AppData\Roaming\bazaar\2.0\bazaar.conf

Linux:  ~/.bazaar/bazaar.conf
</t>
<t tx="ekr.20080919085541.3">http://groups.google.com/group/leo-editor/browse_thread/thread/dff0c165e2211691
</t>
<t tx="ekr.20080922115725.1"># Allow block comments in private shadow files.
# Compute delims using the private shadow file, not the file extension!
# Can @shadow mark externally changed nodes?
</t>
<t tx="ekr.20080922124033.1">The following code can be run from a script to get input from the user using the minibuffer::

    def getInput (event=None):

       stateName = 'get-input'
       k = c.k
       state = k.getState(stateName)

       if state == 0:
           k.setLabelBlue('Input: ',protect=True)
           k.getArg(event,stateName,1,getInput)
       else:
           k.clearState()
           g.es_print('input: %s' % k.arg)

    getInput()

Let's look at this in detail.  The lines::

    stateName = 'get-input'
    k = c.k
    state = k.getState(stateName)

define a state *name*, 'get-input', unique to this code.
k.getState returns the present state (an int) associated with this state.

When getInput() is first called, the state returned by k.getState will be 0,
so the following lines are executed::

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)

These lines put a protected label in the minibuffer:
the user can't delete the label by backspacing.
getArg, and the rest of Leo's key handling code, take care of the extremely
complex details of handling key strokes in states.
The call to getArg never returns.
Instead, when the user has finished entering the input by typing &lt;Return&gt;
getArg calls getInput so that k.getState will return state 1, the value
passed as the third argument to k.getArg.
The following lines handle state 1::

    else:
        k.clearState()
        g.es_print('input: %s' % k.arg)

k.arg is the value returned by k.getArg.
This example code just prints the value of k.arg and clears the input state.
</t>
<t tx="ekr.20080923182326.1">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.
</t>
<t tx="ekr.20080924032842.3">def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
       Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.p

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # Scan back for the first period.
    i = len(s)-1
    # while i &gt; 0 and s[i] != '.':
    while i &gt; 0 and g.isWordChar(s[i]):
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.exit() # Not called from the autocompleter itself.
    return theObject,tabList
</t>
<t tx="ekr.20081001062423.1">http://groups.google.com/group/leo-editor/browse_thread/thread/c46eabe8a9fe6e8
</t>
<t tx="ekr.20081004102201.2">http://groups.google.com/group/leo-editor/browse_thread/thread/5e7bd3af2d1fbf51

How about a shadow.log file which Leo told what it thought of the relationship
between the node, file and shadow? It might provide useful clues.
</t>
<t tx="ekr.20081005065934.7"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
</t>
<t tx="ekr.20081005065934.9"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'after_idle',
    'forceFullRecolor', # The base-class method is usually good enough.
    'initAfterLoad',
    'tag_configure', # used in qtGui.py.
)
</t>
<t tx="ekr.20081031074455.3">mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
)
</t>
<t tx="ekr.20081031074455.4">mustBeDefinedInSubclasses = (
    'appendText',
    'delete',
    'deleteTextSelection',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

</t>
<t tx="ekr.20081031074455.5"># These can be do-nothings
mustBeDefined = (
    'flashCharacter',
    'hasSelection',
    'replace',
    'rowColToGuiIndex',
    'selectAllText',
    'tag_configure',
    'toGuiIndex',
    'toPythonIndex',
    'toPythonIndexRowCol',
)
</t>
<t tx="ekr.20081113095540.1">/etc/apt/sources.list.d is a directory
It contains, on my machine, files called edgy-universe.list.x
The prefix doesn't matter, but the contents of these files must contain the proper ubuntu distro name,
for example, gutsy, hardy, intrepid.
</t>
<t tx="ekr.20081119132758.2">This can be done now that gui's are created on the command line.
</t>
<t tx="ekr.20081205084002.2">Scripts can easily determine what directives are in effect at a particular
position in an outline. c.scanAllDirectives(p) returns a Python dictionary whose
keys are directive names and whose values are the value in effect at position p.
For example::

    d = c.scanAllDirectives(p)
    g.es(g.dictToString(d))

In particular, d.get('path') returns the full, absolute path created by all
\@path directives that are in ancestors of node p. If p is any kind of @file node
(including @file, @auto, @nosent, @shadow, etc.), the following script will
print the full path to the created file::

    path = d.get('path')
    name = p.anyAtFileNodeName()
    if name:
       name = g.os_path_finalize_join(path,name)
       g.es(name)
</t>
<t tx="ekr.20081208102356.1">http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

&gt; Tk only colorizes one body editor, and if you delete that editor it
&gt; colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
</t>
<t tx="ekr.20090105132011.6"># *** match pat2 if not preceded by pat1::

(?&lt;!pat1)pat2

.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:

copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x

[]
    Used to indicate a set of characters. Characters can be listed individually,
    or a range of characters can be indicated by giving two characters and
    separating them by a '-'. Special characters are not active inside sets.

    [akm$] will match any of the characters 'a', 'k', 'm', or '$';
    [a-z] will match any lowercase letter.
    [a-zA-Z0-9] matches any letter or digit.

    Character classes such as \w or \S (defined below) are also
    acceptable inside a range, although the characters they match depends on
    whether LOCALE or UNICODE mode is in force. If you want to include a ']' or
    a '-' inside a set, precede it with a backslash, or place it as the first
    character. The pattern []] will match ']', for example.

    You can match the characters not within a range by complementing the set.
    This is indicated by including a '^' as the first character of the set; '^'
    elsewhere will simply match the '^' character. For example, [^5] will match
    any character except '5', and [^^] will match any character except '^'.

(?=...)
    Matches if ... matches next, but doesnt consume any of the string.
    This is called a lookahead assertion.
    For example, Isaac (?=Asimov) will match 'Isaac ' only if it's followed by 'Asimov'.

(?!...)
    Matches if ... doesn't match next.
    This is a negative lookahead assertion.
    For example, Isaac (?!Asimov) will match 'Isaac ' only if it is not followed by 'Asimov'.

(?&lt;=...)
    Matches if the current position in the string is preceded by a match for ...
    that ends at the current position. This is called a positive lookbehind assertion.
    The contained pattern must only match strings of some fixed length,
    meaning that abc or a|b are allowed, but a* and a{3,4} are not.

(?&lt;!...) Matches if the current position in the string is not preceded by a
    match for .... This is called a negative lookbehind assertion. Similar to
    positive lookbehind assertions, the contained pattern must only match
    strings of some fixed length. Patterns which start with negative lookbehind
    assertions may match at the beginning of the string being searched.
</t>
<t tx="ekr.20090116094356.10">\@menuat modifies the menu tree created by \@menus. This allows settings in
myLeoSettings.leo to change menus without copying the entire menu tree from
leoSettings.leo. This ensures you don’t miss out when new things are added in
the @menus in leoSettings.leo, as you would if you replaced the @menus in
leoSettings.leo with one in myLeoSettings.leo.

\@menuat should occur in a \@settings tree, but not as a descendant of a \@menus
tree. Its children are \@menu and \@item nodes as for the
@menu setting.

The @menuat setting has 2-3 parameters in its head text]::

    @menuat *&lt;path&gt;* *&lt;action&gt;* *[clipboard]*

The path argument specifies a **target** in the menu tree as defined by
\@menus and modified by earlier @menuat settings. The path takes the form::

    /entry1/entry2/entry3
    
Each entry is the **cleaned** name of a menu or item. Cleaned names are a
name with all text except a-z and 0-9 removed and upper case letters converted
to lower case. For example, specify::

    Outline-&gt;Move-&gt;Move Down
    
as::
    
     /outline/move/movedown

The action argument specifies what the menu item does. There are 5 available
actions:

- **before**: Insert items and sub menus immediately before the target.
- **after**:  Insert items and sub menus immediately after the target.
- **append**: Append items and sub menus at the end of the target menu or item.
- **cut**:    Remove the target from the menu tree and save it to an internal clipboard.
- **copy**:   Copy the target to an internal clipboard. Descendants of the @menuat setting are ignored.

The cut and copy arguments ignore descendants of the @menuat setting .

The optional clipboard argument modifies the action of the before, after, and
append actions. By default these actions insert the menus and items supplied as
descendants of the @menuat setting. If you specify “clipboard” (without the
quotes) as the source, the contents of the clipboard from a previous cut or copy
action will be used instead.
</t>
<t tx="ekr.20090116094356.11">The body text contains a list of settings for a font.  For example::

    body_text_font_family = Courier New
    body_text_font_size = None
    body_text_font_slant = None
    body_text_font_weight = None

**Important**: you can use the show-fonts minibuffer command to guide you in making these settings.

</t>
<t tx="ekr.20090116094356.12">The body text contains a list of shortcut specifiers.
</t>
<t tx="ekr.20090116094356.13">The body text contains a list of paths of recently opened files, one path per
line. Leo writes the list of recent files to .leoRecentFiles.txt in Leo's
config directory, again one file per line.
</t>
<t tx="ekr.20090116094356.14">Leo now allows you to specify input modes. You enter mode x with the
enter-x-mode command. The purpose of a mode is to create different bindings
for keys within a mode. Often plain keys are useful in input modes.

You can specify modes with @mode nodes in leoSettings.leo. @mode nodes work
just like @shortcuts nodes, but in addition they have the side effect of
creating the enter-&lt;mode name&gt;-mode command.

The form of this node is::

    @mode *&lt;mode name&gt;*

The body text contains a list of shortcut specifiers. @mode nodes work just
like @shortcuts nodes, but in addition they have the side effect of creating
the enter-&lt;mode name&gt;-mode command.

Notes:

- You can exit any mode using the keyboard-quit (Control-g) command. This is the
  **only** binding that is automatically created in each mode. All other bindings
  must be specified in the @mode node. In particular, the bindings specified in
  @shortcuts nodes are **not** in effect in mode (again, except for the
  keyboard-quit binding).

- Leo supports something akin to tab completion within modes: if you type a key
  that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab
  shows all the keys that you can type and the commands to which they are bound.
  The mode-help command does the same thing.

- @shortcuts nodes specify the bindings for what might be called the 'top-level'
  mode. These are the bindings in effect when no internal state is present, for
  example, just after executing the keyboard-quit command.

- The top_level_unbound_key_action setting determines what happens to
  unbound keys in the top-level mode. Leo ignores unbound keys in all other modes.
  The possibilities are 'insert', 'replace' and 'ignore'.

- The set-insert-mode, set-overwrite-mode and set-ignore-mode
  commands alter what happens to unbound keys in the top-level mode.
  
- If the @mode headline contains ::, everything following
  the :: is the mode prompt. For example::
    
    @mode abc :: xyz
    
Creates the enter-abc-mode command, but the prompt for the command is xyz.

With all these options it should be possible to emulate the keyboard behavior of any other editor.
</t>
<t tx="ekr.20090116094356.2">When reading a .leo file, Leo looks for settings in default settings
files first, then settings in personal settings files, and finally
settings in local settings files.  The exact search order is:

1. Default settings files:

   a. configDir/leoSettings.leo
   b. homeDir/leoSettings.leo
   c. localDir/leoSettings.leo

2. Personal settings files:

   a. configDir/myLeoSettings.leo
   b. homeDir/myLeoSettings.leo
   c. homeDir/&lt;machine-name&gt;LeoSettings.leo (note capitalization)
   d. localDir/myLeoSettings.leo

3. Local settings files:

   a. The file specified by the -c command-line option.
   b. The file being loaded.

Settings that appear later in this list override settings that
appear earlier in this list.  This happens on a setting-by-setting
basis, *not* on a file-by-file basis.  In other words, each individual
setting overrides only the *corresponding* setting in previously-read
files.  Reading a setting file does *not* reset all previous settings.
Note that the same file might appear several times in the search list.
Leo detects such duplicate file names and only loads each settings file once.
Leo remembers all the settings in settings files and does not reread those
settings when reading another .leo file.

**Caution**: This search order offers almost too much flexibility. This can be
confusing, even for power users. It's important to choose the "simplest
configuration scheme that could possibly work".  Something like:

- Use a single leoSettings.leo file for installation-wide defaults.
- Use a single myLeoSettings.leo files for personal defaults.
- Use local settings sparingly.

**Important**: it is good style to limit settings placed in 
myLeoSettings.leo to those settings that differ from default settings.
</t>
<t tx="ekr.20090116094356.3">You should use special care when placing default or personal settings files in
**local** directories, that is, directories other than homeDir, configDir or
machineDir. In particular, the value of localDir can change when Leo reads
additional files. This can result in Leo finding new default and personal
settings files. The values of these newly-read settings files will, as always,
override any previously-read settings.

Let us say that a setting is **volatile** if it is different from a default
setting. Let us say that settings file A.leo **covers** settings file if B.leo
if all volatile settings in B.leo occur in A.leo. With these definitions, the
**safe rule** for placing settings files in local directories is::

   Settings files in local directories should
   cover all other settings files.

Following this rule will ensure that the per-directory defaults specified in the
local settings file will take precedence over all previously-read default and
personal settings files. Ignore this principle at your peril.
</t>
<t tx="ekr.20090116094356.5">An @buttons tree in a settings file defines global buttons that
are created in the icon area of all .leo files.
All @button nodes in the @commands tree create global buttons.
All @button nodes outside the commands tree create buttons local to the settings file.
</t>
<t tx="ekr.20090116094356.6">An \@commands tree in a settings file defines global commands.
All \@command nodes in the @commands tree create global commands.
All \@command nodes outside the commands tree create commands local to the settings file.
</t>
<t tx="ekr.20090116094356.7">The body text contains a list of strings, one per line.
Lines starting with '#' are ignored.
</t>
<t tx="ekr.20090116094356.8" str_atime="1376412853.0">The body text of the @enabled plugins node contains a list of enabled plugins,
one per line. Comment lines starting with '#' are ignored. Leo loads plugins in
the order they appear.
**Important**: Leo handles @enabled-plugins nodes a differently from other kinds
of settings. To avoid confusion, **please read the following carefully**.

As always, Leo looks for @enabled-plugins nodes in settings files in the order
specified by `Search order for settings files`_. Leo will enable all plugins
found in the @enabled-plugins node it finds *last* in the search order. Leo does
*not* enable plugins found in any other @enabled-plugins node. In particular,
**you can not specify a list of default plugins by placing that list in a
settings file that appears early in the search list**. Instead, the last
@enabled-plugins node found in the search list specifies all and *only* the plugins
that will be enabled.

Let us distinguish two different situations. First, what Leo does when loading a
file, say x.leo. Second, what Leo does when loading a second file, say y.leo,
*from x.leo*. When loading the first .leo file, Leo enables plugins from the
@enabled-plugins node it finds *last* in the search order. But after plugins
have *already* been loaded and enabled, there is no way to disable previously
loaded-and-enabled plugins. But local settings files can enable additional
plugins.

To avoid confusion, I highly recommend following another kind of safe rule.
We say that an @enabled-plugin node in file A.leo **covers** an @enabled-plugin
node in file B.leo if all plugins specified in B's @enabled-plugin node appear
A's @enabled-plugin node. The safe rule for plugins is::

  @enabled-plugin nodes in settings files in local directories
  should cover @enabled-plugins nodes in all other settings files.
</t>
<t tx="ekr.20090116094356.9">Leo creates its menus from the @menu, @item and @popup nodes in the @menus tree.
Within @menus trees, @menu nodes create menus and @item nodes create menu items. 

The menu name always follows @menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
@menu nodes define submenus.

The command name follows @item. If the body text of an @item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command
name in an @item node is just a hyphen (-), the item represents a menu
separator.

@popup *&lt;widget-name&gt;* creates a popup menu for use by the contextmenu.py plugin.
The children of this node should be @menu and @item nodes, used as with
@menus.
</t>
<t tx="ekr.20090116130002.1">Settings files can be found in the following directories:

- **homeDir**, the HOME/.leo directory. HOME is given by Python's HOME
  environment variable, or by os.expanduser('~') if no HOME environment variable
  exists.

- **configDir**, Leo's configuration directory: leo/config.

- **machineDir**, the HOME/.leo/MACHINE directory. MACHINE is given by Python's
  HOSTNAME environment variable, or by Python's COMPUTERNAME environment
  variable if there is no HOSTNAME variable, or by the value returned by
  socket.gethostname() if neither environment variable exists.

- **localDir**, the directory containing the .leo file being loaded.

In addition, Leo's -c command-line option can specify any .leo file anywhere.
</t>
<t tx="ekr.20090130144433.1">All questions are welcome at http://groups.google.com/group/leo-editor
</t>
<t tx="ekr.20090130144433.2">You can discuss possible bugs at
http://groups.google.com/group/leo-editor

Please report bugs at
http://bugs.launchpad.net/leo-editor

When reporting a bug, please include *all* of the following:

- The version of Leo used.

- The version of Python used.

- The platform or platforms used: Linux, Windows, MacOS.

- A clear description of the problem.

- Information sufficient to recreate the problem.

It's polite to make the bug report self contained, so that six weeks later
somebody will be able to understand the report as it stands.
</t>
<t tx="ekr.20090131200406.15"></t>
<t tx="ekr.20090202064534.4">@language rest

</t>
<t tx="ekr.20090202191501.7">You can simply unpack Leo anywhere and run from there.  You don't need the
installer.

From a console window, cd to the top-level leo folder.  Run Leo as follows::

    python launchLeo.py

To run Leo with Qt look and feel, use the --gui=qt option::

    python launchLeo.py --gui=qt

To load Leo's source, load leoPyRef.leo::

    python launchLeo.py --gui=qt leo\\core\\leoPyRef.leo
</t>
<t tx="ekr.20090212054250.5"></t>
<t tx="ekr.20090212054250.6">You can get the latest official releases of Leo at
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

However, if at all possible, it is better to use git to get the latest
sources. See the next entry.
</t>
<t tx="ekr.20090212054250.7">Daily snapshots are available at http://www.greygreen.org/leo/
</t>
<t tx="ekr.20090218115025.3">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

&gt; On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney &lt;ktenney@gmail.com&gt; wrote:
&gt;&gt;
&gt;&gt; Currently, Leo pickles the value of unknown attributes unless
&gt;&gt; the name starts with 'str_'
&gt;&gt;
&gt;&gt; Running the following code in node 'UA'
&gt;&gt;
&gt;&gt; p = c.currentPosition()
&gt;&gt; p.v.u = {'hello':'world', 'str_hello':'world'}
&gt;&gt;
&gt;&gt; results in the following in the .leo file:
&gt;&gt;
&gt;&gt; &lt;v t="ktenney.20090218114928.367" str_hello="world"
&gt;&gt; hello="5505776f726c6471002e"&gt;&lt;vh&gt;UA&lt;/vh&gt;&lt;/v&gt;
&gt;&gt;
&gt;&gt; I think this is surprising, Python-centric and contrary to the
&gt;&gt; spirit of Leo as a flexible data management platform.
&gt;
&gt; I suppose your point is that you can't create an arbitrarily named attribute
&gt; with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

&gt; As far as being Python-centric, can you suggest any other way of converting
&gt; arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

&gt; Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
</t>
<t tx="ekr.20090221070927.1">#########
License
#########
All parts of Leo are distributed under the following copyright. This is intended
to be the same as the MIT license, namely that Leo is absolutely free, even for
commercial use, including resale. There is no GNU-like "copyleft" restriction.
This license is compatible with the GPL.

**Copyright 1997-2013 by Edward K. Ream. All Rights Reserved.**

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

**THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.**
</t>
<t tx="ekr.20090223065025.3">**Important**: The changes you make below **will not persist** unless your
script calls c.frame.body.onBodyChanged after making those changes. This
method has the following signature::

    def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

Let::

    w = c.frame.body.wrapper # Leo's body pane.

Scripts can get or change the context of the body as follows::

    w.appendText(s)                     # Append s to end of body text.
    w.delete(i,j=None)                  # Delete characters from i to j.
    w.deleteTextSelection()             # Delete the selected text, if any.
    s = w.get(i,j=None)                 # Return the text from i to j.
    s = w.getAllText                    # Return the entire body text.
    i = w.getInsertPoint()              # Return the location of the cursor.
    s = w.getSelectedText()             # Return the selected text, if any.
    i,j = w.getSelectionRange (sort=True) # Return the range of selected text.
    w.replace(i,j,s)                    # Replace the text from i to j by s.
    w.setAllText(s)                     # Set the entire body text to s.
    w.setSelectionRange(i,j,insert=None) # Select the text.

**Notes**:

- These are only the most commonly-used methods.
  For more information, consult Leo's source code.

- i and j are zero-based indices into the the text. When j is not
  specified, it defaults to i. When the sort parameter is in effect,
  getSelectionRange ensures i &lt;= j.

- color is a Tk color name, even when using the Gt gui.
</t>
<t tx="ekr.20090324085713.2">Leo 4.6 beta 1                                       March 23, 2009

Leo 4.6 b1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.6:
--------------------------

- Leo now requires Python 2.4 or later.
- Leo now features a modern Qt interface;
  Leo's legacy Tk interface can also be used.
- New --config --file and --gui command-line options.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090324085713.272"></t>
<t tx="ekr.20090324085713.285"></t>
<t tx="ekr.20090324085713.289">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090324085713.292"></t>
<t tx="ekr.20090324085713.318">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.
</t>
<t tx="ekr.20090324085713.320">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.
</t>
<t tx="ekr.20090324085713.326"></t>
<t tx="ekr.20090324085713.327">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30
</t>
<t tx="ekr.20090324085713.350">The code should save/restore, just as in the clean_file function (from scripts.leo)
</t>
<t tx="ekr.20090324085713.358">The problem was missing calls to initAfterLoad in c.new.
</t>
<t tx="ekr.20090324085713.395">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90
</t>
<t tx="ekr.20090324085713.404"></t>
<t tx="ekr.20090324085713.513"></t>
<t tx="ekr.20090324085713.605">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090324085713.661"></t>
<t tx="ekr.20090324085713.662">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color
</t>
<t tx="ekr.20090324085713.663"></t>
<t tx="ekr.20090324085713.666">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName
</t>
<t tx="ekr.20090324085713.672">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u
</t>
<t tx="ekr.20090324085713.688"></t>
<t tx="ekr.20090324085713.689">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo
</t>
<t tx="ekr.20090324085713.690"></t>
<t tx="ekr.20090324085713.691"></t>
<t tx="ekr.20090324085713.726">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo
</t>
<t tx="ekr.20090324085713.732">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090324085713.740"># Useful: we don't need a closing @color to enable coloring in descendants.
</t>
<t tx="ekr.20090324085713.745">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
</t>
<t tx="ekr.20090324085713.746">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1
</t>
<t tx="ekr.20090324085713.747"></t>
<t tx="ekr.20090324085713.748">@string underindent-escape-string = \-
</t>
<t tx="ekr.20090324085713.792">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf
</t>
<t tx="ekr.20090324085713.814">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.
</t>
<t tx="ekr.20090324085713.817">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090324085713.835">Only .zip and .leo extensions are allowed at present.
</t>
<t tx="ekr.20090324085713.836">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.
</t>
<t tx="ekr.20090324085713.837">- Tab = indent when there is a text selection
- Shift-Tab unindents always
</t>
<t tx="ekr.20090324085713.847">Escape now ends isearch
</t>
<t tx="ekr.20090324085713.848"></t>
<t tx="ekr.20090324085713.849">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
</t>
<t tx="ekr.20090324085713.850"></t>
<t tx="ekr.20090324085713.867"></t>
<t tx="ekr.20090324085713.868"></t>
<t tx="ekr.20090324085713.869"></t>
<t tx="ekr.20090324085713.881"></t>
<t tx="ekr.20090324085713.890">This contains all gui plugins.
</t>
<t tx="ekr.20090324105223.10"></t>
<t tx="ekr.20090324105223.15"></t>
<t tx="ekr.20090324105223.9"></t>
<t tx="ekr.20090324145450.20"></t>
<t tx="ekr.20090324145450.23">- Leo opens a default .leo file if no other is specified, using the @string
  default_leo_file setting. The default for this setting is::

    ~/.leo/workbook.leo

- Added escapes for underindented lines. The escape is specified by the @string
  underindent-escape-string setting. By default, this escape is \- If a line
  starts with \-N, Leo will write the line with N fewer spaces than expected.

- Leo now warns when attempting to write a file that has been changed outside of
  Leo. This prevents bzr reversions.

- Leo tests syntax of .py files when saving them.

- Leo can now open any file into an @edit node. This allows Leo to be associated
  with the edit action of .py files. Like this::

    C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2

- Leo now warns if when writing an @auto node if the the file exists and the
  node has not been read previously.  This prevents a newly-created
  @auto node from overwriting an existing file.
</t>
<t tx="ekr.20090324145450.27">.. _`autoCompleter.getExternalCompletions`: http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac
.. _`c.getNodePath and c.getNodeFileName`: http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7

- Added `autoCompleter.getExternalCompletions`_.

- Added g.posList.

- c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName

- Added the following properties:
    - p.b, t.b and v.b return the body string of the position or node.
    - p.h, t.h and v.h return the head string of the position or node.
    - t.u and v.u return the uA of the node.
    - p.gnx, t.gnx and v.gnx return the gnx of the position or node.

- Added script to leoSettings.leo to ensure all menu items are valid.

- c.config.getSettingSource(setting_name)
  returns the name of the file which Leo used to determine the setting:

    - D indicates default settings.
    - F indicates the file being loaded
    - L indicates leoSettings.leo
    - M indicates myLeoSettings.leo

- Predefined 'self' in @test/@suite nodes.

- Added `c.getNodePath and c.getNodeFileName`_.
</t>
<t tx="ekr.20090324145450.36">- The ``--config`` command-line option specifies a single config (.leo) file
  to use for configuration.
  See http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

- The ``--file=fileName`` command-line option loads a file.
  Only .zip and .leo extensions are allowed at present.

- The ``--gui=name`` command-line option specifies the gui to use.
  The valid values are ``--gui=qt`` and ``--gui=tk``.
</t>
<t tx="ekr.20090324145450.40">- Added smart home (back-to-home) command.

- Added support for standard behavior of Tab and Shift-Tab keys.
  The tab key indents the text selection, if there is one;
  otherwise, the tab key insert a tab or blanks, depending on the @tabwidth setting.
  Shift-Tab always unindents one or more lines.

- The open command creates @edit nodes when opening non-.leo files
  The open file dialog now shows all files by default.
  Selecting a non-.leo file will load that file into a new node in the present outline.

- Added added pdb minibuffer command.
  This works, but stops Leo in the middle of the command-handling logic.
  You may get the commander c by stepping out into
  k.masterKeyHandler or k.masterCommandHandler.
  Using c, you can then get all other info.

- Improved the isearch commands.

- find-clone-all is a synonym for clone-find-all.

- open-quickstart-leo command opens leo/doc/quickstart.leo.

- The Alt-Right and Alt-Left keys (expand-and-go-right and contract-or-go-left
  commands) now move to the previous or next node if now left/right movement is
  possible.
</t>
<t tx="ekr.20090324145450.46">- Added @nocolor-node directive.

- Improved \@path handling.
</t>
<t tx="ekr.20090324145450.49">.. _`meta keys`: http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1

- @string default_leo_file = ~/.leo/workbook.leo

- @string underindent-escape-string = \-

- @int icon_bar_widgets_per_row

- Added support for `meta keys`_.

- The qt gui is now the default.

- The old bindings bound the PageUp/Down keys to back/forward page commands, and
  these commands work only for text.

  The new default bindings in leoSettings.leo: @keys EKR bindings are::

    back-page                       ! text = PageUp
    back-page-extend-selection      ! text = Shift-PageUp
    forward-page                    ! text = PageDn
    forward-page-extend-selection   ! text = Shift-PageDn

    scroll-down-half-page   ! tree = Shift-PageDn
    scroll-down-page        ! tree = PageDn
    scroll-up-half-page     ! tree = Shift-PageUp
    scroll-up-page          ! tree = PageUp    

- @bool enable_alt_ctrl_bindings.
  The default is False, needed for AltGr functionality on Windows.
</t>
<t tx="ekr.20090324145450.54">- Improved nav_buttons plugin and corresponding nodeHistory class.

- Created qtGui and tkGui plugins.

- Created leoGuiPluginsRef.leo.

- Leo issues an error message if a non-existent plugin appears
  in an @enabled-plugin node.

- New plugins: spydershell.py, qtframecommands.py, and mod_framesize.py.
</t>
<t tx="ekr.20090402072059.13">http://groups.google.com/group/leo-editor/browse_thread/thread/4ec30df3f1db8db3

On Sat, Mar 28, 2009 at 3:24 AM, VR &lt;viktor.ransmayr@gmail.com&gt; wrote:


    When I tried to de-install Leo-4.6b1 I succeeded, but the program
    reported that 5 directories
    were not removed.

    Three of the directories where

    1) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\config
    2) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\doc
    3) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\plugins

    [containing]


    a) .leoSettings.leo_db
    b) .leoDocs.leo_db
    c) .leo_shadow
    d) .leoPluginsRef.leo_db


Thanks for this report. I think it is important, and needs a good solution.

I dislike all these files being sprayed around the file system. I'd like to see
these files placed somewhere the ~/.leo directory. Is there a reason why this
would be a bad idea?

Similarly, we might also prefer to have shadow files place in, say,
~/.leo/shadow_files.

In both cases, I think we want to create files that indicate their location.
Either that, or mirror their location in (subdirectories) ~/.leo. In other
words, this is a general problem, and it would be good to have a robust, general
solution.
</t>
<t tx="ekr.20090428102353.1">.. Leo documentation documentation master file, created by
.. sphinx-quickstart on Mon Mar 30 16:39:02 2009.
.. You can adapt this file completely to your liking, but it should at least
.. contain the root `toctree` directive.

.. 2013/10/08: This page now *does* generate the real TOC.

Leo's Documentation Page
========================

.. toctree::
   :maxdepth: 1
   
   index 

.. toctree::
   :maxdepth: 2
   
   preliminaries
   
.. toctree::
   :maxdepth: 1

   getting-started
   
.. toctree::
   :maxdepth: 1

   Cheat Sheet &lt;cheatsheet&gt;
   
.. toctree::
   :maxdepth: 2

   screencasts
   
   Tutorial &lt;tutorial&gt;
   
   Users Guide &lt;usersguide&gt;
   
   leoandotherprograms
   
   intermediatetopics
   
   appendices

.. toctree::
   :maxdepth: 1
 
   apidoc/index
   
   FAQ
   
   glossary
   
   What's New &lt;what-is-new&gt;

.. toctree::
   :glob:
   :hidden:
   
   apidoc/*

.. toctree::
   :hidden:
   
   slides
   leoLinks
   screen-shots
    </t>
<t tx="ekr.20090601083544.6066">These are plugins/projects that I'd like to investigate further.

interact.py:  Add buttons so leo can interact with command line environments.
</t>
<t tx="ekr.20090620073906.11072">Leo 4.6 beta 2                                  June 22, 2009

Leo 4.6 b2 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes support "round-tripping" of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090620073906.11073"></t>
<t tx="ekr.20090620073906.11074"></t>
<t tx="ekr.20090620073906.11081">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behavior (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible character on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.
</t>
<t tx="ekr.20090620073906.11083">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.
</t>
<t tx="ekr.20090620073906.11086">http://mail.google.com/mail/#inbox/11ef0076a3f4d866
</t>
<t tx="ekr.20090620073906.11087">This is reasonable now that old-style file indices are rare.
</t>
<t tx="ekr.20090620073906.11091">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load 
</t>
<t tx="ekr.20090620073906.11094">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!
</t>
<t tx="ekr.20090620073906.11107">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundantly and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.
</t>
<t tx="ekr.20090620073906.11137">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090620073906.11296">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4
</t>
<t tx="ekr.20090620073906.11349"></t>
<t tx="ekr.20090620073906.11352">The outline wasn't being redrawn properly.
</t>
<t tx="ekr.20090620073906.11374"></t>
<t tx="ekr.20090620073906.11376">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.
</t>
<t tx="ekr.20090620073906.11377">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.
</t>
<t tx="ekr.20090620073906.11378">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.
</t>
<t tx="ekr.20090620073906.11380">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.
</t>
<t tx="ekr.20090620073906.11387">http://bugs.launchpad.net/leo-editor/+bug/376189
</t>
<t tx="ekr.20090620073906.11390"></t>
<t tx="ekr.20090620073906.11521">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090620073906.11564">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0
</t>
<t tx="ekr.20090620073906.11590"></t>
<t tx="ekr.20090620073906.11612"></t>
<t tx="ekr.20090620073906.11620"></t>
<t tx="ekr.20090620073906.11666"></t>
<t tx="ekr.20090620073906.11707">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090620073906.11740">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.
</t>
<t tx="ekr.20090620073906.11759">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090620073906.11760">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.
</t>
<t tx="ekr.20090620073906.11771">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f
</t>
<t tx="ekr.20090620073906.11776">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090620073906.11818"></t>
<t tx="ekr.20090620073906.11824"></t>
<t tx="ekr.20090620073906.11833"></t>
<t tx="ekr.20090620073906.11850">The generated @nocolor line now ends with a newline.
</t>
<t tx="ekr.20090620073906.11864">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en
</t>
<t tx="ekr.20090620073906.11865">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8
</t>
<t tx="ekr.20090620073906.11866">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037
</t>
<t tx="ekr.20090620073906.11870"></t>
<t tx="ekr.20090620073906.11873">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.
</t>
<t tx="ekr.20090620073906.11898"></t>
<t tx="ekr.20090620073906.11923">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2
</t>
<t tx="ekr.20090620073906.11935"></t>
<t tx="ekr.20090620073906.11960">Html files are a good test case.
</t>
<t tx="ekr.20090620073906.11973"></t>
<t tx="ekr.20090620073906.11981"></t>
<t tx="ekr.20090620073906.12044">http://bugs.launchpad.net/leo-editor/+bug/383204
</t>
<t tx="ekr.20090620073906.12061"></t>
<t tx="ekr.20090620073906.12095">- leoDynamicTest.py now supports a ``--path`` argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the ``--silent`` argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.
</t>
<t tx="ekr.20090620082840.5608">Added support for @auto-rst nodes. These import reStructuredText (rST) files
so that the files can be "round-tripped" without introducing extraneous changes.
This makes Leo a superb environment for using rST.
</t>
<t tx="ekr.20090620103431.5601">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090629183608.8446">Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-&lt;object&gt; command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
</t>
<t tx="ekr.20090706042206.14718">Leo's sentinels add outline structure to source files.
However, those sentinels annoy some people who don't use Leo.

You can use @auto, @shadow or @nosent trees to edit
files that are shared with those who don't want to see sentinel comments.

- @auto is best for files whose imported outline structure often changes. In
  most cases, this will be the best option. The drawback of @auto files are a)
  you can't use clones and b) you can't add your own organizer nodes.

- @shadow will work for files whose outline structure seldom changes.
  The advantage of @shadow is that you can add your own structure.

- @nosent is appropriate only for files that you alone modify.
</t>
<t tx="ekr.20090709084001.5944">Leo 4.6 release candidate 1                             July 9, 2009

Leo 4.6 rc1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090709084001.5945"></t>
<t tx="ekr.20090709084001.5968"></t>
<t tx="ekr.20090709084001.6086"></t>
<t tx="ekr.20090709084001.6096"></t>
<t tx="ekr.20090709084001.6119"></t>
<t tx="ekr.20090709084001.6138"></t>
<t tx="ekr.20090709084001.6140"></t>
<t tx="ekr.20090709084001.6144"></t>
<t tx="ekr.20090709084001.6149"></t>
<t tx="ekr.20090709084001.6153">Various get-focus methods must translate from wrapped widget to wrapper widget.
This happens in g.app.gui.get_focus, which needs a c arg to work properly in some cases!
</t>
<t tx="ekr.20090709084001.6156"></t>
<t tx="ekr.20090709084001.6164">https://bugs.launchpad.net/leo-editor/+bug/345917
</t>
<t tx="ekr.20090709084001.6192">Exact repro steps (using trunk):

Help -&gt; open quickstart.leo

Go to Programming--&gt;External files--&gt;reStructuredText (@auto-
rst)--&gt;@path ~--&gt;@@auto-rst myfile_rst.txt

Remove first @ from @auto-rst

Save =&gt; exception occurs.
</t>
<t tx="ekr.20090709084001.6204">@test nodes in the generated file were being run when modules were imported.

The fix was to set g.unitTesting = False while importing in safeImportModule.
</t>
<t tx="ekr.20090709084001.6238"></t>
<t tx="ekr.20090709084001.6241"></t>
<t tx="ekr.20090709084001.6254">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/394965

Several changes:

- Fixed bug in runLeo.py.completeFileName.
  Do not add ".leo" suffix if the file exists without it!

- Fixed (???) the bug by not calling g.doHook("new"...) in g.openWrapperFile.
  This **might** be a perfect fix, but maybe not.
  But if a bug remains, it might be less bad than the duplicated buttons bug :-)
</t>
<t tx="ekr.20090709084001.6283">The culprit was the code in atFile.read that deleted all children.

Added several important new unit tests.
</t>
<t tx="ekr.20090709084001.6291">Also added test for leoQtBody to existing test.
</t>
<t tx="ekr.20090709084001.6296"></t>
<t tx="ekr.20090709084001.6297"></t>
<t tx="ekr.20090709084001.6300">This was a binding issue. Leo has a full range of scrolling commands. They work.

The old bindings bound the PageUp/Down keys to back/forward page commands, and
these commands work only for text.

The new default bindings in leoSettings.leo: @keys EKR bindings are:

back-page                       ! text = PageUp
back-page-extend-selection      ! text = Shift-PageUp
forward-page                    ! text = PageDn
forward-page-extend-selection   ! text = Shift-PageDn

scroll-down-half-page   ! tree = Shift-PageDn
scroll-down-page        ! tree = PageDn
scroll-up-half-page     ! tree = Shift-PageUp
scroll-up-page          ! tree = PageUp         
</t>
<t tx="ekr.20090709084001.6301">Leo now prints an error message when @enabled-plugins node contains a plugin
that does not exist.
</t>
<t tx="ekr.20090709084001.6304"></t>
<t tx="ekr.20090709084001.6307">Warn if the file exists and has never been read. This prevents a newly-created
@auto node from overwriting an existing file.
</t>
<t tx="ekr.20090711120622.10447">################
Leo screen shots
################

</t>
<t tx="ekr.20090713080429.6042">http://groups.google.com/group/leo-editor/browse_thread/thread/bd3e06a8a34a1938

This is the first time we have done this ("stable" branch + trunk),
so it might be good to bring this up:

- When doing a bugfix/improvement, always do it in the oldest branch that will
  receive it.

- Only after that, merge it to trunk

This prevents "manual" merges, and accidental incorporation of unwanted fixes.
It also gives us clean merge history.

I think this is the process python-the-project will use with mercurial. If they
find a bug in python 2.6.whatever, they fix it in that branch first, then merge
from that branch to trunk (so python 2.7 will receive it).

===================

http://groups.google.com/group/leo-editor/browse_thread/thread/3f24628c7f735c42

&gt; I'll probably open a branch (based on the 4-6-final branch) to
  attempt a fix for an rst bug.

You don't need to create the branch on launchpad to do little fixes. The local
branch you create with "bzr branch" is a full-blown branch.

Here's how I do all my commits to trunk:

I have ~/leotrunk. I always keep this up to date with "bzr pull", but never
develop here.  (But I merge from leo-editor, as shown below.)
EKR: I call this main-trunk.

I have ~/leo-editor, also created from trunk. I develop here normally.
Occasionally, I just "bzr push", but often it fails because "branches have
diverged". I resist the temptation to "bzr merge" here, because it screws up
history. Rather, I:

- cd ~/leotrunk
- bzr pull (this always succeeds)
- bzr merge ~/leo-editor
- (investigate diffs)
- bzr qcommit (select the files I really want to commit--usually .py files)
- bzr push

Then, to get my ~/leo-editor up to date again:

cd ~/leo-editor
bzr pull 
</t>
<t tx="ekr.20090717084250.10704"></t>
<t tx="ekr.20090717084250.10808">Leo 4.6 final                             July 15, 2009

Leo 4.6 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.6:
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090717084250.10809"></t>
<t tx="ekr.20090717084250.10810"></t>
<t tx="ekr.20090717084250.10811">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.
</t>
<t tx="ekr.20090717084250.10812">This is reasonable now that old-style file indices are rare.
</t>
<t tx="ekr.20090717084250.10813">Html files are a good test case.
</t>
<t tx="ekr.20090717084250.10814"></t>
<t tx="ekr.20090717084250.10815">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.
</t>
<t tx="ekr.20090717084250.10816"></t>
<t tx="ekr.20090717084250.10817">http://bugs.launchpad.net/leo-editor/+bug/383204
</t>
<t tx="ekr.20090717084250.10818">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8
</t>
<t tx="ekr.20090717084250.10819">The generated @nocolor line now ends with a newline.
</t>
<t tx="ekr.20090717084250.10820">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0
</t>
<t tx="ekr.20090717084250.10821">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4
</t>
<t tx="ekr.20090717084250.10822">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behavior (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible character on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.
</t>
<t tx="ekr.20090717084250.10823">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090717084250.10824"></t>
<t tx="ekr.20090717084250.10825"></t>
<t tx="ekr.20090717084250.10826">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090717084250.10827">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load 
</t>
<t tx="ekr.20090717084250.10828">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.
</t>
<t tx="ekr.20090717084250.10829"></t>
<t tx="ekr.20090717084250.10830">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090717084250.10831">http://bugs.launchpad.net/leo-editor/+bug/376189
</t>
<t tx="ekr.20090717084250.10832">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090717084250.10833">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090717084250.10834">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.
</t>
<t tx="ekr.20090717084250.10835">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en
</t>
<t tx="ekr.20090717084250.10836">The outline wasn't being redrawn properly.
</t>
<t tx="ekr.20090717084250.10837">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.
</t>
<t tx="ekr.20090717084250.10838"></t>
<t tx="ekr.20090717084250.10839"></t>
<t tx="ekr.20090717084250.10840">http://mail.google.com/mail/#inbox/11ef0076a3f4d866
</t>
<t tx="ekr.20090717084250.10841">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.
</t>
<t tx="ekr.20090717084250.10842"></t>
<t tx="ekr.20090717084250.10843">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037
</t>
<t tx="ekr.20090717084250.10844"></t>
<t tx="ekr.20090717084250.10845">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundantly and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.
</t>
<t tx="ekr.20090717084250.10846">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.
</t>
<t tx="ekr.20090717084250.10847">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090717084250.10848">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!
</t>
<t tx="ekr.20090717084250.10849"></t>
<t tx="ekr.20090717084250.10850"></t>
<t tx="ekr.20090717084250.10851"></t>
<t tx="ekr.20090717084250.10852">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f
</t>
<t tx="ekr.20090717084250.10853"></t>
<t tx="ekr.20090717084250.10854"></t>
<t tx="ekr.20090717084250.10855"></t>
<t tx="ekr.20090717084250.10856"></t>
<t tx="ekr.20090717084250.10857">The code should save/restore, just as in the clean_file function (from scripts.leo)
</t>
<t tx="ekr.20090717084250.10858">The problem was missing calls to initAfterLoad in c.new.
</t>
<t tx="ekr.20090717084250.10859">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90
</t>
<t tx="ekr.20090717084250.10860"></t>
<t tx="ekr.20090717084250.10861"></t>
<t tx="ekr.20090717084250.10862">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090717084250.10863">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30
</t>
<t tx="ekr.20090717084250.10864">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090717084250.10865">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.
</t>
<t tx="ekr.20090717084250.10866">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.
</t>
<t tx="ekr.20090717084250.10867"></t>
<t tx="ekr.20090717084250.10868"></t>
<t tx="ekr.20090717084250.10869"></t>
<t tx="ekr.20090717084250.10870">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo
</t>
<t tx="ekr.20090717084250.10871">@string underindent-escape-string = \-
</t>
<t tx="ekr.20090717084250.10872">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf
</t>
<t tx="ekr.20090717084250.10873"></t>
<t tx="ekr.20090717084250.10874">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color
</t>
<t tx="ekr.20090717084250.10875"></t>
<t tx="ekr.20090717084250.10876">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName
</t>
<t tx="ekr.20090717084250.10877">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u
</t>
<t tx="ekr.20090717084250.10878"></t>
<t tx="ekr.20090717084250.10879">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo
</t>
<t tx="ekr.20090717084250.10880"></t>
<t tx="ekr.20090717084250.10881">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
</t>
<t tx="ekr.20090717084250.10882"></t>
<t tx="ekr.20090717084250.10883">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
</t>
<t tx="ekr.20090717084250.10884">Only .zip and .leo extensions are allowed at present.
</t>
<t tx="ekr.20090717084250.10885"></t>
<t tx="ekr.20090717084250.10886"></t>
<t tx="ekr.20090717084250.10887"></t>
<t tx="ekr.20090717084250.10888">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090717084250.10889">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.
</t>
<t tx="ekr.20090717084250.10890">- Tab = indent when there is a text selection
- Shift-Tab unindents always
</t>
<t tx="ekr.20090717084250.10891">Escape now ends isearch
</t>
<t tx="ekr.20090717084250.10892"></t>
<t tx="ekr.20090717084250.10893"># Useful: we don't need a closing @color to enable coloring in descendants.
</t>
<t tx="ekr.20090717084250.10894"></t>
<t tx="ekr.20090717084250.10895"></t>
<t tx="ekr.20090717084250.10896">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090717084250.10897"></t>
<t tx="ekr.20090717084250.10898">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1
</t>
<t tx="ekr.20090717084250.10899">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.
</t>
<t tx="ekr.20090717084250.10900"></t>
<t tx="ekr.20090717084250.10901"></t>
<t tx="ekr.20090717084250.10902"></t>
<t tx="ekr.20090717084250.10903">This contains all gui plugins.
</t>
<t tx="ekr.20090717084250.10904"></t>
<t tx="ekr.20090717084250.10905">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2
</t>
<t tx="ekr.20090717084250.10906">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.
</t>
<t tx="ekr.20090717084250.10907"></t>
<t tx="ekr.20090717084250.10908"></t>
<t tx="ekr.20090717084250.10909"></t>
<t tx="ekr.20090717084250.10910">Leo now warns on dangerous writes to @thin and @file nodes.
</t>
<t tx="ekr.20090718092032.10405">Leo 4.6.1 final                             July 30, 2009

Leo 4.6.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.6.1 fixes several minor bugs in Leo 4.6.


The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090718092032.10406"></t>
<t tx="ekr.20090718092032.10407"></t>
<t tx="ekr.20090718092032.10408">A patch at the start of loadOnePlugin prevents leo from crashing and allows the
gui prompt for a leoID to come up.
</t>
<t tx="ekr.20090718092032.10409">This is reasonable now that old-style file indices are rare.
</t>
<t tx="ekr.20090718092032.10410">Html files are a good test case.
</t>
<t tx="ekr.20090718092032.10411"></t>
<t tx="ekr.20090718092032.10412">http://bugs.launchpad.net/leo-editor/+bug/376634

The fix was to putVnodes.
</t>
<t tx="ekr.20090718092032.10413"></t>
<t tx="ekr.20090718092032.10414">http://bugs.launchpad.net/leo-editor/+bug/383204
</t>
<t tx="ekr.20090718092032.10415">http://groups.google.com/group/leo-editor/browse_thread/thread/981c27d5c24c90f8
</t>
<t tx="ekr.20090718092032.10416">The generated @nocolor line now ends with a newline.
</t>
<t tx="ekr.20090718092032.10417">http://groups.google.com/group/leo-editor/browse_thread/thread/6cab5e676d4d75a0
</t>
<t tx="ekr.20090718092032.10418">- Removed forceGnxOnPosition from leoImport.py and leoAtFile.py.

- readStartNode now always uses root.v for the first node
  instead of calling createThinChild4
</t>
<t tx="ekr.20090718092032.10419">https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behavior (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible character on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.
</t>
<t tx="ekr.20090718092032.10420">The @verbatim was being inserted into the outline.
</t>
<t tx="ekr.20090718092032.10421"></t>
<t tx="ekr.20090718092032.10422"></t>
<t tx="ekr.20090718092032.10423">The problem arose when reading a zipped file:

 File "C:\Programme\Leo-4-6-b1\leo\core\leoFileCommands.py", line
1265, in parse_leo_file
   s = theFile.read()
TypeError: read() takes at least 2 arguments (1 given)
saved: [zipped] Dive-into-Python-3.leo
</t>
<t tx="ekr.20090718092032.10424">exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load 
</t>
<t tx="ekr.20090718092032.10425">http://bugs.launchpad.net/leo-editor/+bug/362048

I have 'dabbrev-expands' bound to the F4 key. When I press F4 after
the word "freq" in a body pane containing the word "frequency" then
Leo 4.5.1 shows a hour-glass for a while before giving an empty
dabbrev-expand: prompt in the minibuffer.

If I back up one character, putting point between the e and q and then
type F4, I get the expected behavior: the word "frequency" is inserted
immediately.

What I did:

- Removed "not ready messages".
- Made the code undoable.
- Added wimpy unit test.
</t>
<t tx="ekr.20090718092032.10426"></t>
<t tx="ekr.20090718092032.10427">Added call to isFKey in k.handleUnboundKeys.
</t>
<t tx="ekr.20090718092032.10428">http://bugs.launchpad.net/leo-editor/+bug/376189
</t>
<t tx="ekr.20090718092032.10429">http://bugs.launchpad.net/leo-editor/+bug/382221
</t>
<t tx="ekr.20090718092032.10430">http://bugs.launchpad.net/leo-editor/+bug/363403

With a long body text you might place the cursor on a line, hold down Shift, and
PgDn several pages to select a large block of text. The last PgDn may overshoot
the range you want selected, so you should be able to use UpArrow to bring the
bottom of the range back up to where you want it. However, on the first UpArrow
the selection is lost and restarted from the current cursor position. I.e. you
end up with just one line selected, instead of trimming one line of the
selection of several pages, as intended.
</t>
<t tx="ekr.20090718092032.10431">http://bugs.launchpad.net/leo-editor/+bug/306671

If a Leo editor window is opened, and the "NewHeadline" node is renamed to
"@auto &lt;path to some valid file&gt;", and then the "File-&gt;Read/Write-&gt;Read @auto
nodes" menu option is selected, the renamed node reverts to its previous name
("NewHeadline"), and nothing is loaded into the node.
</t>
<t tx="ekr.20090718092032.10432">http://groups.google.com/group/leo-editor/browse_thread/thread/21bddd50f3400bdc?hl=en
</t>
<t tx="ekr.20090718092032.10433">The outline wasn't being redrawn properly.
</t>
<t tx="ekr.20090718092032.10434">http://groups.google.com/group/leo-editor/browse_thread/thread/430287018f9d773d

The fix to minibufferFind.changeAll fixes a bug that is several years old.
The fix to findNextMatch fixes a bug that is likely much older than that.
</t>
<t tx="ekr.20090718092032.10435"></t>
<t tx="ekr.20090718092032.10436"></t>
<t tx="ekr.20090718092032.10437">http://mail.google.com/mail/#inbox/11ef0076a3f4d866
</t>
<t tx="ekr.20090718092032.10438">The crash happened inside the call to::

    c.widgetWantsFocusNow(event.widget)

in callAltXFunction. Actually, the crash happened later, in c.outerUpdate.

A better fix would be to use wrappers for all edit widgets, and recalculate the
edit widget any it needs to be used.
</t>
<t tx="ekr.20090718092032.10439"></t>
<t tx="ekr.20090718092032.10440">http://groups.google.com/group/leo-editor/browse_thread/thread/606277d73b193037
</t>
<t tx="ekr.20090718092032.10441"></t>
<t tx="ekr.20090718092032.10442">onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundantly and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.
</t>
<t tx="ekr.20090718092032.10443">http://bugs.launchpad.net/leo-editor/+bug/353925

The "kill-region" function did nothing when using the qt gui.

The fix was to replace tag_ranges with w.getSelectionRange, etc.
This was the only call to tag_ranges in the core.
</t>
<t tx="ekr.20090718092032.10444">http://bugs.launchpad.net/leo-editor/+bug/377907

I'm going to mark this invalid, although the behavior is way too confusing.

I added the following to the plugin's docstring:

Configuration
~~~~~~~~~~~~~

At present, the file leo/plugins/leo_to_html.ini contains configuration settings.
In particular, the default export path, "c:\" must be changed for *nix systems.
</t>
<t tx="ekr.20090718092032.10445">The problem is imports in the Commands ctor. When executed the first time from
the bridge the imports take about 3/4 sec. on my machine. There is nothing that
can or should be done. Ctrl-5 is still hugely faster than opening unitTest.leo!
</t>
<t tx="ekr.20090718092032.10446"></t>
<t tx="ekr.20090718092032.10447"></t>
<t tx="ekr.20090718092032.10448"></t>
<t tx="ekr.20090718092032.10449">http://groups.google.com/group/leo-editor/browse_thread/thread/a04dcefbb672078f
</t>
<t tx="ekr.20090718092032.10450"></t>
<t tx="ekr.20090718092032.10451"></t>
<t tx="ekr.20090718092032.10452"></t>
<t tx="ekr.20090718092032.10453"></t>
<t tx="ekr.20090718092032.10454">The code should save/restore, just as in the clean_file function (from scripts.leo)
</t>
<t tx="ekr.20090718092032.10455">The problem was missing calls to initAfterLoad in c.new.
</t>
<t tx="ekr.20090718092032.10456">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90
</t>
<t tx="ekr.20090718092032.10457"></t>
<t tx="ekr.20090718092032.10458"></t>
<t tx="ekr.20090718092032.10459">Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090718092032.10460">http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30
</t>
<t tx="ekr.20090718092032.10461">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2
</t>
<t tx="ekr.20090718092032.10462">http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

Calls g.makeAllNonExistentDirectories instead of os.mkdir.
</t>
<t tx="ekr.20090718092032.10463">http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

No changes were made in modes/c.py or modes/c.xml.
</t>
<t tx="ekr.20090718092032.10464"></t>
<t tx="ekr.20090718092032.10465"></t>
<t tx="ekr.20090718092032.10466"></t>
<t tx="ekr.20090718092032.10467">http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Added support for @string default_leo_file = ~/.leo/workbook.leo
</t>
<t tx="ekr.20090718092032.10468">@string underindent-escape-string = \-
</t>
<t tx="ekr.20090718092032.10469">http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf
</t>
<t tx="ekr.20090718092032.10470"></t>
<t tx="ekr.20090718092032.10471">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color
</t>
<t tx="ekr.20090718092032.10472"></t>
<t tx="ekr.20090718092032.10473">c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName
</t>
<t tx="ekr.20090718092032.10474">p.b, p.h and p.gnx
t.b, t.h, t.gnx and t.u
v.b, v.h, v.gnx, and v.u
</t>
<t tx="ekr.20090718092032.10475"></t>
<t tx="ekr.20090718092032.10476">c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo
</t>
<t tx="ekr.20090718092032.10477"></t>
<t tx="ekr.20090718092032.10478">http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
</t>
<t tx="ekr.20090718092032.10479"></t>
<t tx="ekr.20090718092032.10480">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
</t>
<t tx="ekr.20090718092032.10481">Only .zip and .leo extensions are allowed at present.
</t>
<t tx="ekr.20090718092032.10482"></t>
<t tx="ekr.20090718092032.10483"></t>
<t tx="ekr.20090718092032.10484"></t>
<t tx="ekr.20090718092032.10485">http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs what may have been the biggest hole in Leo's history.
</t>
<t tx="ekr.20090718092032.10486">This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.
</t>
<t tx="ekr.20090718092032.10487">- Tab = indent when there is a text selection
- Shift-Tab unindents always
</t>
<t tx="ekr.20090718092032.10488">Escape now ends isearch
</t>
<t tx="ekr.20090718092032.10489"></t>
<t tx="ekr.20090718092032.10490"># Useful: we don't need a closing @color to enable coloring in descendants.
</t>
<t tx="ekr.20090718092032.10491"></t>
<t tx="ekr.20090718092032.10492"></t>
<t tx="ekr.20090718092032.10493">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e
</t>
<t tx="ekr.20090718092032.10494"></t>
<t tx="ekr.20090718092032.10495">http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1
</t>
<t tx="ekr.20090718092032.10496">Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettings.leo is the local file.
</t>
<t tx="ekr.20090718092032.10497"></t>
<t tx="ekr.20090718092032.10498"></t>
<t tx="ekr.20090718092032.10499"></t>
<t tx="ekr.20090718092032.10500">This contains all gui plugins.
</t>
<t tx="ekr.20090718092032.10501"></t>
<t tx="ekr.20090718092032.10502">Leo can now open, for example, any .py file.
It will be put in an @edit node in an otherwise-empty outline.

This allows Leo to be associated with the edit action of .py files.
Something like this::

C:\Python26\python.exe "c:\leo.repo\trunk\launchLeo.py" --gui=qt %1 %2
</t>
<t tx="ekr.20090718092032.10503">- leoDynamicTest.py now supports a --path argument giving the .leo file.
  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.
</t>
<t tx="ekr.20090718092032.10504"></t>
<t tx="ekr.20090718092032.10505"></t>
<t tx="ekr.20090718092032.10506"></t>
<t tx="ekr.20090718092032.10507">Leo now warns on dangerous writes to @thin and @file nodes.
</t>
<t tx="ekr.20090802162204.5798">Leo 4.6.2 final                             August 3, 2009

Leo 4.6.2 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.6.2 fixes several bugs reported since Leo 4.6 was released.

The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090803084828.5800">- AltGr properly handled as Alt+Ctrl.
  Created a setting: @bool enable_alt_ctrl_bindings.
  The default is False, needed for AltGr functionality on Windows.

- Fixed unpickling problems in getDescendentUnknownAttributes

- Plugins that fail to import Pmw no longer prevent Leo from launching.

- Fixed bug 397433, tk chapter menu crash, on all platforms.
</t>
<t tx="ekr.20090811090022.14452">.. |leoQtMainWindow|    image:: /images/screen-shots/leo-main-window.png

Here is Leo's main window on Windows 7 showing
the outline pane (1),
the body pane (2),
the minibuffer (3),
the log pane, showing the find tab (4).

The body pane shows the contents of the presently selected node in the outline pane.

|leoQtMainWindow|

.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html

.. |renderRST|      image:: /images/screen-shots/render-rst.png
.. |renderSVGref|   image:: /images/screen-shots/render-svg-movie.png
.. |renderSVGsrc|   image:: /images/screen-shots/render-svg-sources.png
.. |renderSplash|   image:: /images/screen-shots/render-splash-screen.png

The following screenshots show Leo's rendering pane.  It can render `reStructuredText`_:

|renderRST|

The rendering pane can render svg pictures, including animated pictures.  Here we see
an .svg file included by reference:

|renderSVGref|

The rendering pane can also render svg sources contained in the body pane:

|renderSVGsrc|

The rendering pane can show pictures, music and movies.  Here we see Leo's splash screen:

|renderSplash|
</t>
<t tx="ekr.20090811090022.14453">.. |LinuxMainWindow| image:: /images/screen-shots/leo-qt-main-window-linux.png

Here is Leo's main window as it appears on Linux:

|LinuxMainWindow|
</t>
<t tx="ekr.20090909083000.6547">Leo 4.7 beta 1                          September 9, 2009

Leo 4.7 beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

This version of Leo is labeled a beta version because it contains some new,
relatively untested plugins.  However, Leo's core should be quite reliable.

In particular, Leo 4.7 beta 1 fixes a bug that caused Leo 4.6 releases to crash
if .leoID.txt did not exist. Usually this file does exist, but Leo will prompt
for the contents of this file (a user id) the very first time somebody uses Leo.
Alas, an unfortunate reversion of code caused Leo to crash. Not exactly the best
introduction to Leo!

The highlights of Leo 4.7:
--------------------------

- A major simplification of internal data model: the so-called
  one-node world. Note: this is **disabled** in the beta 1 release.
- A new executable Windows installer, whose manifest is created from
  the files that bzr actively manages.
- Leo no longer adds directories to sys.path on startup.
- New plugins.
- The usual assortment of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20090909083000.6552">The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
</t>
<t tx="ekr.20090909083000.6553">http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

Leo no longer adds directories to sys.path on startup.

(Merged the clean-sys-path branch into the trunk.)_
</t>
<t tx="ekr.20090909083000.6555">@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.
</t>
<t tx="ekr.20090909083000.6556">Unlike previous installers, the manifest is created from the
@button make leo.nsi script in dist.leo.
</t>
<t tx="ekr.20091006093902.6558">Leo 4.6.3 final                             September 4, 2009

Leo 4.6.3 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

Leo 4.6.3 fixes a significant caching bug in Leo 4.6.2.
Leo 4.6.3 also comes with an executable installer for Windows.
Leo 3.6.3 adds several new plugins.

The highlights of Leo 4.6
--------------------------

- Cached external files *greatly* reduces the time to load .leo files.
- Leo now features a modern Qt interface by default.
  Leo's legacy Tk interface can also be used.
- New --config, --file and --gui command-line options.
- Leo tests syntax of .py files when saving them.
- Leo can now open any kind of file into @edit nodes.
- @auto-rst nodes allow easy editing of reStructuredText files.
- Properties of commanders, positions and nodes simplify programming.
- Improved Leo's unit testing framework.
- Leo now requires Python 2.5 or later.
- Dozens of small improvements and bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20091006093902.6559">- Leo marks nodes dirty if the nodes changed during read.

- Fixed a bug in g.adjustTripleString.
</t>
<t tx="ekr.20091006093902.6560">- Added --gui=qttabs command-line option

- Added new plugins: spydershell.py, qtframecommands.py, and mod_framesize.py.

- Added "show folder" in rclick menu.
</t>
<t tx="ekr.20091105080104.9031">When using the Qt gui, you specify fonts
using the node in leoSettings.leo called::

    @data qt-gui-plugin-style-sheet

As usual, you will probably want to put this node in your myLeoSettings.leo file.
</t>
<t tx="ekr.20091111112709.6672">#########
Glossary
#########

.. Links
.. _`Customizing Leo`:              customizing.html
.. _`Writing plugins and hooks`:    writingPlugins.html
.. _`Leo's reference`:              directives.html
.. _`leo's tutorial`:               tutorial.html

This is a short glossary of important terms in Leo's world. For more information
about terms, look in the index for links to discussions in other places,
especially in `Leo's Tutorial`_ and `Leo's Reference`_.

.. glossary::
    :sorted:
</t>
<t tx="ekr.20091130111843.6787"></t>
<t tx="ekr.20091130111843.6788">################
The Leo Tutorial
################

.. index:: Leo's tutorial

.. _`Python`: http://www.python.org/

Leo is a power tool for people who want to organize, study and work with
data, especially complex data like computer programs, books, web sites and
data bases. Leonistas say Leo is a revolutionary tool and that Leo is fun
to use--even addictive.

Leo looks like other outlining programs, but it is not. This tutorial
explains the difference.

There are four parts, plus a cheatsheet. Each part will take about 30
minutes to read. The last part is optional, and assumes some familiarity
with programming in `Python`_.

.. toctree::
   :maxdepth: 1

   tutorial-basics
   tutorial-pim
   tutorial-rst3
   tutorial-programming
   tutorial-scripting


</t>
<t tx="ekr.20091217112515.6069">1. codewisecompleter.py now completes by explicit type hints (as seen in
screenhots). p, c also work, as does 'self'.

self works by scanning for parent headlines looking for "class Foo"

Work remains for presentation part (it's mouse only now) but Edward
will probably do it :-).

2. &gt; Would codewise work outside of leo, as stand-alone plugin for a text
&gt; editor?

Yes, currently Leo uses it as an external program ("codewise m
MyClass" dumps the methods in MyClass to stdout).

Someone just has to write the vim integration plugin (or whatever they
call it). OTOH, vim already has "pysmell" and the likes that do the
same thing.

==============

The version of codewise completer that works with Tk is now on trunk.
</t>
<t tx="ekr.20091217112515.6070">http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e

Ville's completer is working and very cool, here are instructions for
making it go.  They're like the instructions Ville gave, only usable ;-)

1. (done) Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. (done) Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. (done) You need a recent trunk version of leo to get the plugin which uses
the above module.

4. (done) Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
with 'op' etc.


===== Ville's response

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

&gt; Then, after restarting leo if necessary, type

&gt; c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
&gt; with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.&lt;alt+0&gt;

And self.&lt;alt+0&gt;
</t>
<t tx="ekr.20091217112515.6071">- You need to create ctags file to ~/.leo/tags. Example::

    cd ~/.leo
    ctags -R /usr/lib/python2.5 ~/leo-editor ~/my-project

- Enter text you want to complete and press alt+0 to show completions
  (or bind/execute ctags-complete command yourself).

Attempting to complete 'foo-&gt;' is useless, but 'foo-&gt;ba' will work (provided you
don't have 2000 functions/methods starting with 'ba'. 'foo-&gt;' portion is ignored
in completion search.
</t>
<t tx="ekr.20091218120633.6299"></t>
<t tx="ekr.20091218120633.6300"></t>
<t tx="ekr.20100112051224.6222">Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to &lt;character&gt;"
that requires a "copy to clipboard" operation after the "find-character"
command.

======

Maybe we just need more commands...
</t>
<t tx="ekr.20100112051224.6223">Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
</t>
<t tx="ekr.20100112051224.6226">The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
</t>
<t tx="ekr.20100112051224.6234">Vi has a collection of "z&lt;movement&gt;" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
</t>
<t tx="ekr.20100112051224.6235">Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

</t>
<t tx="ekr.20100112051224.6236">Vi supports two types of words in its commands:

1. Words that consist of only a subset of the character set and
2. words that consist of all characters except the space and tab characters.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
</t>
<t tx="ekr.20100112051224.6238">Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.

Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
</t>
<t tx="ekr.20100112051224.6239">The "--&gt; mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
</t>
<t tx="ekr.20100113075303.6270">None of these is easily solvable in Leo's present environment.
</t>
<t tx="ekr.20100113075303.6271">Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.

Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
</t>
<t tx="ekr.20100118181428.7557"></t>
<t tx="ekr.20100118181428.7559">They wiped out the newly-inserted selection range.
</t>
<t tx="ekr.20100118181428.7570">My biggest annoyance is the invalid bug 409442, I have to use the tk
GUI because of it.

I've also complained about it in this thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/07cdbb... 

----- Ville +1
I feel your pain.

Please try this workaround (run with ctrl+b):

tree = c.frame.tree.treeWidget
tree.setColumnCount(2)

-----
&gt; Isn't it possible to stick this tree.setColumnCount(2) into some
&gt; constructor in the leo qt GUI plugin so the outline pane would have
&gt; the horizontal scrollbar by default?

Yes, but it's not sure we want to have 2 columns in the tree widget -
and it would create scrollbar on many occasions when it's not
necessary.

So this is not a simple fix for your problem, it has implications
beyond your problem. 
</t>
<t tx="ekr.20100118181428.7571"></t>
<t tx="ekr.20100118181428.7614">Fixed bug Bug 498688: Undo back to last saved content still shows file as
modified ("*" in title)
</t>
<t tx="ekr.20100118181428.7712"></t>
<t tx="ekr.20100118181428.7715">Bug 362950: during body text undo selection goes nuts and view moves
</t>
<t tx="ekr.20100118181428.7830"></t>
<t tx="ekr.20100118181428.7831"></t>
<t tx="ekr.20100118181428.8070"></t>
<t tx="ekr.20100118181428.8077">Fixes bug 497332: importing xml via @data import_xml_tags does not allow dashes in tag.

For characters valid in names see:
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
</t>
<t tx="ekr.20100118181428.8090">Bug 404993: alt+U (universal argument) "freezes" leo state

Press alt+U displays "Universal argument:" in minibuffer, and there is no
obvious way to get out of this state. It seems ctrl+G gets you out of it, but
that's not really obvious. ESC should do it.
</t>
<t tx="ekr.20100118181428.8109">http://groups.google.com/group/leo-editor/browse_thread/thread/81f7bb5060ed8b01
</t>
<t tx="ekr.20100118181428.8236"></t>
<t tx="ekr.20100118181428.8239"></t>
<t tx="ekr.20100118181428.8240"></t>
<t tx="ekr.20100118181428.8242"></t>
<t tx="ekr.20100118181428.8248">Leo now adds a leading period if needed.
</t>
<t tx="ekr.20100118181428.8252"></t>
<t tx="ekr.20100118181428.8257"></t>
<t tx="ekr.20100118181428.8262"></t>
<t tx="ekr.20100118181428.8275"></t>
<t tx="ekr.20100118181428.8278"></t>
<t tx="ekr.20100118181428.8281"></t>
<t tx="ekr.20100118181428.8294"></t>
<t tx="ekr.20100118181428.8297">http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b
</t>
<t tx="ekr.20100118181428.8298">http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9
</t>
<t tx="ekr.20100118181428.8299"></t>
<t tx="ekr.20100118181428.8302">This is now bound in the EKR bindings to insert-node.
</t>
<t tx="ekr.20100118181428.8306">http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476
</t>
<t tx="ekr.20100118181428.8307"></t>
<t tx="ekr.20100118181428.8334"></t>
<t tx="ekr.20100118181428.8358">Form-feed characters were causing problems with Python 3k.
</t>
<t tx="ekr.20100118181428.8362">It can be alarming to select a small chapter in a large outline.
</t>
<t tx="ekr.20100118181428.8363"></t>
<t tx="ekr.20100118181428.8365">This fixes the following two bugs:

- 421957 When body_pane_wraps is set to true, Previous-Line and Next-Line do not
  work as expected.

- 489917 Cursor placement defect 
</t>
<t tx="ekr.20100118181428.8413">http://groups.google.com/group/leo-editor/browse_thread/thread/b84659e608ba44d5
</t>
<t tx="ekr.20100118181428.8447">http://groups.google.com/group/leo-editor/browse_thread/thread/cdf78cbca5c526be
</t>
<t tx="ekr.20100118181428.8449">Shift-PageUp/Down were not working.
</t>
<t tx="ekr.20100118181428.8473">http://bugs.launchpad.net/leo-editor/+bug/381895
</t>
<t tx="ekr.20100118181428.8481">https://bugs.launchpad.net/leo-editor/+bug/451377
</t>
<t tx="ekr.20100118181428.8485">The Tk part of this bug can not be fixed.
</t>
<t tx="ekr.20100118181428.8486">http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
</t>
<t tx="ekr.20100118181428.8497">http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
</t>
<t tx="ekr.20100118181428.8502">http://groups.google.com/group/leo-editor/browse_thread/thread/c8f3edda9de05484
</t>
<t tx="ekr.20100118181428.8514">ctrl-tab (currently binded to cycle-focus) didn't work in windows with pyqt.
</t>
<t tx="ekr.20100118181428.8517">https://bugs.launchpad.net/leo-editor/+bug/349027
</t>
<t tx="ekr.20100118181428.8518"></t>
<t tx="ekr.20100118181428.8522">https://bugs.launchpad.net/leo-editor/+bug/486433
</t>
<t tx="ekr.20100118181428.8523">https://bugs.launchpad.net/leo-editor/+bug/420988
</t>
<t tx="ekr.20100118181428.8524"></t>
<t tx="ekr.20100118181428.8525"></t>
<t tx="ekr.20100118181428.8813">Leo 4.7 beta 1                January 28, 2009

Leo 4.7 release beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 beta 1 fixes all known serious bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20100118181428.8815">Leo requires Python 2.6 or above, including Python 3.0 and above.
</t>
<t tx="ekr.20100118181428.8827"></t>
<t tx="ekr.20100119145003.7319"></t>
<t tx="ekr.20100119145003.7320"></t>
<t tx="ekr.20100119145003.7322"></t>
<t tx="ekr.20100119145003.7324"></t>
<t tx="ekr.20100119145003.7325"></t>
<t tx="ekr.20100119145003.7327">Note: changing a headline as *no effect* on an @nosent file!
The only bug was that redraw_after_head_changed must update icons.
</t>
<t tx="ekr.20100119145003.7358"></t>
<t tx="ekr.20100119145003.7531"></t>
<t tx="ekr.20100119145003.7546"></t>
<t tx="ekr.20100119145003.7612"></t>
<t tx="ekr.20100119145003.7618"></t>
<t tx="ekr.20100119145003.7625"></t>
<t tx="ekr.20100119145003.7629"></t>
<t tx="ekr.20100119145003.7632"></t>
<t tx="ekr.20100119145003.7643"></t>
<t tx="ekr.20100119145003.7718"></t>
<t tx="ekr.20100122073254.11655">This section describes the process of creating an importer for a new language.
There are a set of "importers" in leoImport.py, all based on the
baseScannerClass class. You can define your own importer by creating a subclass.
This shouldn't be too difficult: baseScannerClass is supposed to do almost all
the work. With luck, your subclass might be very simple, as with class cScanner.

**Important** As I write this, I realize that I remember very little about the
code, but I do remember its general organization and the process of creating a
new importer. The following should be all you need to write any importer.

This base class has three main parts:

1. The "parser" that recognizes where nodes begin and end.

2. The "code generator" the actually creates the imported nodes.

3. Checking code that ensures that the imported code is equivalent
   to the original code.

You should never have to change the code generators or the checking code.
Confine your attention to the parser.

The parser thinks it is looking for classes, and within classes,
method definitions.  Your job is to tell the parser how to do this.
Let's look at part of the ctor for baseScannerClass for clues::

   # May be overridden in subclasses.
   self.anonymousClasses = [] # For Delphi Pascal interfaces.
   self.blockCommentDelim1 = None
   self.blockCommentDelim2 = None
   self.blockCommentDelim1_2 = None
   self.blockCommentDelim2_2 = None
   self.blockDelim1 = '{'
   self.blockDelim2 = '}'
   self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
   self.classTags = ['class',] # tags that start a tag.
   self.functionTags = []
   self.hasClasses = True
   self.hasFunctions = True
   self.lineCommentDelim = None
   self.lineCommentDelim2 = None
   self.outerBlockDelim1 = None
   self.outerBlockDelim2 = None
   self.outerBlockEndsDecls = True
   self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
   self.sigFailTokens = []
       # A list of strings that abort a signature when seen in a tail.
       # For example, ';' and '=' in C.
   self.strict = False # True if leading whitespace is very significant.

Naturally, this looks like gibberish at first. I do *not* remember what all
these things do in detail, although obviously the names mean something. What I
*do* remember is that these ivars control the operation of the startsFunction
and startsClass methods and their helpers (especially startsHelper) and
the methods that call them, scan and scanHelper. Most of these methods have a
trace var that will enable tracing during importing.

So the strategy is simple: study startsHelper in detail, set the ivars above to
make startsHelper do what you want, and trace until things work as you want.

There is one more detail. Sometimes the ivars above are not sufficient to get
the job done. In that case, subclasses will override various methods of the
parser, but *not* the code generator. If indentation is important, you will want
to look at the Python importer. Notice that it overrides skipCodeBlock, called
by startsHelper.

That's about it. It would be pointless to give you more details, because those
details would lead you *away* from the process you need to follow. Having said
that, feel free to ask further questions. I'll be glad to answer them.
</t>
<t tx="ekr.20100124164700.11919">@nocolor-node

It looks like you should be able to put the following in an
@font node, and get restructured text bold to appear in bold on screen:

rest_keyword2_font_size = 16
rest_keyword2_font_family = Bitstream Charter
rest_keyword2_font_slant = roman
rest_keyword2_font_weight = bold

However nothing happens when I do this. The python examples in the
test.leo file work fine for me, so I'm not sure what's gone wrong.

I think that the following should also work, but it's also currently
not doing anything for me:

@color rest_keyword2_color = black

==================

Rev 2706 fixes a significant colorizer bug that caused your problem.
Previously, the colorizer inited the so-called configuration tags only
once, which is wrong. These tags are what the @font settings specify.
Now, the colorizer inits the tags when the language changes when
switching nodes.  Usually the language doesn't change, so the new code
will be approximately as fast as the old. 
</t>
<t tx="ekr.20100124164700.11920">'backward-find-character'
'find-character'
</t>
<t tx="ekr.20100124164700.11921">@nocolor-node

On Mon, Jan 18, 2010 at 9:25 PM, tfer &lt;tfetherston@aol.com&gt; wrote:

cmd.exe /k C:\PyDev\leo-editor\trunk\launchLeo.py --gui=qttabs -- ipython

1) (??) the button removal menu just flash on right mouse click, disappears immediately.

2) Leo opens up the workbook, I open a new doc in a tab, 'untitled', save it,
   get saved ... in log, however, tab title does not change unless I close and
   reload it.
</t>
<t tx="ekr.20100124164700.11922">@
The problem occurs because the QtGui.QLineEdit object goes away
when the minibuffer gets focus and the QTreeWidget loses focus.

The fix: add a 'permanent' ivar to leoQtTextWidgets, and set
this ivar to False for headline widgets.
</t>
<t tx="ekr.20100124164700.11923">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/db797dd1d4dddffb

1) Create an @thin file based outline.
2) In the @thin file, create an unreferenced section (something like a
  header &lt;&lt;This Section Is Bogus&gt;&gt;).
3) Now, File-&gt;Exit
4) A dialog box pops up
  (Save changes to leo_file.leo before quitting? Yes/No/Cancel)
5) Click "Yes"
6) In the log pane, you will see: "undefined section" and "saved: leo_file.leo"
  and in the console window, you see "undefined section: ..."

The point is that I can't kill Leo if I keep saying "Yes" to the
"Save change before quitting" dialog. This is definitely not the
intended behavior. The correct behavior would be to save the file,
give me the warning about the undefined section, and exit.

EKR: The fix was simple: write_leo_file ignores the status returned from
c.atFileCommands.writeAll.

Note that Leo writes the write error to the console as well as the log pane,
so this should be safe enough.
</t>
<t tx="ekr.20100124164700.11924"></t>
<t tx="ekr.20100124164700.11925"></t>
<t tx="ekr.20100124164700.11926">@nocolor-node

I also unhappily discovered that any file named somedoc.leo.bak will
get deleted whenever you save a file named somedoc.leo.

===========

This turned into a major refactoring of write_Leo_file.
</t>
<t tx="ekr.20100124164700.11927">https://bugs.launchpad.net/leo-editor/+bug/510148

The fix was in sortSiblings.
</t>
<t tx="ekr.20100124164700.11928">@nocolor-node

- 'encoding' arg removed from appendStringToBody, setBodyString

- There are too many usages of _bodyString !!

- There is no way to give an encoding to setBodyString:
    It should give an internal error if the s arg is not unicode.
</t>
<t tx="ekr.20100124164700.11938"></t>
<t tx="ekr.20100124164700.11944"></t>
<t tx="ekr.20100124164700.11946">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/510145

Current leo trunk, r2732, Slackware Linux

- I go to /tmp in terminal
- there is no aaa.leo there (this is important, see below why)
- I launch leo (the current working directory is /tmp)
- I select "File-&gt;Save as" menu item
- the save file dialog opens in /tmp, this is correct
- I type in the file name "aaa" then hit "Save" button
- leo dumps an error in the log pane:

exception renaming /tmp/aaa.leo to /tmp/tmpbNydoS
IOError: [Errno 2] No such file or directory: u'/tmp/aaa.leo'

=============

The solution was to create the backup file only if fileName exists.
</t>
<t tx="ekr.20100124164700.11951">@nocolor-node

Made sure _bodyString _headString used only in leoNodes.py.

We allow setting this vars in file reading code.

*** p.b/p.h setters call c.setBody/HeadString,
    which are very slow!
</t>
<t tx="ekr.20100124164700.11965">@nocolor-node

- Removed thinFile arg from atFile.read.
  atFile.read can uncache *any* cached file.
- Removed thinFile arg from initReadIvars.
- self.thinFile ivar set only in readOpenFile.
- atFile.read no longer calls scanHeaderForThin:
  we simply use the thinFile value returned by scanHeader.
- atFile.readOpenFile deletes children as needed.
</t>
<t tx="ekr.20100124164700.12027"></t>
<t tx="ekr.20100128094926.12524">These marks were just annoying.
</t>
<t tx="ekr.20100128094926.12739"></t>
<t tx="ekr.20100128094926.12756">Deleting a range of line containing unicode characters deletes too much.
</t>
<t tx="ekr.20100129054823.11924"></t>
<t tx="ekr.20100129054823.11928">- Leo now treats @file nodes just like it treats @thin nodes. This makes Leo
  much safer to use in cooperative environments that use source code control
  systems. As part of this change, Leo no longer supports @noref nodes.

- @auto-rst now works much more reliably.

- Leo now has a simple, robust, and extremely useful scheme to recover from
  clone conflicts, no matter how they may arise. This removes all the dread from
  "node changed" messages. It is easy to see what the changes were, and it is
  easy to choose what, if anything to do.

  When a clone conflict occurs, you will see a red message in the log pane and a
  "Recovered Nodes" node as the last top-level node. This node has one child per
  red message. Each of these children contains two nodes: an "old" node and a
  "new" node. Unless there are multiple conflicts for a single node, the "new"
  node will have "won": every clone contains the new node's headline and body
  text. All these nodes are plain nodes, *not* clones. It is up to you to change
  the corresponding clone nodes if you choose to do so.

- Leo minimizes unnecessary changes to .leo files. Leo writes outline-size and
  orientation to the cache in your .leo directory. This eliminates unnecessary
  changes to .leo files.

- Leo now creates temporary files in the systems standard temporary directory.
  This prevents Leo from over-writing user-generated .bak files.
</t>
<t tx="ekr.20100129054823.11931">- The ``--debug`` command-line option sets g.debug.

- The ``--version`` command-line option causes Leo
  to print it's version and exit.

</t>
<t tx="ekr.20100129054823.11934">The qt colorizer now supports font specifications in @font nodes.
</t>
<t tx="ekr.20100129054823.11935">Added options for vim plugin. The setting::

    @string vim_trigger_event = icondclick2

is the default. It opens vim when the user double-clicks the icon box.
Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.

</t>
<t tx="ekr.20100129054823.17680">Leo requires Python 2.6 or above, including Python 3.0 and above.
</t>
<t tx="ekr.20100129054823.17683">- The --debug command-line option sets g.debug.

- The --version command-line option causes Leo
  to print it's version and exit.

</t>
<t tx="ekr.20100129054823.17685">The qt colorizer now supports font specifications in @font nodes.
</t>
<t tx="ekr.20100131161507.6303"># Just make the test.  It doesn't have to pass.
</t>
<t tx="ekr.20100201192329.7018">Leo 4.7 beta 3                       February 2, 2009

Leo 4.7 beta 3 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 beta 3 fixes all known serious bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20100201192329.7095"></t>
<t tx="ekr.20100201192329.7101">This was a serious error.  It could cause clone clashes on later reloads.
</t>
<t tx="ekr.20100201192329.7106">This only happened if two nodes had the same headline.
</t>
<t tx="ekr.20100201192329.7108"></t>
<t tx="ekr.20100201192329.7113">@nocolor-node

The problem arises because an @path directive ended with ':':

    @path: aPath

What I did:

- g.get_directives_dict now carefully checks for non-whitespace following a directive.
- The qt colorizer does the same.
- Added unit test to check for this.
</t>
<t tx="ekr.20100201192329.7116">Eliminated most imports from the leo/extensions folder.

</t>
<t tx="ekr.20100201192329.7141">'utf-8' is now the official, explicit unicode encoding unless overridden when
reading files.

This simplifies the code in several ways. In particular, the 'mbcs' encoding is
never used by default, and there is no g.app.defaultEncoding argument.

The rst3 command now uses 'utf-8' for all encodings unless explicitly overridden.
</t>
<t tx="ekr.20100205152016.14053">Leo 4.7 rc 1                    February 12, 2009

Leo 4.7 release candidate 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 rc 1 fixes all known bugs in Leo, serious or minor.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20100205152016.14054">Leo now has a simple, robust, and extremely useful scheme to recover from clone
battles, no matter how they may arise. This removes all the dread from "node
changed" messages. It is easy to see what the changes were, and it is easy to
choose what, if anything to do.

It is easy to test the code to see how it works:

1. Put a clone in an external file, and put another clone in Leo
outside of any external file.

2. Change the clone outside of Leo using an external editor.

3. Reload Leo.

When a clone conflict occurs, you will see a red message in the log pane and a
"Recovered Nodes" node as the last top-level node. This node has one child per
red message. Each of these children contains two nodes: an "old" node and a
"new" node. Unless there are multiple conflicts for a single node, the "new"
node will have "won": every clone contains the new node's headline and body
text. All these nodes are plain nodes, *not* clones. It is up to you to change
the corresponding clone nodes if you choose to do so.
</t>
<t tx="ekr.20100209114432.5751"># Simplify the structure of the cache: put more into the "minor" files.
</t>
<t tx="ekr.20100209160132.11690"></t>
<t tx="ekr.20100209160132.11691"></t>
<t tx="ekr.20100209160132.11692">@nocolor-node

The fix: back-to-home is now included in k.singleLineCommandList.
</t>
<t tx="ekr.20100209160132.11694">There was code in tnodeAttributes that did something brain-dead when unit
testing, just to support a unit test!
</t>
<t tx="ekr.20100209160132.11700"></t>
<t tx="ekr.20100209160132.11701">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/6d87d95ecbc3b986

If a @path directive is within the body text of an @thin node then the
file write uses the @path directive but the file read does not.  Since
the file read cannot know of the @path directive until after it has
read the file it has no choice but to not use it.  The @thin file
write code should not use any @path declarations found in its body
text.

What I did:

- Defined g.app.atPathInBodyWarning, set by g.get_directives_dict to p.h
- g.get_directives_dict also sets d['@path_in_body'] = p.h
- c.scanAtPathDirectives doesn't set the path if d['@path_in_body'] is true.
- atFile.scanAllDirectives issues a warning if g.app.atPathInBodyWarning is true,
  but only if the issuePathWarning keyword arg is true.
</t>
<t tx="ekr.20100209160132.11711">@nocolor-node

Traceback (most recent call last):
  File "launchLeo.py", line 8, in &lt;module&gt;
    leo.core.runLeo.run()
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 95, in run
    ok = doPostPluginsInit(args,fn,relFn,script,versionFlag)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 354, in doPostPluginsInit
    c,frame = createFrame(fileName,relativeFileName,script)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 383, in createFrame
    ok, frame = g.openWithFileName(relativeFileName or fileName,None)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2439, in openWithFileName
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2502, in handleOpenHooks
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 911, in open
    silent=silent)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 811, in getLeoFile
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 659, in readAll
    at.readOneAtAutoNode (fileName,p)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 732, in readOneAtAutoNode
    self.writeCachedTree(p, cachefile)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 593, in writeCachedTree
    elif cachefile in c.db:
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 138, in __contains__
    return self.has_key(key)
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 234, in has_key
    value = self[key]
  File "c:\leo.repo\trunk\leo\external\pickleshare.py", line 160, in __getitem__
    fil = self.root / key
  File "c:\leo.repo\trunk\leo\external\path.py", line 102, in __div__
    return path(os.path.join(self, rel))
  File "c:\python31\lib\ntpath.py", line 111, in join
    elif isabs(b):
  File "c:\python31\lib\ntpath.py", line 92, in isabs
    s = splitdrive(s)[1]
  File "c:\python31\lib\ntpath.py", line 198, in splitdrive
    if len(p) &gt; 1:
TypeError: object of type 'NoneType' has no len()

c:\leo.repo\trunk&gt;
</t>
<t tx="ekr.20100209160132.11712">@nocolor-node

Adding a blank line did not change the file!

The culprit was the ignoreLineEndings logic in compareFiles.
A new unit test is needed.
</t>
<t tx="ekr.20100209160132.11718">@nocolor-node

What I did:

- fc.createBackupFile now calls shutils.move directly,
  avoiding g.utils_rename which does way too much:
  it calls g.makeAllNonExistentDirectories(!!)

- Simplified g.utils_rename.  We can assume shutils exists.

- Removed an unwise call to g.utils_remove in g.utils_rename.
  This could cause havoc with the following call to
  shutils_move!!
</t>
<t tx="ekr.20100209160132.11736"></t>
<t tx="ekr.20100209160132.11742">Removed call to g.makeAllNonExistentDirectories in g.utils_rename.

This has global effects. Happily, there were only three callers of g.utils_rename:

- handleWriteLeoFileException: should *not* create directories.

- x.rename: no longer used!
</t>
<t tx="ekr.20100209160132.11751">Non-extending cursor moves now always clear the selection.
</t>
<t tx="ekr.20100209160132.11755"></t>
<t tx="ekr.20100209160132.11756">The title says it all.

This was likely fixed at rev 2438 of the trunk, in early October, 2009.
</t>
<t tx="ekr.20100209160132.11765">@nocolor-node

The module imported correctly, but leoTest.checkFileSyntax was failing.

It was a whitespace problem--the fix was stripping '\r' characters in checkFileSyntax.
</t>
<t tx="ekr.20100209160132.11767"></t>
<t tx="ekr.20100209160132.11770">@nocolor-node

There may have been a bug in the (no-longer-existing) open_with plugin that allowed it to be active
when it shouldn't have been.
</t>
<t tx="ekr.20100209160132.11771">@nocolor-node

I am getting an exception when double-clicking to rename a node. The
exception does not occur when I rename a new node immediately
following creation while it is highlighted.

#---#
Leo Log Window
Leo 4.7 beta 3, build 2835, February 2, 2010
Python 3.1.1, qt version 4.6.1
Windows 6, 1, 7600, 2,
reading: C:\Users\skrivsm\Documents\toolbox\scratch\ruby_scratch.leo
creating:   newHeadline_LeoTemp_63898064.py
exception creating temp file
Traceback (most recent call last):
 File "C:\leo-editor\trunk\leo\core\leoCommands.py", line 1164, in
createOpenWithTempFile
   f.write(s)
TypeError: must be str, not bytes
recreating:   newHeadline_LeoTemp_63898064.py
exception creating temp file
Traceback (most recent call last):
 File "C:\leo-editor\trunk\leo\core\leoCommands.py", line 1164, in
createOpenWithTempFile
   f.write(s)
TypeError: must be str, not bytes
#---#
</t>
<t tx="ekr.20100209160132.11773">https://bugs.launchpad.net/leo-editor/+bug/518823

Clone headline modification not propagated after edit
</t>
<t tx="ekr.20100209160132.11888">@nocolor-node

Global entries are in g.app.leoHomeDir/db/global

Per-leo-files entries are in g.app.homeLeoDir/db/&lt;filename&gt;_&lt;hash&gt;
</t>
<t tx="ekr.20100209160132.5770">Top-level folder are direct subfolders of .leo/db.
Top-level folders represent file *locations* not file contents.
Exception: the top-level "globals" folder represents minor data.

Only two files are ever needed in a top-level folder:

contents_&lt;key&gt;: the contents of the file.
data_&lt;key&gt;: a dict representing the "minor data" of the file:
    &lt;globals&gt; element stuff, expansion bits, etc.

We write contents_&lt;key&gt; only once.
By definition, its contents never changes, since the contents generates the key.
We can write data_&lt;key&gt; as many times as we like.

To do:
- Simplify or even eliminate the path-manipulation code in PickleShareDB.
- Use g.makeAllNonExistentDirectories to make top-level directories.
- Clear cache should clear all top-level directories.
</t>
<t tx="ekr.20100210163813.5748">This is a recent bug, but imo it has uncovered some other caching buglets. These
buglets are not big enough to delay Leo 4.7, but the new caching scheme would
ensure they never bite.

1. The code that computes what I have been calling the top-level directory is dubious::

    dbdirname = join(g.app.homeLeoDir,'db',
            '%s_%s' % (bname,hashlib.md5(fn).hexdigest()))

The problem is that bname is only the base name of the cached file, not a name
(or key) that depends on the full path. Thus, two copies of the same file in the
same place will be cached in the same directory. Is this ominous?

2. It's not clear what caching to do with the save-to command.
</t>
<t tx="ekr.20100211095442.6201">1. Memory does leak, and that's not ok with me.  And I want just two
files per top-level directory.

2. Strange things can happen with caching, as just happened to me when
I restored qtui_generate.py mistakenly deleted from leo/test.  There
is an @auto node for this file in qtGui.py, and I got improper 'can
not open' messages for this file.

3. It is troubling that the present caching scheme does not use the
full path to a file, only the basename.  This means that two identical
files in two different places will use the same cache entries.  I've
been wondering for the last several days about whether this could
cause problems.  I don't know for sure, but I am uncomfortable.

4. I want the clear-cache and clear-all-caches commands to do what
they say: get rid of everything.  Among other things, this is good for
debugging and recovering from cache problems.

</t>
<t tx="ekr.20100211125418.11596"></t>
<t tx="ekr.20100211125418.11599">This bug was highly annoying: it caused the newly-selected node to have the
insert point of a just-deleted node. This bug made it difficult, for example, to
delete nodes while examining the nodes created by clone-find-all.
</t>
<t tx="ekr.20100211125418.11602"></t>
<t tx="ekr.20100211125418.11611"></t>
<t tx="ekr.20100211221936.7098">- The clear-cache and clear-all-caches commands.
</t>
<t tx="ekr.20100219083854.5615"></t>
<t tx="ekr.20100223063657.7182"># This fixed a Python 3.x compatibility problem.
</t>
<t tx="ekr.20100223063657.7192"></t>
<t tx="ekr.20100223063657.7212">The edit pane lost focus after save commands.
</t>
<t tx="ekr.20100223063657.7232">fileKey is needed even if force is True.
</t>
<t tx="ekr.20100223063657.7238">https://bugs.launchpad.net/leo-editor/+bug/508108
</t>
<t tx="ekr.20100223063657.7245">Default fonts were not being properly restored after being overridden in another language.

For example, after colorizing php, python keywords looked like php keywords.
</t>
<t tx="ekr.20100223063657.7246">The bug: Find/change prompts were not fully protected after the user hit the
&lt;home&gt; key.
</t>
<t tx="ekr.20100223063657.7249"></t>
<t tx="ekr.20100223063657.7262">Leo 4.7 final                    February 23, 2010

Leo 4.7 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7 final fixes all known bugs in Leo.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20100223063657.7263"></t>
<t tx="ekr.20100223063657.7264"></t>
<t tx="ekr.20100223075705.5635"></t>
<t tx="ekr.20100223100750.5842">http://groups.google.com/group/pyxides

Robin Dunn's post, reproduced at:
http://groups.google.com/group/leo-editor/browse_thread/thread/4f76a0f57759aba
continues to be one of the benchmarks for Leo.

Leo 4.7 went out the door today.  It contains many important
improvements, but few directly related to Robin's important post.
That doesn't mean Robin's post is irrelevant, but it does mean that
other considerations were more relevant :-)  In particular, Leo passes
all unit tests with Python 2.6 and Python 3.1.

Leo 4.8 will concentrate on better support for vim-like bindings.  As
a happy side effect, this will make Leo compliant with almost all
unfinished aspects of Robin's mission.

There are two major items from Robin's list that are incomplete in
Leo:

* The Kill-Ring.  Leo does have a kill ring.  The vim work will fix
discrepancies between how Leo, emacs and vim handle the kill ring.

* Good keystroke macro recording and the ability to save and load
keystroke macros.  This happen as part of support for vim's "dot"
command.  To some extent, Leo's execute-script command compensates for
wimpy macro support, but I'd like to do better.

The following could be done easily using Leo's @command or @button
features.  There doesn't seem to be much demand for them in Leo, but
I'll list them here for completeness.

- Flexible build/grep commands.
- Interactive diffs, merges and applying of patches.
- Able to be a front-end for gdb. (Leo has a plugin to do this).
- Able to be a front-end for CVS, SVN, etc.
- Have a built-in psychotherapist or be able to play towers of
hanoi.  ;-)

As always, I invite you all to try Leo, and to ask for features that
would be important to you.

======

P.S. Leo does have auto-completion.  It will be improved in Leo 4.9.

</t>
<t tx="ekr.20100223100750.5843">Here are the emacs features that I use very often that any editor would
need to have in order for me to switch.  I've seen some editors with
some of these, but none with all unless it is an emacs clone.  I'll
leave out the obvious things like platform independence, good syntax
highlighting, calltips or auto-completion.  Also, these features are
just dealing with the code editor portion of the app, if it is more than
that (like a full IDE) then some of these things may or may not apply to
the non code editor parts:

* (done) Python should be just one of the languages that this editor supports,
not the primary target.  I spend as much time in C/C++ as I do Python,
and my editor of choice needs to help me with C/C++ coding just as much
as it does with Python.  So some sort of support for calltips and
auto-completion would be marvelous, and also being able to act as a
front-end for gdb since I currently use emacs for that most of the time.

* (done) Absolutely every feature or action must be able to be done with just
the keyboard.  Moving the hand back and forth to the mouse wastes time,
breaks concentration and contributes to RSI.  Multi-key sequences are
fine as long as they are grouped in a logical fashion.  For example in
emacs all of the version control features are accessible via the
Ctrl-x,v sequence plus one more letter.

* (done) Incremental search, both forward and reverse, and wrapping around
after you've reached the end or the beginning of the document.  I like
to have the same key to start the search and also do a search-next after
you've typed all the characters you are searching for, and also to have
backspace go back one search position and/or remove one character from
the search text.

* (done) Multiple top level windows, and able to show any buffer in any TLW,
including those that are already displayed in another TLW.  Of course
there should be key-bindings available for opening a new TLW, cycling
forward and backward through the buffer list, and a way to select a
buffer from a popup list of buffer/file names.

* (to be improved) The Kill-Ring.  For those of you that have never used an emacs-like
editor it works like this:  There is a collection of the N previous
blocks of text that have been cut or copied (in emacs 'cut' == 'kill'
more or less)  When I do a yank (paste) it uses the last thing put in
the kill-ring.  If I then immediately use another key-binding then it
replaces that pasted text with the next item in the kill ring, and so on
until I eventually wrap around get back to the first one in the ring, or
I do some other command or move the cursor somewhere else.

* (done) Registers.  A text snippet can be copied into a register, which is
like the kill ring except you refer to each one by name, where the names
are 'a' through 'z'.  You can also append to a register that already has
text in it, and you can paste the contents of a register into the
document at the current cursor location.

* (done) Able to have selections be either a stream of characters or a
rectangle.  A stream selection is like what you have in all text
editors, it starts from position a on line N and continues forward or
back to position b on line M and includes all the characters in between.

  A rectangle selection is all the characters between position a and b
on lines N to M.  In other words, it has width and height and it might
be something like positions 5 through 10 on lines 20 to 25.  Cutting or
deleting a rectangle removes the text in the rectangle and shifts any
text to the right of the rectangle over.  It does not remove any lines
although they may end up being empty.  Pasting a rectangle inserts the
new text with the upper-left of the rectangle at the current cursor
position, shifts existing text to the right if needed, and fills with
spaces on the left if a line affected by the paste is not long enough.
New lines are not added unless the file needs to be extended to
accommodate the rectangle paste.  Rectangles can also be put into registers.

* (to be improved) Good keystroke macro recording and the ability to save and load
keystroke macros, and the ability to assign a key-binding to a saved
recorded macro. Any time I need to make the same edits to a bunch of
lines or groups of lines I'll record doing it on the first one including
the keystrokes needed to reposition for the next line, and then stop
recording and then it's just one keystroke to replay the keystrokes for
every other line that needs it done.  I record, use and throw away up to
a dozen or so macros per day.

* (done, and better than asserted) If you must have a toolbar make it optional
and keep it simple. Toolbars require the mouse and the goal is to keep the hand
off the mouse as much as possible.

* (done) Similarly, avoid using popup dialogs whenever possible.  This includes
things like the file dialog.  I don't mind seeing the file dialog if I
select a menu item, because most likely my hand is already on the mouse,
but the rest of the time I just want to hit a key, type a path name
(with tab-completion to help find stuff, up/down keys to cycle through
past selections) and press enter.  So I would prefer this editor to have
something like emacs' minibuffer, or the QuickFind panel in Firefox.  In
other words, when there is something you would normally use a dialog for
just create a small panel that rolls up from the bottom of the frame,
put the keyboard focus there, perhaps do stuff in the main buffer as
they are typing if appropriate, and then when the user is done the panel
rolls out of sight again and keyboard focus is restored to their active
buffer.  This can be done for file open/saves, search &amp; replace,
specifying build or grep commands (see next item) choosing to execute
some editor function by name that may not have some key-binding yet (see
item after next) etc.

* (done, with user @commands)

Flexible build/grep commands.  Emacs handles both of these in almost
the same way so I'll list them together here.  I hit a key and am
presented with either the default, or the most recently used compile or
grep command.  I can edit the command or use the up/down arrows to
select previous commands that I've used.  I then hit enter and emacs
runs the command putting the output in an editor buffer.  There is a key
I can hit to kill the compile if needed.  It then parses the output and
there is a key I can use to find the file listed in the compile or grep
output, load it, and position the cursor on the reported line.  (This
can even be done while the compile/grep is still running.)

* (done) For access to editor commands/functionality that may not be bound to a
keystroke it's real nice to have the ability to hit a key, type the
command name, press enter and then it's done.  This can also allow for
commands that might need to prompt for parameters, be interactive, etc.
  All editor commands should be named and can be bound to keys by name
or executed by name in this way.

* (done) def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    &lt;&lt; define s &gt;&gt;

    self.c.putApropos(s)
 search.  Emacs has support for regular expression search modes
for all of the search types, incremental search, search/replace,
although I don't use it that much.

* (done, or not needed, depending on your point of view)
Multi-file search and replace.  Be able to select files interactively,
or by wildcard, or both.  Enter search string, or regex, and replace
text.  The editor loads each file and does the search, allowing you to
choose for each one whether to do the replacement, or replace all.

* If it is a full IDE it would be nice to have a way to start just the
code editor portion for quick edits.

Things that would be nice to have, but that I could live without:

(All of these things can be done easily with @command)

* Interactive diffs, merges and applying of patches.

* Able to be a front-end for gdb.

* Able to be a front-end for CVS, SVN, etc.

* (done) Be able to run shell commands, or the shell itself in an editor buffer.

* (easy) have a built-in psychotherapist or be able to play towers of hanoi.  ;-) 
</t>
<t tx="ekr.20100223123910.5930">@
The present operation of recent files is surprising.

Recent files should be a global list, managed by a single controller.
</t>
<t tx="ekr.20100225102026.7139">Leo 4.7.1 final                    February 26, 2010

Leo 4.7.1 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo 4.7.1 fixes a dangerous bug in Leo 4.7. When converting file-like sentinels
to thin-like sentinels in an external file, Leo now issues a warning and sets
the corresponding @file node dirty. This ensures that Leo will write the
converted external file and .leo file together, making it impossible to lose
data.

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.7:
--------------------------

- Leo now uses the simplest possible internal data model.
  This is the so-called "one-node" world.
- Leo supports Python 3.x.
- Leo requires Python 2.6 or above.
- Several important improvements in file handling.
    - Leo converts @file nodes to @thin nodes automatically.
    - Leo creates a 'Recovered Nodes' node to hold data that
      otherwise might be lost due to clone conflicts.
    - @auto-rst now works much more reliably reliably.
    - Leo no longer supports @noref trees.  Such trees are not
      reliable in cooperative environments.
- A new Windows installer.
- Many other features, including new command line options and new plugins.
- Dozens of bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20100225102026.7140">- Fixed a dangerous bug that could cause data loss when converting @file nodes
  from file-like to thin-like sentinels. The problem arose because it was too
  easy to save the .leo file (thus deleting the tnodeList) without forcing the
  converted external files to be saved. The next time Leo attempted to read the
  external files, the tnodeList would be missing and data would be lost.

  Leo's read logic now determines whether the file has file-like sentinels by
  reading the *uncached* contents of the file. When converting file-like
  sentinels to thin-like sentinels, Leo warns that it is converting the file and
  sets the @file node dirty. This ensures that Leo will write the converted
  external file whenever Leo writes the .leo file. This will make it impossible
  for a naive user to lose data. A sophisticated user might cause problems by
  using the write-outline-only command...

- Fixed expand/contract-pane commands.

- Fixed Python 3.x problems in delete-editor and cycle-editor-focus.

- Added a log message for show-colors saying the color picker does not exist for qt.

- Corrected date in trunk/license.txt.
</t>
<t tx="ekr.20100225102636.5627"># It should be possible to avoid duplicate reads.
</t>
<t tx="ekr.20100506062734.11593">The mod_scripting plugin runs @scripts before plugin initiation is complete.
Thus, such scripts can not directly modify plugins. Instead, a script can create
an event handler for the after-create-leo-frame that will modify the plugin.

For example, the following modifies the cleo.py plugin after Leo has completed loading it::

    def prikey(self, v):
        try:
            pa = int(self.getat(v, 'priority'))
        except ValueError:
            pa = -1

        if pa == 24:
            pa = -1
        if pa == 10:
            pa = -2

        return pa

    import types
    from leo.core import leoPlugins

    def on_create(tag, keywords):
        c.cleo.prikey = types.MethodType(prikey, c.cleo, c.cleo.__class__)

    leoPlugins.registerHandler("after-create-leo-frame",on_create)

Attempting to modify c.cleo.prikey immediately in the @script gives an
AttributeError as c has no .cleo when the @script is executed. Deferring it by
using registerHandler() avoids the problem.
</t>
<t tx="ekr.20100521090440.5887">From Tom L

This is hardwired for the first parameter.  Things I need to expand
this:

1. put in a variable that cycles through the tabStops

2. In this mock up, you are entering the parameters in the minibuffer,
a more advanced version would collect each keypress and put it in the
body at the current tabStop, a tab would finalize the entry and
advance to the next stop, no text other than the 'help', ends up in
the minibuffer.

Sinc I'm only modifying existing code without real understanding of
what Leo is doing, any guidance would be appreciated.

===== EKR: I think this has been solved.
</t>
<t tx="ekr.20100731112744.7274">.. _`install Leo from a debian package`: installing.html#installing-from-a-debian-package
.. _`install Leo from sources`: installing.html#installing-from-sources-linux

If you are using Debian/Ubuntu, it's best to
`install Leo from a debian package`_, as described next.
This provides file associations, icons, launcher items, etc.

Otherwise, `install Leo from sources`_.
</t>
<t tx="ekr.20100731112744.7276">Install Python and Qt, as described above (`Installing Packages`_).

Now you have a choice.  You can use Leo's binary (single-click) installer
or download Leo's sources directly.
</t>
<t tx="ekr.20100804133903.7250">.. index::
    pair: @; Glossary

\@
    Starts a doc part. Doc parts continue until an \@c
    directive or the end of the body text.

.. index::
    pair: @@ convention for headlines; Glossary

\@@ convention for headlines
    Within \@asis trees only, if a headline starts with \@@, Leo
    writes everything in the headline following the \@@ just before the
    corresponding body text.

.. index::
    pair: @&lt;file&gt; node; Glossary

\@&lt;file&gt; node
    A node whose headline starts with
    @asis, @edit, @file, @nosent, @shadow, @thin, or their longer forms.
    We often refer to outline nodes by the directives they contain.
    For example, an @file node is a node whose headline starts with @file, etc.

.. index::
    pair:  @all; Glossary

\@all
    Copies the body text of all nodes in an @file tree to the external file.

.. index::
    pair: @asis; Glossary

\@asis &lt;filename&gt;
    Creates an external file containing no Leo sentinels directly from the @asis tree.

.. index::
    pair: @auto; Glossary

\@auto &lt;filename&gt;

    Imports an external file into the Leo outline, splitting the file into
    pieces if an importer exists for the give filetype. Importers presently
    exist for the following languages: C, C++, C#, HTML, INI files, Java, PHP,
    Pascal, Python and XML.

.. index::
    pair: @c; Glossary
    pair: @code; Glossary

\@c and \@code

    Ends a doc part and starts a code part.

.. index::
    pair: @chapter; Glossary
    pair: @chapters; Glossary

\@chapter and \@chapters

    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

.. index::
    pair: @color; Glossary

\@color

    Enables syntax coloring in a node and its descendants until the next
    \@nocolor directive.

.. index::
    pair: @comment; Glossary

\@comment

    Sets the comment delimiters in \@thin, \@file and \@shadow files.

.. index::
    pair: @delims; Glossary

\@delims

  Sets the comment delimiters in \@thin, \@file and \@shadow files.

.. index::
    pair: @edit; Glossary

\@edit &lt;filename&gt;

    Reads an entire external file into a single node.

.. index::
    pair: @encoding; Glossary

\@encoding &lt;encoding&gt;

    Specifies the Unicode encoding for an external file.

.. index::
    pair: @end_raw; Glossary

\@end_raw

    Ends a section of 'raw' text.

.. index::
    pair: @file; Glossary

\@file &lt;filename&gt;

    Creates an external file containing sentinels. When writing \@file
    trees, Leo expands section references and \@all and \@others directives.

    **Important**: \@file is the recommended way to create and edit most files.
    Using \@file trees is **highly recommended** when sharing external files in
    a collaborative environment.

.. index::
    pair: @first; Glossary

\@first &lt;text&gt;

    The \@first directive allows you to place one or more lines at the very start of an
    external file, before the first sentinel. For example::

	    @first #! /usr/bin/env python

.. index::
    pair: @killcolor; Glossary

\@killcolor

    Completely disables syntax coloring in a node, regardless of other directives.

.. index::
    pair: @language; Glossary

\@language &lt;language name&gt;

    Specifies the source language, which affects syntax coloring and the
    comments delimiters used in external files and syntax coloring.

.. index::
    pair: @last; Glossary

\@last &lt;text&gt;

    Allows you to place lines at the very end of external files, after the last
    sentinel. For example::

        @first &lt;?php
        ...
        @last ?&gt;

.. index::
    pair: @lineending; Glossary

\@lineending cr/lf/nl/crlf

    Sets the line endings for external files.

.. index::
    pair: @nocolor; Glossary

\@nocolor

    Disables syntax coloring in a node and its descendants until the next \@color
    directive.

.. index::
    pair: @nocolor-node; Glossary

\@nocolor-node

    Completely disables coloring for one node. Descendant nodes are not affected.

.. index::
    pair: @nosent; Glossary

\@nosent

    Creates an external file containing no sentinels. Unlike \@asis, sections
    references and the @all and @others directives are valid in \@nosent trees.

.. index::
    pair: @nowrap; Glossary

\@nowrap

    Disables line wrapping the Leo's body pane.

.. index::
    pair: @others; Glossary

\@others

    Copies the body text of all nodes *except* section definition nodes in an
    \@file tree to the corresponding external file.

.. index::
    pair: @pagewidth; Glossary

\@pagewidth &lt;n&gt;

   Sets the page width used to break doc parts into lines.

.. index::
    pair: @path; Glossary

\@path &lt;path&gt;

  Sets the path prefix for relative filenames for descendant \@&lt;file&gt; directives.

.. index::
    pair: @raw; Glossary

\@raw
    Starts a section of "raw" text that ends *only* with the
    \@end_raw directive or the end of the body text.

.. index::
    pair: @tabwidth; Glossary

\@tabwidth &lt;n&gt;

    Sets the width of tabs. Negative tab widths cause Leo to convert tabs to
    spaces.

.. index::
    pair: @thin; Glossary

\@thin &lt;filename&gt;

    A synonym for @file.

.. index::
    pair: @wrap; Glossary

\@wrap

    Enables line wrapping in Leo's body pane.
</t>
<t tx="ekr.20100804133903.7251">.. index::
    pair: Body pane; Glossary

Body pane

    The pane containing the body text of the currently selected headline in the
    outline pane.

.. index::
    pair: Body text; Glossary

Body text

    The text in the body pane. That is, the contents of a node.

.. index::
    pair: Body text box; Glossary

Body text box

    A small blue box in the icon box indicating that the node contains body
    text.

.. index::
    pair: Child; Glossary

Child

    The direct descendant of a node.

.. index::
    pair: Clone; Glossary

Clone
    A copy of a tree that changes whenever the original changes.
    The original and all clones are treated equally:
    no special status is given to the "original" node.

.. index::
    pair: Clone arrow; Glossary

Clone arrow

    A small red arrow in the icon box indicating that the node is a clone.

.. index::
    pair: Code part; Glossary

Code part

    A part of a section definition that contains code. Code parts start with @c
    or @code directives and continue until the next doc part.

.. index::
    pair: Contract; Glossary

Contract:

    To hide all descendants of a node.
</t>
<t tx="ekr.20100804133903.7252">.. index::
    pair: Demote; Glossary

Demote
    To move all siblings that follow a node so that they become children of the node.

.. index::
    pair: Descendant; Glossary

Descendant
    An offspring of a node.  That is, a child, grandchild, etc. of a node.

.. index::
    pair: Directive; Glossary

Directive

    A keyword, preceded by an '@' sign, in body text that controls Leo's
    operation. The keyword is empty for the \@ directive.

.. index::
    pair: Doc part; Glossary

Doc part

    A part of a section definition that contains comments. Doc parts start with
    @ and continue until the @c directive or the end of the body text.

.. index::
    pair: Escape convention; Glossary

.. _`noweb`: http://www.eecs.harvard.edu/~nr/noweb/

Escape convention

    A convention for representing sequences of characters that would otherwise
    have special meaning. **Important**: Leo does not support escape conventions
    used by `noweb`_. Any line containing matched &lt;\&lt; and &gt;\&gt; is a section
    reference, regardless of context. To use &lt;\&lt; and &gt;\&gt; as ordinary characters,
    place them on separate lines.

.. index::
    pair: Expand; Glossary

Expand

    To make the children of a node visible.

.. index::
    pair: External file; Glossary

External file

    A file outside of Leo that is connected to Leo by an \@&lt;file&gt; node.

.. index::
    pair: Grandchild; Glossary

Grandchild

    The child of a child of a node.
</t>
<t tx="ekr.20100804133903.7253">.. index::
    pair: Headline; Glossary

Headline

    The headline text of a node.  The part of the node visible in the outline pane.

.. index::
    pair: Hoist; Glossary
    pair: Dehoist; Glossary

Hoist &amp; dehoist

    Hoisting a node redraws the screen that node and its descendants becomes the
    only visible part of the outline. Leo prevents the you from moving nodes
    outside the hoisted outline. Dehoisting a node restores the outline.
    Multiple hoists may be in effect: each dehoist undoes the effect of the
    immediately preceding hoist.

.. index::
    pair: Icon box; Glossary

Icon box

    An icon just to the left of headline text of a node indicating whether the
    node is cloned, marked or dirty, and indicating whether the node contains
    body text.

.. index::
    pair: Log pane; Glossary

Log Pane

    The part of Leo's main window that shows informational messages from Leo. It
    also contains the Find tab, the Spell tab, the autocompletion tab.
</t>
<t tx="ekr.20100804133903.7254">.. index::
    pair: Mark; Glossary

Mark

    A red vertical line in the icon box of a node.

.. index::
    pair: Node; Glossary

Node

    The organizational unit of an outline. The combination of headline text and
    body text. Sometimes used as a synonym for tree.

.. index::
    pair: Offspring; Glossary

Offspring

    A synonym for the descendants of a node.
    The children, grandchildren, etc. of a node.

.. index::
    pair: Organizer node; Glossary

Organizer node

    A node containing no body text. Organizing nodes may appear anywhere in an
    @file tree; they do not affect the external file in any way. In particular,
    organizing nodes do not affect indentation in external files.

.. index::
    pair: Orphan node; Glossary

Orphan node

    A node that would not be copied to a external file. Orphan nodes can arise
    because an @file tree has no @others or @all directives. Sections that are
    defined but not used also create orphan nodes.

    Leo issues a warning when attempting to write an @file tree containing
    orphan nodes, and does not save the external file. No information is lost;
    Leo saves the information in the @file tree in the .leo file. Leo will load
    the @file tree from the .leo file the next time Leo opens the .leo file.

.. index::
    pair: Outline; Glossary

Outline

    A node and its descendants. A tree. All the nodes of a .leo file.

.. index::
    pair: Outline order; Glossary

Outline order

    The order that nodes appear on the screen when all nodes are expanded.

.. index::
    pair: Outline pane; Glossary

Outline pane

    The pane containing a visual representation of the entire outline, or a part
    of the outline if the outline is hoisted.
</t>
<t tx="ekr.20100804133903.7255">.. index::
    pair: Parent; Glossary

Parent

    The node that directly contains a node.

.. index::
    pair: Plugin; Glossary

Plugin

    A way to modify and extend Leo without changing Leo's core code.
    See `Writing plugins and hooks`_.

.. index::
    pair: Promote; Glossary

Promote

    To move all children of a node in an outline so that they become siblings of
    the node.

.. index::
    pair: reStructuredText; Glossary
    pair: rST; Glossary

.. _`rST primer`: http://docutils.sourceforge.net/docs/user/rst/quickstart.html

reStructuredText (rST)

    A simple, yet powerful markup language for creating .html, or LaTeX output
    files. See the `rST primer`_.

.. index::
    pair: Root; Glossary

Root

    The first node of a .leo file, outline, suboutline or @&lt;file&gt; tree.
</t>
<t tx="ekr.20100804133903.7256">.. index::
    pair: Section; Glossary

Section

    A fragment of text that can be incorporated into external files.

.. index::
    pair: Section definition; Glossary

Section definition

    The body text of a section definition node.

.. index::
    pair: Section definition node; Glossary

Section definition node

    A node whose headline starts with a section name and whose body text defines
    a section.

.. index::
    pair: Section name; Glossary

Section name

    A name enclosed in &lt;\&lt; and &gt;\&gt;. Section names may contain any characters
    except newlines and "&gt;&gt;".

.. index::
    pair: Section reference; Glossary

Section reference

    A section name appearing in a code part. When writing to an external file,
    Leo replaces all references by their definitions.

.. index::
    pair: Sentinel; Glossary

Sentinel

    Comment lines in external files used to represent Leo's outline structure.
    Such lines start with an \@ following the opening comment delimiter.
    Sentinels embed outline structure into external files.

    **Do not alter sentinel lines**. Doing so can corrupt the outline structure.

.. index::
    pair: Setting; Glossary

Settings:

    Plugins and other parts of Leo can get options from @settings trees,
    outlines whose headline is @settings. When opening a .leo file, Leo looks
    for @settings trees in the outline being opened and also in various
    leoSettings.leo files. @settings trees allow plugins to get options without
    any further support from Leo's core code. For a full discussion of @settings
    trees, see `Customizing Leo`_.

.. index::
    pair: Sibling; Glossary

Sibling

    Nodes with the same parent. Siblings of the root node have the hidden root
    node as their parent.

.. index::
    pair: Target language; Glossary

Target language

    The language used to syntax color text. This determines the default comment
    delimiters used when writing external files.

.. index::
    pair: Tree; Glossary

Tree

    An outline. A node and its descendants.

.. index::
    pair: Underindented Line; Glossary

Underindent line

    A line of body text that is indented less then the starting line of the
    class, method or function in which it appears. Leo outlines can not
    represent such lines exactly: every line in an external file will have at
    least the indentation of any unindented line of the corresponding node in
    the outline.

.. index::
    pair: View node; Glossary

View node

    A node that represents a view of an outline. View nodes are typically
    ordinary, non-cloned nodes that contain cloned descendant nodes. The cloned
    descendant nodes comprise most of the data of the view. Other non-cloned
    nodes may add additional information to the view.
</t>
<t tx="ekr.20100804133903.7262">This section is a reference guide for all other Leo directives, organized
alphabetically.

Unless otherwise noted, all directives listed are valid only in body text,
and they must start at the leftmost column of the node.

.. glossary::
     :sorted:

.. index::
    pair: @; Reference
.. index::
    pair: @doc; Reference
.. index::
    pair: Doc part; Reference

\@ and \@doc

    These directives start a doc part. \@doc is a synonym for \@. Doc parts
    continue until an \@c directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect.

.. index::
    pair: @c; Reference
.. index::
    pair: @code; Reference

\@c and \@code

    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@c.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.

.. index::
    pair: @chapter; Reference
.. index::
    pair: @chapters; Reference

\@chapter and \@chapters

    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

.. index::
    pair: @encoding; Reference

\@encoding &lt;encoding&gt;

    Specifies the Unicode encoding for an external file. For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    actually used in the external file or "byte hash" will result.

.. index::
    pair: @first; Reference

\@first &lt;text&gt;

    Places lines at the very start of an external file, before any Leo
    sentinels. \@first lines must be the very first lines in an \@&lt;file&gt; node.
    More then one \@first lines may appear.

    This creates two first lines, a shebang line and a Python encoding line::

        @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

    Here is a perl example::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore

    Tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @&lt;file&gt; nodes, the \@ignore directive
    causes Leo not to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index::
    pair: @language; Reference

\@language &lt;language name&gt;

    Specifies the language in effect, including comment delimiters.
    If no \@language directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are: actionscript, ada, autohotkey, batch, c, config,
    cpp, csharp, css, cweb, elisp, forth, fortran, fortran90, haskell, haxe,
    html, ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby, shell,
    tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    **Note**: Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also controls syntax coloring. For language x, the
    file leo/modes/x.py describes how to colorize the language. To see the
    languages presently supported, look in the leo/modes directory. There are
    over 100 such languages.

.. index::
    pair: @last; Reference

\@last &lt;text&gt;

    Places lines at the very end of external files.

    This directive must occur at the very end of top-level \@&lt;file&gt; nodes. More
    than one \@last directive may exist. For example::

        @first &lt;?php
        ...
        @last ?&gt;

    Leo does not recognize \@last directive in \@asis trees.

.. index::
    pair: @lineending; Reference

\@lineending cr/lf/nl/crlf

    Sets the line endings for external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index::
    pair: @nowrap; Reference

\@nowrap

    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

..  If \@others occurs multiple times in the same node, all non-section nodes
..  appear at the location of the first instance of the \@others directive; the
..  remainder are remembered as sentinels but have no other content.

.. index::
    pair: @pagewidth; Reference

\@pagewidth &lt;n&gt;

   Sets the page width used to break doc parts into lines.
   &lt;n&gt; should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index::
    pair: @path; Reference
.. index::
    pair: Absolute path; Reference
.. index::
    pair: Path prefix; Reference

\@path &lt;path&gt;

   Sets the **path prefix** for relative filenames for all \@&lt;file&gt; tree.

   This directive may appear in headlines or body text, and may
   appear in top-level \@&lt;file&gt; nodes.

   The path is an **absolute path** if it begins with c:\\ or /,
   otherwise the path is a **relative** paths.

   Multiple \@path directives may contribute to the path prefix.
   Absolute paths overrides any ancestor \@path directives.
   Relative paths add to the path prefix.

   If no \@path directives are in effect, the default path prefix is
   the directory containing the .leo file.

   Within @path and @&lt;file&gt; paths, {{exp}} gets evaluated with the following
   symbols known: c, g, p, os and sys.  For example::

       @file {{os.path.abspath(os.curdir)}}/abc.py

   refers to the file abc.py in (absolute path of) the current directory.

.. index::
    pair: @tabwidth; Reference
.. index::
    pair: Negative tab width; Reference

\@tabwidth &lt;n&gt;

  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index::
    pair: @wrap; Reference

\@wrap

    Enables line wrapping in Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
</t>
<t tx="ekr.20100806170836.4392">.. index::
    pair: @&lt;file&gt;; Reference

This section discusses the \@&lt;file&gt; directives. These directives create or
import external files.

**Important**: Newcomers to Leo should create external files with \@auto or
\@file. Use \@auto if your external files must not contain sentinel lines. Use
\@file otherwise. In particular, \@file is **highly recommended** when sharing
external files in a collaborative environment.

**Note**: All these directive must appear in headlines.

The following table summarizes the various ways of creating external files.

+---------+------------+------------------+-----------------+
|         | Sentinels  | Sections and     | File data stored|
| Kind    | in external| @others expanded | in .leo file?   |
|         | file?      | on write?        |                 |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | yes             |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @edit   | no         | no               | no              |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @shadow | Note 1     | yes              | no              |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              |                 |
| @thin   |            |                  | no              |
| Note 2  |            |                  |                 |
+---------+------------+------------------+-----------------+

**Note 1**: \@shadow nodes create two files, a **public** file without sentinels
and a **private** file with sentinels.

**Note 2**: \@file and \@thin nodes are synonyms.

Within @path and @&lt;file&gt; paths, {{exp}} gets evaluated with the following
symbols known: c, g, p, os and sys.  For example::

    @file {{os.path.abspath(os.curdir)}}/abc.py

refers to the file abc.py in (absolute path of) the current directory.
</t>
<t tx="ekr.20100806170836.4393">.. index::
    pair: @asis; Reference

The \@asis directive creates an external file without sentinels and without any
expansions.

Use this directive only when you must have complete control over every character
of the external file. When writing \@asis nodes, writes the body text of all
nodes in outline order. Leo writes the body text *as is*, without recognizing
section definitions, without expanding section references, and without treating
directives specially in any way. In particular, Leo copies all directives,
including \@ or \@c directives, to the external file as text.

.. index::
    pair: @@ convention in @asis trees; Reference

**The @@ convention**: Within \@asis trees only, if a headline starts with \@@,
Leo writes everything in the headline following the \@@ just before the
corresponding body text.

Files created from \@asis trees contain *nothing* not contained in body text (or
\@@ headlines). In particular, if body text does not end in a newline, the first
line from the next node will concatenated to the last line of the preceding
node.

Within \@asis trees, Leo writes no sentinels to the external file, so Leo can not update the outline
using changes to the external file. When reading .leo files, Leo does *not* read
external files created from \@asis nodes. Instead, all data in an \@asis tree is
stored in the .leo file.

Within \@asis trees, Leo recognizes the \@ignore directive only in the
*ancestors* of \@asis nodes. This allows you to use the \@ignore directive to
prevent Leo from writing \@asis trees.

**Note**: \@file-asis and \@silent are deprecated synonyms for \@asis.
</t>
<t tx="ekr.20100806170836.4395">.. index::
    pair: @edit; Reference

The \@edit directive imports an external file into a single node.

When reading \@edit nodes, Leo reads the entire file into the \@edit node. Lines
that look like sentinels will be read just as they are.

When writing \@edit nodes, \@edit nodes must not have children and section
references and @others are not allowed.
</t>
<t tx="ekr.20100806170836.4396">.. index::
    pair: @auto; Reference

The \@auto directive imports an external file into a tree of nodes. Using \@auto
is *highly recommended* when using external files that must not contain Leo
sentinels.

\@auto trees allow people to use Leo in collaborative environments without using
sentinels in external files. Even without sentinels, \@auto trees can change
when the corresponding external file changes outside of Leo.

.. index::
    pair: Importer; Reference

When reading \@auto nodes, Leo creates the \@auto tree using **importers**,
parsers that create an outline with nodes for each class, method and function in
the external file. Some importers create other kinds of nodes as well.

Importers presently exist for C, elisp, HTML, .ini files, Java, Javascript, Pascal, PHP,
Python and xml. Leo determines the language using the file's extension. If no
parser exists for a language, Leo copies the entire body of the external file
into the \@auto node.

.. index::
    pair: Organizer tag; Reference

**Note**: the \@data import_xml_tags setting specifies the **organizer tags**
that cause the HTML and XML importers to create outline nodes. By default, the
**organizer tags** are html, body, head, and div.

When writing \@auto nodes, Leo writes the external file without sentinels. This
allows you to use Leo in collaborative environments without disturbing colleagues.

When importing files into \@auto trees, Leo performs several checks to ensure
that writing the imported file will produce exactly the same file. These checks
can produces **errors** or **warnings**. Errors indicate a potentially serious
problem. Leo inserts an \@ignore directive in the \@auto tree if any error is
found. This prevents the \@auto tree from modifying the external file.

.. index::
    pair: Strict language; Reference

Before importing a file, Leo **regularizes** the leading whitespace of all
lines of the original source file. That is, Leo converts blanks to tabs or
tabs to blanks depending on the value of the \@tabwidth directive in effect
for the \@auto node. Leo also checks that the indentation of any non-blank
line is a multiple of the indentation specified by the \@tabwidth directive.
**Strict languages** are languages such as Python for which leading
whitespace must be preserved exactly as it appears in the original source
file. Problems during regularizing whitespace generate errors for strict
languages and warnings for non-strict languages.

After importing a file, Leo verifies that writing the \@auto node would create
the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any such bugs immediately.

2. Underindented lines in classes, methods or function.

.. index::
    pair: Underindented line; Reference

An **underindented line** is a line of body text that is indented less then the
starting line of the class, method or function in which it appears. Leo outlines
can not represent such lines exactly: every line in an external file will have
at least the indentation of any unindented line of the corresponding node in the
outline. Leo will issue a warning (not an error) for underindented Python
comment lines. Such lines can not change the meaning of Python programs.
</t>
<t tx="ekr.20100806170836.4398">The \@color, \@killcolor, \@nocolor and \@nocolor-node directives control how
Leo colors text in the body pane.

.. index::
    pair: Ambiguous node; Reference

These directives typically affect the node in which they appear and all
descendant nodes. Exception: an **ambiguous node**, a node containing both
\@color and \@nocolor directives, has no effect on how Leo colors text in
descendant nodes.

.. glossary::
    :sorted:

.. index::
    pair: @color; Reference

\@color

    Enables syntax coloring until the next \@nocolor directive.

.. index::
    pair: @killcolor; Reference

\@killcolor

    Disables syntax coloring in a node, overriding all \@color, \@nocolor or
    \@nocolor-node directives in the same node.

.. index::
    pair: @nocolor; Reference

\@nocolor

    Disables syntax coloring until the next \@nocolor directive.

.. index::
    pair: @nocolor-node; Reference

\@nocolor-node

    Disables coloring for only the node containing it. The \@nocolor-node
    directive overrides the \@color and \@nocolor directives within the same
    node.
</t>
<t tx="ekr.20100806170836.4399">.. index::
    pair: @nosent; Reference

The \@nosent &lt;filename&gt; creates an external file without sentinel lines.

When writing an \@nosent tree, Leo expands section references, \@all and
\@others directives, but Leo writes no sentinels to the external file.
Thus, Leo can not update \@nosent trees from changes made to the external
file. However, \@nosent trees do have their uses: unlike \@auto trees,
cloned nodes *are* valid in \@nosent trees.

When reading an \@nosent node, Leo does *not* read the external file.
Instead, all the data in the \@nosent tree is stored in the .leo file.

**Note**: \@auto or \@shadow are usually better choices than \@nosent for
creating external files without sentinels.

**Note**: The \@bool force_newlines_in_at_nosent_bodies setting controls whether
Leo writes a trailing newline if non-empty body text does not end in a newline.
The default is True.
</t>
<t tx="ekr.20100806170836.4402">.. index::
    pair: @shadow; Reference
    pair: Private file; Reference
    pair: Public file; Reference

The \@shadow directive creates *two* external files, a **public** file without
sentinels, and a **private** file containing sentinels.

When reading an \@shadow node, Leo uses a brilliant algorithm devised by
Bernhard Mulder that compares the public and private files, and then updates the
outline based on changes to the *public* file. In this way, \@shadow provides
many of the benefits of \@file trees without writing sentinels in the (public)
external file.

Leo can do an initial import of \@shadow trees by parsing the corresponding
public file, exactly as is done for \@auto nodes.
</t>
<t tx="ekr.20100806170836.4403">.. index::
    pair: @file; Reference
    pair: @thin; Reference

The \@file directive creates an external file containing sentinels. When writing
\@file trees, Leo expands section references and \@all and \@others directives.

When reading external files created by \@file, the sentinels allow Leo to
recreate all aspects of the outline. In particular, Leo can update the
outline based on changes made to the file by another editor. 

**Important**: \@file is the recommended way to create and edit most files. In
particular, using \@file nodes is **highly recommended** when sharing external
files in a collaborative environment.

The \@thin directive is a synonym for \@file.

Prior to Leo 4.7, \@file worked differently from \@thin. This should not be
a problem: Leo 4.7 can read all external files written by Leo 4.6.
</t>
<t tx="ekr.20100806170836.4408">These directives alter how Leo represents data in external files. They are
**dangerous**--mistakes in using these sentinels can make it impossible for Leo
to read the resulting external file. Use them with care!

Nevertheless, these sentinels can be useful in special situations.

.. glossary::
    :sorted:

.. index::
    pair: @comment; Reference

\@comment &lt;1, 2 or three comment delims&gt;

    Sets the comment delimiters in \@file and \@shadow files.
    **Important**: Use \@comment for unusual situations only. In most cases, you
    should use the \@language directive to set comment delimiters.

    The \@comment directive may be followed by one, two or three delimiters,
    separated by whitespace. If one delimiter is given, it sets the delimiter
    used by single-line comments. If two delimiters are given, they set the
    block comment delimiter. If three delimiters are given, the first sets the
    single-line-comment delimiter, and the others set the block-comment
    delimiters.

    Within these delimiters, underscores represent a significant space, and
    double underscores represent a newline. Examples::

        @comment REM_
        @comment __=pod__ __=cut__

    The second line sets PerlPod comment delimiters.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: \@language and \@comment may appear in the same node, provided
    that \@comment appears *after* the \@language directive: \@comment overrides
    \@language.

    The \@comment directive must precede the first section name or \@c
    directive.
    
    There are situations where using \@delims or \@comment is not avoidable or impractical to
    add new language definition, and including it causes the resulting file to be invalid.
    In place of delimiter definition, use @0x + delimiter encoded in hexadecimal.
    The hexadecimal part must be acceptable input to binascii.unhexlify(), otherwise whole 
    directive will be ignored. Use binascii.hexlify('my-delimiter') to generate it.
    Decoded delimiters are not checked for validity (such as, UTF-8) and whether they 
    do not clash with Leo format (like newline or NUL characters)!
    
    Example::
    
        @comment @0x3c212d2d2120 @0x202d2d3e
    
    for GenshiXML is the same definition as 
        
        @comment &lt;!--!_ _--&gt;
    
    to create comments that will be removed from the output by Genshi. But the latter would 
    cause XML parsing error on the @comment line.
    
.. index::
    pair: @delims; Reference

\@delims &lt;1 or 2 comment delims&gt;

    Sets comment delimiters in external files containing sentinel lines.

    The \@delims directive requires one or two delimiters, separated by
    whitespace. If one delimiter is present it sets the single-line-comment
    delimiter. If two delimiters are present they set block comment delimiters.

    This directive is often used to place Javascript text inside XML or HTML
    files. Like this::

        @delims /* */
        Javascript stuff
        @delims &lt;-- --&gt;
        HTML stuff

    **Warning**: you **must** change back to previous delimiters using another
    \@delims directive. Failure to change back to the previous delimiters will
    thoroughly corrupt the external file as far as compilers, HTML renderers,
    etc. are concerned. Leo does not do this automatically at the end of a node.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: The \@delims directive can not be used to change the comment
    strings at the start of the external file, that is, the comment strings for
    the \@+leo sentinel and the initial \@+body and \@+node sentinels.

.. index::
    pair: @raw; Reference
    pair: @end_raw; Reference

\@raw and \@end_raw

    \@raw starts a section of "raw" text that ends *only* with the \@end_raw directive
    or the end of the body text containing the \@raw directive. Within this
    range, Leo ignores all section references and directives, and Leo generates
    no additional leading whitespace.
</t>
<t tx="ekr.20100806170836.4411">These control how Leo places text when writing external files.
They are two of the most important directives in Leo.

.. glossary::
    :sorted:

.. index::
    pair: @all; Reference

\@all

    Copies *all* descendant nodes to the external file. Use \@all to place
    unrelated data in an external file.

    The \@all directive is valid only in the body of \@file trees.

    Within the range of an \@all directive, Leo ignores the \@others directive
    and section references, so Leo will not complain about orphan nodes.

.. index::
    pair: @others; Reference

\@others

    Writes the body text of all unnamed descendant into the external file, in
    outline order.

    Whitespace appearing before \@others directive adds to the indentation of
    all nodes added by the \@others directive.

    A single node may contain only one \@others directive, but descendant nodes
    may have other \@others directives.
</t>
<t tx="ekr.20100807120250.4398">Organizer nodes convey information about the structure and design of a large
system. Decoupling structure from content in this way is precisely what is
needed for flexibility: one can reorganize at will without worrying about
changing the meaning of the code.

Outlines clarify the shape of code

These last several paragraphs have discussed comments in detail because the net
effect of "putting comments where they belong" is that comments don't clutter
the code. Section references hide irrelevant detail, so larger-scale patterns
within functions (or declarations) become more apparent. Often just recasting
code into web format has created Aha's about my own code, with no special
attention to recoding or redesign! Recasting a function as a web raises the real
and apparent level of abstraction.

Organizer nodes eliminate mundane comments
The headline of an organizer node is often all that needs to be said.

Nodes create places for comments

Each of Leo's nodes provide a place for lengthy comments that do not clutter
other code. In practice this encourages comments where they are needed.

Outlines reduce the need for comments

Bridge or transition phrases are almost always unnecessary in a
Leo outline. One never needs to say something like, "having just finished
with topic x, we turn now to topic y."

Comments and formatting no longer have to indicate overall design; node do that.

Nodes reduce the visual "weight" of code

Nodes and their helpers (usually in child nodes) can be as complex as
necessary without affecting the organization of the outline. Moreover,
collapsed nodes are inconspicuous, no matter how many children they contain
and no matter how much code each child contains.
</t>
<t tx="ekr.20100807120250.4399">Leo's outlines don't merely represent design. They often *are* the design.
Outlines effortlessly show relationships between class, methods or any other
data.

Outlines express design and structure directly. In most programs, the grouping
of functions into files, or the organization of a single file as a set of
functions, etc. 

Typical design tools are separate from the resulting product. With Leo, your
designs become your programs or web site.

Leo's outline pane always shows you the big picture, and the relationship of the
presently selected outline to that big picture. At all times you are aware of
both the overall design and all the intermediate levels of detail.

Outlines create new design dimensions.

There are many ways to express a program as a Leo outline. Such choices are
important. They add clarity to the entire program. These are different *kind* of
choices. They simply can not be expressed at all in other editors. In other
words, such choices exist in a new design space. 

Outlines add a new dimension to the design and coding process. Choices about
what sections do, what they are named, what order they appear in, are choices in
a design space different from "normal" programming. This an abstract concept, to
be sure. However, the previous paragraphs are really a manifestation of
working in this new design space.
</t>
<t tx="ekr.20100807120250.4400">Typical browsers show you a fixed view of code. In contrast, Leo allows you to
organize your programs as *you* want, and *Leo remembers your organizations*.

Furthermore, Leo does not constrain you to a single "right" view of your data,
programs or designs. By using clones, a single outline may contain dozens or
even thousands of views of the nodes in the outline. You are free to create a
new view for every new task or project.

Finally, you can insert organizer nodes anywhere in an outline, including
anywhere in any view. Organizer nodes do not change the meaning of programs,
html pages or web sites, yet they can clarify and simplify designs, programs,
web sites or data.
</t>
<t tx="ekr.20100807120250.4401">Nodes naturally provide **useful** context. For example, @button and @test nodes.

Outlines provide a convenient way of expressing the intended scope of commands.
Many of Leo's commands operates on the presently selected tree.
</t>
<t tx="ekr.20100808120531.4281">############################
Some outline commands
############################

.. index::
    pair: Outline commands; Tutorial

You can use Leo as fairly typical outliner. Click the expansion box of nodes to
show and hide their children.

.. index::
    pair: Tab completion; Tutorial

Play around with some of the commands from the Outline menu or from the
minibuffer. The keyboard shortcut and minibuffer key sequence appear in
parentheses. **Note**: as usual, you can use tab completion in the minibuffer.

Edit Headline (Ctrl+H or &lt;Alt-x&gt;edit-headline&lt;return&gt;)

    Begins editing of the headline text of a node.
    To end editing, hit &lt;return&gt; or &lt;Ctrl-g&gt;

Insert Node (Ctrl+I or &lt;Alt-x&gt;insert-node&lt;return&gt;)

    Inserts a new headline into the outline.

Cut Node (Ctrl+Shift+X or &lt;Alt-x&gt;cut-node&lt;return&gt;)

    Deletes a node and all its descendants, copying them to the clipboard.

Paste Node (Ctrl+Shift+V or &lt;Alt-x&gt;paste-node&lt;return&gt;)

    Pastes a tree copied by the Cut Node command.

Copy Node (Ctrl+Shift+C or &lt;Alt-x&gt;copy-node&lt;return&gt;)

    Copies a node and all its descendants to clipboard without deleting it from
    outline. You can copy a tree from one Leo outline to another using Copy Node
    and Paste Node.

Contract or Go Left (Alt-Left-Arrow or &lt;Alt-x&gt;contract-or-go-left&lt;return)

    Contracts a node if it is expanded, otherwise selects its parent.

Expand and Go Right (Alt-Right-Arrow or &lt;Alt-x&gt;expand-and-go-right&lt;return&gt;)

    Select a node's first child, expanding the original node if needed.

Goto Prev Visible (Alt-Up-Arrow or &lt;Alt-x&gt;goto-prev-visible&lt;return&gt;)

    Select the previous visible node.

Goto Next Visible (Alt-Down-Arrow or &lt;Alt-x&gt;goto-next-visible&lt;return&gt;)

    Select the next visible node.

Move Up (Ctrl+U or &lt;Alt-x&gt;move-outline-up&lt;return&gt;)

    Moves a node up in the outline.

Move Down (Ctrl+D or &lt;Alt-x&gt;move-outline-down&lt;return&gt;)

    Moves a node down.

Move Left (Ctrl+L or &lt;Alt-x&gt;move-outline-left&lt;return&gt;)

    Moves a node left.

Move Right (Ctrl+R or &lt;Alt-x&gt;move-outline-right&lt;return&gt;)

    Moves a node right.

Promote (Ctrl+} or &lt;Alt-x&gt;promote&lt;return&gt;) 

    Makes all the children of a node to be siblings of the node.

Demote (Ctrl+{ or &lt;Alt-x&gt;demote&lt;return&gt;)

    Makes all following siblings of a node to be children of the headline.

Please experiment with Leo's outline now. Move around the tree and
expand/collapse nodes by pressing Alt + arrow keys. This also moves the focus to
tree, so, after pressing Alt + arrow, you can move around by using arrow keys
alone. Return the focus to the body control by pressing Enter.
</t>
<t tx="ekr.20100808120531.4284">#################
Leo in a Nutshell
#################

This page introduces Leo's features and shows why Leo is a unique tool for
understanding and manipulating data.

**Outlines and organization**: Leo's outlines are more flexible and powerful
than any other outline, for at least three reasons:

1. Unlike class browsers, you are in complete control of the outline's
   structure. You can organize it however you like, and Leo will *remember* what
   you have done and will show it to you just that way when come back next time.
   This seems like a minor feature. After you use Leo, you will see that it is
   not.

2. Leo outlines may *look* like other outlines, but in fact Leo outlines are
   views of a more general underlying data (graph) structure. Nodes in Leo's
   outlines may appear in many places in the same outline. We call such nodes
   **clones**. Using clones, it is easy to create as many **views** of the data
   in the outline as you like. In effect, Leo becomes a supremely flexible
   filing cabinet: any outline node may be filed any place in this cabinet.

3. Leo outlines are intimately connected to both external files and Python
   scripting, as explained next.

.. index::
    pair: External file; Nutshell

**External files**: Any outline node (and its descendants) can be "connected" to
any file on your file system. Three common kinds of connection are:

1. @edit: Leo reads the entire external file into the @edit node's body text.

2. @auto: Leo parses the external file and automatically creates an outline that
   shows the structure of the external file, just as in typical class browsers.

3. @file: Leo makes a two-way connection between the @file tree (the @file node
   and its descendants) and the external file. You can update the external file
   by writing the Leo outline connected to it, or you can update the outline by
   changing the external file. To do this Leo uses comments in the external file
   called **sentinels** that represent the outline structure *in the external
   file itself*.

\@edit, \@auto and \@file allow you to share external files with others in a
collaborative environment. With \@file, you also **share outline structure**.

A single Leo outline can connect to dozens or even hundreds of external files.
Using Leo, you never have to open these files by hand, Leo does so automatically
when it opens the Leo outline. Outlines connected to external files make Leo a
new kind of IDE (Integrated Development Environment).

**Scripting**: Every outline node can contain Python scripts. Moreover, each
node in a Leo outline is a programmable object. All nodes are *easily* available
to any Leo script. The structure of the outline is *also* easily available to
any script.  Scripts can *easily* determine the parents and children of any node.
Finally, Leo makes it easy for scripts to visit any or all nodes of an outline.

.. index::
    pair: @kind convention; Nutshell
    pair: User-defined types; Nutshell

Leo's headlines provide a natural place to indicate the **type** of data
contained in nodes. By *convention*, @test in a headline denotes a unit test,
\@command creates a new Leo command. The \@kind convention creates 
**user-defined types** that turn any outline Node into a true programming
object.

.. index::
    pair: Leonine; Nutshell

Unifying scripting, data and outline structure creates a new world. We use the
term **Leonine** to denote the Leo-centric (outline-centric) view of
programming, data and scripting. Here are some of the implications of this
new world:

**Data organization**: Leo's clones allow unprecedented flexibility in
organizing data. Leo outlines have been used as an entirely new kind of
database. It is easily scriptable. As my brother has shown, it is possible to
design Leo outlines so that parts of the outline *are* SQL queries!

**Design**: With Leo, you always see the big picture, and as many of the details
as you like. But this makes outlines ideal for representing designs. In fact,
Leo outlines don't just represent designs, they *are* the designs. For example,
all of Leo's source code reside in just a few Leo outlines. And Leo outlines can
represent input data to other design tools.

**Programming/Coding**: It's much easier to program when the design is always
easily visible. Nodes provide the perfect way to organize large modules, classes
and functions. Nodes also provide unlimited room to save as many details as you
like, *without* cluttering your overall view of the task, or rather tasks, at
hand.

**Testing**: Leo is a supremely powerful unit-testing framework:

1. You can make a node a unit test simply by putting @test at the start of its
   headline. Leo will then automatically generate all the blah-blah-blah needed
   to turn the node's script into a fully-functional unit test. Oh yes,
   the headline becomes the name of the unit test.

2. Unit tests can use data in children of @test nodes. Typical tests put input
   data in one child node, and the expected results of running the test in another
   child node. The test simply compares the actual and expected results.

3. You can easily run tests in the entire outline or just in the selected
   outline. Because tests reside in nodes, you can use clones to organize tests
   in as many ways as you like. For example, it is trivial to run only those
   tests that are failing.

**Maintenance and support**: Leo's ability to contain multiple views of data is
*precisely* what is needed while maintaining any large project. For every new
support task and every new bug, a new (plain) **task node** will contain all the
data needed for that task, notes, test data, whatever. Furthermore, when fixing
bugs, the task node can contain clones of all classes, methods or functions
related to the bug. Fixing a node in the task node fixes the node in the
external file! And as always, you can use all of Leo's outlining features
(including clones) to organize your task nodes.

**Organization everywhere**: Have you noticed that Leo's organizational prowess
applies to *everything*? Indeed, you can use outlines and clones in new ways to
organize files, projects, data, design, programs, testing, and tasks. Leo
doesn't need lots of features--outlines, clones and scripts suffice.  The more
complex your data, designs, program and tasks, the better Leo is suited to them.

It's time to mention one of Leo's most unique features.  Simple, *optional*
markup makes it possible to synthesize (build) scripts and entire computer programs
from outlines. Leo is more than a filing cabinet for scripts and programs, Leo
is a build tool for scripts and outlines!

**Scripting everything**: Let's step back a moment. A single outline can contain
databases, designs, actual computer code, unit tests, test scripts and task
nodes. But Leo scripts will work on any kind of node. Thus, it is *easy* to run
scripts on *anything*! Examples:

- Scripting itself: @button nodes creates a **script button**, a Python script
  that can be applied to any node in an outline! Script buttons have been
  written (in Python) that will execute Leo scripts in other languages.

- Data: The @kind convention for headlines tells scripts what a node contains
  without having to parse the node's contents.  The possibilities are endless.

- Design: scripts can verify properties of design based on either the contents
  of design nodes or their outline structure.

- Coding: scripts routinely make massive changes to outlines. Scripts and unit
  tests can (and do!) verify arbitrarily complex properties of outlines.

- Scientific programming: Leo scripts can run experiments many times using
  different starting points. Nodes are the perfect place to store results and
  notes. Many scientists use the IPython shell-- Using Leo's **IPython bridge**,
  Leo can execute IPython scripts, and scripts in IPython have full access to
  all nodes in Leo outlines.

- Testing: scripts can (and do!) create @test nodes themselves.

- Maintenance: scripts could gather statistics about tasks using simple @kind
  conventions.

The Leo Aha is just this: Leo outlines are far more than eye candy. Leo outlines
revolutionize your view of data--Leo outlines can organize *anything*. Leo
outlines create a new kind of programming environment, one in which outline
structure and user-defined data types create totally new opportunities.
</t>
<t tx="ekr.20100809122216.4286">Here is a complete list of options for the rst3 and code-to-rst commands:

.. glossary::
    :sorted:

call_docutils (default: True):

    Call docutils to process the intermediate file.

default_path (default: '')

    The path to be prepended to filenames given in root nodes.

default_encoding (default: utf-8)

    The default encoding to be used for non-ascii (unicode characters).

encoding (default: the default_encoding setting)

    The encoding to be used for non-ascii (unicode) characters.
    **Important**: this option has effect only in @rst-options doc parts
    in root @rst nodes.

generate_rst (default: True)

    A master switch.
    True: generate rST markup for rST sections and rST code-blocks.
    False: generate plain text and ignore @ @rst-markup doc parts.

generate_rst_header_comment (default: True)

    True: Leo writes a comment line of the form::

        .. rst3: filename: &lt;filename&gt;

    at the start of intermediate files. This option has effect only if the
    generate_rst and write_intermediate_file options are both True.

publish-argv-for-missing-stylesheets (Default: '')

    The arguments to be passed to docutils.core.Publisher().publish() when no
    stylesheet is in effect. This is a string that represents a comma-separated
    list of strings: For example, the option::

        publish-argv-for-missing-stylesheets=--language=de,--documentclass=report,--use-latex-toc

    results in the call::

        publish(['--language=de','--documentclass=report','--use-latex-toc'])

show_headlines (default: True)

    True: automatically generate rST sections from headlines.
    False: ignore headlines.

    **Note**: The level of the node in the outline determines the level of the
    section underlining in the rST markup. Higher-level headlines in the outline
    correspond to higher-level section headings; lower-level headlines in the
    outline correspond to lower-level section headings.

show_organizer_nodes (default: True)

    True: generate rST sections for nodes that do not contain body text.

    **Note**: This option has no effect unless the rST section would otherwise be written.

show_sections (default: True)

    True: generate rST sections corresponding to headlines.
    False: don't generate sections.  Instead, generate lines of the form::

        **headline**

strip_at_file_prefixes (default: True)

    True: remove @auto, @file, @nosent and @thin from the start of headlines.

stylesheet_name (default: 'default.css')

    The name of the stylesheet passed to docutils.

stylesheet_path (default: '')

    The directory containing the stylesheet passed to docutils.

    **Note**: If the stylesheet_embed option is True, specify a path relative to
    the location of the Leo file. If the stylesheet_embed option is False,
    specify a path relative to the location of the HTML file.

stylesheet_embed (default: True)

    True: The content of the stylesheet file will be embedded in the HTML file.
    False: The HTML file will link to an external stylesheet file.

underline_characters (default: #=+*^~"'\`-:&gt;\_)

    The underlining characters to be used to specify rST sections.
    The first character is reserved so you can specify the top-level section explicitly.

verbose (default: True)

    True: write informational messages.

write_intermediate_file (default: False)

    **Important**: the rst3 command *always* creates an intermediate file.
    This option controls whether that file is an internal Python object
    or an actual file on the external file system.

    True: writes the intermediate file to the external file system. The name of
    the intermediate file has the name of the output file with .txt appended.
    This option has effect only if the generate_rst option is True.

    False: writes the intermediate file to an internal Python object.
</t>
<t tx="ekr.20100810091118.4298">**Markup doc parts** have the following form::

    @ @rst-markup
    any rST markup
    @c

Markup doc parts inserts the markup directly into the output. Markup doc parts
are most useful when formatting an outline as code using the code-to-rst
command.
</t>
<t tx="ekr.20100810091118.4301">The following options have effect only in code mode.

.. glossary::
    :sorted:

number_code_lines (default: True)

    Controls whether to number code lines in code mode.
    This option has no effect in rst mode.

show_leo_directives (default: True)

    True: include Leo directives
    False: ignore Leo directives.

show_markup_doc_parts (default: False)

    True: include markup doc parts.
    False: ignore markup doc parts.

show_options_doc_parts (default: False)

    True: include options doc parts.
    False: ignore options doc parts.

show_doc_parts_as_paragraphs (default: False)

    True: Move doc parts outside of the code-block directive. False: Show doc
    parts in the code-block directive. **Cool**: Any rST markup in doc parts
    included as the result of this option will be rendered properly.

show_options_nodes (default: False)

    True: show @rst-options nodes.
    False: Ignore @
</t>
<t tx="ekr.20100810091118.4306">The following option has effect only in rst mode.

.. glossary::

show_doc_parts_in_rst_mode [True,False or class names] (default: True)

    This option is most useful for rst documents which are not computer code.
    It allows you to use doc parts to make comments on the draft document
    which are either excluded from the output or formatted in a way that highlights
    their nature as comments rather than content.  For example, you're writing a book, and
    you want to use a doc part at the top of a section to remind yourself "need
    to explain how Ted got to Sally's".    Note: you may need to add
    CSS to have them formatted differently.

    The option can be `True`, `False`, or one or more class names.

    **True**: Treat the entire doc part from the opening '@' to the closing '@c
    as normal markup.

    **False**: Remove the doc part.

    **class names**: Process the contents of the doc part as it if were in an rst
    `container` directive. For example::

         @ @rst-options
         show_doc_parts_in_rst_mode = notes literal
         @c

    would wrap the doc part contents in the output in a div with classes
    "container notes literal". Furthermore, if one of the class names is
    `literal`, then the doc part content will be output as a literal block
    wrapped in a container as described above. This allows you to use text which
    is not valid rst as rough notes for annotating a draft document.
</t>
<t tx="ekr.20100810203016.4296"></t>
<t tx="ekr.20100810203016.4298">By default, the rst3 command operates in **rst mode**. In rst mode, the rst3
command treats body text as rST (or Sphinx) markup. This is the mode of
operation discussed in the Tutorial.

In **code mode** the rst3 command treats body text as computer source code.
**Note**: both rST and Sphinx have markup designed to represent computer
programs. The rst3 command generates that markup automatically in code mode.

Code mode is inherently complex. As we shall see, there are *many* possible
options in code mode. This can hardly be helped--this is truly an advanced
topic!

In **doc_only_mode**, rst3 command outputs only regular doc parts and @
@rst-markup doc parts. Headlines create section in doc_only mode only if:

1. The node contains a doc part or

2. The show_organizer_nodes option is in effect.

The code_mode and doc_only_mode options determine the mode as follows:

- By default (code_mode=False; doc_only_mode=False), the rst3 command is in
  rst mode.

- Setting code_mode=True causes the rst3 command to enter code mode.

- Setting code_mode=False cause the rst3 command to enter rst mode.

- Setting doc_only_mode=True causes the rst3 command to enter doc_only mode.

</t>
<t tx="ekr.20100813075851.4296">This section discusses options--what they are, how to set them and how to set their defaults.
</t>
<t tx="ekr.20100813075851.4297"></t>
<t tx="ekr.20100817101952.4303">.. links

.. _`latest stable release`: http://sourceforge.net/projects/leo/files/Leo/4.11%20final/
.. _`SourceForge`: https://sourceforge.net
.. _`Leo's snapshots page`: http://www.greygreen.org/leo/
.. _`nightly snapshot`: http://www.greygreen.org/leo/
.. _`Leo's latest sources`: https://github.com/leo-editor/leo-editor

Leo's core code is always being improved and developed. Unit-testing
ensures that the daily commits are as bug-free as possible. Almost all of
the time, downloading the most recent `nightly snapshot`_ of the
development code is going to give you code that is just as stable and much
more up-to-date than the most recent `latest stable release`_ which most
Leonistas would consider already outdated.

If you are just checking Leo out, feel free to use the `latest stable release`_
download if it makes you feel more secure, but once you've
decided to work with Leo on a regular basis, we highly recommend regularly
keeping your installation up to date with the most recent `nightly snapshot`_.

To summarize, you may get Leo in three ways:

1. Download the `latest stable release`_ from `SourceForge`_. This release
   contains an executable installer. This release will usually be a bit out
   of date.

2. Download a `nightly snapshot`_ from `Leo's snapshots page`_. This page
   contains .zip archives of Leo's code from 1, 2, 5, 10, 30 and 90 days
   ago.
   
3. Download `Leo's latest sources`_ from `GitHub`_ using `git`_.
   Installing git is easy, and once set up this is the easiest way
   to get the latest version of Leo's code::
   
        git clone https://github.com/leo-editor/leo-editor (http access)
    
   or::
   
        git clone git@github.com:leo-editor/leo-editor.git (ssh access)
</t>
<t tx="ekr.20100817101952.4306">**Important**: This section tells how to set up git_ so that you can grab
the latest sources using ``git clone``. However, you can get a nightly
snapshot of Leo's git repository (without installing git) from
http://www.greygreen.org/leo/

Many users will want to track the development version of Leo, in order to stay
on top of the latest features and bug fixes. Running the development version is
quite safe and easy, and it's also a requirement if you want to contribute to
Leo.

1. First, you need to get git from http://git-scm.com/.
2. Get Leo from GitHub by doing::

        git clone https://github.com/leo-editor/leo-editor (http access)
    
   or::
   
        git clone git@github.com:leo-editor/leo-editor.git (ssh access)

And that's it! You can run leo/core/leo.py directly. When you want to refresh the
code with latest modifications from GitHub, run git pull.

..  If you make modifications to Leo (with the interest in sharing them with the Leo
..  community), you can check them in to your local branch by doing bzr checkin.
..  Now, to actually request your changes to be merged to Leo trunk, you need a
..  Launchpad account with RSA keys in place. There is showmedo video about how to
..  accomplish this in Windows using puttygen and pageant at
..  http://showmedo.com/videos/video?name=1510070&amp;fromSeriesID=151.

..  After your Launchpad account is set up, go to
..  https://launchpad.net/leo-editor, choose "Code" tab -&gt; Register Branch,
..  select Branch type "Hosted" and fill in descriptive details about the branch.
..  After that, go to the branch home page from Code tab again, and copy-paste the
..  push command line to terminal. For example, for branch::

    ..  https://code.launchpad.net/~leo-editor-team/leo-editor/my_branch

..  The push command is::

    ..  bzr push bzr+ssh://my_name@bazaar.launchpad.net/~leo-editor-team/leo-editor/my_branch 

..  You may wish to add --remember command line option to bzr push, to direct all
..  future pushes to that location. Then, you only need to execute bzr push.

..  After your branch is pushed, you can email the Leo mailing list and request it
..  to be reviewed and merged to trunk.
</t>
<t tx="ekr.20100821182153.4343">@ @rst-options
call_docutils=False
stylesheet_path=..\doc
write_intermediate_file = True
@c

######
Slides
######

This is the front page for various slide shows about Leo.

.. links
.. _`Clones and views`:         slides/clones-and-views/slide-001.html
.. _`External files`:           slides/external-files/slide-005.html
.. _`Installation`:             slides/installation/slide-001.html
.. _`Leo Basics Step By Step`:  slides/leo-basics-step-by-step/slide-001.html
.. _`Scripting Leo`:            slides/scripting-leo/slide-001.html
.. _`Using Leo's Minibuffer`:   slides/using-leos-minibuffer/slide-001.html

Basic slide shows
-----------------

`Installation`_  tells how to install Leo.

`Leo Basics Step By Step`_  explains the basics of Leo outlines.

`External Files`_ discusses creating external files with \@file, \@auto and \@edit.

`Clones and views`_ illustrates how clones work and show how they create views.

`Using Leo's Minibuffer`_ tells how to execute Leo's commands by name.

Intermediate slide shows
------------------------

`Scripting Leo`_ explains how to use Python scripting in Leo.
</t>
<t tx="ekr.20100826110728.5839">2008

http://groups.google.com/group/leo-editor/browse_thread/thread/b738e3f8d164f9fc

May 10, 2010

Kent

I think there could be quite a bit of interest in moving
the shadow files to their own tree, avoiding what might
be considered 'pollution' of a tree of files in @shadow nodes.

Edward has said that this would add a lot of complexity to Leo.

It seems that a VCS back end for Leo might simplify the
task of arbitrary shadow file location, as well as adding
versioning capability.


Those of us old enough to remember the Groucho Marx show will know what I am ...

bogomil
 to me

In order to relocate .leo_shadow directories in home dir, I have made
the following changes leoShadow.py:
1. Introduce new setting 'shadow_in_home_dir':
   x.ctor:
     ...
     self.shadow_prefix = c.config.getString('shadow_prefix') or ''

=&gt;  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir')
or False
    ...

2. Make the following line:
   x.shadowDirName and shadowPathName:
      ...
      fileDir = g.os_path_dirname(filename)

=&gt;   if self.shadow_in_home_dir:
        fileDir = "//".join([baseDir, fileDir.replace(':','%')])

In this way I keep .leo_shadow dirs in a tree and it is ok if the user
reorgs the original tree.

=====================
Edward K. Ream
 to bogomil

Thanks for these suggestions.  I'll try them soon.

A few minor comments about the code.

&gt;  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir') or False

This works (because c.config.getBool returns None if the setting does
not exist). Thus, the "or False" part merely replaces None by False.
I prefer the following:

self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir',default=False)

&gt;   if self.shadow_in_home_dir:
&gt;         fileDir = "//".join([baseDir, fileDir.replace(':','%')])

This looks like a Windows-only solution because of ':'.  It might fail
in strange ways on other platforms.
</t>
<t tx="ekr.20100828074347.5828">http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/

http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. 
</t>
<t tx="ekr.20100830120622.5829">&gt; &gt; Hmm, I guess that would be more clear, although I think I'd like an option
to include it in the following def to avoid

&gt; &gt; Decoration
&gt; &gt; index
&gt; &gt; Decoration
&gt; &gt; add_user
&gt;
&gt; Sure.  Decorations must always be part of a definition.

Well, personally I'd like to have them included in the definition, but I think
Kent's preference for a separate node is reasonable to. If your function and
hence definition node is called "pluralize", and it's decorated with something
like "@authenticate_user", you may never check the innocent looking pluralize
definition to find out what on earth's triggering the mysterious network
database call. And this isn't a completely specious example, authentication may
have been added to stop pluralize being used in a user existence detection
exploit or something. OTOH in well behaved code like CherryPy apps you don't
want a separate node for every @cherrypy.expose.

Bottom line is I think we're asking for a set of @settings to fine tune python
import behavior:

@python_import_interdef = previous | next | own_node | ai
@python_import_decoration = next | own_node

I'm not sure I believe the AI option is possible / practical, and am not asking
for it, just listing it :-)

I'd also like

@python_import_init_in_class_node = true | false

as often there's more docs on a class in the __init__ than the class docstring.

I think that's really all we're talking about, some @settings to test during import.
</t>
<t tx="ekr.20100904134301.8336">El 01/05/09 15:12, Ville M. Vainio escribió:

- make latex
- cd _build/latex
- make all-pdf
</t>
<t tx="ekr.20101004092958.5914">@ treepad.py is from the treepad website
</t>
<t tx="ekr.20101004092958.5939">@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

</t>
<t tx="ekr.20101004092958.5940">import sys, os, re, string

# constants
VERSION = "&lt;Treepad version 2.7&gt;"

# regexes
END_RE = re.compile(r'^&lt;end node&gt; ([^ ]+)$')
</t>
<t tx="ekr.20101004092958.5941">class Node:
    @others
</t>
<t tx="ekr.20101004092958.5942">def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
</t>
<t tx="ekr.20101004092958.5943">def __str__(self):
    return "%s/%d" % (self.title, self.level)
</t>
<t tx="ekr.20101004092958.5944">def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
</t>
<t tx="ekr.20101004092958.5945">def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
</t>
<t tx="ekr.20101004092958.5946">def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("&lt;node&gt;\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("&lt;end node&gt; %s\n" % self.end)
</t>
<t tx="ekr.20101004092958.5947">def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

</t>
<t tx="ekr.20101004092958.5948">class NodeReader:
    @others
</t>
<t tx="ekr.20101004092958.5949">def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
</t>
<t tx="ekr.20101004092958.5950">def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
</t>
<t tx="ekr.20101004092958.5951">def readstart(self):
    self.expect(VERSION)
</t>
<t tx="ekr.20101004092958.5952">def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) &lt; 1:
        return None
    self.expect("dt=Text", line)
    self.expect("&lt;node&gt;")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

</t>
<t tx="ekr.20101004092958.5953">class TreeReader:
    @others
</t>
<t tx="ekr.20101004092958.5954">def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
</t>
<t tx="ekr.20101004092958.5955">def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level &gt; 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
</t>
<t tx="ekr.20101004092958.5956">def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

</t>
<t tx="ekr.20101004092958.5957">class TreeWriter:
    @others
</t>
<t tx="ekr.20101004092958.5958">def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
</t>
<t tx="ekr.20101004092958.5959">def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

</t>
<t tx="ekr.20101004092958.5960">class Main:
    @others
</t>
<t tx="ekr.20101004092958.5961">def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
</t>
<t tx="ekr.20101004092958.5962">
def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

</t>
<t tx="ekr.20101004092958.6050">http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/a1558a10eb8537c0?lnk=gst&amp;q=codewise#a1558a10eb8537c0

1. Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. You need a recent trunk version of leo to get the plugin which uses
the above module.

4. Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
with 'op' etc.

Nice work Ville, thanks.

==================

Thanks for this, I hope others will take a stab at it as well, given
sane instructions (I burned my free cycles frantically coding this
thing and neglected the all-important HOWTO). This is important
because functional completion is the single most important thing still
missing from Leo. Or, well, was ;-).

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

&gt; Then, after restarting leo if necessary, type

&gt; c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
&gt; with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.&lt;alt+0&gt;

And self.&lt;alt+0&gt; 
</t>
<t tx="ekr.20101009114830.4723">@nocolor-node

Formerly, this had to be on because the expansion bits
of @screenshot trees were significant.

Happily, this is no longer true.

True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.

False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.
</t>
<t tx="ekr.20101009114830.4724"></t>
<t tx="ekr.20101024062147.6004"></t>
<t tx="ekr.20101024234254.5433">Leo 4.8 alpha 1                    October 29, 2010

Leo 4.8 alpha 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20101025080245.5791">##################
What's New in Leo
##################

.. contents::
    :depth: 3
</t>
<t tx="ekr.20101025080245.5798"></t>
<t tx="ekr.20101025080245.5799" str_atime="1376411965.0"></t>
<t tx="ekr.20101025080245.5805"></t>
<t tx="ekr.20101025080245.5980">.. _`p.deletePositionsInList`: http://groups.google.com/group/leo-editor/browse_thread/thread/0aa8d9d17f6300b8#
.. _`g.findTestScript`: http://groups.google.com/group/leo-editor/browse_thread/thread/a108d70400b28dc9#

- The execute-script now calls execfile (or its equivalent when using Python 3k)
  when @bool write_script_file = True. This allows pdb (or pudb) to show the
  text of Leo scripts!

- Added `p.deletePositionsInList`_, an important new helper.

- Added `g.findTestScript`_, an important new pattern for sharing code in Leo
  scripts, including scripts in @test nodes.

    Suppose there is common code that I want to include in several unit tests::

        class Hello():
            def __init__(self,name='john'):
                self.name=name
                print('hello %s' % name)

    I put this in a node called 'Common test code'. Now the unit tests can "import"
    the code as follows::

        exec(g.findTestScript('Common test code'))

    After this exec statement completes the class Hello is available to the test
    code! This is something that I've wanted to do forever.
</t>
<t tx="ekr.20101025080245.5985">.. _`Reorganized`: http://groups.google.com/group/leo-editor/browse_thread/thread/d02df89c0b831a7c

- Several important improvements to Leo's installer for Windows.

- Leo doesn't create @chapter nodes for new files.

- Leo now uses PyEnchant to check spelling.

    This is much safer than the old Aspell wrapper.

- All \@auto nodes end with a newline.

- Leo now writes @edit nodes like @nosent nodes.

- Added legend for print-settings command.

- Improved the importer for elisp.

- Added an .ini importer.

- Created introductory slide shows.

- `Reorganized`_ the users guide.

- Improved the installation instructions.

- Added support for .nsi files.
</t>
<t tx="ekr.20101025080245.6006">- Leo can now open multiple files from the command line.

- You can now set a proportional font to use in all "@language plain" nodes.
   Specify fonts in @font nodes::

        @font plain null font

            plain_null_font_family = Times New Roman
            plain_null_font_size = 16
            plain_null_font_slant = roman
            plain_null_font_weight = bold

  That is, the actual font specs are in the body text.  Everything
  except \@font is ignored in the headline.

  Specify font colors with \@color nodes::

        @color plain null color = black

- Added support for minibuffer colors. Added the following options with the
  indicated defaults::

    @color minibuffer_background_color = lightblue
    @color minibuffer_warning_color = lightgrey

- Added support for \@string qt-toolbar-location = &lt;spot&gt;

    Valid values for &lt;spot&gt; are top,bottom,left,right

- Added support for \@bool write_expansion_bits_in_leo_files.

- The ``-screen-shot`` command-line argument tells Leo to take a screenshot and exit.

- The ``--window-size`` command-line argument specifies the initial size of the Leo
  window.  This is especially useful with the ``screen-shot`` command-line argument::

    --window-size=600x900  # &lt;height&gt; x &lt;width&gt;, in pixels.

- Added support for @bool at_auto_separate_non_def_nodes option.

    When true, the @auto file importers put inter-def code in their own node.
    The default (legacy mode) is False.
</t>
<t tx="ekr.20101025080245.6077">.. _`simplest possible`: http://groups.google.com/group/leo-editor/browse_thread/thread/8b659c96720afd53/628a09779ca9e8c6
.. _`org-mode`: http://orgmode.org/

Leo now writes \@file files with the `simplest possible`_ sentinel lines.

    - Eliminated \@-node sentinels.
    - Eliminated \@nl and \@nonl sentinels.
    - Simpler representation of \@doc and \@ in sentinels.
    - Simplified representation of \@others and section references.
    - Use a scheme much like Emacs `org-mode`_ to represent headline level.

The result is, provably, the simplest possible representation of Leo's outline
structure in external files.
</t>
<t tx="ekr.20101025080245.6078">The Qt Gui now supports drag and drop in Leo outlines.

You can drag files into Leo.  Leo will create \@file or \@auto nodes if appropriate.
</t>
<t tx="ekr.20101025080245.6079">When abbreviation mode is on (abbrev-mode toggles this mode) Leo will expand
abbreviations as you type. Type the name of an abbreviation, followed by a
space. As soon as you type the space, Leo will replace the name by the
abbreviations value. You can undo the replacement as usual.

Note that defining any abbreviation automatically turns on abbreviation
mode.

The add-global-abbreviation command (&lt;alt-x&gt;add-gl&lt;tab&gt;&lt;return&gt;) takes the
selected text as the replacement value of the abbreviation. The minibuffer
prompts you for the name of the abbreviation.

Three new settings apply to the abbreviation commands:

- @bool enable-abbreviations (default: False)

    When true, enables substitution of abbreviations.

- @data global-abbreviations

- @data abbreviations

      In both cases, body text contains lines of the form::

        name=value

      name is the abbreviation name, value is the substituted text. Whitespace
      is ignore around the name, but is significant in the value. Abbreviation
      names may contain only alphabetic characters, but may start with the '@'
      sign.

      By *convention* @data global-abbreviations setting should be defined in
      myLeoSettings.leo, while @data abbreviations should be defined in other
      .leo files. Regardless of where they are defined, abbreviations in @data
      abbreviation nodes will override settings (with the same name) in @data
      global-abbreviations nodes.
</t>
<t tx="ekr.20101025080245.6080">If the body text is non-empty, it is assumed to contain the URL.
This is a remarkably important improvement--it allows the
headline to contain a description of the url.
</t>
<t tx="ekr.20101025080245.6081">- The screenshots.py plugin helps make slide shows containing many screen shots.
</t>
<t tx="ekr.20101025080245.6084"></t>
<t tx="ekr.20101025080245.6085">Added support for @shadow files. This was a major breakthrough.
See the `Using @shadow`_ chapter for full details.
</t>
<t tx="ekr.20101025080245.6086">This version of Leo featured more significant improvements:

- Added support for the Qt gui.  This was a major project that
  significantly improves the look and feel of Leo.

- A file-caching scheme produced spectacular improvements in the
  speed of loading Leo outlines.

- Added support for @auto-rst nodes. These import reStructuredText (rST) files
  so that the files can be "round-tripped" without introducing extraneous
  changes. This makes Leo a superb environment for using rST.

- Added support for @edit nodes.
</t>
<t tx="ekr.20101025080245.6087">Leo 4.7 accomplishes something I long thought to be impossible: the unification
of vnodes and tnodes. tnodes no longer exist: vnodes contain all data. The Aha
that made this possible is that iterators and positions allow a single node to
appear in more than one place in a tree traversal.

This is one of the most significant developments in Leo's history. At last the
endless confusion between vnodes and tnodes is gone. At the most fundamental
level, Leo's data structures are as simple as possible. This makes them as
general and as powerful as possible!

This version successfully produced a common code base that can run on both
Python 2.x and Python 3.x.
</t>
<t tx="ekr.20101025080245.6088">Leo 4.7 accomplishes something I long thought to be impossible: the unification
of vnodes and tnodes. tnodes now longer exist: vnodes contain all data. The Aha
that made this possible is that iterators and positions allow a single node to
appear in more than one place in a tree traversal.
</t>
<t tx="ekr.20101025080245.6089">Leo 4.8 simplified Leo's sentinels as much as possible.
Leo's sentinel lines look very much like Emacs org-mode comment lines,
except for the addition of gnx's.

This version also produced a fundamentally important addition to Leo's error
recovery. Leo now shows "Resurrected" and "Recovered" nodes when loading an
outline. These nodes protect against data loss, and also implicitly warn when
unusual data-changing events occur. Creating this scheme is likely the final
chapter in the epic saga of error recovery in Leo.
</t>
<t tx="ekr.20101026082911.5538">.. .. _`here`: atShadow.html#aha-boundary-cases-don-t-matter

The \@shadow algorithm guarantees *only* that writing an updated \@shadow
outline will generate the updated **public** file. There is *no way* to
guarantee that the updated outline structure will be as expected. The
\@shadow algorithm can not guess between two or more ways of updating the
**private** file when each of the ways yields the same **public** file.

Happily, this "fact of life" about \@shadow is not serious. If you don't like
the "guesses" that the \@shadow algorithm has made, you can simply change the
\@shadow tree. After saving the outline, the *private* file will record your
choice. The next time you open the outline, you will see the choices *you* made,
not the guesses that the \@shadow algorithm made.
</t>
<t tx="ekr.20101031172539.5880"></t>
<t tx="ekr.20101104091058.4975">@nocolor

Leo 4.8 rc 1                               November 15, 2010

Leo 4.8 release candidate 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- Improved autocompletion: Ctrl-space starts a one-time completion.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20101104091058.4976">There are at least 2 installer issues outstanding:

1. Installing to the "Program Files" folder or the "Program Files
(x86)" folder can cause some unit tests to fail due to permission
issues.  I don't think this is too serious.

2. Installing to the "Program Files (x86)" folder can cause PyEnchant
not to find the spellpyx.txt folder.  This looks like a bug in
PyEnchant.
</t>
<t tx="ekr.20101104091058.4977"></t>
<t tx="ekr.20101104091058.4978"></t>
<t tx="ekr.20101104091058.4979"># Also, created a "Resurrected Nodes" node to handle such nodes cleanly and safely.
</t>
<t tx="ekr.20101104091058.4980">Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle
consequence of how Leo writes outlines and reads derived files.  This
is a big bug in Leo, not cvs.  The effect of the bug is that nodes can
appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the
following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such
files.  Maybe all @thin derived files should be -kb files, but Leo's
users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is
concerned.  Other .txt files, like leoScripts.txt, should also be
binary files.  As we shall see, the fact that leoProjects.txt is now a
-kb file means that we can not possibly blame the cvs merge algorithm
for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I
added a node called 'changed in the main line'.  In sandbox 2 I added
a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the
following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/
leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.
1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not**
been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge
surprise: the outline contains **both** the node 'changed in main-
line' and the node 'changed2'!

How did this happen?  Well, obviously the 'changed in main-line' node
came from the cvs update.  I expected that.  The 'changed2' line must
have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had
happened.  The 'changed2' is a descendant of a cloned node called '4.4
projects'.

- One clone of '4.4 projects' node is a descendant of the @thin
leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but
outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was
reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node
**already existed in the outline** before Leo read leoProjects.txt,
and the present atFile read logic only **adds** nodes, it never
deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read
logic.  The 'changed2' node became a 'vampire' node that couldn't be
killed.

The problem is far from benign.  Because of clones, the vampire node
became an orphan node in **another** file, namely leoKeys.py.  I tried
two or three times to remove the vampire/orphan node before realizing
what had happened.

The fix (there is *always* a fix) will require some care.  The present
atFile.read logic is robust because it *doesn't* delete nodes.  It is
essential that the read logic remain robust.  I suspect the solutions
will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes
initially, because it doesn't know whether there will be read errors
later.  If there are read errors absolutely nothing must change.  This
ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not
actually read from the derived file.  I think (but haven't proven)
that all descendants of vampire nodes are also vampire nodes.  If that
is so the post-pass will simply delete vampire nodes without worrying
about whether they have descendants.

Warning: the new scheme will mean that cvs update can destroy
information that previously existed in the outline.  I believe this is
correct: we assume that derived files are the 'truly meaningful'
files.  Hey, if we are wrong we can always get the old info from
cvs :-)
QQQ

At present, atFile.read contains code to warn of "resurrected" nodes,
and I did indeed get such a warning when the recent problem arose.

After a quick look at atFile.read, I strongly suspect that the problem
remains today pretty much exactly as it was in 2003.  The only
difference is that the caching code (the call to
root.v.createOutlineFromCacheList(c,aList)) doesn't do the check:
\&lt;\&lt; advise user to delete all unvisited nodes \&gt;\&gt;
that is done later in read(). That probably should be fixed.

Finding a better solution to vampire nodes has been on the list since
2003.  It's not easy because it involves the dreaded "multiple delete"
problem.

Hmm.  The present read code *does* delete the tree before reading thin
external files.  So it appears that vampire nodes could only be
expected in external files derived from @file nodes.  It may be that
part of the problem is that somehow Leo thinks that it is reading an
@file node?? That's pretty weird, but messages about resurrected nodes
and missing tnode lists did happen.  It's quite a puzzle.

Edward
</t>
<t tx="ekr.20101104091058.4981">Specifying a @path directory causes Leo to save an "@thin file.ext" node below
it in Leo's home directory without any warning. The next time Leo is opened it
issues an error that it can not find the file.

It should instead issue a warning that the @path directory does not exist.

If this occurs when the saving of @thin nodes to files is performed as part of
the user closing Leo, the closing of Leo should be aborted to prevent the loss
of data.

===== The Aha

The computation of at./ic.default_directory **must not** attempt to create
directories! It's too early for that!

This simplifies all aspects of the code:

- No need to report errors &amp; no need to recover from errors.
- at.scanAllDirectives can call c.

===== The actual fix:

Due to a previous fix, at.writeAllAtFileNodesHelper does *not* report errors.
This causes Leo to clear all dirty bits.

The proper fix, therefore, is to force a write of the entire @edit tree in
putVnode if it is orphaned.

Similarly, putVnode now forces writes of @auto and @shadow trees.

</t>
<t tx="ekr.20101104091058.4986">http://groups.google.com/group/leo-editor/browse_thread/thread/dbe098206376ec8d

The fixes are marked # 2010/10/22 in &lt;&lt; handle the opcode &gt;&gt;.
</t>
<t tx="ekr.20101104091058.4988"></t>
<t tx="ekr.20101104091058.4989"></t>
<t tx="ekr.20101104091058.4990">- Open a node with long (multi-page) body text
- Move cursor towards the end of the node
- Save (ctrl+s)
- Observe how window is scrolled, cursor is moved
</t>
<t tx="ekr.20101104091058.4991"></t>
<t tx="ekr.20101104091058.4992">https://bugs.launchpad.net/leo-editor/+bug/549319

Leo 4.7.1 final, build 3005, February 26, 2010
Python 2.6.2, qt version 4.5.2
Windows 5, 1, 2600, 2, Service Pack 3

When redirecting the output to the Log pane using g.redirectStderr() and
g.redirectStdout(), the output displays non-breaking space characters (&amp;nbsp;)
everywhere there is supposed to be a space.

For example, if I run print 'Hello World' I get Hello&amp;nbsp;World in the Log
pane. This is really hard to read when you have 50 or 100 lines of numbers from
the output of a program.
</t>
<t tx="ekr.20101104091058.4993">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 366, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 284, in autoComplete
    k.masterCommand(event,func=None,stroke=None,commandName=None)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2606, in masterCommand
    val = k.handleDefaultChar(event,stroke)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2664, in handleDefaultChar
    if stroke.lower() == 'return': stroke = '\n'
AttributeError: 'NoneType' object has no attribute 'lower'
</t>
<t tx="ekr.20101104091058.4994"></t>
<t tx="ekr.20101104091058.4995"></t>
<t tx="ekr.20101104091058.4996"></t>
<t tx="ekr.20101104091058.4997">On Windows, using Leo trunk from a few days ago, I get "error: class
class does not end in a newline; one will be added [nl]" on what seems
to be every imported java chunk.

This issue seems to be line-ending related and I duplicated it with a
simple test.  When I run the following code from within a Leo node, I
get the same error as when I tried to import the file.
</t>
<t tx="ekr.20101104091058.4999"></t>
<t tx="ekr.20101104091058.5000"></t>
<t tx="ekr.20101104091058.5001">https://bugs.launchpad.net/leo-editor/+bug/618474

in core/leoRst the method removeLeoDirectives seems not to remove the leo directives.
which results in @leo directives inside generated rst code.

The problematic code line is the statement "g.match_word(s, 0,key)" in the following block:

                for key in self.leoDirectivesList:
                    if g.match_word(s, 0,key):
                        #g.trace('removing %s' % s)
                        break

As far as I understand the function match_word, it returns 1 if s contains key at index 0,
The self.leoDirectivesList contains all directive like color, language, ... (without @) but
s is a complete body line that looks like: @language rest

That means language starts at index 1 not at 0.
changing the line to
  g.match_word(s, 1,key)

let it work correctly in my installation (4.7.1)
</t>
<t tx="ekr.20101104091058.5002">https://bugs.launchpad.net/leo-editor/+bug/618482

in leoRst.py:

the method "handleCodeMode" does not preserve line linefeeds of the original code. While this is only annoying for code
parts it is fatal for doc parts, because rst directives does not work anymore.

The problem is in the line "elif not z.rstrip(): pass" of the following code block at the end of the method
        for z in result:
            if z == '': result2.append('\n\n')
            elif not z.rstrip(): pass
            elif z.endswith('\n\n'): result2.append(z) # Leave alone.
            else: result2.append('%s\n' % z.rstrip())

Commenting this line out, preserves the linefeeds in the doc part but doubles them in the code part.

The method "rstripList" is responsible for the doubling linefeeds:
   The lines arguments is a list of lines with (!) trailing linefeeds (\n),

   The statement s = '\n'.join(theList).rstrip() doubles therefore the linefeeds
    replacing the line with s = ''.join(theList).rstrip() works.
</t>
<t tx="ekr.20101104091058.5003"></t>
<t tx="ekr.20101104091058.5004"></t>
<t tx="ekr.20101104091058.5005">Also give calmer messages for non-existent plugins.
</t>
<t tx="ekr.20101104091058.5006">Replace ';' by os.pathsep.
</t>
<t tx="ekr.20101104091058.5007">Changed w to self in leoQLineEditWidget.setInsertPoint.
</t>
<t tx="ekr.20101104091058.5008">k.fullCommand now ignores fkeys and Ins.
</t>
<t tx="ekr.20101104091058.5009">leoRst: option strip_at_file_prefixes does not strip file prefixes in leo 4.7.1

The problematic code is in method underline of class rstCommands.
The last statement:

  return '%s\n%s\n\n' % (p.h.strip(),ch*n)

returns the full heading and not stripped one, (in the s parameter)
</t>
<t tx="ekr.20101104091058.5010">If one or more chapters exist (other than main), "Go to clone" switches to the
first chapter, whether or not the clone is in that chapter.

The new code always selects the main chapter.
This is the simplest thing that could possibly work.
Other approaches are fraught with difficulties.
</t>
<t tx="ekr.20101104091058.5011">I created a file time.leo. When it's in the dir d:/Dmitry it's being
opened fine. But when I put it into the dir with Russian characters:
D:/Личное/Время leo prints squares at the window header and doesn't
open the file correctly. This problem existed in one of the revisions,
then it was fixed in the last official release. Now it emerged again
in my Leo 4.8 devel, build 3005

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 3307, in pr
    sys.stdout.write(s2)
  File "c:\python31\lib\encodings\cp437.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_map)[0]

UnicodeEncodeError: 'charmap' codec can't encode character '\xc2' in position
31: character maps to &lt;undefined&gt; path changed for @thin
Unicode-Â-folder/unicode-Â-test2.txt created:
C:\Users\edreamleo\Unicode-Â-folder\unicode-Â-test2.txt
</t>
<t tx="ekr.20101104091058.5012">@nocolor-node

Removed the check-all-python-code and check-python code commands
(and removed the references to these commands in menus.)

- Retained the actual code for scripts.
- Retained automatic syntax checking of python files on saves

The problem with separate commands is that they don't necessarily check an
entire file: things like 'return' in a node that doesn't look it is in a
function.

Directives and section references are not the problem:
they get translated to comments before the check.
</t>
<t tx="ekr.20101104091058.5013">nav_qt.py just uses these:

    c.goPrevVisitedNode()
    c.goNextVisitedNode()

and these subsequently use leoCommand.py / class nodeHistory.

The fix would have to happen in leoFrame.py / selectHelper() which does this:

    c.nodeHistory.update(p) # Remember this position.

It shouldn't call update() there. Rather, the call should be moved to
wherever body focus code is.

The fix was to leoTree.selectHelper and qtBody.onFocusIn.

</t>
<t tx="ekr.20101104091058.5014">Removed all traces of the "significant change" logic. The read code remembers
whether a node existed when Leo loaded the outline.

Leo will warn when writing a node that didn't previously exist. This is a nice
simplification of the code.
</t>
<t tx="ekr.20101104091058.5015">This simplifies the print-settings command.
</t>
<t tx="ekr.20101104091058.5016"></t>
<t tx="ekr.20101104091058.5017">http://groups.google.com/group/leo-editor/browse_thread/thread/a108d70400b28dc9#

g.findTestScript is an important new pattern for sharing code in Leo scripts,
including scripts in @test nodes.

Suppose there is common code that I want to include in several unit tests::

    class Hello():
        def __init__(self,name='john'):
            self.name=name
            print('hello %s' % name)

I put this in a node called 'Common test code'.

The unit tests can "import" the code as follows::

    exec(g.findTestScript('Common test code'))

Now class Hello is available the test code!

This is something that I've wanted to do forever.  It's almost too
easy.  I suppose it's a small security problem, but so is every other
@test node!
</t>
<t tx="ekr.20101104091058.5018">http://groups.google.com/group/leo-editor/browse_thread/thread/e3c736bc9f545b7e#

This is an important new helper.
</t>
<t tx="ekr.20101104091058.5019"></t>
<t tx="ekr.20101104091058.5020"></t>
<t tx="ekr.20101104091058.5021"># And deprecated code mode.
</t>
<t tx="ekr.20101104091058.5022">It is useless in the one-node world.
</t>
<t tx="ekr.20101104091058.5023">http://groups.google.com/group/leo-editor/browse_thread/thread/24cb88a8c2a20a07#

- Space activates abbreviations.
- Multi-line abbreviations handled properly.
- add-global-abbrev command uses entire selected text as the value of the abbreviation.
- Inserted abbreviations are undoable.
- Added support for @data abbreviations and @data global-abbreviations.
- Added support for @bool enable-abbreviations.

apropos-abbreviations
=====================

When abbreviation mode is on (abbrev-mode toggles this mode) Leo will expand
abbreviations as you type. Type the name of an abbreviation, followed by a
space. As soon as you type the space, Leo will replace the name by the
abbreviations value. You can undo the replacement as usual.

Note that defining any abbreviation automatically turns on abbreviation mode.

The add-global-abbreviation command (&lt;alt-x&gt;add-gl&lt;tab&gt;&lt;return&gt;) takes the
selected text as the replacement value of the abbreviation. The minibuffer
prompts you for the name of the abbreviation.
</t>
<t tx="ekr.20101104091058.5024"></t>
<t tx="ekr.20101104091058.5025"></t>
<t tx="ekr.20101104091058.5026">http://groups.google.com/group/leo-editor/browse_thread/thread/d02df89c0b831a7c

I created my own copy of the home page:

    Files--&gt;@edit leo_toc.html

This allows me to group items without creating special pages.
</t>
<t tx="ekr.20101104091058.5027"></t>
<t tx="ekr.20101104091058.5028"></t>
<t tx="ekr.20101104091058.5029">I think @chapters node shouldn't be in a new leo file, but it should
be created when the first chapter is created.

Ditto for the chapter selector toolbar button.
</t>
<t tx="ekr.20101104091058.5030">http://groups.google.com/group/leo-editor/browse_thread/thread/a5a47afa65af9a37

The following changes are on the trunk, and also on Leo's web site:

- In home page, added link to Install page, just above the Beginner's Guide.

- Added more explicit instructions for installing Tk and Qt.

- In step 6 of the Windows install steps, the "assoc .leo=LeoFile"
  is on a line by itself.

- Updated home page to indicate that Leo requires Python and PyQt.
  I also revised and simplified the introduction in other ways.
  Ditto for description of Leo on SourceForge.

- Changed "%1" to "%*" throughout the installation instructions.

- Made batch files given in Installing Leo and Running Leo the same.

- The dialogs that ask for the Leo ID now tells why Leo needs it.

- Just before raising the dialog that asks for the Leo ID, Leo attempts
  to create the Qt Gui first, and then the Tk Gui if Qt does not exist.
  This should make it much less likely that a prompt for the id
  will be sent to the console.


2. The readme.txt file for 4.7.1-final does not mention that Python and PyQt is
   required.

readme.txt does say it has a new Windows installer. This
led me to believe -- erroneously -- that the Windows installer is all
I would need to download and install, since it's typical for most open
source programs I've used to have everything needed for the install
(for example. .NET) in the single Windows download.

2b. And perhaps the readme.txt file as well?

Can the [install] page be updated to make this clearer?

4. When I first went to the Install page, I clicked on the link for
"Installing Leo on Windows", got to the end of the steps and saw the
next section was "Tracking the development version" which I wasn't
interested in doing so I didn't read any further.

Clicking on the installer-created Windows link for Leo on the Start
Menu did nothing. Eventually I found the Windows section under
"Running Leo" and learned it was required to run Leo the first time
from a console window and not by launching it from Windows.
</t>
<t tx="ekr.20101104091058.5031">DnD creates @file or @auto nodes if appropriate
</t>
<t tx="ekr.20101104091058.5032"></t>
<t tx="ekr.20101104091058.5033">http://groups.google.com/group/leo-editor/browse_thread/thread/62ac1977b3704590#

</t>
<t tx="ekr.20101104091058.5034">Having to type the url after @url in headline is annoying.

The @url handler should look into the first line of body for url, if the text in
the headline is not an url. This way, the headline could actually be
descriptive.

I know some plugin does this, but there is no reason why this couldn't be the
default behavior.
</t>
<t tx="ekr.20101104091058.5035">The fix was to the "if not trailingNewlineFlag:" code at the end of at.putBody.
</t>
<t tx="ekr.20101104091058.5036">- improved support for elisp.

    - Use @language lisp instead of @language elisp.

- added importer for .ini files.
</t>
<t tx="ekr.20101104091058.5037"></t>
<t tx="ekr.20101104091058.5038">Refactored g.app.config.readSettingsFiles.

Settings now honored in workbook.

* Window size not honored when opened from menu.
</t>
<t tx="ekr.20101104091058.5039">http://groups.google.com/group/leo-editor/browse_thread/thread/e6075a699909db53

You can now set a proportional font to use in all "@language plain" nodes

Specify fonts in @font nodes:

@font plain null font

plain_null_font_family = Times New Roman
plain_null_font_size = 16
plain_null_font_slant = roman
plain_null_font_weight = bold

That is, the actual font specs are in the body text.  Everything
except @font is ignored in the headline.

Specify colors in @color nodes:

@color plain null color = black
</t>
<t tx="ekr.20101104091058.5040">Added the following options with the indicated defaults.

\@color minibuffer_background_color = lightblue
\@color minibuffer_warning_color = lightgrey
</t>
<t tx="ekr.20101104091058.5041">Valid values are top,bottom,left,right
</t>
<t tx="ekr.20101104091058.5042"></t>
<t tx="ekr.20101104091058.5043">Command-line args
</t>
<t tx="ekr.20101104091058.5044">@bool enable-abbreviations (default: False)

  When true, enables substitution of abbreviations.

@data global-abbreviations
@data abbreviations

  In both cases, body text contains lines of
  the form::

   name=value

  name is the abbreviation name, value is the substituted text. Whitespace is
  ignore around the name, but is significant in the value. Abbreviation names
  may contain only alphabetic characters, but may start with the '@' sign.

  By *convention* @data global-abbreviations setting should be defined in
  myLeoSettings.leo, while @data abbreviations should be defined in other .leo
  files. Regardless of where they are defined, abbreviations in @data
  abbreviation nodes will override settings (with the same name) in @data
  global-abbreviations nodes.
</t>
<t tx="ekr.20101104091058.5045"></t>
<t tx="ekr.20101104091058.5150"></t>
<t tx="ekr.20101104091058.5252">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/611413

These work around the lack of AI in Python's importer.

Added leoImport.findClass helper.

The head-to-prev-node command moves non-empty text preceding a class, method or
function definition to the end of the previous sibling node.

The tail-to-next-node command moves non-empty text following a class, method or
function definition to the start of the next sibling node.
</t>
<t tx="ekr.20101104173324.4920">g.app.setLeoID now calls createDefaultGui instead of createTkGui.

We can *not* put up the LeoID dialog later: it is needed to set
g.app.nodeIndices, which is used in the read logic for outlines, so it *must* be
set before we load any Leo file!

</t>
<t tx="ekr.20101104173324.4921">There are some tricky issues here:

http://groups.google.com/group/leo-editor/browse_thread/thread/4da36f0d897a25e8

Important: g.loadOnePlugin calls the plugins onCreate method to make up for
events that have already been generated. pc.loadOnePlugin does not.
</t>
<t tx="ekr.20101104173324.4923"># Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
</t>
<t tx="ekr.20101104173324.4924">putVnode must test for @file just like @thin.
</t>
<t tx="ekr.20101104173324.5021"></t>
<t tx="ekr.20101104173324.5023">The code that calculates the end of a block of indented Python code now takes
take more care with backslashes.
</t>
<t tx="ekr.20101104173324.5028"></t>
<t tx="ekr.20101104173324.5031"></t>
<t tx="ekr.20101104173324.5032">Allow "always on" operation:

- Ctrl-space is now bound to force-auto-completion

- Remove Alt-1 and Alt-2 default bindings.
</t>
<t tx="ekr.20101104173324.5102">- Added better prompts for move/copy/clone commands.

- Undo/redo of these commands select the main chapter.
</t>
<t tx="ekr.20101104173324.5133">http://bugs.launchpad.net/leo-editor/+bug/611413

These work around the lack of AI in Python's importer.

The head-to-prev-node command moves non-empty text preceding a class, method or
function definition to the end of the previous sibling node.

The tail-to-next-node command moves non-empty text following a class, method or
function definition to the start of the next sibling node.
</t>
<t tx="ekr.20101104173324.5138">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/dea95cd8ab976cac


&gt; &gt; * The file 'INSTALL.TXT' contains the outline text with sentinels from
&gt; &gt; 'Chapter 1: Installing Leo'

There are *two* files called install.txt: the one that should
contain installation instructions and the one that contains the
"Installing Leo" chapter.

The solution was to change install.txt to installing.txt in the users guide.
</t>
<t tx="ekr.20101104173324.5140"></t>
<t tx="ekr.20101104173324.5141">- Added code-to-rst command.

- Completed cascade-windows and minimize-all-windows commands.

- Created head-to-prev-node and tail-to-next-node commands.

- Removed mark-clones command.  It is useless in the one-node world.

- Added extract-python-method command.
</t>
<t tx="ekr.20101104173324.5142"></t>
<t tx="ekr.20101104191857.5820">http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

</t>
<t tx="ekr.20101105082829.4917">Fixed wishlist bug 670744: add a setting to put inter-def code in its own node

Added support for @bool at_auto_separate_non_def_nodes option.
The default (legacy mode) is False.
</t>
<t tx="ekr.20101113063552.9398" str_atime="1376413523.0">.. |br| raw:: html

   &lt;br /&gt;

active_path.py |br|
    Synchronizes @path nodes with folders.

add_directives.py |br|
    Allows users to define new @directives.

at_folder.py |br|
    Synchronizes @folder nodes with folders.

at_produce.py |br|
    Executes commands in nodes whose body text starts with @produce.

at_view.py |br|
    Adds support for \@clip, \@view and \@strip nodes.

attrib_edit.py |br|
    Edits user attributes in a Qt frame.

backlink.py |br|
    Allows arbitrary links between nodes.

bibtex.py |br|
    Manages BibTeX files with Leo.
   
bigdash.py |br|
    Creates a global search window.

bzr_qcommands.py |br|
    Adds a context menu to each node containing all the commands in the bzr Qt
    interface. Bzr is invoked based on the path of the current node.

chapter_hoist.py |br|
    Creates hoist buttons.

colorize_headlines.py |br|
    Manipulates appearance of individual tree widget items.

contextmenu.py |br|
    Defines various useful actions for context menus (Qt only).

datenodes.py |br|
    Allows users to insert headlines containing dates.

debugger_pudb.py |br|
    Makes g.pdb() enter the Pudb debugger instead of pdb.

detect_urls.py |br|
    Colorizes URLs everywhere in a node's body on node selection or saving.
    Double clicking on any URL launches it in the default browser.

dtest.py |br|
    Sends code to the doctest module and reports the result.

dump_globals.py |br|
    Dumps Python globals at startup.

EditAttributes.py |br|
    Lets the user associate text with a specific node.

empty_leo_file.py |br|
    Allows Leo to open any empty file as a minimal .leo file.

enable_gc.py |br|
    Enables debugging and tracing for Python's garbage collector.

expfolder.py |br|
    Adds @expfolder nodes that represent folders in the file system.

FileActions.py |br|
    Defines actions taken when double-clicking on @&lt;file&gt; nodes and
    supports @file-ref nodes.

geotag.py |br|
    Tags nodes with latitude and longitude.

graphcanvas.py |br|
    Adds a graph layout for nodes in a tab.
    Requires Qt and the backlink.py plugin.

import_cisco_config.py |br|
    Allows the user to import Cisco configuration files.

initinclass.py |br|
    Modifies the Python @auto importer so that the importer
    puts the __init__ method (ctor) into the body of the class node.

interact.py |br|
    Adds buttons so Leo can interact with command line environments.

ipython.py |br|
    Creates a two-way communication (bridge) between Leo
    scripts and IPython running in the console from which Leo was launched.

leo_interface.py |br|
    Allows the user to browse XML documents in Leo.

leo_pdf.py |br|
    This NOT a Leo plugin: this is a docutils writer for .pdf files.

leo_to_html.py |br|
    Converts a leo outline to an html web page.**.

leo_to_rtf.py |br|
    Outputs a Leo outline as a numbered list to an RTF file. The RTF file can be
    loaded into Microsoft Word and formatted as a proper outline.

leocursor.py |br|
    Creates a LeoCursor object that can walk around a Leo outline and decode
    attributes from nodes.
   
leomylyn.py |br|
    Provides a "Mylyn" like experience for Leo.

leoremote.py |br|
    Remote control for Leo.

leoscreen.py |br|
    Allows interaction with shell apps via screen.

lineNumbers.py |br|
    Adds #line directives in perl and perlpod programs.
   
livecode.py |br|
    Creates a live code-evaluation pane.

macros.py |br|
    Creates new nodes containing parameterized section references.

maximizeNewWindows.py |br|
    Maximizes all new windows.

mime.py |br|
    Opens files with their default platform program.

mod_autosave.py |br|
    Autosaves the Leo outline every so often.

mod_framesize.py |br|
    Sets a hard coded frame size.

mod_http.py |br|
    A minimal http plugin for Leo, based on AsyncHttpServer.py.

mod_read_dir_outline.py |br|
    Allows Leo to read a complete directory tree into a Leo outline. Converts
    directories into headlines and puts the list of file names into bodies.

mod_scripting.py |br|
    Creates script buttons and @button, @command, @plugin and @script nodes.

mod_tempfname.py |br|
    Replaces c.openWithTempFilePath to create alternate temporary
    directory paths.

mod_timestamp.py |br|
    Timestamps all save operations to show when they occur.

multifile.py |br|
    Allows Leo to write a file to multiple locations.

nav_qt.py |br|
    Adds "Back" and "Forward" buttons (Qt only).

niceNosent.py |br|
    Ensures that all descendants of @file-nosent nodes end
    with exactly one newline, replaces all tabs with spaces, and
    adds a newline before class and functions in the derived file.

nodeActions.py |br|
    Allows the definition of double-click actions.
   
nodeTags.py |br|
    Provides node tagging capabilities to Leo.

open_shell.py |br|
    Creates an 'Extensions' menu containing two commands:
    Open Console Window and Open Explorer.

outline_export.py |br|
    Modifies the way exported outlines are written.

paste_as_headlines.py |br|
    Creates new headlines from clipboard text.

plugins_menu.py |br|
    Creates a Plugins menu and adds all actives plugins to it.

pretty_print.py |br|
    Customizes pretty printing.
   
printing.py |br|
    Supports printing for the Qt gui.

projectwizard.py |br|
    Creates a wizard that creates @auto nodes.

quickMove.py |br|
    Creates buttons to move nodes quickly to other nodes.

quicksearch.py |br|
    Adds a fast-to-use search widget, like the "Find in files" feature of many editors.

quit_leo.py |br|
    Shows how to force Leo to quit.

read_only_nodes.py |br|
    Creates and updates @read-only nodes.

redirect_to_log.py |br|
    Sends all output to the log pane.

run_nodes.py |br|
    Runs a program and interface Leos through its input/output/error streams.
   
screen_capture.py |br|
    Supports taking screen shots. See http://leo-editor.github.io/screen_capture.html

screenshots.py |br|
    Creates stand-alone slideshows containing screenshots.

script_io_to_body.py |br|
    Sends output from the Execute Script command to the end of the body pane.

scripts_menu.py |br|
    Creates a Scripts menu for LeoPy.leo.

scrolledmessage.py |br|
    Provides a Scrolled Message Dialog service for Qt.

setHomeDirectory.py |br|
    Sets g.app.homeDir to a hard-coded path.

slideshow.py |br|
    Support slideshows in Leo outlines.

spydershell.py |br|
    Launches the spyder environment with access to Leo instance.
    See http://packages.python.org/spyder/.

startfile.py |br|
    Launches (starts) a file given by a headline when double-clicking the icon.

stickynotes.py |br|
    Adds simple "sticky notes" feature (popout editors) for Qt gui.
   
timestamp.y
    Manages attributes containing node creation/modification/viewed times.

todo.py |br|
    Provides to-do list and simple task management for leo (Qt only).

tomboy_import.py |br|
    Allows imports of notes created in Tomboy / gnote.

trace_gc_plugin.py |br|
    Traces changes to Leo's objects at idle time.

trace_keys.py |br|
    Traces keystrokes in the outline and body panes.

trace_tags.py |br|
    Traces most common hooks, but not key, drag or idle hooks.

valuespace.py |br|
    Supports outline-based calculations similar to spreadsheets.

viewrendered.py |br|
    Creates a window for *live* rendering of rst, html, etc.
    This plugin uses docutils, http://docutils.sourceforge.net/,
    to do the rendering, so installing docutils is recommended.
    Supports @graphics-script, @image, @html, @movie and @svg nodes.
   
viewrendered.py |br|
    An alternate/enhanced version of viewrendered.py.

vim.py |br|
    Enables two-way communication with VIM.

word_count.py |br|
    Counts characters, words, lines, and paragraphs in the body pane.

word_export.py |br|
    Adds the Plugins\:Word Export\:Export menu item to format and export
    the selected outline to a Word document, starting Word if necessary.

xemacs.py |br|
    Allows you to edit nodes in emacs/xemacs.

xsltWithNodes.py |br|
    Adds the Outline:XSLT menu containing XSLT-related commands.

zenity_file_dialogs.py |br|
    Replaces Leo's file dialogs on Linux with external
    calls to the zenity gtk dialog package.
</t>
<t tx="ekr.20101113063552.9399" str_atime="1376413520.0"></t>
<t tx="ekr.20101113063552.9400">Edits user attributes in a Qt frame.

This plugin creates a frame for editing attributes similar to::

    Name:   Fred Blogs
    Home:   555-555-5555
    Work:   555-555-5556

``attrib_edit`` is also intended to provide attribute editing for
other plugins, see below.

The attributes can be stored in different ways, three modes are implemented
currently:

v.u mode
  These attributes are stored in the "unknownAttributes" (uA) data for
  each node, accessed via v.u.

Field:
  Attributes are lines starting (no whitespace) with "AttributeName:" in
  the body text.

@Child
  Attributes are the head strings of child nodes when the head string
  starts with '@AttributeName' where the first letter (second character)
  must be capitalized.

The plugin defines the following commands, available either in the
plugin's sub-menu in the Plugins menu, or as ``Alt-X attrib-edit-*``.

attrib-edit-modes
    Select which attribute setting / getting modes to use.  More than one mode
    can be used at the same time.

    You can also control which modes are active by listing them 
    with the @data attrib_edit_active_modes setting.  For example::

        Field:
        @Child
        # v.u mode

    would cause only the "Field:" and "@Child" modes to be active be default.

attrib-edit-manage
    Select which attributes, from all attributes seen so
    far in this outline, to include on the current node.

attrib-edit-scan
    Scan the entire outline for attributes so ``attrib-edit-manage``
    has the complete list.

attrib-edit-create
    Create a new attribute on the current node.  If Field: or \@Child modes
    are active, they simply remind you how to create an attribute in the log pane.
    If the "v.u mode" mode is active, you're prompted for a path for the attribute.
    For example::

        addressbook First

    to store the attribute in v.u['addressbook']['_edit']['First']

    As a convenience, entering a path like::

        todo metadata created|creator|revised

    would create::

        v.u.['todo']['metadata']['_edit']['created']
        v.u.['todo']['metadata']['_edit']['creator']
        v.u.['todo']['metadata']['_edit']['revised']


**Technical details**

See the source for complete documentation for use with other
plugins. Here are some points of interest:

- In addition to ``v.u['addressbook']['_edit']['first']``, paths
  like ``v.u['addressbook']['_edit']['_int']['age']`` may be used
  to identify type, although currently there's no difference in
  the edit widget.

- In the future the plugin may allow other plugins to register
  to provide attribute path information, instead of just
  scanning for ['_edit'] entries in v.u.

- Currently there's no sorting of the attributes in "v.u mode", which is
  a problem for some applications.  It's unclear where the
  desired order would be stored, without even more repetition
  in v.u.  When other plugins can register to manipulate the
  attribute list each plugin could address this, with unordered
  presentation in the absence of the client plugin.

- There's code to have the editor appear in a tab instead
  of its own area under the body editor, but (a) this is
  always being buried by output in the log window, and
  (b) there's a bug which leaves some (harmless) ghost 
  widgets in the background.  Enable by @setting
  ``attrib_edit_placement`` to 'tab'.

</t>
<t tx="ekr.20101113063552.9401">Manipulates appearance of individual tree widget items.

This plugin is mostly an example of how to change the appearance of headlines.
As such, it does a relatively mundane chore of highlighting @thin, @auto,
@shadow nodes in bold.
</t>
<t tx="ekr.20101113063552.9402">Defines various useful actions for context menus (Qt only).

Examples are:

- Edit in $EDITOR
- Edit @thin node in $EDITOR (remember to do "refresh" after this!)
- Refresh @thin node from disk (e.g. after editing it in external editor)
- Go to clone

Here's an example on how to implement your own context menu items 
in your plugins::

    def nextclone_rclick(c,p, menu):
        """ Go to next clone """

        # only show the item if you are on a clone
        # this is what makes this "context sensitive"
        if not p.isCloned():
            return    

        def nextclone_rclick_cb():
            c.goToNextClone()

        # 'menu' is a QMenu instance that was created by Leo 
        # in response to right click on tree item

        action = menu.addAction("Go to clone")
        action.connect(action, QtCore.SIGNAL("triggered()"), nextclone_rclick_cb)

And call this in your plugin *once*::

    g.tree_popup_handlers.append(nextclone_rclick)
</t>
<t tx="ekr.20101113063552.9403">Adds "Back" and "Forward" buttons (Qt only).

Creates "back" and "forward" buttons on button bar. These navigate
the node history.

This plugin does not need specific setup. If the plugin is loaded, the buttons 
will be available. The buttons use the icon specified in the active Qt style

</t>
<t tx="ekr.20101113063552.9404">Creates a wizard that creates @auto nodes.

Opens a file dialog and recursively creates @auto &amp; @path nodes from the path
where the selected file is (the selected file itself doesn't matter.)

</t>
<t tx="ekr.20101113063552.9405">Adds a fast-to-use search widget, like the "Find in files" feature of many editors.

Just load the plugin, activate "Nav" tab, enter search text and press enter.

The pattern to search for is, by default, a case *insensitive* fnmatch pattern
(e.g. foo*bar), because they are typically easier to type than regexps. If you
want to search for a regexp, use 'r:' prefix, e.g. r:foo.*bar.

Regexp matching is case sensitive; if you want to do a case-insensitive regular
expression search (or any kind of case-sensitive search in the first place), do it
by searching for "r:(?i)Foo". (?i) is a standard feature of Python regular expression
syntax, as documented in 

http://docs.python.org/library/re.html#regular-expression-syntax

</t>
<t tx="ekr.20101113063552.9406">Provides a Scrolled Message Dialog service for Qt.

The plugin can display messages supplied as plain text or formatted as html. In
addition the plugin can accept messages in rst format and convert them to be
displayed as html.

The displayed format can be controlled by the user via check boxes, so rst
messages may be viewed either as text or as html. Html messages can also be
viewed as raw text, which will be a good debug feature when creating complex
dynamically generated html messages.

The user interface is provided by a ScrolledMessage.ui file which is dynamically
loaded each time a new dialog is loaded.

The dialog is not modal and many dialogs can exist at one time. Dialogs can be
named and output directed to a dialog with a specific name.

The plugin is invoked like this::

    g.doHook('scrolledMessage', c=c, msg='message', title='title',  ...etc    )

or::

    g.app.gui.runScrolledMessageDialog(c=c, ...etc)

All parameters are optional except c.

**Parameters**

msg:
    The text to be displayed (html, rst, plain).

    If the text starts with 'rst:' it is assumed to be rst text and
    is converted to html for display after the rst: prefix has been removed.
    If the text starts with '&lt;' it is assumed to be html.
    These auto detection features can be overridden by 'flags'.

label:
    The text to appear in a label above the display. If it is '', the label is hidden.

title:
    The title to appear on the window or dock.

flags:
    Says what kind of message: 'rst', 'text', 'html'. This overrides auto-detection.

    Flags can be combined, for example, 'rst html' causes the message to be interpreted as rst and
    displayed as html.

..  To Do
..  - Add parameters to control position, size, closing, hiding etc.
..  - Save or print files from the dialog.
..  - Add an option to put the dialog in leo's log notebook.
..  - Add \@settings to control default behavior
..  - Provide a menu of plugins that allows their docstring to be displayed.
..  - Provide a menu of @rst nodes in the current outline, automatically track changes
..    if it is set to display any of these nodes.
</t>
<t tx="ekr.20101113063552.9407">Launches the spyder environment with access to Leo instance.
See http://packages.python.org/spyder/

Execute alt-x spyder-launch to start spyder. Execute alt-x spyder-update to pass
current c,p,g to spyder interactive session. spyder-update also shows the window
if it was closed before.

</t>
<t tx="ekr.20101113063552.9408">Adds simple "sticky notes" feature (popout editors) for Qt gui.

Adds the following (``Alt-X``) commands:

``stickynote``
  pop out current node as a sticky note
``stickynoter``
  pop out current node as a rich text note
``stickynoteenc``
  pop out current node as an encrypted note
``stickynoteenckey``
  enter a new en/decryption key
``tabula``
  add the current node to the stickynotes in the `Tabula`
  sticky note dock window, and show the window
``tabula-show``
  show the`Tabula` sticky note dock window
  (without adding the current node)
``tabula-marked``
  add all marked nodes to the stickynotes in the `Tabula`
  sticky note dock window, and show the window

Sticky notes are synchronized (both ways) with their parent Leo node.

Encrypted mode requires the python-crypto module.

The first time you open a note in encrypted mode you'll be asked for a pass
phrase. That phrase will be used for the rest of the session, you can change it
with ``Alt-X`` ``stickynoteenckey``, but probably won't need to.

The encrypted note is stored in base64 encoded *encrypted* text in the parent
Leo node, if you forget the pass phrase there's no way to un-encrypt it again.
Also, you must not edit the text in the Leo node.

When **creating an encrypted note**, you should **start with an empty node**.
If you want to encrypt text that already exists in a node, select-all cut it to
empty the node, then paste it into the note.

</t>
<t tx="ekr.20101113063552.9409">Provides to-do list and simple task management for leo (Qt only).

This plugin adds time required, progress and priority settings for nodes. With
the @project tag a branch can display progress and time required with dynamic
hierarchical updates.

For full documentation see:

  - http://leo.zwiki.org/ToDo 
  - http://leo.zwiki.org/tododoc.html

</t>
<t tx="ekr.20101113063552.9410">Creates a window for *live* rendering of rst, html, etc.  Qt only.
Supports @graphics-script, @image, @html, @movie and @svg nodes.

viewrendered.py creates a single ``Alt-X`` style command, ``viewrendered``,
which opens a new window where the current body text is rendered as HTML
(if it starts with '&lt;'), or otherwise reStructuredText.  reStructuredText
errors and warnings may be shown.  For example, both::

    Heading
    -------

    `This` is **really** a line of text.

and::

    &lt;h1&gt;Heading&lt;h1&gt;

    &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text.

will look something like:

**Heading**

`This` is **really** a line of text.

</t>
<t tx="ekr.20101113063552.9411">Adds a graph layout for nodes in a tab.
Requires Qt and the backlink.py plugin.

</t>
<t tx="ekr.20101113063552.9412"></t>
<t tx="ekr.20101113063552.9413">Allows users to define new @direcives.

</t>
<t tx="ekr.20101113063552.9414">Adds a context menu to each node containing all the commands in the bzr Qt
interface. Bzr is invoked based on the path of the current node.

**Requires contextmenu.py.**

</t>
<t tx="ekr.20101113063552.9415">Allows Leo to open any empty file as a minimal .leo file.

</t>
<t tx="ekr.20101113063552.9416">Allows the user to import Cisco configuration files.

Adds the "File:Import:Import Cisco Configuration" menu item. The plugin will:

1)  Create a new node, under the current node, where the configuration will be
    written. This node will typically have references to several sections (see below).

2)  Create sections (child nodes) for the indented blocks present in the original
    config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
    there will be an 'interface' child node, with as many sub-nodes as there are real
    interfaces in the configuration file).

3)  Create sections for the custom keywords specified in the customBlocks[] list in
    importCiscoConfig(). You can modify this list to specify different keywords. DO
    NOT put keywords that are followed by indented blocks (these are taken care of by
    point 2 above). The negated form of the keywords (for example, if the keyword is
    'service', the negated form is 'no service') is also included in the sections.


4)  Not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.

</t>
<t tx="ekr.20101113063552.9417">Modifies the Python @auto importer so that the importer
puts the __init__ method (ctor) into the body of the class node.

This makes it easier to keep the instance variable docs in the class
docstring in sync. with the ivars as manipulated by __init__, saves
repeating explanations in both places.

Note that this is done *after* the consistency checks by the @auto
import code, so using this plugin is at your own risk.  It will change
the order of declarations if other methods are declared before __init__.

</t>
<t tx="ekr.20101113063552.9418">Allows the user to browse XML documents in Leo.

This file implements an interface to XML generation,
so that the resulting file can be processed by leo.

..  class file represents the whole leo file.
..  class leo_node has a headline and body text.

..  If you encounter the first of a set of clones, create a leo_node. If you
..  encounter the same set of clones later, create a leo_clone node and refer back
..  to the first element.

</t>
<t tx="ekr.20101113063552.9419">Adds #line directives in perl and perlpod programs.

Over-rides two methods in leoAtFile.py to write #line directives after node
sentinels. This allows compilers to give locations of errors in relation to the
node name rather than the filename. Currently supports only perl and perlpod.

</t>
<t tx="ekr.20101113063552.9420">Creates new nodes containing parameterized section reference.

.. No longer available: http://sourceforge.net/forum/message.php?msg_id=2444117

This plugin adds nodes under the currently selected tree that are to act as
section references. To do so, go the Outline menu and select the
'Parameterize Section Reference' command. This plugin looks for a top level node called
'Parameterized Nodes'. If it finds a headline that matches the section reference
it adds a node/nodes to the current tree.

To see this in action, do the following:

0. **Important**: in the examples below, type &lt;&lt; instead of &lt; &lt; and
   type &gt;&gt; instead of &gt; &gt;.  Docstrings can not contain section references!

1. Create a node called 'Parameterized Nodes', with a sub-node called  &lt; &lt; Meow \&gt;\&gt;.
   The body of &lt; &lt; Meow &gt; &gt; should have the text::

        I mmmm sooo happy I could  &lt; &lt; 1$  &gt; &gt;.
        But I don't know if I have all the  &lt; &lt; 2$  &gt; &gt;
        money in the world.

2. In a node called A, type::

        &lt; &lt; meow( purrrrrr, zzooot )  &gt; &gt;
        (leave the cursor at the end of the line)

3. In a node called B, type::

         &lt; &lt; meow ( spit or puke, blinkin  )  &gt; &gt;
        (leave the cursor at the end of the line)

4. Leave the cursor in Node A at the designated point.

5. Go to Outline and select Parameterize Section Reference.

The plugin searches the outline, goes to level one and finds a Node with the Headline,
"Parameterized Nodes". It looks for nodes under that headline with the the headline
&lt;\&lt; meow &gt;\&gt;. It then creates this node structure under Node A::

        &lt; &lt; meow ( purrrrrr, zzooot ) &gt; &gt;
            &lt; &lt;2$&gt; &gt;
            &lt; &lt;1$&gt; &gt;

6. Examine the new subnodes of Node A:  

        &lt; &lt; meow ( purrrrrr, zzooot ) &gt; &gt; contains the body text of the &lt; &lt; meow &gt; &gt; node.
        &lt; &lt; 1$ &gt; &gt; contains the word purrrrrr.
        &lt; &lt; 2$ &gt; &gt; contains the word zzooot.

7. Go to Node B, and leave the cursor at the designated point.

Go to Outline Menu and select Parameterize Section Reference command.

8. Examine the new subnodes of Node B.

It's a lot easier to use than to explain!

</t>
<t tx="ekr.20101113063552.9421">Autosaves the Leo outline every so often.

The time between saves is given by the setting, with default as shown::

    @int mod_autosave_interval = 300

This plugin is active only if::

    @bool mod_autosave_active = True

</t>
<t tx="ekr.20101113063552.9422">Allows Leo to read a complete directory tree into a Leo outline. Converts
directories into headlines and puts the list of file names into bodies.

Ce plug-in permet de traduire l'arborescence d'un répertoire en une arborescence
Leo : Chaque dossier est converti en noeud dans Leo ; son nom est placé dans
l'entête du noeud et chaque nom de fichier qu'il contient est listé dans son
contenu.

Feedback on this plugin can be sent to::

    Frédéric Momméja
    &lt;frederic [point] mommeja [at] laposte [point] net&gt;

</t>
<t tx="ekr.20101113063552.9423">Timestamps all save operations to show when they occur.

</t>
<t tx="ekr.20101113063552.9425">Modifies the way exported outlines are written.

</t>
<t tx="ekr.20101113063552.9426">Creates new headlines from clipboard text.

If the pasted text would be greater than 50 characters in length, the plugin
truncates the headline to 50 characters and pastes the entire line into the body
text of that node. Creates a "Paste as Headlines" option the Edit menu directly
under the existing Paste option.

</t>
<t tx="ekr.20101113063552.9427">Customizes pretty printing.

The plugin creates a do-nothing subclass of the default pretty printer. To
customize, simply override in this file the methods of the base prettyPrinter
class in leoCommands.py. You would typically want to override putNormalToken or
its allies. Templates for these methods have been provided. You may, however,
override any methods you like. You could even define your own class entirely,
provided you implement the prettyPrintNode method.

</t>
<t tx="ekr.20101113063552.9428">Creates buttons to move nodes quickly to other nodes.

Quickly move/copy/clone nodes from around the tree to one or more target nodes.
It can also create bookmark and tagging functionality in an outline (see `Set
Parent Notes` below).

Adds `Move/Clone/Copy To Last Child Button` and `Move/Clone/Copy To First Child Button`,
`Link To/From` and `Jump To` commands to the Move sub-menu on the
Outline menu, and each node's context menu, if the `contextmenu` plugin is enabled.

Select a node ``Foo`` and then use the `Move To Last Child Button` command.
This adds a 'to Foo' button to the button bar. Now select another node and click
the 'to Foo' button. The selected node will be moved to the last child
of the node 'Foo'.

`To First Child Button` works the same way, except that moved nodes are inserted
as the first child of the target node.

`Clone` and `Copy` variants are like `Move`, but clone or copy instead of moving.

`Link` works in conjunction with the `backlink` plugin (and also the
`graphcanvas` plugin) creating a link to/from the target and current nodes.

`Jump` buttons act as bookmarks, taking you to the target node.

You can right click on any of these buttons to access their context menu:

  Goto Target
    takes you to the target node (like a `Jump` button).
  Make Permanent
    makes the button permanent, it will reappear
    when the file is saved / closed / re-opened.
  Set Parent
    allows you to move buttons to sub-menu items of other
    `quickMove` buttons.  This implicitly makes the moved button
    permanent.  It also causes the moved button to lose its context menu.
  Remove Button
    comes from the `mod_scripting` plugin, and just
    removes the button for the rest of the current session.

Set Parent Notes
  `Set Parent` doesn't allow you to do anything with `quickMove` you couldn't
  do with a long strip of separate buttons, but it collects quickMove buttons
  as sub-menu items of one quickMove button, saving a lot of toolbar space.

Bookmarks 
  Create somewhere out of the way in your outline a node called
  `Bookmarks`. Use the quickMove menu to make it a `Jump To` button, and use its
  context menu to make it permanent. There is no particular reason to jump to
  it, but it needs to be a `quickMove` button of some kind.

  Now, when you want to bookmark a node, first use the quickMove menu to make
  the node a `Jump To` button, and then use the context menu on the button to
  set its parent to your `Bookmarks` button.  It becomes a sub-menu item
  of the `Bookmarks` button.

Tags
  In conjunction with the `backlinks` plugin you can use `quickMove` to
  tag nodes.   The `backlinks` plugin adds a `Links` tab to the `Log pane`.

  Create somewhere in your outline a node called `Tags`. Use the quickMove menu
  to make it a `Jump To` button, and use its context menu to make it permanent.
  Clicking on it will jump you to your tag list. Now create a node under the
  `Tags` node for each tag you want. The node's name will be the tag name, and
  can be changed later. Then use the quickMove menu to make each of these nodes
  a `Link To` button, and then use the context menu on the button to set its
  parent to your `Tags` button. It becomes a sub-menu item of the `Tags` button.

  To see the tags on a node, you need to be looking at the `Links` tab in the
  `Log pane`.  To see all the nodes with a particular tag, click on the `Tags`
  button to jump to the tag list, and select the node which names the tag of
  interest.  The nodes with that tag will be listed in th `Links` tab in the
  `Log pane`.

</t>
<t tx="ekr.20101113063552.9429">Sets g.app.homeDir to a hard-coded path.

</t>
<t tx="ekr.20101113063552.9430">Counts characters, words, lines, and paragraphs in the body pane.

It adds a "Word Count..." option to the bottom of the Edit menu that will
activate the command.

</t>
<t tx="ekr.20101113063552.9431"></t>
<t tx="ekr.20101113063552.9432">Makes g.pdb() enter the Pudb debugger instead of pdb.

Pudb is a full-screen Python debugger:
http://pypi.python.org/pypi/pudb

</t>
<t tx="ekr.20101113063552.9433">Dumps Python globals at startup.

</t>
<t tx="ekr.20101113063552.9434">Enables debugging and tracing for Python's garbage collector.

</t>
<t tx="ekr.20101113063552.9435">Shows how to force Leo to quit.

</t>
<t tx="ekr.20101113063552.9436" str_atime="1376412861.0">Traces changes to Leo's objects at idle time.

</t>
<t tx="ekr.20101113063552.9437">Traces keystrokes in the outline and body panes.

</t>
<t tx="ekr.20101113063552.9438">Traces most common hooks, but not key, drag or idle hooks.

</t>
<t tx="ekr.20101113063552.9439"></t>
<t tx="ekr.20101113063552.9440">Creates a two-way communication (bridge) between Leo
scripts and IPython running in the console from which Leo was launched.

Using this bridge, scripts running in Leo can affect IPython, and vice versa.
In particular, scripts running in IPython can alter Leo outlines!

For full details, see Leo Users Guide:
http://leoeditor.com/IPythonBridge.html

</t>
<t tx="ekr.20101113063552.9441">Replaces c.openWithTempFilePath to create alternate temporary
directory paths.

Two alternates are supported. The default method creates temporary files with a
filename that begins with the headline text, and located in a "username_Leo"
subdirectory of the temporary directory. The "LeoTemp" prefix is omitted. If
'open_with_clean_filenames' is set to true then subdirectories mirror the node's
hierarchy in Leo. Either method makes it easier to see which temporary file is
related to which outline node.

</t>
<t tx="ekr.20101113063552.9442">Creates an 'Extensions' menu containing two commands:
Open Console Window and Open Explorer.

The Open Console Window command opens xterm on Linux.
The Open Explorer command Opens a Windows explorer window.

This allows quick navigation to facilitate testing and navigating large systems
with complex directories.

Please submit bugs / feature requests to etaekema@earthlink.net

Current limitations:
- Not tested on Mac OS X ...
- On Linux, xterm must be in your path.

</t>
<t tx="ekr.20101113063552.9443">Allows imports of notes created in Tomboy / gnote.

Usage:

* Create a node with the headline 'tomboy'
* Select the node, and do alt+x act-on-node    
* The notes will appear as children of 'tomboy' node
* The next time you do act-on-node, existing notes will be updated (they don't need to 
  be under 'tomboy' node anymore) and new notes added.

</t>
<t tx="ekr.20101113063552.9444">Enables two-way communication with VIM.

It's recommended that you have gvim installed--the basic console vim is not recommended.

When properly installed, this plugin does the following:

- By default, the plugin opens nodes on icondclick2 events.
  (double click in the icon box)

- The setting::

    @string vim_trigger_event = icondclick2

  controls when nodes are opened in vim.  The default, shown above,
  opens a node in vim on double clicks in Leo's icon box.
  A typical alternative would be::

      @string vim_trigger_event = iconclick2

  to open nodes on single clicks in the icon box.
  You could also set:

      @string vim_trigger_event = select2

  to open a node in vim whenever the selected node changes for any reason.

- Leo will put Vim cursor at same location as Leo cursor in file if 'vim_plugin_positions_cursor' set to True.

- Leo will put node in a Vim tab card if 'vim_plugin_uses_tab_feature' set to True.

- Leo will update the node in the outline when you save the file in VIM.

To install this plugin do the following:

1. On Windows, set the vim_cmd and vim_exe settings to the path to vim or gvim
   as shown in leoSettings.leo. Alternatively, you can ensure that gvim.exe is
   on your PATH.

1. If you are using Python 2.4 or above, that's all you need to do. Jim
   Sizelove's new code will start vim automatically using Python's subprocess
   module. The subprocess module comes standard with Python 2.4. For Linux
   systems, Leo will use subprocess.py in Leo's extensions folder if necessary.
</t>
<t tx="ekr.20101113063552.9445">Allows you to edit nodes in emacs/xemacs.

Depending on your preference, selecting or double-clicking a node will pass the
body text of that node to emacs. You may edit the node in the emacs buffer and
changes will appear in Leo.

</t>
<t tx="ekr.20101113063552.9446">Adds the Plugins\:Word Export\:Export menu item to format and export
the selected outline to a Word document, starting Word if necessary.

</t>
<t tx="ekr.20101113063552.9447"></t>
<t tx="ekr.20101113063552.9448">Synchronizes @path nodes with folders.

If a node is named '@path path_to_folder', the content (file and folder names)
of the folder and the children of that node will synchronized whenever the
node's status-iconbox is double clicked.

For files not previously seen in a folder a new node will appear on top of the
children list (with a mark).

Folders appear in the list as /foldername/. If you double click on the icon-box
of the folder node, it will have children added to it based on the contents of
the folder on disk. These folders have the '@path' directive as the first line
of their body text.

When files are deleted from the folder and the list is updated by double
clicking the files will appear in the list as *filename* (or */foldername/*).

You can describe files and directories in the body of the nodes.

You can organize files and directories with organizer nodes, an organizer node
name cannot contain with '/'.

Files and folders can be created by entering a node with the required name as
its headline (must start and/or end with "/" for a folder) and then double
clicking on the node's status-iconbox.

\@auto nodes can be set up for existing files can be loaded by
double clicking on the node's status-iconbox. If you prefer
\@shadow or something else use the "active_path_attype" setting,
without the "@".

There are commands on the Plugins active_path submenu:

- show path - show the current path
- set absolute path - changes a node "/dirname/" to "@path /absolute/path/to/dirname".
- purge vanished (recursive) - remove *entries*
- update recursive - recursive load of directories, use with caution on large
  file systems

If you want to use an input other than double clicking a node's status-iconbox
set active_path_event to a value like 'iconrclick1' or 'iconclick1'.

There are @settings for ignoring directory entries and automatically loading files.  ``re.search`` is used, rather than ``re.match``, so patterns need only match part of the filename, not the whole filename.

The body of the @setting ``@data active_path_ignore`` is a list of regex
patterns, one per line.  Directory entries matching any pattern in the list will be ignored.  The names of directories used for matching will have forward slashes around them ('/dirname/'), so patterns can use this to distinguish between directories and files.

The body of the @setting ``@data active_path_autoload`` is a list of regex
patterns, one per line.  File entries matching any pattern in the list will be loaded automatically.  This works only with files, not directories (but you can load directories recursively anyway).

Set ``@bool active_path_load_docstring = True`` to have active_path load the docstring
of .py files automatically.  These nodes start with the special string::

    @language rest # AUTOLOADED DOCSTRING

which must be left intact if you want active path to be able to double-click load
the file later.

\@float active_path_timeout_seconds (default 10.) controls the maximum
time active_path will spend on a recursive operation.

\@int active_path_max_size (default 1000000) controls the maximum
size file active_path will open without query.

active_path is a rewrite of the at_directory plugin to use \@path directives
(which influence \@auto and other \@file type directives), and to handle
sub-folders more automatically.

</t>
<t tx="ekr.20101113063552.9449">Synchronizes @folder nodes with folders.

If a node is named '@folder path_to_folder', the content (filenames) of the
folder and the children of that node will be sync. Whenever a new file is put
there, a new node will appear on top of the children list (with mark). So that
I can put my description (i.e. annotation) as the content of that node. In this
way, I can find any files much easier from leo.

Moreover, I add another feature to allow you to group files(in leo) into
children of another group. This will help when there are many files in that
folder. You can logically group it in leo (or even clone it to many groups),
while keep every files in a flat/single directory on your computer.

</t>
<t tx="ekr.20101113063552.9450">Executes commands in nodes whose body text starts with @produce.

WARNING: trying to execute a non-existent command will hang Leo.

To use, put in the body text of a node::

    @produce echo hi
    
This plugin creates two new commands: at-produce-all and at-produce-selected.

at-produce-all scans the entire tree for body text containing @produce.
at-produce-selected just scans the selected tree.

Whatever follows @produce is executed as a command.

@produce commands are executed in the order they are found, that is, in outline order.

The at-produce commands produce a log node as the last top-level node of the outline.
Any output, including error messages, should be there.

This plugin is not intended as a replacement for make or Ant, but as a
simple substitute when that machinery is overkill.
</t>
<t tx="ekr.20101113063552.9451">Adds support for \@clip, \@view and \@strip nodes.

- Selecting a headline containing \@clip appends the contents of the clipboard to
  the end of the body pane.

- Double clicking the icon box of a node whose headline contains \@view
  *&lt;path-to-file&gt;* places the contents of the file in the body pane.

- Double clicking the icon box of a node whose headline contains \@strip
  *&lt;path-to-file&gt;* places the contents of the file in the body pane, with all
  sentinels removed.

This plugin also accumulates the effect of all \@path nodes.

</t>
<t tx="ekr.20101113063552.9452">Allows arbitrary links between nodes.

</t>
<t tx="ekr.20101113063552.9453">Allows users to insert headlines containing dates.

'Date nodes' are nodes that have dates in their headlines. They may be added to
the outline one at a time, a month's-worth at a time, or a year's-worth at a
time. The format of the labels (headlines) is configurable.

There are options to omit Saturdays and Sundays.

An 'Insert Date Nodes ...' submenu will be created (by default) in the 'Outline'
menu.  This menu can be suppressed by using either of the following settings:

    - @bool suppress-datenodes-menus
    - @bool suppress-all-plugins-menus

The following commands are available for use via the minibuffer or in
@menu/@popup settings.

    - datenodes-today
    - datenodes-this-month
    - datenodes-this-year

</t>
<t tx="ekr.20101113063552.9454">Adds @expfolder nodes that represent folders in the file system.

Double clicking on the icon of an @expfolder heading reads the files in the
directory at the path specified and creates child nodes for each file in the
subfolder. Subdirectories are made into child @expfolder nodes so the tree can
be easily traversed. If files have extensions specified in the expfolder.ini
file they are made into @text nodes so the content of the files can be easily
loaded into leo and edited. Double clicking a second time will delete all child
nodes and refresh the directory listing. If there are any changed @text nodes
contained inside you will be prompted about saving them.

The textextensions field on the expfolder Properties page contains a list of
extensions which will be made into @text nodes, separated by spaces.

For the @text and @expfolder nodes to interact correctly, the textnode plugin
must load before the expfolder plugin. This can be set using the Plugin
Manager's Plugin Load Order pane.

</t>
<t tx="ekr.20101113063552.9455">Defines actions taken when double-clicking on @&lt;file&gt; nodes and supports
@file-ref nodes.

Double-clicking any kind of @&lt;file&gt; node writes out the file if changes have
been made since the last save, and then runs a script on it, which is retrieved
from the outline.

Scripts are located in a node whose headline is FileActions. This node can be
anywhere in the outline. If there is more than one such node, the first one in
outline order is used.

The children of that node are expected to contain a file pattern in the headline
and the script to be executed in the body. The file name is matched against the
patterns (which are Unix-style shell patterns), and the first matching node is
selected. If the filename is a path, only the last item is matched.

Execution of the scripts is similar to the "Execute Script"
command in Leo. The main difference is that the namespace
in which the scripts are run contains these elements:

- 'c' and 'g' and 'p': as in the regular execute script command.

- 'filename': the filename from the @file directive.

- 'shellScriptInWindow', a utility function that runs a shell script in an
   external windows, thus permitting programs to be called that require user
   interaction

File actions are implemented for all kinds @&lt;file&gt; nodes. There is also a new
node type @file-ref for referring to files purely for the purpose of file
actions, Leo does not do anything with or to such files.

</t>
<t tx="ekr.20101113063552.9456">Tags nodes with latitude and longitude.

</t>
<t tx="ekr.20101113063552.9457">Creates a LeoCursor object that can walk around a Leo outline and decode
attributes from nodes.

Node names can be used through . (dot) notation so ``cursor.Data.Name._B`` for
example returns the body text of the Name node which is a child of the Data node
which is a child of the cursors current location.

See .../plugins/examples/leocursorexample.leo for application.

</t>
<t tx="ekr.20101113063552.9458">Opens files with their default platform program.

Double-clicking @mime nodes will attempt to open the named file as if opened
from a file manager. \@path parent nodes are used to find the full filename
path.  Fore example::

    @mime foodir/document.pdf

The string setting 'mime_open_cmd' allows specifying a program to handle opening
files::

    @settings
        @string mime_open_cmd = see
        .. or ..
        @string mime_open_cmd = see %s

Where '%s' is replaced with the full pathname.

**Note**: This plugin terminates handling of the 'icondclick1' event by returning
True. If another plugin using this event (e.g. vim.py) is also enabled, the
order in @enabled-plugins matters. For example: if vim.py is enabled before
mime.py, double-clicking on an @mime node will both open the body text in [g]vim
AND call the mime_open_cmd.

This plugin is complementary to the UNL.py plugin's @url nodes. Use @url for
opening either URLs or Uniform Node Locators in "\*.leo" files and use @mime
nodes for opening files on the local file system. It also replaces the
startfile.py plugin, where here the headline must start with @mime to activate
this plugin.

For other sys.platform's, add an elif case to the section "guess file
association handler" and either define a default _mime_open_cmd string, where
"%s" will be replaced with the filename, or define a function taking the
filename string as its only argument and set as open_func.

</t>
<t tx="ekr.20101113063552.9459">Allows Leo to write a file to multiple locations.

This plugin acts as a post-write mechanism, a file must be written to the
file system for it to work. At this point it is not a replacement for @path or an
absolute path, it works in tandem with them.

To use, place @multipath at the start of a line in the root node or an ancestor
of the node. The format is (On Unix-like systems)::

    @multipath /machine/unit/:/machine/robot/:/machine/

New in version 0.6 of this plugin: the separator used above is ';' not ':',
for example::

    @multipath c:\prog\test;c:\prog\unittest

It will places copy of the written file in each of these directories.

There is an additional directive that simplifies common paths, it is called
@multiprefix. By typing @multiprefix with a path following it, before a
@multipath directive you set the beginning of the paths in the @multipath
directive. For example::

    #@multiprefix /leo #@multipath /plugins 

or::

    #@multiprefix /leo/
    #@multipath plugins: fungus : drain

copies a file to /leo/plugins /leo/fungus /leo/drain.

Note I put # in front of the directives here because I
don't want someone browsing this file to accidentally save multiple copies of
this file to their system :) )

The @multiprefix stays in effect for the entire tree until reset with another
@multiprefix directive. @multipath is cumulative, in that for each @multipath in
an ancestor a copy of the file is created. These directives must at the
beginning of the line and by themselves.

</t>
<t tx="ekr.20101113063552.9460">Ensures that all descendants of @file-nosent nodes end
with exactly one newline, replaces all tabs with spaces, and
adds a newline before class and functions in the derived file.

</t>
<t tx="ekr.20101113063552.9461">Creates and updates @read-only nodes.

Here's my first attempt at customizing leo. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only
be read by leo (not tangled), and also kept in sync with the content on the
drive.

The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't
want leo to tangle or in any way modify them. At the same time, I want them
to be up-to-date in the leo outline.

So I coded the directive plugin. It has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
  on disk has changed from what is stored in the outline, it marks the node as
  changed and prints a "changed" message to the log window; if, on the other hand,
  the file content has _not_ changed, the file is simply read and the node is
  not marked as changed.

- When you write a @read-only directive, the file content is added to the node
  immediately, i.e. as soon as you press Enter (no need to call a menu
  entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
  and press Enter. The file is reloaded, and if in the meantime it has changed,
  a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

The syntax to access files in @read-only via ftp/http is the following::

    @read-only http://www.ietf.org/rfc/rfc0791.txt
    @read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows::

    @read-only ftp://username:password@ftp.someserver.org/filepath

For more details, see the doc string for the class FTPurl.

Davide Salomoni

</t>
<t tx="ekr.20101113063552.9462">Runs a program and interface Leos through its input/output/error streams.

Double clicking the icon box whose headlines are @run 'cmd args' will execute
the command. There are several other features, including @arg and @input nodes.

The run_nodes.py plugin introduce two new nodes that transform leo into a
terminal. It was mostly intended to run compilers and debuggers while having the
possibility to send messages to the program.

Double clicking on the icon of an node whose headline is @run &lt;command&gt; &lt;args&gt;
will launch &lt;command&gt; with the given arguments. It will also mark the node. #
Terminates the argument list. @run # &lt;comment&gt; is also valid.

@in nodes are used to send input to the running process. Double clicking on
the icon of an @in &lt;message&gt; node will append a "\n" to &lt;message&gt; and write it
to the program, no matter where the node is placed. If no @run node is active,
nothing happens.

The body text of every child, in which the headlines do not begin with '@run'
or '@in', will be appended to &lt;command&gt;, allowing you to add an unlimited number
of arguments to &lt;command&gt;.

The output of the program is written in the log pane (Error output in red).
When the program exit the node is set unmarked and the return value is
displayed... When the enter key is pressed in the body pane of an active @run
node the content of it body pane is written to the program and then emptied
ready for another line of input. If the node have @run nodes in its descendants,
they will be launched successively. (Unless one returned an exit code other
than 0, then it will stop there)

By Alexis Gendron Paquette. Please send comments to the Leo forums.

</t>
<t tx="ekr.20101113063552.9463">Support slideshows in Leo outlines.

This plugin defines four new commands:

- next-slide-show:  move to the start of the next slide show,
  or the first slide show if no slide show has been seen yet.
- prev-slide-show:  move to the start of the previous slide show,
  or the first slide show if no slide show has been seen yet.
- next-slide: move to the next slide of a present slide show.
- prev-slide: move to the previous slide of the present slide show.

Slides shows consist of a root @slideshow node with descendant @slide nodes.
@slide nodes may be organized via non-@slide nodes that do not appear in the slideshow.

All these commands ignore @ignore trees.

</t>
<t tx="ekr.20101113063552.9464">Launches (starts) a file given by a headline when double-clicking the icon.

This plugin ignores headlines starting with an '@'. Uses the @folder path if the
headline is under an @folder headline. Otherwise the path is relative to the Leo
file.

</t>
<t tx="ekr.20101113063552.9466">Adds the Outline:XSLT menu containing XSLT-related commands.

This menu contains the following items:

- Set StyleSheet Node:
    - Selects the current node as the xsl stylesheet the plugin will use.

- Process Node with Stylesheet Node:
    - Processes the current node as an xml document,
      resolving section references and Leo directives.
    - Creates a sibling containing the results.

Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org.

</t>
<t tx="ekr.20101113063552.9467"></t>
<t tx="ekr.20101113063552.9468">Allows interaction with shell apps via screen.

Analysis environments like SQL, R, scipy, ipython, etc. can be
used by pasting sections of text from an editor (Leo) and a
shell window.  Results can be pasted back into the editor.

This plugin streamlines the process by communicating with ``screen``,
the shell multiplexer

**Commands**

leoscreen-run-text
  Send the text selected in Leo's body text to the shell app.
  Selects the next line for your convenience.

leoscreen-get-line
  Insert a line of the last result from the shell into Leo's body text
  at the current insert point.  Lines are pulled one at a time starting
  from the end of the output.  Can be used repeatedly to get the
  output you want into Leo.

leoscreen-get-all
  Insert all of the last result from the shell into Leo's body text
  at the current insert point.

leoscreen-get-note
  Insert all of the last result from the shell into a new child node of
  the current node.

leoscreen-show-all
  Show the output from the last result from the shell in a temporary
  read only window. **Important**: The output is not stored.

leoscreen-show-note
  Insert all of the last result from the shell into a new child node of
  the current node and display that node a a stickynote (requires stickynote
  plugin).

leoscreen-next
  Switch screen session to next window.

leoscreen-prev
  Switch screen session to preceding window.

leoscreen-other
  Switch screen session to last window displayed.

leoscreen-get-prefix
  Interactively get prefix for inserting text into body (#, --, //, etc/)
  Can also set using::

      c.leo_screen.get_line_prefix = '#'

leoscreen-more-prompt
  Skip one less line at the end of output when fetching output into Leo.
  Adjusts lines skipped to avoid pulling in the applications prompt line.

leoscreen-less-prompt
  Skip one more line at the end of output when fetching output into Leo
  Adjusts lines skipped to avoid pulling in the applications prompt line.

**Settings**

leoscreen_prefix
  Prepended to output pulled in to Leo. The substring SPACE in this
  setting will be replaced with a space character, to allow for trailing
  spaces.

leoscreen_time_fmt
  time.strftime format for note type output headings.

**Theory of operation**

leoscreen creates a instance at c.leo_screen which has some methods which might
be useful in ``@button`` and other Leo contexts.

**Example SQL setup**

In a Leo file full of interactive SQL analysis, I have::

    @settings
        @string leoscreen_prefix = --SPACE
    @button rollback
        import time
        c.leo_screen.run_text('ROLLBACK;  -- %s\n' % time.asctime())
    @button commit
        import time
        cmd = 'COMMIT;  -- %s' % time.asctime()
        c.leo_screen.run_text(cmd)
        c.leo_screen.insert_line(cmd)

which creates a button to rollback messed up queries, another to commit
(requiring additional action to supply the newline as a safeguard) and
sets the prefix to "-- " for text pulled back from the SQL session into
Leo.

**Implementation note**: screen behave's differently if screen -X is executed
with the same stdout as the target screen, vs. a different stdout. Although
stdout is ignored, Popen() needs to ensure it's not just inherited.

</t>
<t tx="ekr.20101113063552.9469">Creates script buttons and @button, @command, @plugin and @script
nodes.

This plugin puts buttons in the icon area. Depending on settings the plugin will
create the 'Run Script', the 'Script Button' and the 'Debug Script' buttons.

The 'Run Script' button is simply another way of doing the Execute Script
command: it executes the selected text of the presently selected node, or the
entire text if no text is selected.

The 'Script Button' button creates *another* button in the icon area every time
you push it. The name of the button is the headline of the presently selected
node. Hitting this *newly created* button executes the button's script.

For example, to run a script on any part of an outline do the following:

1.  Select the node containing the script.
2.  Press the scriptButton button.  This will create a new button.
3.  Select the node on which you want to run the script.
4.  Push the *new* button.

That's all.

For every @button node, this plugin creates two new minibuffer commands: x and
delete-x-button, where x is the 'cleaned' name of the button. The 'x' command is
equivalent to pushing the script button.

You can specify **global buttons** in leoSettings.leo or myLeoSettings.leo by
putting \@button nodes as children of an @buttons node in an \@settings trees.
Such buttons are included in all open .leo (in a slightly different color).
Actually, you can specify global buttons in any .leo file, but \@buttons nodes
affect all later opened .leo files so usually you would define global buttons in
leoSettings.leo or myLeoSettings.leo.

The cleaned name of an @button node is the headline text of the button with:

- Leading @button or @command removed,
- @key and all following text removed,
- @args and all following text removed,
- all non-alphanumeric characters converted to a single '-' characters.

Thus, cleaning headline text converts it to a valid minibuffer command name.

You can delete a script button by right-clicking on it, or by
executing the delete-x-button command.

The 'Debug Script' button runs a script using an external debugger.

This plugin optionally scans for @button nodes, @command, @plugin nodes and
@script nodes whenever a .leo file is opened.

- @button nodes create script buttons.
- @command nodes create minibuffer commands.
- @plugin nodes cause plugins to be loaded.
- @script nodes cause a script to be executed when opening a .leo file.

Such nodes may be security risks. This plugin scans for such nodes only if the
corresponding atButtonNodes, atPluginNodes, and atScriptNodes constants are set
to True in this plugin.

You can specify the following options in leoSettings.leo.  See the node:
@settings--&gt;Plugins--&gt;scripting plugin.  Recommended defaults are shown::

    @bool scripting-at-button-nodes = True
    True: adds a button for every @button node.

    @bool scripting-at-commands-nodes = True
    True: define a minibuffer command for every @command node.

    @bool scripting-at-plugin-nodes = False
    True: dynamically loads plugins in @plugins nodes when a window is created.

    @bool scripting-at-script-nodes = False
    True: dynamically executes script in @script nodes when a window is created.
    This is dangerous!

    @bool scripting-create-debug-button = False
    True: create Debug Script button.

    @bool scripting-create-run-script-button = False
    True: create Run Script button.
    Note: The plugin creates the press-run-script-button regardless of this setting.

    @bool scripting-create-script-button-button = True
    True: create Script Button button in icon area.
    Note: The plugin creates the press-script-button-button regardless of this setting.

    @int scripting-max-button-size = 18
    The maximum length of button names: longer names are truncated.

You can bind key shortcuts to @button and @command nodes as follows.

@button name @key=shortcut

    Binds the shortcut to the script in the script button. The button's name is
    'name', but you can see the full headline in the status line when you move the
    mouse over the button.

@command name @key=shortcut

    Creates a new minibuffer command and binds shortcut to it. As with @buffer
    nodes, the name of the command is the cleaned name of the headline.

This plugin is based on ideas from e's dynabutton plugin, quite possibly the
most brilliant idea in Leo's history.

You can run the script with sys.argv initialized to string values using @args.
For example:

@button test-args @args = a,b,c

will set sys.argv to [u'a',u'b',u'c']

</t>
<t tx="ekr.20101113063552.9470">Sends output from the Execute Script command to the end of the body pane.

</t>
<t tx="ekr.20101113063552.9471"></t>
<t tx="ekr.20101113063552.9472">Remote control for Leo.

Example client::

    from leo.external import lproto
    import os


    addr = open(os.path.expanduser('~/.leo/leoserv_sockname')).read()
    print("will connect to",addr)
    pc  = lproto.LProtoClient(addr)
    pc.send("""
        g.es("hello world from remote") 
        c = g.app.commanders()[0]
    """)

    # note how c persists between calls
    pc.send("""c.k.simulateCommand('stickynote')""")

</t>
<t tx="ekr.20101113063552.9473">A minimal http plugin for Leo, based on AsyncHttpServer.py.

Use this plugin is as follows:

1. Start Leo with the plugin enabled. You will see a purple message that says
   something like::

    "http serving enabled on port 8080, version 0.91"

2. Start a web browser, and enter the following url: http://localhost:8080/

You will see a a "top" level page containing one link for every open .leo file.
Start clicking :-)

You can use the browser's refresh button to update the top-level view in the
browser after you have opened or closed files.

To enable this plugin put this into your file::

    @settings
        @bool http_active = True
        @int  port = 8080
        @string rst_http_attributename = 'rst_http_attribute'

**Note**: the browser_encoding constant (defined in the top node of this file)
must match the character encoding used in the browser. If it does not, non-ascii
characters will look strange.

</t>
<t tx="ekr.20101113063552.9474"></t>
<t tx="ekr.20101113063552.9475">Creates stand-alone slideshows containing screenshots.

This plugin defines five commands. The
**apropos-slides** command prints this message to
Leo's log pane. The **slide-show-info** command
prints the settings in effect.

The **make-slide** and **make-slide-show**
commands, collectively called **slide commands**,
create collections of slides from **@slideshow**
trees containing **@slide** nodes.

Slides may link to screenshots. The slide commands
can generate screenshots from **@screenshot-tree**
nodes, but this feature has proven to be clumsy
and inflexible. It is usually more convenient to
use screenshots taken with a program such as Wink.
The **meld-slides** command creates references to
externally-generated screenshots within @slide
nodes.

\@slide nodes may contain **@url nodes**. These @url
nodes serve two purposes. First, they allow you to
see various files (slides, initial screenshots,
working files and final screenshots). Second,
these @url nodes guide the meld script and the
four commands defined by this plugin (see below).
By inserting or deleting these @url nodes you (or
your scripts) can customize how the commands (and
meld) work. In effect, the @url nodes become
per-slide settings.

**Prerequisites**

Inkscape (Required)
  An SVG editor: http://www.inkscape.org/
  Allows the user to edit screenshots.
  Required to create final output (PNG) files.

PIL (Optional but highly recommended)
  The Python Imaging Library,
  http://www.pythonware.com/products/pil/

Wink (Optional)
  A program that creates slideshows and slides.
  http://www.debugmode.com/wink/

**Summary**

@slideshow &lt;slideshow-name&gt;
  Creates the folder:
  &lt;sphinx_path&gt;/slides/&lt;slideshow-name&gt;

@slide &lt;ignored text&gt;
  Creates slide-&lt;slide-number&gt;.html
  (in the sphinx _build directory).
  **Note**: the plugin skips any @slide nodes
  with empty body text.

@screenshot
  Specifies the contents of the screenshot.

**Options** are child nodes of @slideshow or
\@slide nodes that control the make-slide and
make-slide-show commands. See the Options section
below.

The make-slide and make-slide-show commands
create the following @url nodes as children
of each @slide node:

@url built slide
  Contains the absolute path to the final slide in
  the _build/html subfolder of the slideshow
  folder. If present, this @url node completely
  disables rebuilding the slide.

@url screenshot
  Contains the absolute path to the original
  screenshot file. If present, this @url node
  inhibits taking the screenshot.

@url working file
  Contains the absolute path to the working file.
  If present, this @url node disables taking the
  screenshot, creating the working file. The final
  output file will be regenerated if the working
  file is newer than the final output file.

@url final output file
  Contains the absolute path to the final output
  file.

Thus, to completely recreate an @slide node, you
must delete any of the following nodes that appear
as its children::

    @url screenshot
    @url working file
    @url built slide

**Making slides**

For each slide, the make-slide and make-slide-show
commands do the following:

1. Create a slide.

  If the @slide node contains an @screenshot tree,
  the plugin appends an ``.. image::`` directive
  referring to the screenshot to the body text of
  the @slide node. The plugin also creates a child
  @image node referring to the screenshot.

2. (Optional) Create a screenshot.

  The plugin creates a screenshot for an @slide
  node only if the @slide node contains an
  @screenshot node as a direct child.

  **Important**: this step has largely been
  superseded by the ``@button meld`` script in
  LeoDocs.leo.

  Taking a screenshot involves the following steps:

  A. Create the **target outline**: screenshot-setup.leo.

    The target outline contains consists of all
    the children (and their descendants) of the
    @screenshot node.

  B. Create the **screenshot**, a bitmap (PNG) file.

    The slide commands take a screen shot of the
    target outline. The @pause option opens the
    target outline but does *not* take the
    screenshot. The user must take the screenshot
    manually. For more details, see the the
    options section below.

  C. Convert the screenshot file to a **work file**.

    The work file is an SVG (Scalable Vector
    Graphics) file: http://www.w3.org/Graphics/SVG/.

  D. (Optional) Edit the work file.

    If the @slide node has a child @edit node, the
    plugin opens Inkscape so that the user can
    edit the work file.

  E. Render the **final output file**.

    The plugin calls Inkscape non-interactively to
    render the final output file (a PNG image)
    from the work file. If the Python Imaging
    Library (PIL) is available, this step will use
    PIL to improve the quality of the final output
    file.

3. Build the slide using Sphinx.

  After making all files, the plugins runs Sphinx
  by running 'make html' in the slideshow folder.
  This command creates the final .html files in the
  _build/html subfolder of the slideshow folder.

4. Create url nodes.

  Depending on options, and already-existing @url
  nodes, the make-slide and make-slide-show
  commands may create one or more of the following
  \@url nodes::

    @url built slide
    @url screenshot
    @url working file 
    @url final output file

**Options and settings**

You specify options in the headlines of nodes.
**Global options** appear as direct children of
\@slideshow nodes and apply to all @slide nodes
unless overridden by a local option. **Local
options** appear as direct children of an @slide
node and apply to only to that @slide node.

**Global options nodes**

The following nodes may appear *either* as a
direct child of the @slideshow node or as the
direct child of an @slide node.

@sphinx_path = &lt;path&gt;
  This directory contains the slides directory,
  and the following files: 'conf.py',
  'Leo4-80-border.jpg', 'Makefile' and 'make.bat'.

@screenshot_height = &lt;int&gt;
  The height in pixels of screenshots.

@screenshot_width = &lt;int&gt;
  The height in pixels of screenshots.

@template_fn = &lt;path&gt;
  The absolute path to inkscape-template.svg

@title = &lt;any text&gt;
  The title to use for one slide or the entire
  slideshow.

@title_pattern = &lt;pattern&gt;
  The pattern used to generate patterns for one
  slide or the entire slideshow. The title is
  computed as follows::

    d = {
        'slideshow_name':slideshow_name,
        'slide_name':    slide_name,
        'slide_number':  sc.slide_number,
    }
    title = (pattern % (d)).title()

  If neither an @title or @title_pattern option
  node applies, the title is the headline of the
  \@slide node. If this is empty, the default
  pattern is::

    '%(slideshow_name)s:%(slide_number)s'

\@verbose = True/False
  True (or true or 1):  generate informational message.
  False (or false or 0): suppress informational messages.

\@wink_path = &lt;path&gt;
  This path contains screenshots created by wink.
  This is used only by the meld-slides command.

**Local options nodes**

The following nodes are valid only as the direct
child of an @slide node.

@callout &lt;any text&gt;
  Generates a text callout in the working .svg file.
  An @slide node may have several @callout children.

@edit = True/False
  If True (or true or 1) the plugin enters
  Inkscape interactively after taking a
  screenshot.

@markers = &lt;list of integers&gt;
  Generates 'numbered balls' in the working .svg file.

@pause = True/False
  If True (or true or 1) the user must take the
  screenshot manually. Otherwise, the plugin takes
  the screenshot automatically.

  If the slide node contains an @pause node as one
  of its directive children, the slide commands
  open the target node, but do *not* take a screen
  shot.

  The user may adjust the screen as desired, for
  example by selecting menus or showing dialogs.
  The *user* must then take the screen shot
  manually. **Important**: the screenshot need not
  be of Leo--it could be a screenshot of anything
  on the screen.

  As soon as the user closes the target
  outline, the slide commands look for the screen
  shot on the clipboard. If found, the slide
  commands save the screenshot to the screenshot
  file.

@screenshot
  The root of a tree that becomes the entire
  contents of screenshot. No screenshot is taken
  if this node does not exist.

@select &lt;headline&gt;
  Causes the given headline in the @screenshot
  outline to be selected before taking the screenshot.

**Settings**

@string screenshot-bin = &lt;path to inkscape.exe&gt;
  The full path to the Inkscape program.   

**File names**

Suppose the @slide node is the n'th @slide node in
the @slideshow tree whose sanitized name is
'name'. The following files will be created in
(relative to) the slideshow directory::

    slide-n.html.txt:   the slide's rST source.
    screenshot-n.png:   the original screenshot.
    screenshot-n.svg:   the working file.
    slide-n.png:        the final output file.
    _build/html/slide-n.html: the final slide.

</t>
<t tx="ekr.20101113063552.9476"></t>
<t tx="ekr.20101113063552.9477">Manages BibTeX files with Leo.

Create a bibliographic database by
putting '@bibtex filename' in a headline. Entries are added as nodes, with
'@entrytype key' as the headline, and the contents of the entry in body text.
The plugin will automatically insert a template for the entry in the body pane
when a new entry is created (hooked to pressing enter when typing the headline
text). The templates are defined in dictionary 'templates' in the \&lt;\&lt;globals\&gt;\&gt;
section, by default containing all required fields for every entry.

The file is written by double-clicking the node. Thus the following outline::

    -@bibtex biblio.bib
     +@book key
      author = {A. Uthor},
      year = 1999

will be written in the file 'biblio.bib' as::

    @book{key,
    author = {A. Uthor},
    year= 1999}

Strings are defined in @string nodes and they can contain multiple entries.
All @string nodes are written at the start of the file. Thus the following
outline::

    -@bibtext biblio.bib
     +@string
      j1 = {Journal1}
     +@article AUj1
      author = {A. Uthor},
      journal = j1
     +@string
      j2 = {Journal2}
      j3 = {Journal3}

Will be written as::

    @string{j1 = {Journal1}}
    @string{j2 = {Journal2}}
    @string{j3 = {Journal3}}

    @article{AUj1,
    author = {A. Uthor},
    journal = j1}

No error checking is made on the syntax. The entries can be organized under
nodes --- if the headline doesn't start with '@', the headline and body text are
ignored, but the child nodes are parsed as usual.

BibTeX files can be imported by creating an empty node with '@bibtex filename'
in the headline. Double-clicking it will read the file 'filename' and parse it
into a @bibtex tree. No syntax checking is made, 'filename' is expected to be a
valid BibTeX file.

</t>
<t tx="ekr.20101113063552.9478">Sends code to the doctest module and reports the result.

When the Dtest plugin is enabled, the ``dtest`` command is active.
Typing:: 

    Alt-X dtest

will run doctest on a file consisting of the current node and it's children.
If text is selected only the selection is tested.

From Wikipedia::

    'Doctest' is a module included in the Python programming language's 
    standard library that allows for easy generation of tests based on 
    output from the standard Python interpreter.

http://tinyurl.com/cqh53 - Python.org doctest page    

http://tinyurl.com/pxhlq - Jim Fulton's presentation::

    Literate Testing:
    Automated Testing with doctest

</t>
<t tx="ekr.20101113063552.9480">Outputs a Leo outline as a numbered list to an RTF file. The RTF file can be
loaded into Microsoft Word and formatted as a proper outline.

If this plug-in loads properly, you should have an "Outline to Microsoft RTF"
option added to your File &gt; Export... menu in Leo.

Settings such as outputting just the headlines (vs. headlines &amp; body text) and whether
to include or ignore the contents of @file nodes are stored in the rtf_export.ini file
in your Leo\plugins folder.

The default export path is also stored in the INI file. By default, it's set to c:\ so
you may need to modify it depending on your system.

</t>
<t tx="ekr.20101113063552.9482"></t>
<t tx="ekr.20101113063552.9483">Supports Uniform Node Locators (UNL's) for linking to nodes in any Leo file.

UNL's specify nodes within any Leo file. You can use them to create
cross-Leo-file links! UNL

This plugin consists of two parts:

1) Selecting a node shows the UNL in the status line at the bottom of the Leo
   window. You can copy from the status line and paste it into headlines, emails,
   whatever. 

2) Double-clicking @url nodes containing UNL's select the node specified in the
   UNL. If the UNL species in another Leo file, the other file will be opened.

Format of UNL's:

UNL's referring to nodes within the present outline have the form::

    headline1--&gt;headline2--&gt;...--&gt;headlineN

headline1 is the headline of a top-level node, and each successive headline is
the headline of a child node.

UNL's of the form::

    file:&lt;path&gt;#headline1--&gt;...--&gt;headlineN

refer to a node specified in &lt;path&gt; For example, double clicking the following
headline will take you to Chapter 8 of Leo's Users Guide::

    @url file:c:/prog/leoCvs/leo/doc/leoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo

For example, suppose you want to email someone with comments about a Leo file.
Create a comments.leo file containing @url UNL nodes. That is, headlines are
@url followed by a UNL. The body text contains your comments about the nodes in
the _other_ Leo file! Send the comments.leo to your friend, who can use the
comments.leo file to quickly navigate to the various nodes you are talking
about. As another example, you can copy UNL's into emails. The recipient can
navigate to the nodes 'by hand' by following the arrows in the UNL.

**Notes**:

- At present, UNL's refer to nodes by their position in the outline. Moving a
  node will break the link.

- Don't refer to nodes that contain UNL's in the headline. Instead, refer to the
  parent or child of such nodes.

- You don't have to replace spaces in URL's or UNL's by '%20'.

</t>
<t tx="ekr.20101113063552.9484">Creates hoist buttons.

This plugin puts two buttons in the icon area: a button called 'Save Hoist' and
a button called 'Dehoist'. The 'Save Hoist' button hoists the presently selected
node and creates a button which can later rehoist the same node. The 'Dehoist'
button performs one level of dehoisting

Requires at least version 0.19 of mod_scripting.

</t>
<t tx="ekr.20101113063552.9485">Colorizes URLs everywhere in node's body on node selection or saving. Double
click on any URL launches it in default browser.

URL regex:  (http|https|file|ftp)://[^\s'"]+[\w=/]

Related plugin:  contextmenu.py
</t>
<t tx="ekr.20101113063552.9486">Lets the user to associate text with a specific node.

Summon it by pressing button-2 or button-3 on an icon Box in the outline. This
will create an attribute editor where the user can add, remove and edit
attributes. Since attributes use the underlying tnode, clones will share the
attributes of one another.

</t>
<t tx="ekr.20101113063552.9487">Adds buttons so Leo can interact with command line environments.

:20100226: see also leoscreen.py for a simpler approach.

Currently implements `bash` shell and `psql` (postresql SQL db shell).

Single-line commands can be entered in the headline with a blank body,
multi-line commands can be entered in the body with a descriptive
title in the headline.  Press the `bash` or `psql` button to send
the command to the appropriate interpreter.

The output from the command is **always** stored in a new node added
as the first child of the command node.  For multi-line commands
this new node is selected.  For single-line command this new node
is not shown, instead the body text of the command node is updated
to reflect the most recent output.  Comment delimiter magic is used
to allow single-line and multi-line commands to maintain their
single-line and multi-line flavors.

Both the new child nodes and the updated body text of single-line
commands are timestamped.

For the `bash` button the execution directory is either the directory
containing the `.leo` file, or any other path as specified by ancestor
`@path` nodes.

Currently the `psql` button just connects to the default database.  ";"
is required at the end of SQL statements.

Requires `pexpect` module.

</t>
<t tx="ekr.20101113063552.9488">Maximizes all new windows.

</t>
<t tx="ekr.20101113063552.9489">Sets a hard coded frame size.

Prevents Leo from setting custom frame size (e.g. from an external .leo
document)

</t>
<t tx="ekr.20101113063552.9491">Sends all output to the log pane.

</t>
<t tx="ekr.20101113063552.9492">Creates a Scripts menu for LeoPy.leo.

</t>
<t tx="ekr.20101113063552.9493">Replaces the gui file dialogs on Linux with external
calls to the zenity gtk dialog package.

This plugin is more a proof of concept demo than
a useful tool.  The dialogs presented do not take
filters and starting folders can not be specified.

Despite this, some Linux users might prefer it to the
gui dialogs.

</t>
<t tx="ekr.20101113063552.9528" str_atime="1376413521.0"></t>
<t tx="ekr.20101113063552.9794" str_atime="1376412861.0">Creates a Plugins menu and adds all actives plugins to it.

Selecting these menu items will bring up a short **About Plugin** dialog
with the details of the plugin. In some circumstances a submenu will be created
instead and an 'About' menu entry will be created in this.

**INI files and the Properties Dialog**

If a file exists in the plugins directory with the same file name as the plugin
but with a .ini extension instead of .py, then a **Properties** item will be
created in a submenu. Selecting this item will pop up a Properties Dialog which
will allow the contents of this file to be edited.

The .ini file should be formated for use by the python ConfigParser class.

**Special Methods**

Certain methods defined at the top level are considered special.

cmd_XZY
    If a method is defined at the module level with a name of the form
    **cmd_XZY** then a menu item **XZY** will be created which will invoke
    **cmd_XZY** when it is selected. These menus will appear in a sub menu.

applyConfiguration

topLevelMenu
    This method, if it exists, will be called when the user clicks on the plugin
    name in the plugins menu (or the **About** item in its submenu), but only if
    the plugin was loaded properly and registered with g.plugin_signon.

**Special Variable Names**

Some names defined at the top level have special significance.

__plugin_name__
    This will be used to define the name of the plugin and will be used
    as a label for its menu entry.

__plugin_priority__
    Plugins can also attempt to select the order they will appear in the menu by
    defining a __plugin_prioriy__. The menu will be created with the highest
    priority items first. This behavior is not guaranteed since other plugins
    can define any priority. This priority does not affect the order of calling
    handlers.
    To change the order select a number outside the range 0-200 since this range
    is used internally for sorting alphabetically. Properties and INI files.

</t>
<t tx="ekr.20101113063552.9798">Allows the definition of double-click actions.

When the user double-clicks a node this plugin checks for a match of the clicked
node's headline text with a list of patterns. If a match occurs, the plugin
executes the associated script.

**nodeAction** nodes may be located anywhere in the outline. Such nodes should
contain one or more **pattern nodes** as children. The headline of each pattern
node contains the pattern; the body text contains the script to be executed when
the pattern matches the double-clicked node.

For example, the "nodeActions" node containing a "launch URL" pattern node
and a "pre-process python code" node could be placed under an "@settings"
node::

   @settings
   |
   +- nodeActions
      |
      +- http:\\*
      |
      +- @file *.py

**Configuration**

The nodeActions plugin supports the following global configurations using
Leo's support for setting global variables within an @settings node's
sub-nodes in the leoSettings.leo, myLeoSettings.leo, and the project Leo
file:

@bool nodeActions_save_atFile_nodes = False

  :True:
     Double-click on an @file type node will save the file to disk
     before executing the script.

  :False:
     Double-click on an @file type node will **not** save the file to disk
     before executing the script. (default)

@int nodeActions_message_level = 1

  Specifies the type of messages to be sent to the log pane.  Specifying a
  higher message level will display that level and all lower levels.
  The following integer values are supported::

    0 no messages
    1 Plugin triggered and the patterns that were matched (default)
    2 Double-click event passed or not to next plugin
    3 Patterns that did not match
    4 Code debugging messages

**Patterns**

Pattern matching is performed using python's support for Unix
shell-style patterns unless overwritten by the "X" pattern directive.
The following pattern elements are supported::

    *           matches everything
    ?           matches any single character
    [&lt;seq&gt;]     matches any character in &lt;seq&gt;
    [!&lt;seq&gt;]    matches any character **not** in &lt;seq&gt;

Unix shell-style pattern matching is case insensitive and always starts from
the beginning of the headline.  For example:

     ======= =========== ==============
     Pattern   Matches   Does not match
     ======= =========== ==============
     \*.py   Abc_Test.py
     .py     .py - Test  Abc_Test.py
     test*   Test_Abc.py Abc_Test.py
     ======= =========== ==============

To enable a script to run on any type of @file node (@thin, @shadow, ...),
the pattern can start with "@files" to match on any
external file type.  For example, the pattern "@files \*.py" will
match a node with the headline "@file abcd.py".

The headline of the double-clicked node is matched against the patterns
starting from the first sub-node under the "nodeActions" node to the last
sub-node.

Only the script associated with the first matching pattern is
invoked unless overwritten by the "V" pattern directive.

Using the "V" pattern directive allows a broad pattern such
as "@files \*.py" to be invoked, and then, by placing a more restrictive
pattern above it, such as "@files \*_test.py", a different script can be
executed for those files requiring pre-processing::

  +- nodeActions
     |
     +- @files *_test.py
     |
     +- @files *.py

**Note**: To prevent Leo from trying to save patterns that begin with a derived
file directive (@file, @auto, ...) to disk, such as "@file \*.py", place the
"@ignore" directive in the body of the "nodeActions" node.

Pattern nodes can be placed at any level under the "nodeActions" node.
Only nodes with no child nodes are considered pattern nodes.
This allows patterns that are to be used in multiple Leo files to be read
from a file.  For example, the following structure reads the pattern
definition from the "C:\\Leo\\nodeActions_Patterns.txt" file::

    +- nodeActions
    |
    +- @files C:\\Leo\\nodeActions_Patterns.txt
        |
        +- http:\\*
        |
        +- @file *.py

**Pattern directives**

The following pattern specific directives can be appended to the end of a
pattern (do not include the ':'):

:[X]:
  Use python's regular expression type patterns instead of the Unix
  shell-style pattern syntax.

  For example, the following patterns will match the same headline string::

     Unix shell-style pattern:
        @files *.py

     Regular Expression pattern:
        ^@files .*\.py$ [X]

:[V]:
  Matching the pattern will not block the double-click event from
  being passed to the remaining patterns.
  The "V" represents a down arrow that symbolizes the passing of the event
  to the next pattern below it.

  For example, adding the "[V]" directive to the "@files \*_test.py" in
  the Patterns section above, changes its script from being 'an
  alternate to' to being 'a pre-processor for' the "@files \*.py" script::

     +- nodeActions
        |
        +- @files *_test.py [V]
        |
        +- @files *.py

:[&gt;]:
  Matching the pattern will not block the double-click event from being
  passed to other plugins.
  The "&gt;" represents a right arrow that
  symbolizes the passing of the event to the next plugin.

  If the headline matched more than one headline,
  the double-click event will be passed to the next plugin if the
  directive is associated with any of the matched patterns.

The directive(s) for a pattern must be contained within a single set of
brackets, separated from the pattern by a space, with or without a comma
separator.  For example, the following specifies all three directives::

  ^@files .*\.py$ [X,V&gt;]

**Scripts**

The script for a pattern is located in the body of the pattern's node.
The following global variables are available to the script::

    c
    g
    pClicked - node position of the double-clicked node
    pScript - node position of the invoked script

**Examples**

Double-clicking on a node with a "http:\\\\www.google.com" headline
will invoke the script associated with the
"http:\\\\\*" pattern.  The following script in the body of the pattern's
node displays the URL in a browser::

     import webbrowser
     hClicked = pClicked.h     #Clicked node's Headline text
     webbrowser.open(hClicked) #Invoke browser

The following script can be placed in the body of a pattern's node to
execute a command in the first line of the body of a double-clicked node::

     g.os.system('"Start /b ' + pClicked.bodyString() + '"')
</t>
<t tx="ekr.20101113063552.9800">Converts a leo outline to an html web page.

This plugin takes an outline stored in Leo and converts it to html which is then
either saved in a file or shown in a browser. It is based on the original
leoToHTML 1.0 plugin by Dan Rahmel which had bullet list code by Mike Crowe.

The outline can be represented as a bullet list, a numbered list or using html
&lt;h?&gt; type headings. Optionally, the body text may be included in the output.

If desired, only the current node will be included in the output rather than
the entire outline.

An xhtml header may be included in the output, in which case the code will be
valid XHTML 1.0 Strict.

The plugin is fully scriptable as all its functionality is available through a
Leo_to_HTML object which can be imported and used in scripts.

**Menu items and @settings**

If this plugin loads properly, the following menu items should appear in
your File &gt; Export... menu in Leo::

    Save Outline as HTML  (equivalent to export-html)
    Save Node as HTML     (equivalent to export-html-node)
    Show Outline as HTML  (equivalent to show-html)
    Show Node as HTML     (equivalent to show-html-node)

*Unless* the following appears in an @setting tree::

    @bool leo_to_html_no_menus = True

in which case the menus will **not** be created. This is so that the user can
use @menu and @item to decide which commands will appear in the menu and where.

**Commands**

Several commands will also be made available

export-html
  will export to a file according to current settings.
export-html-*
  will export to a file using bullet type '*' which can be
  **number**, **bullet** or **head**.

The following commands will start a browser showing the html.

show-html
  will show the outline according to current settings.

show-html-*
  will show the outline using bullet type '*' which can be
  **number**, **bullet** or **head**.

The following commands are the same as above except only the current node is converted::

    export-html-node
    export-html-node-*
    show-html-node
    show-html-node-*

**Properties**

There are several settings that can appear in the leo_to_html.ini properties
file in leo's plugins folder or be set via the Plugins &gt; leo_to_html &gt;
Properties... menu. These are:

exportpath:
    The path to the folder where you want to store the generated html file.
    Default: c:\\

flagjustheadlines:
    Default: 'Yes' to include only headlines in the output.

flagignorefiles:
    Default: 'Yes' to ignore @file nodes.

use_xhtml:
    Yes to include xhtml doctype declarations and make the file valid XHTML 1.0 Strict.
    Otherwise only a simple &lt;html&gt; tag is used although the output will be xhtml
    compliant otherwise. Default: Yes

bullet_type:
    If this is 'bullet' then the output will be in the form of a bulleted list.
    If this is 'number' then the output will be in the form of a numbered list.
    If this is 'heading' then the output will use &lt;h?&gt; style headers.

    Anything else will result in &lt;h?&gt; type tags being used where '?' will be a
    digit starting at 1 and increasing up to a maximum of six depending on depth
    of nesting. Default: number

browser_command:
    Set this to the command needed to launch a browser on your system or leave it blank
    to use your systems default browser.

    If this is an empty string or the browser can not be launched using this command then
    python's `webbrowser` module will be tried. Using a bad command here will slow down the
    launch of the default browser, better to leave it blank.
    Default: empty string

**Configuration**

At present, the file leo/plugins/leo_to_html.ini contains configuration
settings. In particular, the default export path, "c:\" must be changed for \*nix
systems.

</t>
<t tx="ekr.20101114081049.5004">@nocolor

Leo 4.8 beta 1                               November 5, 2010

Leo 4.8 beta 1 is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- Improved autocompletion: Ctrl-space starts a one-time completion.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20101114081049.5090"></t>
<t tx="ekr.20101114081049.5101">@nocolor-node

Removed the keybindings.py plugin.  The print-bindings command should suffice.

The plugins_menu.py has been renamed old_plugin_menu.py to indicate that it
needs a lot of work to become functional.

The following plugins are now gui-independent (the used to be Tk only):

at_produce.py
chapter_hoist.py
import_cisco_config.py
macros.py
mod_read_dir_outline.py
multifile.py
read_only_nodes.py
word_count.py
xsltWithNodes.py

I also registered the menu2 event instead of the open2 event in all plugins that
use this event to create menus. This is required because a relatively recent
change creates menus *after* the open2 event happens.
</t>
<t tx="ekr.20101114081049.5102"></t>
<t tx="ekr.20101114081049.5103">execute-script now calls execfile (or its equivalent when using Python 3k)
when @bool write_script_file = True.

This allows pdb to show the text of scripts!
</t>
<t tx="ekr.20101114081049.5108">This should have been done *ages* ago. The command makes it easy to put python
methods in separate nodes.

Select a range of text, the first line of which starts with 'def foo (...)'

Do alt-x extract-python-method (or ctrl-p if you are repeating the command).

What happens:

- Creates a new child node whose headline is 'foo'.

- The body of foo contains all the selected text, properly indented.

The command is undoable.
</t>
<t tx="ekr.20101115085632.4928">Leo opens the file specified by the default_leo_file setting if it exists.

New in 4.8 rc1: if default (workbook) file does not exist Leo will
open an empty file and name is to be the default file.
</t>
<t tx="ekr.20101115085632.4930">The installer now makes proper entries in the Windows start menu.
</t>
<t tx="ekr.20101119030344.5838">@language python
@color

'''Add @g.command(command_name) before all commands.'''

@others

import os ; os.system('cls')

d = c.commandsDict
f_dict = find_all_defs(c)

result1, result2 = [],[]
for f_name in sorted(f_dict): # These are function names, not command name.
    c_name = c.k.inverseCommandsDict.get(f_name) # Get the emacs command name.
    if c_name:
        f = d.get(c_name) # f is the function name that defines a command.
        if f:
            d_name = f.__name__
            s = repr(f)
            tag = '&lt;bound method '
            if s.startswith(tag): s = s[len(tag):]
            i = s.find(' of ')
            if i &gt; -1: s = s[:i]
            aList = [p.h for i,p in f_dict.get(d_name,[])]
            if len(aList) == 1:
                result1.append((d_name,s,aList),)
            else:
                result2.append((d_name,s,aList),)

print('----- duplicate commands -----\n')
for d_name,s,aList in result2:
    print('%s: %s\n%s %s\n' % (d_name,s,len(aList),aList))

print('----- unambiguous commands -----\n')
for d_name,s,aList in result1:
    print('%40s %s' % (d_name,aList[0]))

if 0:
    for name in sorted(d):
        f = d.get(name)
        f_name = f.__name__
        # name is the minibuffer command name, f_name is the function name.
        i,p = find(c,command,f_name)
        adjust(c,f_name,i,p)
</t>
<t tx="ekr.20101119030344.5839">def find (c,command,f_name):

    g.trace('%30s %s' % (command,f_name))

    for p in c.all_unique_nodes():
        s = p.b
        i = s.find('def %s' % f_name)
</t>
<t tx="ekr.20101119030344.5840">def adjust(f,i,p):
    pass
</t>
<t tx="ekr.20101119030344.5841">def find_all_defs (c):

    '''Return a dict containing all function defs.

    Keys are function names, values are lists of (i,p) pairs.'''

    # To do: consider only files that actually generate commands?
    d = {}
    suppress = ('__init__',)
    for p in c.all_unique_positions():
        done,i,s = False,0,p.b
        while not done and i &lt; len(s):
            progress = i
            i = i1 = s.find('def',i)
            if i == -1:
                done = True ; break
            i += 3 # Assures progress.
            if not g.match_word(s,i-3,'def'): continue
            j = g.skip_ws(s,i)
            if j == i: continue
            i = j
            j = g.skip_id(s,i,chars='_')
            if j == i: continue
            name = s[i:j]
            if name not in suppress:
                aList = d.get(name,[])
                aList.append((i1,p.copy()),)
                d[name] = aList
            # g.trace('%30s %s' % (name,p.h))
            i = j
            assert progress &lt; i
    return d
</t>
<t tx="ekr.20101124083644.5052">.. index::
    pair: Autocompletion; Tutorial
    
Autocompletion reminds you of all members (functions, methods, ivars, etc.)
contained in objects in Leo's source code, and in Python's standard library
modules.

Alt-1 (toggle-autocompleter) enables and disables autocompletion. **Note**:
Autocompletion can be enabled only when @language python is in effect.

For example, typing just "c.atF" (in the body pane, with autocompletion
enabled) automatically inserts "c.atFileCommands" into the body pane,
because "c.atFileCommands" is the only possible completion of "c.atF".

As another example, typing "at.writeA" will show (in an autocompleter tab in the Log pane)
all of the write commands in leoAtFile.py::

    writeAll:method
    writeAllHelper:method
    writeAtAutoNodes:method
    writeAtAutoNodesHelper:method
    writeAtShadowNodes:method
    writeAtShadowNodesHelper:method

When a single completion is shown, typing '?' will show the docstring for a method::
For example, "c.atFileCommands.write?" shows::

    Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node
</t>
<t tx="ekr.20101124102457.5135">@nocolor

Leo 4.8 final                               November 26, 2010

Leo 4.8 final is now available at:
http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

Leo is a text editor, data organizer, project manager and much more. See:
http://leoeditor.com/tutorial.html

The highlights of Leo 4.8:
--------------------------

- Leo now uses the simplest possible sentinel lines in external files.
  External files with sentinels now look like Emacs org-mode files.
- Leo Qt gui now supports Drag and Drop.
  This was one of the most frequently requested features.
- Improved abbreviation commands.
  You now define abbreviations in Leo settings nodes, not external files.
- @url nodes may contain url's in body text.
  This allows headlines to contain summaries: very useful.
- Leo now uses PyEnchant to check spelling.
- Leo can now open multiple files from the command line.
- Leo's ancient Tangle and Untangle commands are now deprecated.
  This will help newbies how to learn Leo.
- Leo now shows "Resurrected" and "Recovered" nodes.
  These protect data and show how data have changed.
  These fix several long-standing data-related problems.
- A new "screenshots" plugin for creating slide shows with Leo.
  I used this plugin to create Leo's introductory slide shows.
- Improved autocompletion: Ctrl-space starts a one-time completion.
- A better installer.
- Many bug fixes.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20101124102457.5136">There are at least 2 installer issues outstanding:

1. Installing to the "Program Files" folder or the "Program Files
(x86)" folder can cause some unit tests to fail due to permission
issues.  I don't think this is too serious.

2. Installing to the "Program Files (x86)" folder can cause PyEnchant
not to find the spellpyx.txt folder.  This looks like a bug in
PyEnchant.
</t>
<t tx="ekr.20101124102457.5137"></t>
<t tx="ekr.20101124102457.5138"></t>
<t tx="ekr.20101124102457.5139"></t>
<t tx="ekr.20101124102457.5140"># Also, created a "Resurrected Nodes" node to handle such nodes cleanly and safely.
</t>
<t tx="ekr.20101124102457.5141">Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle
consequence of how Leo writes outlines and reads derived files.  This
is a big bug in Leo, not cvs.  The effect of the bug is that nodes can
appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the
following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such
files.  Maybe all @thin derived files should be -kb files, but Leo's
users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is
concerned.  Other .txt files, like leoScripts.txt, should also be
binary files.  As we shall see, the fact that leoProjects.txt is now a
-kb file means that we can not possibly blame the cvs merge algorithm
for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I
added a node called 'changed in the main line'.  In sandbox 2 I added
a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the
following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/
leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.
1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not**
been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge
surprise: the outline contains **both** the node 'changed in main-
line' and the node 'changed2'!

How did this happen?  Well, obviously the 'changed in main-line' node
came from the cvs update.  I expected that.  The 'changed2' line must
have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had
happened.  The 'changed2' is a descendant of a cloned node called '4.4
projects'.

- One clone of '4.4 projects' node is a descendant of the @thin
leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but
outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was
reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node
**already existed in the outline** before Leo read leoProjects.txt,
and the present atFile read logic only **adds** nodes, it never
deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read
logic.  The 'changed2' node became a 'vampire' node that couldn't be
killed.

The problem is far from benign.  Because of clones, the vampire node
became an orphan node in **another** file, namely leoKeys.py.  I tried
two or three times to remove the vampire/orphan node before realizing
what had happened.

The fix (there is *always* a fix) will require some care.  The present
atFile.read logic is robust because it *doesn't* delete nodes.  It is
essential that the read logic remain robust.  I suspect the solutions
will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes
initially, because it doesn't know whether there will be read errors
later.  If there are read errors absolutely nothing must change.  This
ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not
actually read from the derived file.  I think (but haven't proven)
that all descendants of vampire nodes are also vampire nodes.  If that
is so the post-pass will simply delete vampire nodes without worrying
about whether they have descendants.

Warning: the new scheme will mean that cvs update can destroy
information that previously existed in the outline.  I believe this is
correct: we assume that derived files are the 'truly meaningful'
files.  Hey, if we are wrong we can always get the old info from
cvs :-)
QQQ

At present, atFile.read contains code to warn of "resurrected" nodes,
and I did indeed get such a warning when the recent problem arose.

After a quick look at atFile.read, I strongly suspect that the problem
remains today pretty much exactly as it was in 2003.  The only
difference is that the caching code (the call to
root.v.createOutlineFromCacheList(c,aList)) doesn't do the check:
\&lt;\&lt; advise user to delete all unvisited nodes \&gt;\&gt;
that is done later in read(). That probably should be fixed.

Finding a better solution to vampire nodes has been on the list since
2003.  It's not easy because it involves the dreaded "multiple delete"
problem.

Hmm.  The present read code *does* delete the tree before reading thin
external files.  So it appears that vampire nodes could only be
expected in external files derived from @file nodes.  It may be that
part of the problem is that somehow Leo thinks that it is reading an
@file node?? That's pretty weird, but messages about resurrected nodes
and missing tnode lists did happen.  It's quite a puzzle.

Edward
</t>
<t tx="ekr.20101124102457.5142">Specifying a @path directory causes Leo to save an "@thin file.ext" node below
it in Leo's home directory without any warning. The next time Leo is opened it
issues an error that it can not find the file.

It should instead issue a warning that the @path directory does not exist.

If this occurs when the saving of @thin nodes to files is performed as part of
the user closing Leo, the closing of Leo should be aborted to prevent the loss
of data.

===== The Aha

The computation of at./ic.default_directory **must not** attempt to create
directories! It's too early for that!

This simplifies all aspects of the code:

- No need to report errors &amp; no need to recover from errors.
- at.scanAllDirectives can call c.

===== The actual fix:

Due to a previous fix, at.writeAllAtFileNodesHelper does *not* report errors.
This causes Leo to clear all dirty bits.

The proper fix, therefore, is to force a write of the entire @edit tree in
putVnode if it is orphaned.

Similarly, putVnode now forces writes of @auto and @shadow trees.

</t>
<t tx="ekr.20101124102457.5143">http://groups.google.com/group/leo-editor/browse_thread/thread/dbe098206376ec8d

The fixes are marked # 2010/10/22 in &lt;&lt; handle the opcode &gt;&gt;.
</t>
<t tx="ekr.20101124102457.5144">putVnode must test for @file just like @thin.
</t>
<t tx="ekr.20101124102457.5145"></t>
<t tx="ekr.20101124102457.5146"></t>
<t tx="ekr.20101124102457.5147">- Open a node with long (multi-page) body text
- Move cursor towards the end of the node
- Save (ctrl+s)
- Observe how window is scrolled, cursor is moved
</t>
<t tx="ekr.20101124102457.5148"></t>
<t tx="ekr.20101124102457.5149">https://bugs.launchpad.net/leo-editor/+bug/549319

Leo 4.7.1 final, build 3005, February 26, 2010
Python 2.6.2, qt version 4.5.2
Windows 5, 1, 2600, 2, Service Pack 3

When redirecting the output to the Log pane using g.redirectStderr() and
g.redirectStdout(), the output displays non-breaking space characters (&amp;nbsp;)
everywhere there is supposed to be a space.

For example, if I run print 'Hello World' I get Hello&amp;nbsp;World in the Log
pane. This is really hard to read when you have 50 or 100 lines of numbers from
the output of a program.
</t>
<t tx="ekr.20101124102457.5150">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 366, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 284, in autoComplete
    k.masterCommand(event,func=None,stroke=None,commandName=None)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2606, in masterCommand
    val = k.handleDefaultChar(event,stroke)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2664, in handleDefaultChar
    if stroke.lower() == 'return': stroke = '\n'
AttributeError: 'NoneType' object has no attribute 'lower'
</t>
<t tx="ekr.20101124102457.5151"></t>
<t tx="ekr.20101124102457.5152"></t>
<t tx="ekr.20101124102457.5153"></t>
<t tx="ekr.20101124102457.5154">On Windows, using Leo trunk from a few days ago, I get "error: class
class does not end in a newline; one will be added [nl]" on what seems
to be every imported java chunk.

This issue seems to be line-ending related and I duplicated it with a
simple test.  When I run the following code from within a Leo node, I
get the same error as when I tried to import the file.
</t>
<t tx="ekr.20101124102457.5155"></t>
<t tx="ekr.20101124102457.5156"></t>
<t tx="ekr.20101124102457.5157">https://bugs.launchpad.net/leo-editor/+bug/618474

in core/leoRst the method removeLeoDirectives seems not to remove the leo directives.
which results in @leo directives inside generated rst code.

The problematic code line is the statement "g.match_word(s, 0,key)" in the following block:

                for key in self.leoDirectivesList:
                    if g.match_word(s, 0,key):
                        #g.trace('removing %s' % s)
                        break

As far as I understand the function match_word, it returns 1 if s contains key at index 0,
The self.leoDirectivesList contains all directive like color, language, ... (without @) but
s is a complete body line that looks like: @language rest

That means language starts at index 1 not at 0.
changing the line to
  g.match_word(s, 1,key)

let it work correctly in my installation (4.7.1)
</t>
<t tx="ekr.20101124102457.5158">https://bugs.launchpad.net/leo-editor/+bug/618482

in leoRst.py:

the method "handleCodeMode" does not preserve line linefeeds of the original code. While this is only annoying for code
parts it is fatal for doc parts, because rst directives does not work anymore.

The problem is in the line "elif not z.rstrip(): pass" of the following code block at the end of the method
        for z in result:
            if z == '': result2.append('\n\n')
            elif not z.rstrip(): pass
            elif z.endswith('\n\n'): result2.append(z) # Leave alone.
            else: result2.append('%s\n' % z.rstrip())

Commenting this line out, preserves the linefeeds in the doc part but doubles them in the code part.

The method "rstripList" is responsible for the doubling linefeeds:
   The lines arguments is a list of lines with (!) trailing linefeeds (\n),

   The statement s = '\n'.join(theList).rstrip() doubles therefore the linefeeds
    replacing the line with s = ''.join(theList).rstrip() works.
</t>
<t tx="ekr.20101124102457.5159"></t>
<t tx="ekr.20101124102457.5160"></t>
<t tx="ekr.20101124102457.5161">Also give calmer messages for non-existent plugins.
</t>
<t tx="ekr.20101124102457.5162">Replace ';' by os.pathsep.
</t>
<t tx="ekr.20101124102457.5163">Changed w to self in leoQLineEditWidget.setInsertPoint.
</t>
<t tx="ekr.20101124102457.5164">k.fullCommand now ignores fkeys and Ins.
</t>
<t tx="ekr.20101124102457.5165">leoRst: option strip_at_file_prefixes does not strip file prefixes in leo 4.7.1

The problematic code is in method underline of class rstCommands.
The last statement:

  return '%s\n%s\n\n' % (p.h.strip(),ch*n)

returns the full heading and not stripped one, (in the s parameter)
</t>
<t tx="ekr.20101124102457.5166">If one or more chapters exist (other than main), "Go to clone" switches to the
first chapter, whether or not the clone is in that chapter.

The new code always selects the main chapter.
This is the simplest thing that could possibly work.
Other approaches are fraught with difficulties.
</t>
<t tx="ekr.20101124102457.5167">I created a file time.leo. When it's in the dir d:/Dmitry it's being
opened fine. But when I put it into the dir with Russian characters:
D:/Личное/Время leo prints squares at the window header and doesn't
open the file correctly. This problem existed in one of the revisions,
then it was fixed in the last official release. Now it emerged again
in my Leo 4.8 devel, build 3005

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 3307, in pr
    sys.stdout.write(s2)
  File "c:\python31\lib\encodings\cp437.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_map)[0]

UnicodeEncodeError: 'charmap' codec can't encode character '\xc2' in position
31: character maps to &lt;undefined&gt; path changed for @thin
Unicode-Â-folder/unicode-Â-test2.txt created:
C:\Users\edreamleo\Unicode-Â-folder\unicode-Â-test2.txt
</t>
<t tx="ekr.20101124102457.5168">@nocolor-node

Removed the check-all-python-code and check-python code commands
(and removed the references to these commands in menus.)

- Retained the actual code for scripts.
- Retained automatic syntax checking of python files on saves

The problem with separate commands is that they don't necessarily check an
entire file: things like 'return' in a node that doesn't look it is in a
function.

Directives and section references are not the problem:
they get translated to comments before the check.
</t>
<t tx="ekr.20101124102457.5169">nav_qt.py just uses these:

    c.goPrevVisitedNode()
    c.goNextVisitedNode()

and these subsequently use leoCommand.py / class nodeHistory.

The fix would have to happen in leoFrame.py / selectHelper() which does this:

    c.nodeHistory.update(p) # Remember this position.

It shouldn't call update() there. Rather, the call should be moved to
wherever body focus code is.

The fix was to leoTree.selectHelper and qtBody.onFocusIn.

</t>
<t tx="ekr.20101124102457.5170">Removed all traces of the "significant change" logic. The read code remembers
whether a node existed when Leo loaded the outline.

Leo will warn when writing a node that didn't previously exist. This is a nice
simplification of the code.
</t>
<t tx="ekr.20101124102457.5171">This simplifies the print-settings command.
</t>
<t tx="ekr.20101124102457.5172"></t>
<t tx="ekr.20101124102457.5173">http://groups.google.com/group/leo-editor/browse_thread/thread/a108d70400b28dc9#

g.findTestScript is an important new pattern for sharing code in Leo scripts,
including scripts in @test nodes.

Suppose there is common code that I want to include in several unit tests::

    class Hello():
        def __init__(self,name='john'):
            self.name=name
            print('hello %s' % name)

I put this in a node called 'Common test code'.

The unit tests can "import" the code as follows::

    exec(g.findTestScript('Common test code'))

Now class Hello is available the test code!

This is something that I've wanted to do forever.  It's almost too
easy.  I suppose it's a small security problem, but so is every other
@test node!
</t>
<t tx="ekr.20101124102457.5174">http://groups.google.com/group/leo-editor/browse_thread/thread/e3c736bc9f545b7e#

This is an important new helper.
</t>
<t tx="ekr.20101124102457.5175">g.app.setLeoID now calls createDefaultGui instead of createTkGui.

We can *not* put up the LeoID dialog later: it is needed to set
g.app.nodeIndices, which is used in the read logic for outlines, so it *must* be
set before we load any Leo file!

</t>
<t tx="ekr.20101124102457.5176">There are some tricky issues here:

http://groups.google.com/group/leo-editor/browse_thread/thread/4da36f0d897a25e8

Important: g.loadOnePlugin calls the plugins onCreate method to make up for
events that have already been generated. pc.loadOnePlugin does not.
</t>
<t tx="ekr.20101124102457.5177"># Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
</t>
<t tx="ekr.20101124102457.5178"></t>
<t tx="ekr.20101124102457.5179"></t>
<t tx="ekr.20101124102457.5180"># And deprecated code mode.
</t>
<t tx="ekr.20101124102457.5181">It is useless in the one-node world.
</t>
<t tx="ekr.20101124102457.5182">http://groups.google.com/group/leo-editor/browse_thread/thread/24cb88a8c2a20a07#

- Space activates abbreviations.
- Multi-line abbreviations handled properly.
- add-global-abbrev command uses entire selected text as the value of the abbreviation.
- Inserted abbreviations are undoable.
- Added support for @data abbreviations and @data global-abbreviations.
- Added support for @bool enable-abbreviations.

apropos-abbreviations
=====================

When abbreviation mode is on (abbrev-mode toggles this mode) Leo will expand
abbreviations as you type. Type the name of an abbreviation, followed by a
space. As soon as you type the space, Leo will replace the name by the
abbreviations value. You can undo the replacement as usual.

Note that defining any abbreviation automatically turns on abbreviation mode.

The add-global-abbreviation command (&lt;alt-x&gt;add-gl&lt;tab&gt;&lt;return&gt;) takes the
selected text as the replacement value of the abbreviation. The minibuffer
prompts you for the name of the abbreviation.
</t>
<t tx="ekr.20101124102457.5183"></t>
<t tx="ekr.20101124102457.5184">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/611413

These work around the lack of AI in Python's importer.

Added leoImport.findClass helper.

The head-to-prev-node command moves non-empty text preceding a class, method or
function definition to the end of the previous sibling node.

The tail-to-next-node command moves non-empty text following a class, method or
function definition to the start of the next sibling node.
</t>
<t tx="ekr.20101124102457.5189"></t>
<t tx="ekr.20101124102457.5190"></t>
<t tx="ekr.20101124102457.5191">http://groups.google.com/group/leo-editor/browse_thread/thread/d02df89c0b831a7c

I created my own copy of the home page:

    Files--&gt;@edit leo_toc.html

This allows me to group items without creating special pages.
</t>
<t tx="ekr.20101124102457.5192"></t>
<t tx="ekr.20101124102457.5193"></t>
<t tx="ekr.20101124102457.5194">I think @chapters node shouldn't be in a new leo file, but it should
be created when the first chapter is created.

Ditto for the chapter selector toolbar button.
</t>
<t tx="ekr.20101124102457.5195">http://groups.google.com/group/leo-editor/browse_thread/thread/a5a47afa65af9a37

The following changes are on the trunk, and also on Leo's web site:

- In home page, added link to Install page, just above the Beginner's Guide.

- Added more explicit instructions for installing Tk and Qt.

- In step 6 of the Windows install steps, the "assoc .leo=LeoFile"
  is on a line by itself.

- Updated home page to indicate that Leo requires Python and PyQt.
  I also revised and simplified the introduction in other ways.
  Ditto for description of Leo on SourceForge.

- Changed "%1" to "%*" throughout the installation instructions.

- Made batch files given in Installing Leo and Running Leo the same.

- The dialogs that ask for the Leo ID now tells why Leo needs it.

- Just before raising the dialog that asks for the Leo ID, Leo attempts
  to create the Qt Gui first, and then the Tk Gui if Qt does not exist.
  This should make it much less likely that a prompt for the id
  will be sent to the console.


2. The readme.txt file for 4.7.1-final does not mention that Python and PyQt is
   required.

readme.txt does say it has a new Windows installer. This
led me to believe -- erroneously -- that the Windows installer is all
I would need to download and install, since it's typical for most open
source programs I've used to have everything needed for the install
(for example. .NET) in the single Windows download.

2b. And perhaps the readme.txt file as well?

Can the [install] page be updated to make this clearer?

4. When I first went to the Install page, I clicked on the link for
"Installing Leo on Windows", got to the end of the steps and saw the
next section was "Tracking the development version" which I wasn't
interested in doing so I didn't read any further.

Clicking on the installer-created Windows link for Leo on the Start
Menu did nothing. Eventually I found the Windows section under
"Running Leo" and learned it was required to run Leo the first time
from a console window and not by launching it from Windows.
</t>
<t tx="ekr.20101124102457.5196">DnD creates @file or @auto nodes if appropriate
</t>
<t tx="ekr.20101124102457.5197"></t>
<t tx="ekr.20101124102457.5198">http://groups.google.com/group/leo-editor/browse_thread/thread/62ac1977b3704590#

</t>
<t tx="ekr.20101124102457.5199">Having to type the url after @url in headline is annoying.

The @url handler should look into the first line of body for url, if the text in
the headline is not an url. This way, the headline could actually be
descriptive.

I know some plugin does this, but there is no reason why this couldn't be the
default behavior.
</t>
<t tx="ekr.20101124102457.5200">The fix was to the "if not trailingNewlineFlag:" code at the end of at.putBody.
</t>
<t tx="ekr.20101124102457.5201">- improved support for elisp.

    - Use @language lisp instead of @language elisp.

- added importer for .ini files.
</t>
<t tx="ekr.20101124102457.5202"></t>
<t tx="ekr.20101124102457.5203">Refactored g.app.config.readSettingsFiles.

Settings now honored in workbook.

* Window size not honored when opened from menu.
</t>
<t tx="ekr.20101124102457.5204">http://groups.google.com/group/leo-editor/browse_thread/thread/e6075a699909db53

You can now set a proportional font to use in all "@language plain" nodes

Specify fonts in @font nodes:

@font plain null font

plain_null_font_family = Times New Roman
plain_null_font_size = 16
plain_null_font_slant = roman
plain_null_font_weight = bold

That is, the actual font specs are in the body text.  Everything
except @font is ignored in the headline.

Specify colors in @color nodes:

@color plain null color = black
</t>
<t tx="ekr.20101124102457.5205">Added the following options with the indicated defaults.

\@color minibuffer_background_color = lightblue
\@color minibuffer_warning_color = lightgrey
</t>
<t tx="ekr.20101124102457.5206">Valid values are top,bottom,left,right
</t>
<t tx="ekr.20101124102457.5207"></t>
<t tx="ekr.20101124102457.5208">Command-line args
</t>
<t tx="ekr.20101124102457.5209">@bool enable-abbreviations (default: False)

  When true, enables substitution of abbreviations.

@data global-abbreviations
@data abbreviations

  In both cases, body text contains lines of
  the form::

   name=value

  name is the abbreviation name, value is the substituted text. Whitespace is
  ignore around the name, but is significant in the value. Abbreviation names
  may contain only alphabetic characters, but may start with the '@' sign.

  By *convention* @data global-abbreviations setting should be defined in
  myLeoSettings.leo, while @data abbreviations should be defined in other .leo
  files. Regardless of where they are defined, abbreviations in @data
  abbreviation nodes will override settings (with the same name) in @data
  global-abbreviations nodes.
</t>
<t tx="ekr.20101124102457.5210"></t>
<t tx="ekr.20101124102457.5211"></t>
<t tx="ekr.20101124102457.5212">The code that calculates the end of a block of indented Python code now takes
take more care with backslashes.
</t>
<t tx="ekr.20101124102457.5213"></t>
<t tx="ekr.20101124102457.5214">- Added better prompts for move/copy/clone commands.

- Undo/redo of these commands select the main chapter.
</t>
<t tx="ekr.20101124102457.5215">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/dea95cd8ab976cac


&gt; &gt; * The file 'INSTALL.TXT' contains the outline text with sentinels from
&gt; &gt; 'Chapter 1: Installing Leo'

There are *two* files called install.txt: the one that should
contain installation instructions and the one that contains the
"Installing Leo" chapter.

The solution was to change install.txt to installing.txt in the users guide.
</t>
<t tx="ekr.20101124102457.5216"></t>
<t tx="ekr.20101124102457.5217">Allow "always on" operation:

- Ctrl-space is now bound to force-auto-completion

- Remove Alt-1 and Alt-2 default bindings.
</t>
<t tx="ekr.20101124102457.5218">http://bugs.launchpad.net/leo-editor/+bug/611413

These work around the lack of AI in Python's importer.

The head-to-prev-node command moves non-empty text preceding a class, method or
function definition to the end of the previous sibling node.

The tail-to-next-node command moves non-empty text following a class, method or
function definition to the start of the next sibling node.
</t>
<t tx="ekr.20101124102457.5219">Fixed wishlist bug 670744: add a setting to put inter-def code in its own node

Added support for @bool at_auto_separate_non_def_nodes option.
The default (legacy mode) is False.
</t>
<t tx="ekr.20101124102457.5220"></t>
<t tx="ekr.20101124102457.5221">@nocolor-node

Removed the keybindings.py plugin.  The print-bindings command should suffice.

The plugins_menu.py has been renamed old_plugin_menu.py to indicate that it
needs a lot of work to become functional.

The following plugins are now gui-independent (the used to be Tk only):

at_produce.py
chapter_hoist.py
import_cisco_config.py
macros.py
mod_read_dir_outline.py
multifile.py
read_only_nodes.py
word_count.py
xsltWithNodes.py

I also registered the menu2 event instead of the open2 event in all plugins that
use this event to create menus. This is required because a relatively recent
change creates menus *after* the open2 event happens.
</t>
<t tx="ekr.20101124102457.5222"></t>
<t tx="ekr.20101124102457.5223">execute-script now calls execfile (or its equivalent when using Python 3k)
when @bool write_script_file = True.

This allows pdb to show the text of scripts!
</t>
<t tx="ekr.20101124102457.5224">This should have been done *ages* ago. The command makes it easy to put python
methods in separate nodes.

Select a range of text, the first line of which starts with 'def foo (...)'

Do alt-x extract-python-method (or ctrl-p if you are repeating the command).

What happens:

- Creates a new child node whose headline is 'foo'.

- The body of foo contains all the selected text, properly indented.

The command is undoable.
</t>
<t tx="ekr.20101124102457.5225">Leo opens the file specified by the default_leo_file setting if it exists.

New in 4.8 rc1: if default (workbook) file does not exist Leo will
open an empty file and name is to be the default file.
</t>
<t tx="ekr.20101124102457.5226">The installer now makes proper entries in the Windows start menu.
</t>
<t tx="ekr.20101124102457.5227">- Fixed key redefinition message.
</t>
<t tx="ekr.20101125062332.5090">Leo requires the `Python`_ and `PyQt_` package.
The `PyEnchant`_ package is optional. 

**Python**: Leo will work on any platform that supports Python 2.6 or
above, including Python 3.0 and above. To install Python, see
http://python.org.

**PyQt**: PyQt provides Leo's widgets. To install PyQt, get the binary
package from: http://www.riverbankcomputing.co.uk/software/pyqt/download
The PyQt version must match your installed Python version. Remember that
Leo requires Python 2.6 or later, or Python 3.0 or later. Now run the
binary PyQt installer.

**PyEnchant**: You must install the PyEnchant package if you want to use
Leo's Spell tab. Download and install the PyEnchant package from
http://pythonhosted.org/pyenchant/download.html There is an executable
installer for Windows users.
</t>
<t tx="ekr.20101127152442.5878">@color

@language rest
</t>
<t tx="ekr.20101127152442.5879"></t>
<t tx="ekr.20101127152442.5880">http://www.vim.org/scripts/script.php?script_id=850
</t>
<t tx="ekr.20101127152442.5881">http://groups.google.com/group/leo-editor/browse_thread/thread/c537f3bc8328a938
</t>
<t tx="ekr.20101127152442.5882"></t>
<t tx="ekr.20101127152442.5883">http://groups.google.com/group/leo-editor/browse_thread/thread/e236feb5bd2a097a/d261f6dbdb7eb950

@language rest

As requested, there is now user-friendly way of adding minibuffer
commands to context menu (in trunk, qt only).

I also added example to quickstart.leo, but all you need to know is
that you need to create

@settings
  @data contextmenu_commands

And the content is like:

# The format is &lt;command&gt; SPACE &lt;description&gt;

stickynote Create a sticky note
read-at-file-nodes Read file nodes 
</t>
<t tx="ekr.20101127152442.5884"></t>
<t tx="ekr.20101127152442.5885">For newbies (and for power users too, for that matter), it may be helpful to
have a "Find and Replace" dialog box similar to the one below:

.. image:: c:/prog/findReplace.jpg

</t>
<t tx="ekr.20101127152442.5886">c:/prog/findReplace.jpg
</t>
<t tx="ekr.20101127152442.5887"></t>
<t tx="ekr.20101127152442.5888">http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

@language rest

This features a long an important discussion of using Leo with vim.
</t>
<t tx="ekr.20101127152442.5889">http://groups.google.com/group/leo-editor/browse_thread/thread/bdcbe3a4ffb5ac61/7dbeea85f671cfe9

@language rest

Source-highlight Qt Library 0.2.2
http://srchiliteqt.sourceforge.net/source-highlight-qt.html

This seems to be a (c++ based) syntax highlighting package that would
allow us to avoid running any python code for syntax highlighting.
Needless to say this is probably very fast.

Investigation needed how easy this would be to deploy in python &amp; leo.
I might(!) make a plugin that allows you to use it instead of leo's
own highlighters...

t seems to support lots of languages already:

http://www.gnu.org/software/src-highlite/

seems you can define your own languages:

http://www.gnu.org/software/src-highlite/source-highlight.html#Language-Definitions

lots of stuff there, but the simple case (keywords) seem to be simple:

http://www.gnu.org/software/src-highlite/source-highlight.html#Simple-definitions

EKR: We would have to support coloring of Leo directives.

</t>
<t tx="ekr.20101127152442.5890">http://groups.google.com/group/leo-editor/browse_thread/thread/d030a9eccfae2aa2/3a951894e0c15f72

@language rest

This is a cool video:

http://www.cs.brown.edu/people/acb/codebubbles_site.htm
</t>
<t tx="ekr.20101127152442.5891"></t>
<t tx="ekr.20101127152442.5892">http://www.caliopywork.org/
</t>
<t tx="ekr.20101127152442.5893"></t>
<t tx="ekr.20101127152442.5894"></t>
<t tx="ekr.20101127152442.5895">http://blog.enthought.com/?p=127

rst project of interest 2009/07/14

http://mail.google.com/mail/#label/Cool/1227cc2c66c976ec

It may be that the codebase could be worth looking at.  I find the
prospect of doing a full sphinx rendering of a document in real time
quite fascinating :-).

Requires ETS (Enthought Tool Suite)
http://code.enthought.com/projects/index.php
</t>
<t tx="ekr.20101127152442.5896">https://code.launchpad.net/~villemvainio/leo-editor/autosphinx

http://groups.google.com/group/leo-editor/browse_thread/thread/f292f7c9f2fd66d8

bzr branch lp:~villemvainio/leo-editor/autosphinx 

@language rest


No, we want *another window*, like with @button rst-preview, that is
updated in real time. The html output is not editable anyway.

&gt;&gt; Now, the thing is to
&gt;&gt; update this in real time (as you are editing, i.e. not on save or
&gt;&gt; explicit tangle step).

&gt; How about doing it at idle time, that is, at most every half second?

It needs to happen in another process in order to not bog down normal
editing (if we stop doing that, the ui will hang). Generating sphinx
output is somewhat expensive operation.

&gt; I don't want to involve any part of the file logic in rendering: it's too
&gt; complex as it is.

With @auto-rst, we get this for free (i.e. rendering every time you
save). Barring that, we could do the rendering just for current node,
but that is not faithful to the final output.

I think the best implementation is a new process that monitors a file.
That way, it's not really leo-specific, and it's easy to do. Leo just
needs to tell it what file to monitor.

-- 
</t>
<t tx="ekr.20101127152442.5897">http://groups.google.com/group/leo-editor/browse_thread/thread/20ec9f3ec33eb174/dacfce8823e727c1

@language rest

</t>
<t tx="ekr.20101127152442.5898">@language rest

&gt; On a related note, is there a good example somewhere of embedding
&gt; LaTeX markup in rst?

You can use the ..raw directive

Here is a quote from another thread
http://groups.google.com/group/leo-editor/browse_thread/thread/16272e...

QQQ
One of the difficulties was how to "convince" Leo to write raw code, I
wanted to write some equations and tables, so it was necessary to use
symbols like \, { }, and so on, i. e., what is required by LaTeX. The
problem was that all these symbols were "interpreted" wrongly and
replaced by an unreadable code. The solution was to use the raw
directive. An example is much better to show this. Assume the
following LaTeX code for an equation and a table in a Leo node:

@
.. raw:: latex html

 \begin{equation}  f(x)=\frac{e^{X\beta}}{1-e^{X\beta}}  \end
{equation}

 \newline
 \begin{tabular}[b]{|r|l||c|r|}
    &lt;content deleted ...&gt;
 \end{tabular}

@c

Attention: RsT code requires an indentation with respect to the raw
directive. I didn't know it. It is here a leading blank space for all
LaTeX code inside the raw directive. And then it worked fine.
QQQ 
</t>
<t tx="ekr.20101127152442.5899">I think you get the most control by having leo generate an rst file and
then processing it yourself.

Like this somewhat dated page (skip the first section):
http://leo.zwiki.org/RstEmacs

For a project I'm currently working on, currently :), my set up is like
this:

Edit rst in leo using an @auto-rst node.

Run this script (it is (pointlessly) a Makefile):

.. sourcecode:: make

  all:
        rst2html.py report2.rst report2.html
        itex2MML &lt; report2.html &gt; report2.xhtml
        rst2latex.py --documentoptions=letterpaper --stylesheet-path=myprefs.inc \
          --reference-label="ref*" --use-latex-citations report2.rst report2.tex
        echo | pdflatex -draftmode report2 &gt;/dev/null 2&gt;&amp;1
        echo | pdflatex -draftmode report2 &gt;/dev/null 2&gt;&amp;1
        echo | pdflatex report2 2&gt;&amp;1 | tr \\n \\r
        rst2latex.py --documentoptions=letterpaper --stylesheet-path=myprefs.inc \
          report2.rst report2.tex

The two -draftmode parses take care of references etc. much quick than
non-draft, because they don't chew up time turning pngs and pdfs into
part of the pdf output.  I.e. they don't produce pdf output.

``myprefs.inc`` looks like:

.. sourcecode:: latex

  \usepackage{pslatex}
  \usepackage{mathptmx}
  \usepackage[scaled=.90]{helvet}
  \usepackage{courier}
  \renewcommand\sfdefault{phv}%               use helvetica for sans serif
  \renewcommand\familydefault{\sfdefault}%    use sans serif by default
  \renewcommand{\topfraction}{0.85}
  \renewcommand{\textfraction}{0.1}
  \renewcommand{\floatpagefraction}{0.75}
  \setcounter{bottomnumber}{2}
  \renewcommand{\bottomfraction}{0.8}

  \setlength{\parskip}{2ex}
  \setlength{\parindent}{0pt}

  \addtolength{\oddsidemargin}{-1.5cm}
  \addtolength{\evensidemargin}{-1.5cm}
  \addtolength{\textwidth}{3cm}
  \addtolength{\topmargin}{-2cm}
  \addtolength{\textheight}{4cm}

  \usepackage{fancyhdr}
  \pagestyle{fancy}
  \lhead{Synoptic mapping of Native Plant Communities}
  \rhead{}
  \lfoot{\footnotesize 20091203-draft }

itex2MML (referenced in the ``Makefile``) converts latex math notation to MathML in the .xhtml output.

To insert raw latex in the latex output from rst, use

.. sourcecode:: rst

  .. raw:: latex

     \some{latex here}

Cheers -Terry 
</t>
<t tx="ekr.20101127152442.5900">http://rst2a.com/

@language rest

A web service that converts reStructuredText to pdf or other formats.

You can use that to, say, quickly generate pdf from an (@auto-) rst file.

There is an api for the web service:

http://rst2a.com/api/
</t>
<t tx="ekr.20101127152442.5901"></t>
<t tx="ekr.20101127152442.5903"></t>
<t tx="ekr.20101127152442.5904">http://mail.google.com/mail/#label/Cool/121a1f23e75fc348

@language rest

Often, it' useful to decouple node creation from data processing. Case
in point is the read code &amp; the hash based speedup scheme I described
(and referred to again in previous thread!)

(for every instance of 'json' below, you can substitute "hierarchical
python object". I'm thinking of json because of interoperability &amp;
human-readablity of json vs. pickle).

What I mean is:

- Provide a way to create tree structure from json object. This is
easy, just add function

c.createSubTreeFromJson(p, json)

The 'json' arg is just a string with subtree encoded in json. Something like

[ ('h1', 'body1', 'gnx1', [ ('h1.1' , 'body1.1' , 'gnx1.1'), ('h1.2' ,
'body1.2' , 'gnx1.2')], ('h2', ......]

i.e. it's a recursive data structure with list of nodes as tuples (h,
b, gnx, children) where 'children' is the recursive part. So far, so
good. That's the easy part - it's just like xml, apart from the fact
that xml is overkill for this problem, requiring nontrivial parser
code (and thus being of lower usability &amp; speed). Yes, the json is
pretty much the same as repr(python_object).

Now, for the important part.

All code that creates trees (read code as the most relevant example!)
probably shouldn't create the tree directly. Rather, it should use c
and p to learn what it needs to, then compose a result json object and
pass it on to c.createSubTreeFromJson(p, json). This is important &amp;
elegant distinction from current behaviour where the data processing
code also modify the tree. We can basically have tests for most of the
stuff without altering the tree in any way, allowing the tree to stay
"read only" as long as possible.

The hash speedup I've been talking about will execute the auto/thin
parsing code exactly once for the particular file content, store away
the json, and just read that json file on subsequent runs. There is no
need to speculate on feasibility of this scheme, we've already had
that particular discussion. It really is the simplest &amp; fastest
possible solution.

We could also add lazy loading (though this is not as important), but
*also this* will be easier with this scheme. Basically, the lazy
loading would:

- Run in a thread in the background, collecting stuff from external
files to json objects
- Every once in a while, do the "destructive" thing and update the
tree from these json objects, redrawing if necessary.

Also this will be perfectly safe - the background thread never does
gui manipulation. At any given time, it's only reading a file, and
writing the json obj to buffer. No communication with leo gui is
necessary. If position with root obj no longer exist, we just throw
the json away and rescan if needed.
</t>
<t tx="ekr.20101127152442.5905">http://mail.google.com/mail/#label/Cool/121b225322eb0a6a

@language rest

I experimented with creating a "direct" recursive data structure for leo trees.

It's pretty simple (who needs Haskell &amp; friends when we have python):

def p_to_obj(p):
   return [p.h, p.b, p.gnx, [p_to_obj(po) for po in p.children_iter()]]

Yes, I removed utf8 encoding to keep it more elegant ;-).

The whole snippet is somewhat like this:

http://pastebin.com/f6a30f859

It creates a python object like this:

http://pastebin.com/f17a3a285

(list of p,h,gnx, children...)

Now, the interesting part. This can be directly encoded as Yaml, to
render the rather readable:

http://pastebin.com/f3d750af3

The part that needs work is the body text, it should probably be
improvable by using "block scalars".

This idea is related to my "jsonification" refactoring suggestion a
while ago. If functions like read code emitted stuff that p_to_obj
returns, the yaml structure could be used to debug / trace the data
(but still in machine-readable form). This could also be used to
communicate outline structure so that it can be both read, and copy
pasted from emails to real tree structure.

No need to take any action regarding this email. Just a food for
thought, perhaps for inspiration...
</t>
<t tx="ekr.20101127152442.5906">http://groups.google.com/group/leo-editor/browse_thread/thread/f83704ecc4ba225a/9e75ecc105aab953

@language rest

&gt; Would it be possible to publish somewhere the scripts or other files you use
&gt; to create the .deb files?

It's somewhat of a nontrivial effort (that I do manually), but the
debian/ directory is here:

https://code.launchpad.net/~leo-editor-team/leo-editor/packaging-jaunty

In order to build the package, I have set up the ubuntu "ppa" (you can
register it at launchpad), use "debuild -S -sa" to build the package
when everything is at correct place (it's picky about directory &amp; file
names and such), and use "dput" to upload it to launchpad servers.
After a while (one hour?), the package is built.

I have a .leo file that I use to trace these steps. I can push it to
trunk. But there is no automatic script to do it; it's possible to
just run "dpkg-buildpackage -rfakeroot" when the debian/ directory is
at leo-editor directory, but that's not the "proper" way, as your
environment is almost never clean enough to get a reliable package
that directly reflects the source snapshot at that tag. 
</t>
<t tx="ekr.20101127152442.5907"></t>
<t tx="ekr.20101127152442.5908">http://www.json.org/

@language rest

**object**:

{   string : value,
    string : value,
    ...
} 

**array**:

[ value, value...]

**value**: string object array true false null

**number**: 
    int
    int frac
    int e digits
    int frac e digits 
</t>
<t tx="ekr.20101127152442.5909">serverfault.com
stackoverflow.com

@language rest

Quora
</t>
<t tx="ekr.20101127152442.5910"></t>
<t tx="ekr.20101127152442.5911">http://clonedigger.sourceforge.net/
</t>
<t tx="ekr.20101127152442.5912">http://leo.zwiki.org/LeoAsAFileSystem

@language rest

</t>
<t tx="ekr.20101127152442.5913">http://pypi.python.org/pypi/manuel

@language rest

Manuel parses documents, evaluates their contents,
then formats the result of the evaluation.
</t>
<t tx="ekr.20101127154340.5927">http://groups.google.com/group/leo-editor/browse_thread/thread/32c3a295d2dae35b
</t>
<t tx="ekr.20101127154340.5928">http://pexpect.sourceforge.net/pexpect.html

@language rest

pexpect: a Python module for spawning child applications and
controlling them automatically. 
</t>
<t tx="ekr.20101127154340.5930">http://pyjs.org/

@language rest

Pyjamas: AJAX tool kit.
</t>
<t tx="ekr.20101127154340.5931">http://code.google.com/p/pysmell/

@language rest
</t>
<t tx="ekr.20101127154340.5932">http://pythoscope.org/

@language rest
</t>
<t tx="ekr.20101127154340.5933">http://rope.sourceforge.net/

@language rest
</t>
<t tx="ekr.20101127154340.5934">http://projects.gnome.org/tomboy/index.html

http://groups.google.com/group/leo-editor/browse_thread/thread/18d4af19686f2ead
</t>
<t tx="ekr.20101127154340.5935"></t>
<t tx="ekr.20101127154340.5936">http://groups.google.com/group/leo-editor/browse_thread/thread/db6e75d82da4b41d

@language rest

A few buttons turns Leo into a competitor for google groups.

</t>
<t tx="ekr.20101127154340.6803">@language python
@tabwidth -4

"""
Analyzing program flow.

Run (ctrl+b) this script after 

cd ~/leo-editor
python -m trace --trackcalls launchLeo.py --gui=qt &gt;trace.txt

"""

tracefile = '~/leo-editor/trace.txt'

import os

tr = open(os.path.expanduser(tracefile))
print tr
top = p.insertAsLastChild().copy()
top.h = 'trace session'
cur = None
no = None
for l in tr:
    if l.startswith('***'):
        cur = top.insertAsLastChild().copy()
        cur.h = os.path.basename(l.split()[1])
    elif l.startswith('  --&gt;'):
        no = cur.insertAsLastChild().copy()
        no.h = os.path.basename(l.split()[1].strip())
    else:
        if no:
            no.b += l.strip() + '\n'

    print ".",
</t>
<t tx="ekr.20101127154340.6804">http://docs.python.org/library/trace.html

@language rest

See the child node for a cool script.
(It is also in scripts.leo).
</t>
<t tx="ekr.20101127154340.6805"></t>
<t tx="ekr.20101127154340.6806">http://www.reviewboard.org/

@language rest
</t>
<t tx="ekr.20101127154340.6807">http://groups.google.com/group/pyxides

@language rest
</t>
<t tx="ekr.20101127154340.6808"></t>
<t tx="ekr.20101127154340.6809">http://www.tinkerpop.com/
</t>
<t tx="ekr.20101127154340.6810">http://flask.pocoo.org/docs/

@language rest
</t>
<t tx="ekr.20101127154340.6811">http://www.zeromq.org/
</t>
<t tx="ekr.20101127154340.6812">http://fishsoup.net/software/reinteract/

@language rest

</t>
<t tx="ekr.20101127154340.6813"></t>
<t tx="ekr.20101127154340.6814">http://www.fprintf.net/vimCheatSheet.html

@language rest
</t>
<t tx="ekr.20101127154340.6815">http://www.dc.turkuamk.fi/docs/soft/vim/vim.html

@language rest
</t>
<t tx="ekr.20101127154340.6816">http://linuxgazette.net/152/srinivasan.html

@language rest
</t>
<t tx="ekr.20101127154340.6817">http://vim-voom.webs.com/

@language rest
</t>
<t tx="ekr.20101127154340.6818">http://www.viemu.com/a-why-vi-vim.html

@language rest
</t>
<t tx="ekr.20101127154340.6819">http://www.delorie.com/gnu/docs/emacs/viper.html

@language rest
</t>
<t tx="ekr.20101127154340.6820">http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html

@language rest
</t>
<t tx="ekr.20101127154340.6822">http://udk.openoffice.org/python/python-bridge.html

@language rest

http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/ProUNO/Professional_UNO
</t>
<t tx="ekr.20101127154340.6823">http://community.activestate.com/forums/komodo/open-komodo

@language rest

archives:

http://lists.openkomodo.com/pipermail/openkomodo-dev/
</t>
<t tx="ekr.20101127154340.6824">http://www.literatureandlatte.com/scrivener.html

@language rest
</t>
<t tx="ekr.20101127154340.6825">http://orgmode.org/worg/org-contrib/babel/intro.php

@language rest
</t>
<t tx="ekr.20101127154340.6826"></t>
<t tx="ekr.20101127154340.6827">http://nsis.sourceforge.net/Docs/Contents.html

@language rest
</t>
<t tx="ekr.20101127154340.6828">http://www.burgaud.com/scite-java-api/

@language rest
</t>
<t tx="ekr.20101127154340.6829">http://www.scintilla.org/tags2api.py

@language rest

Produces a .api file for SciTE's identifier completion and calltip features.
</t>
<t tx="ekr.20101127154340.6830">http://www.koders.com/python/fid7000B9C96CF2C6FB5BCE9DF700365C5B2A1F36A7.aspx?s=gtk#L53

@language rest

gen_python_api.py generates a python.api file for SciTE
</t>
<t tx="ekr.20101127154340.6833">http://tinyurl.com/35ddr4w

@language rest
</t>
<t tx="ekr.20101127154340.6835">http://www.makelinux.net/kernel_map

@language rest
</t>
<t tx="ekr.20101127154340.6836">http://www.blender.org/

@language rest
</t>
<t tx="ekr.20101127154340.6837"></t>
<t tx="ekr.20101127154340.6838">http://sagemath.org/

@language rest
</t>
<t tx="ekr.20101127154340.6839">http://gul.sourceforge.net/viewdog-manual/node3.html

@language rest
</t>
<t tx="ekr.20101127154340.6840">http://groups.csail.mit.edu/uid/sikuli/

@language rest
</t>
<t tx="ekr.20101127154340.6841">http://screenr.com/
</t>
<t tx="ekr.20101127154340.6842">http://jingproject.com
</t>
<t tx="ekr.20101127154340.6843">http://inkscape.org/

@language rest

</t>
<t tx="ekr.20101127154340.6844">http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx?PHPSESSID=d926

@language rest
</t>
<t tx="ekr.20101127154340.6845">http://www.egenix.com/products/python/mxBase/mxTextTools/

@language rest
</t>
<t tx="ekr.20101127154340.6846">http://www.w3.org/

@language rest
</t>
<t tx="ekr.20101127154340.6847">http://www.2die4games.com/

Thread: TL's 2die4games web site

http://groups.google.com/group/leo-editor/browse_thread/thread/cace15fe101e4844/6acd66a982bc063b
</t>
<t tx="ekr.20101127154340.6848">http://code.google.com/appengine/

@language rest
</t>
<t tx="ekr.20101127154340.6849">http://browsershots.org/

@language rest
</t>
<t tx="ekr.20101127154340.6850">http://goosh.org/

@language rest
</t>
<t tx="ekr.20101127154340.6851">https://sourceforge.net/project/admin/explorer.php?group_id=3458

@language rest
</t>
<t tx="ekr.20101127154340.6852">http://www.mail-archive.com/leo-editor@googlegroups.com/msg10145.html
</t>
<t tx="ekr.20101127154340.6853"></t>
<t tx="ekr.20101127154340.6854">http://commandwindows.com/command1.htm

@language rest
</t>
<t tx="ekr.20101127154340.6855">http://www.codeproject.com/Articles/36538/Windows-7-Tricks-and-Keyboard-Shortcuts.aspx

@language rest
</t>
<t tx="ekr.20101127154340.6856">http://www.lazysoft.com/

@language rest
</t>
<t tx="ekr.20101127201907.5945">http://groups.google.com/group/leo-editor/browse_thread/thread/440bbf170787c5ed/c228a9fd1d429fa6

@language rest
</t>
<t tx="ekr.20101127201907.5946">http://groups.google.com/group/leo-editor/browse_thread/thread/6b77a59a3a5c7cbb/f26164f24bee68d2

@language rest
</t>
<t tx="ekr.20101127201907.5947"></t>
<t tx="ekr.20101127201907.5948">http://groups.google.com/group/leo-editor/browse_thread/thread/278442febf1a1965/6a6640976c23935f

@language rest

configure_tags killing performance again

EKR:

Rev 2119 contains what appears to be a major improvement in speed:

- leoQTextEditWidget.SetAllText now sets a lockout that prevents a duplicate
  recoloring of text. This doubles the speed of the syntax colorer, and almost
  doubles the speed of unit tests!

- updateSyntaxColorer and colorize set self.flag = False for large body text.
  This doesn't prevent recolor from being called, but it does short-circuit
  recolor.

And yes, configure_tags is called only by the ctor, that is, just once. 

Ville:

Now that was one damn fine checkin... 
</t>
<t tx="ekr.20101127201907.5949">http://groups.google.com/group/leo-editor/browse_thread/thread/9fb569af95eee493/00c3bbe120567771

Thread: A new design for the incremental colorer

This long posting will discuss a new design for an incremental
colorizer using QSyntaxHighlighter.  The essential features of this
design became apparent during yesterday's walk. 
</t>
<t tx="ekr.20101127201907.5950">http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106/478c773f875815db

@language rest

- Create one QWebView window, zoom it in to have large fonts
- Create @button that converts current node containing
  restructuredtext to html, and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

=====

Terry:
</t>
<t tx="ekr.20101127201907.5951">http://groups.google.com/group/leo-editor/browse_thread/thread/47dfb2e1767d2cda/8e658c5b73406a8d

@language rest

I have gotten *zero* responses to my 42 post:
http://groups.google.com/group/leo-and-pylint/browse_thread/thread/3c...

I should have remembered that nobody reads long posts. So here is the
Aha in a nutshell:

Unit tests are not just for testing!  They are *the* master tool for
programming, design, testing, refactoring, studying code, or *anything
else*. 
</t>
<t tx="ekr.20101127201907.5952"></t>
<t tx="ekr.20101127201907.5953">http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence/

@language rest


Thread: Interesting post on data tree design

http://groups.google.com/group/leo-editor/browse_thread/thread/e4646371478cd30/44eba97b45bd53b3
</t>
<t tx="ekr.20101127201907.5954">http://groups.google.com/group/leo-editor/browse_thread/thread/d119424cbccc96df/379a0600dfb8f4ca?lnk=gst&amp;q=terry+brown#379a0600dfb8f4ca

@language rest

Was: "Anchors" as pseudo-persistent positions

Now: OT: rst/html in email

Important : You should try and view the HTML version of this message!

On Thu, 10 Dec 2009 10:46:05 -0600 Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; Hey - would it be cool to have an email system which lets you write
&gt; in rst and then sends both text (rst) and html forms...

Despite the fact y'all failed to chorus "Yes it would" ;-) I went ahead and set
it up in Claws-mail

   1.

      Add an rst-preview button to the Claws-mail compose window. It just runs a
      user command on the body text:

      | rst2pyg &gt;~/.tmp.html; x-www-browser ~/.tmp.html

      rst2pyg is included below.
   2.

      Add an indent button to the Claws-mail compose window. It just runs a user command on the selected text:

          | sed 's/^/  /' |

   3.

      Write rst2email, included below.
   4.

      Use Send Later for messages you want to process, so rst2email can get at them in the queue directory.
   5.

      You can get rst2email_pygments.py (as imported by both rst2email and rst2pyg) from my blog, it's the file at the end of this page.

rst2email::

    #!/usr/bin/python
    """rst2email - look for messages in an email queue folder and
    add an html part by processing the text part as rst

    Terry Brown, terry_n_brown@yahoo.com
    """

    import email
    import mailbox
    from email.mime.text import MIMEText
    from docutils.core import publish_string

    # this import adds the sourcecode:: directive to rst
    import rst2email_pygments

    queue = "/home/tbrown/Mail/queue"

    mbox = mailbox.MH(queue, email.message_from_file)

    for msgkey in mbox.iterkeys():
        # d = email.utils.parsedate(msg.get('Date'))

        msg = mbox[msgkey]

        if not msg.is_multipart():
            txt = msg.get_payload()
            html = publish_string(txt, writer_name='html')
            part1 = MIMEText(txt, 'plain')
            part2 = MIMEText(html, 'html')
            part1["X-rst2email"] = "rst"
            part2["X-rst2email"] = "html"
            msg.set_type("multipart/alternative")
            msg.set_payload([])
            msg.attach(part1)
            msg.attach(part2)
            mbox[msgkey] = msg
        else:
            txtpart = None
            htmlpart = None
            for part in msg.walk():
                if part.get_content_type() == "text/plain":
                    if txtpart:  # can't handle more than one
                        txtpart = None
                        break
                    txtpart = part
                if part.get_content_type() == "text/html":
                    if htmlpart:  # can't handle more than one
                        htmlpart = None
                        break
                    htmlpart = part
            if txtpart and htmlpart and not txtpart.is_multipart():
                htmlpart.set_payload(
                    publish_string(txtpart.get_payload(),
    writer_name='html')) txtpart["X-rst2email"] = "rst"
                htmlpart["X-rst2email"] = "html"
                msg.set_type("multipart/alternative")
                mbox[msgkey] = msg

rst2pyg::



    #!/usr/bin/python

    from docutils.core import publish_string
    import rst2email_pygments
    import sys

    print publish_string(sys.stdin.read(), writer_name='html')

===== Ville M. Vainio	

This kind of stuff makes me think html email is actually a somewhat tolerable concept.

For thunderbird, there is pasteCode:

https://addons.mozilla.org/en-US/thunderbird/addon/4046

===== Terry Brown

Maybe :-) even as I wrote it it was more because I thought email
rendered (to html) from rst was cool, rather than that I think html
email is necessary.  It's funny looking at postings in this list vs. my
main inbox, here very very few msgs have html parts, whereas in the
main inbox at least 50% do.

Did occur to me that it would probably be possibly to set up some
combination of unicode chrs and css which would render leo trees
nicely in an html email.
</t>
<t tx="ekr.20101129064803.6059">http://groups.google.com/group/leo-editor/browse_thread/thread/2b6cceebd7cd2e3/dddcb73e2a6469b9

@language rest

Linux only

For using inotify from Python, I've used pyinotify; it seems to be a
bit more mature: 

http://pypi.python.org/pypi/pyinotify/0.9.1

There's also inotifyx: (more portable?)

http://pypi.python.org/pypi/inotifyx/0.1.1 
</t>
<t tx="ekr.20101129064803.6060">http://groups.google.com/group/leo-editor/browse_thread/thread/278aa85d7298a319/ef6446fcf6268c0d

leoRemote.py
</t>
<t tx="ekr.20101129064803.6061">http://groups.google.com/group/leo-editor/browse_thread/thread/2e1b240b023b545e/8e9164b52ff25199

Cool slide show: very technical, about graph traversals, from AT&amp;T technical talk

http://www.slideshare.net/slidarko/problemsolving-using-graph-traversals-searching-scoring-ranking-and-recommendation
</t>
<t tx="ekr.20101129064803.6062">http://groups.google.com/group/leo-editor/browse_thread/thread/f8234a8fdeb08d22/4f42eafa955eae9b

Rich text editing in Leo

markdown: http://www.freewisdom.org/projects/python-markdown/

his is a Python implementation of John Gruber's Markdown. It is almost
completely compliant with the reference implementation.

http://daringfireball.net/projects/markdown/

Markdown is a text-to-HTML conversion tool for web writers. Markdown allows you
to write using an easy-to-read, easy-to-write plain text format, then convert it
to structurally valid XHTML (or HTML).
</t>
<t tx="ekr.20101129064803.6063">http://groups.google.com/group/leo-editor/browse_thread/thread/f65470074f6573ab/c73d5b313526d5af

pida: http://pida.co.uk/

PIDA is an IDE (integrated development environment). PIDA is different from
other IDEs in that it will use the tools you already have available rather than
attempting to reinvent each one. PIDA is written in Python with the PyGTK
toolkit, and although is designed to be used to program in any language, PIDA
has fancy Python IDE.
</t>
<t tx="ekr.20101129064803.6064">http://groups.google.com/group/leo-editor/browse_thread/thread/d052979864a278bc/3ff8f82b2a80774d

@language rest

python in leo to generate rst

Here's a fun example of rst / latex tricks.  I want (well, the report
recipients want) 16 similar figures included.  I write a little python
in an rst comment, use ``Ctrl-b`` to execute it, and then an rst ``..
include::`` directive to include its output.  Here's the rst:

.. sourcecode:: rst

  The range of each input variable which occurs within each cluster
  could be examined to assign a biological meaning to each cluster.
  Figures `Upland cluster 1 and variables`_ through
  `Wetland cluster 8 and variables`_ show the
  relationships between clusters and variables.  The maps
  give a more general view of the clusters, and
  a variable by variable interpretation of each cluster may
  not add much useful information.

  ..  python

    out = file('/home/tbrown/Desktop/Proj/AitkinMap/varvsclust.rst', 'w')
    def pnt(x): out.write(x+'\n')
    for uw in 'Upland', 'Wetland':
      for i in range(1,9):
        pnt(".. figure:: plots/%s_Cluster_%d.pdf" % (uw,i))
        pnt("   :width: 95%")
        pnt("")
        pnt("   %s cluster %d and variables" % (uw,i))
        pnt("")
    out.close()

  .. include:: varvsclust.rst

Note: The .. python is just a comment.  "Empty" comments like::

    ..
      print 40+2
      print 'done'

don't work, because empty comments don't consume indented blocks
</t>
<t tx="ekr.20101129064803.6065">http://groups.google.com/group/leo-editor/browse_thread/thread/66bcdc5cac03f5ad/0528c66838f1726d

communicating with a running Leo

@language rest

Terry Brown

For some time I've wanted a simple way to make an running leo session
load a file from the command line, like emacs-client.\

Now, thanks to Ville, I also want a way to make an running leo session
pop up a stickynote window (which would correspond to an automatically
created node which would probably use current data and time as a
headstring).

Ville

First working version of this (using qt) is now on trunk.

Testing it requires some manual work:

1. bzr pull
2. Put this script (it's a simple example client) to your leo-editor
directory: http://pastebin.com/f2bcbfd36
3. Enable leoremote.py plugin
4. Launch leo, do alt-x leoserv-start. The leo process where you last
ran leoserv-start is always the session that will receive your
commands
5. Try running the script (it's a python script, not leo script) you
created at #2 from another command prompt 

Terry

Very very cool Ville, thanks.

Here http://pastebin.com/mf678e24 is my version of a functioning
stickynote script. 

And here: http://pastebin.com/m236194c

is a quick hack at a script to edit (or create and edit) a file in leo
from the command line. 

Terry -&gt; EKR

&gt; Can you explain in more detail.  I am totally lost about why this
&gt; gives us anything new.  Thanks.

It's probably of little benefit to people who work with mouse, menus, and icons
all the time. But if you do everything from the command line (i.e. your OS's
shell), then it makes moving things into leo much smoother.

Suppose I've run leo and checked my todo items for the day, and now
leo's buried under some other window and I'm working in the shell in
some directory I've just created where I've just unzipped something and
now I want to edit a file that was in the .zip.

I can either:

  - find the leo window
  - insert a node
  - active the open file dialog
  - navigate to the directory containing this file
  - select the file
  - and finally do the editing I want to do

or, with Ville's communication to the running leo:

  - enter on the command line `led foo.txt`
  - and do the editing I want to do

where led is a script which causes the running leo to create an @edit
node containing foo.txt and pop to the front with the node selected.

Previously I was much more likely to use emacs, just because it was
easier to invoke that way from the command line.

So, opening files, creating sticky notes, invoking leo to handle output
from grep or diff or whatever - all these things are better now. 


Matt Wilkie

The corresponding point and click process for this scenario is

a) select &gt; r-click &gt; Edit with Leo
b) or drag'n'drop from folder to Leo icon on task bar (or window if visible)

In short, I see this being a productivity boost for all users. 
</t>
<t tx="ekr.20101129064803.6066">http://pastebin.com/f2bcbfd36

from leo.external import lproto
import os

addr = open(os.path.expanduser('~/.leo/leoserv_sockname')).read()
print "will connect to",addr
pc  = lproto.LProtoClient(addr)
pc.send('''

g.es("hello world from remote") 
c = g.app.commanders()[0]

''')
</t>
<t tx="ekr.20101129064803.6067">http://pastebin.com/m236194c
</t>
<t tx="ekr.20110111100539.12257">Apparently, ctrl-e is not passed to Leo at all.

This probably can't be fixed.
</t>
<t tx="ekr.20110111100539.12258">http://mail.google.com/mail/#inbox/12c5646c646a90d2

I expect C-e to go to end-of-line, but C-e works as the next line.
Alt-x and check end-of-line and I get the following result.

I use Mac OS X 10.6.5, newest Leo, and Python/Qt.

Leo 4.8 rc1, build 3715, November 15, 2010
Python 2.6.1, qt version 4.7.0
darwin

I remember I could use C-e, but it doesn't work anymore even after I
reinstall the Leo.

As I explained in this post - http://groups.google.com/group/leo-editor/browse_thread/thread/1ee0b35b4f76c999
After having @bool swap_mac_keys = True, I can use C-e.

C-a move the cursor to the start of line, but C-e seems to move the
cursor the first of the next line, which is the end of last line + 1.
If the line is the final one, C-e moves the cursor to the end of line
as there's no next line.

</t>
<t tx="ekr.20110202094848.12568">Another is named marks, in Vim you can store a number of cursor
locations, and recall them to jump around in your code.  This was also
useful in filling out templates as each stop could be given a name
mark.  This helped make filling out a template easier as you weren't
stuck in a linear filling in the blanks in a set order, template stops
where linked in rings, you could jump from the last stop back to the
first and make and changes you wanted on a second go round.  Gravity
of marks made things easier to inspect to determine what stops where
used and which ones were being bypassed.

As these things had an actual presence in the text buffer, it going to
be a little harder to come up with a reasonable work around.
</t>
<t tx="ekr.20110419083918.6104">@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in &lt;edge&gt; elements if that
would be preferable.

Recent changes
==============

- Added &lt;graphml&gt; element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed &lt;leo_file&gt; to &lt;leo:outline&gt;
    - Renamed &lt;descendant-attributes&gt; to &lt;leo:at-file-attributes&gt;

- Used &lt;leo:at-file-attributes&gt; for marks, removing the special case.

- Enclosed &lt;leo:descendant-attributes&gt; in a (graphml) &lt;data&gt; element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"/&gt;
        

No session data
===============

There will be no &lt;globals&gt;, &lt;preferences&gt; or
&lt;find_panel_settings&gt; elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within &lt;node&gt; elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"/&gt;
    &lt;graph&gt;
    &lt;nodes&gt;
        &lt;!-- marked attribute appears only if the vnode is marked --&gt;
        &lt;node id="gnx"&gt; 
            &lt;head&gt;headline text&lt;/head&gt;
            &lt;attr key="marked"&gt;1&lt;/attr&gt;
            &lt;!-- uA's... --&gt;
            &lt;!-- format="string" is the default --&gt;
            &lt;attr key="a"&gt;a string&lt;/attr&gt;
            &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
            &lt;attr key="c" format="pickle"&gt;a pickled string&lt;/attr&gt;
            &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
            ...
            &lt;body&gt;body text&lt;/body&gt;
        &lt;/node&gt;
        ...
        &lt;!-- @file nodes contain a &lt;data&gt; package --&gt;
        &lt;node id="gnx"&gt;
            &lt;head&gt;@file x.py&lt;/head&gt;
            ...
            &lt;data&gt;
                &lt;leo:at-file-attributes&gt;
                    &lt;attr&gt;key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx"&gt;value
                    &lt;/attr&gt;
                    ...
                &lt;/leo:at-file-attributes&gt;
            &lt;/data&gt;
        &lt;/node&gt;
        ...
    &lt;/nodes&gt;
    &lt;edges&gt;
        &lt;edge type="child" from="gnx" to="gnx"&lt;/edge&gt;
        ...
    &lt;/edges&gt;
    &lt;/graph&gt;
    &lt;/graphml&gt;
    &lt;/leo:outline&gt;

&lt;attr&gt; elements
===============

&lt;attr&gt; elements will one of the following forms::

    &lt;attr key="a"&gt;a unicode string&lt;/attr&gt;
    &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
    &lt;attr key="c" format="pickle"&gt;a json string&lt;/attr&gt;
    &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No &lt;attr&gt; element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

&lt;edge&gt; elements
===============

&lt;edge&gt; elements will have the form::

    &lt;edge type="child" from="gnx" to="gnx"/&gt;
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    &lt;edge type="undirected" from="gnx" to="gnx"/&gt;
    &lt;edge type="bidirectional" from="gnx" to="gnx"/&gt;
    &lt;edge type="backlink" from="gnx" to="gnx"/&gt;
    &lt;edge type="myPlugin" from="gnx" to="gnx"/&gt;
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The &lt;leo:at-file-attributes&gt; element may be contained in the
&lt;node&gt; element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    &lt;data&gt;
        &lt;leo:at-file-attributes&gt;
            &lt;attr&gt;key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx"&gt;value
            &lt;/attr&gt;
            ...
        &lt;/leo:at-file-attributes&gt;
    &lt;/data&gt;
    
In other words, we use the graphml &lt;attr&gt; element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
</t>
<t tx="ekr.20110421132230.6107">@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in &lt;attr&gt; elements (and "type" in &lt;edge&gt; elements.)

First lines
===========

Leo file will start with the following::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
        

No session data
===============

There will be no &lt;globals&gt;, &lt;preferences&gt; or
&lt;find_panel_settings&gt; elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within &lt;node&gt; elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graph&gt;
    &lt;nodes&gt;
        &lt;!-- marked attribute appears only if the vnode is marked --&gt;
        &lt;node id="gnx"&gt; 
            &lt;head&gt;headline text&lt;/head&gt;
            &lt;attr key="marked"&gt;1&lt;/attr&gt;
            &lt;!-- uA's... --&gt;
            &lt;!-- format="string" is the default --&gt;
            &lt;attr key="a"&gt;a string&lt;/attr&gt;
            &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
            &lt;attr key="c" format="pickle"&gt;a pickled string&lt;/attr&gt;
            &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
            ...
            &lt;body&gt;body text&lt;/body&gt;
        &lt;/node&gt;
        ...
        &lt;!-- @file nodes contain a &lt;data&gt; package --&gt;
        &lt;node id="gnx"&gt;
            &lt;head&gt;@file x.py&lt;/head&gt;
            ...
            &lt;at-file-attributes&gt;
                &lt;attr&gt;key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx"&gt;value
                &lt;/attr&gt;
                ...
            &lt;/at-file-attributes&gt;
        &lt;/node&gt;
        ...
    &lt;/nodes&gt;
    &lt;edges&gt;
        &lt;edge type="child" from="gnx" to="gnx"&lt;/edge&gt;
        ...
    &lt;/edges&gt;
    &lt;/graph&gt;
    &lt;/leo_file&gt;

&lt;attr&gt; elements
===============

&lt;attr&gt; elements will one of the following forms::

    &lt;attr key="a"&gt;a unicode string&lt;/attr&gt;
    &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
    &lt;attr key="c" format="pickle"&gt;a json string&lt;/attr&gt;
    &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No &lt;attr&gt; element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

&lt;edge&gt; elements
===============

&lt;edge&gt; elements will have the form::

    &lt;edge type="child" from="gnx" to="gnx"/&gt;
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    &lt;edge type="undirected" from="gnx" to="gnx"/&gt;
    &lt;edge type="bidirectional" from="gnx" to="gnx"/&gt;
    &lt;edge type="backlink" from="gnx" to="gnx"/&gt;
    &lt;edge type="myPlugin" from="gnx" to="gnx"/&gt;
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The &lt;at-file-attributes&gt; element may be contained in the
&lt;node&gt; element for @file nodes::

    &lt;at-file-attributes&gt;
        &lt;attr&gt;key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx"&gt;value
        &lt;/attr&gt;
        ...
    &lt;/at-file-attributes&gt;
    
In other words, we use the graphml &lt;attr&gt; element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
</t>
<t tx="ekr.20110520051220.18203">@language rest

This would be a substitute for cross-file clones.
</t>
<t tx="ekr.20110521135104.18151">Cross-file clones are cloned nodes in one outline that refer to data in another
outline. This is a frequently requested feature. For example::

    I would absolutely love to have the leo files in different project
    directories, and a "master" leo file to rule them all.

However, cross-file clones will never be a part of Leo. Indeed, cross-file
clones would violate the principle that data should be defined and managed in
exactly one place. Just as human managers would not willingly accept shared
responsibility for even a single line of code, every piece of Leonine data
should be the responsibility of one and *only* one .leo file.

The problem fundamental. If the *same* (cloned) data were "owned" by two
different Leo files we would have a classic "multiple update problem" for the
data. Each outline could change the data in incompatible ways, and whichever
outline changed the data last would "win."

To make such a scheme workable and safe, one would have to devise a scheme that
would keep the data in "component" .leo files consistent even when the component
.leo files changed "randomly", without the "master" .leo file being in *any* way
in "control" of the changes. Good luck :-)

Let us be clear: it's no good having a scheme that works *most* of the time, it
must work *all* the time, even with unexpected or even pathological file
updates. If it doesn't you are asking for, and will eventually get, catastrophic
data loss, without being aware of the loss for an arbitrarily long period of
time. Even with a source code control system this would be an intolerable
situation.
</t>
<t tx="ekr.20110527084258.18374">http://groups.google.com/group/leo-editor/browse_thread/thread/9b1dbebd56d50e14/d5a690127ddad38e
 
"Sprint" isn't really the correct term.  We wrote no code.  Instead,
we discussed what seemed to each of us as the most important
directions for Leo.

After much pleasant discussion, we reached agreement, dreaded or not,
on just about everything. I'll summarize the topics here, and
elaborate about file format issues in a separate thread.

1.  (Done) Make .leo files as standards-compliant as possible.

This will demonstrate to newbies that we have some sophistication re
web standards, and it will allow external tools to handle .leo files
in the easiest possible way.

I've delegated the design of this project to Kent.  I'll be in charge
of implementation.

2. Simplify and revise Leo's file format.

Details in a separate thread: some items deserve just a bit more
discussion.  In particular, we want the about-to-be-renamed &lt;t&gt;
elements to contain headline text so that &lt;t&gt; elements represent key/
value pairs directly.  The question is, should the about-to-be-renamed
&lt;v&gt; elements contain headline text (readable, but "denormalized")?

3. Support reading and writing Leo outlines in JSON format.

This will allow closer cooperation with databases and other tools.
I'll do this.

4. Complete the transition to Terry's free_layout plugin.

A. Place separate body editors in free_layout areas.  This should
*easy* to do!  Almost nothing changes in the code, but the visual
effect should be much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane)
and "untabified."  There are a few details to be handled, but nothing
major.

Terry and I will collaborate on this.

5. Add global search to the quicksearch plugin and to Leo's find
command.

6. (Abandoned) Add node-specific undo asap.

The present undo is almost useless after a few levels.  Node-specific
undo would be much more useful. This has been on the list forever.  It
should be done yesterday.

7.  Rejected direct support for .ini files instead of Leo's @settings
nodes.

After some discussion we decided that the present .ini importer should
suffice.  In other words, it seems like a bad idea to support .ini
settings *instead* of, or in *addition* to, .ini files.  However,
scripts or commands to import/export Leo settings to one or more .ini
files would be fine.

8.  (done) Make uA's first class citizens.

There should be commands to get and set uA's.  This is easy to do:
it's just an oversight.

Summary
=======

Looking back on the discussions, I am struck once again by how minor
the suggestions are.  Most of these items can be done in a day or two,
or a week or two at most.  The conclusion is that Leo has reached a
mature state.

Kent, Terry, did I omit anything?  Misstate anything? 
</t>
<t tx="ekr.20110527084258.18378">@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- &lt;attr&gt; solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the &lt;v&gt; elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

</t>
<t tx="ekr.20110528034751.18272">Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
</t>
<t tx="ekr.20110529104352.18248"></t>
<t tx="ekr.20110529104352.18249"></t>
<t tx="ekr.20110529115328.18238">I'll do these if and and only if somebody asks for them.
</t>
<t tx="ekr.20110529115328.18247">Having worked with Tk text canvases more that Qt, there still seem to
be things that it had that have to be worked around as the Qt people
just haven't seen the need for.

One is the block cursor, I giving Leo Vim like functionality, it would
be nice if one where supported, theses new kids just don't understand
something so primitive I guess.
</t>
<t tx="ekr.20110531155858.19246">Leo 4.9 final              June 21, 2011

Leo 4.9 final is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
See: http://leoeditor.com/tutorial.html

The highlights of Leo 4.9:
--------------------------

- The Qt gui completely replaces the Tk gui--Qt gui now has all essential
  features of Tk, including plugins.

- Completed Leo's autocompleter.

- The rendering pane can now display movies, html, svg images, etc.

- Nodes may contain multiple @language directives.

- Leo highlights URL's everywhere. Ctrl-click URL's opens them in your web
  browser. 

- Leo uses an @file node's extension by default if there is no @language
  directive in effect.
  
- Unified extract and import commands.

- Leo can now colorize multiple @language directives in a single node.

- Plain up/down arrow keys in headline-editing mode select a new node.

- New commands to insert, delete, change or print uA's.

- Added namespace directive to .leo files.

- Fixed many bugs, some important, most quite minor.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20110531155858.19830"></t>
<t tx="ekr.20110531155858.20246"></t>
<t tx="ekr.20110531155858.20559">.. _`This FAQ entry`: FAQ.html#how-can-i-use-leo-to-develop-leo-itself

Here is the workflow I use to develop Leo. The intention is to help
present and potential developers use Leo effectively.

Overview:

- Develop in an outline containing all of Leo's source files. Close this outline
  rarely: this keeps the code I am using stable while I'm hacking the code.

- Test in a *separate* .leo file, say test.leo. In fact, I often test in a
  private file, ekr.leo, so that test.leo doesn't get continually updated on git
  with trivial changes.

These two points are covered in a bit more detail in `This FAQ entry`_.

Additional tips:

A. Avoid using the mouse whenever possible. For example, use alt-tab to switch
between windows.

B. Always develop Leo in a console. This allows you to see the output of g.trace.

Speaking of g.trace, I hardly ever use 'print' because g.trace prints the name
of the function or method in which it appears. The typical pattern for enabling
traces is::

    trace = True and not g.unitTesting
    if trace: g.trace(whatever)

This pattern is especially useful when a method contains multiple calls to
g.trace.

C. I use scripts to open particular Leo files. These are batch files on Windows,
   and aliases on Linux, but invoking them is the same on either platform::

    all:     opens all my main development files using the qt-tabs gui.
    t:       opens test.leo.
    e:       opens ekr.leo.  I use this file for private testing.
    d:       opens LeoDocs.leo.
    s:       opens LeoPy.leo.
    plugins: opens leoPlugins.leo.
    gui:     opens leoGui.leo.
    u:       opens unitTest.leo.

  These run Leo with Python 3.x. There are similar scripts, ending in 2, that run
  Leo with Python 2.x. For example, u2 opens unitTest.leo with Python 2.x.
  Thus, to run a test, I alt-tab to an available console window, then type 'e' or
  't' or 'u' or, if I want Python 2.x, 'e2' or 't2' or 'u2'.

D. Use clones to focus attention on the task at hand.
   For more details, see the tutorial's introduction to `clones`_.

E. For thousand of example of my programming style, see leoPy.leo and
   leoGuiPlugins.leo. The projects section in leoPy.leo contains many examples
   of using clones to create view nodes. I typically delete the clones in the
   views shortly before a release.

Writing documentation:

- Use postings as pre-writing for documentation.

  I don't mind blabbing on and on about Leo because all my posts become
  pre-writing for Leo's documentation. I simply copy posts to nodes in the
  "documentation to-do" section. At release time, I edit these nodes and put
  them in Leo's main documentation or the release notes. This posting is an
  example.
  
- Use the vr command to debug reStructuredText documentation. The viewrendered
   pane updates as you type. This makes Leo a killer app for rST.
   
Administrative tips:

- Never rely on memory.

   A project like this contains thousands and thousands of details. Everything
   eventually goes into a Leo node somewhere. If it doesn't it surely *will* be
   forgotten.

- Do easy items first.
   
   This keeps to-do lists short, which keeps energy high.

Tips for using git:

I use the following batch files related to bzr::

    g:      short for git
    gs:     short for bzr status
    tr:     short for cd &lt;path to trunk&gt;
    main:   short for cd &lt;path to copy of trunk&gt;

The "main" (copy) of the trunk is purely for handling git conflicts.
If one happens I do this::

    main
    g pull
    g merge ../trunk
    g c -m "my commit message"
    g push

If the merge goes well (it usually does), I do this to resolve the conflict::

    tr
    g pull
</t>
<t tx="ekr.20110531155858.20563">The following script will create a minimal Leo outline::

    if 1:
        # Create a visible frame.
        c2 = g.app.newCommander(fileName=None)
    else:
        # Create an invisible frame.
        c2 = g.app.newCommander(fileName=None,gui=g.app.nullGui)

    c2.frame.createFirstTreeNode()
    c2.redraw()
    
    # Test that the script works.
    for p in c2.all_positions():
        g.es(p.h)
</t>
<t tx="ekr.20110531155858.20564">You set most colors in the following settings node::

    @data qt-gui-plugin-style-sheet
    
However, settings for colors that can change during Leo's execution
are found in the node::

    Body pane colors
    
These settings are as follows, with the defaults as shown::
    

    \@color body_cursor_background_color = None
    \@color body_cursor_foreground_color = None
    \@color body_insertion_cursor_color = None
    \@color body_text_background_color = None
    \@color body_text_foreground_color = None
    \@color command_mode_bg_color = #f2fdff&lt;/vh&gt;&lt;/v&gt;
    \@color command_mode_fg_color = None&lt;/vh&gt;&lt;/v&gt;
    \@color insert_mode_bg_color = #fdf5f5&lt;/vh&gt;&lt;/v&gt;
    \@color insert_mode_fg_color = black&lt;/vh&gt;&lt;/v&gt;
    \@color overwrite_mode_bg_color = azure2&lt;/vh&gt;&lt;/v&gt;
    \@color overwrite_mode_fg_color = black&lt;/vh&gt;&lt;/v&gt;
    \@color unselected_body_bg_color = #ffffef&lt;/vh&gt;&lt;/v&gt;
    \@color unselected_body_fg_color = black&lt;/vh&gt;&lt;/v&gt;
</t>
<t tx="ekr.20110601105631.19349">@language rest

</t>
<t tx="ekr.20110601105631.19359">- Leo no longer supports the Tk gui. The Qt gui now does everything
  the Tk gui did, and more, and better.

- Removed show/hide/toggle minibuffer commands. The minibuffer is an essential
  part of Leo.
  
- These settings are no longer used::
    
    @string selected-background-color
    @string selected-command-background-color
    
- The import-at-root command is no longer supported.
</t>
<t tx="ekr.20110601105631.19360">- Fixed an important bug involving orphan nodes. Leo now never saves an external
  file containing orphan nodes. This ensures that all the information in the
  external file will, in fact, be saved in the .leo file.

- Almost 40 minor bugs have been fixed. For details, see the release notes.

- Fixed mod_http plugin
  
</t>
<t tx="ekr.20110601105631.19434"></t>
<t tx="ekr.20110601105631.19435">- Support multiple @language directives in a single node
  As with @color directives, only unambiguous @language directives affect the
  default coloring of descendant nodes.

- Colorize url's in the body text. You can open url's by control-clicking on
  them, or by using the open-url command.

- Added support for cython colorizing

- Leo ignores (and does not color) @language directive for unknown languages.

- Leo completely recolors nodes when you change @language directives by typing.
</t>
<t tx="ekr.20110601105631.19441">- If you type a *plain* up/down arrow key while editing a headline, Leo will act
  as if you had typed the corresponding *alt*- arrow key. That is, Leo will end
  editing of the headline and go to the next previous node. Leo will end editing
  even if there is no next/ previous node, which is convenient.

- A single click on an already-selected tree node edits the headline

  Enabled only if @bool single_click_auto_edits_headline = True.

- Added a splash screen

  The --no-splash command-line option suppresses the splash screen. In addition,
  Leo puts up no splash screen when the --silent or --script command-line
  options are given. To change the splash screen, replace
  leo\Icons\SplashScreen.jpg with another image.

- The apropos commands now print in a separate area if possible. The commands use
  the scrolledmessage plugin if possible, which in turn uses the viewrendered
  plugin by default. This makes the apropos messages much more visible.

- Handle click events like alt-x or ctrl-g Clicking in the minibuffer now is
  equivalent to alt-x, provided that the minibuffer is not in use. Clicking most
  places outside the minibuffer is equivalent to ctrl-g. Catching clicks is much
  safer than catching focus events.

- The first loaded file sets tabbed gui size

- Enter insert mode after ctrl-h.  This is a vim-related improvement.

- Disabled find/change text areas in find panel.  This reduces confusion.
</t>
<t tx="ekr.20110601105631.19463">- Added the replace-current-character command. It replaces the character to the
  left of the cursor, or replaces the selection range if there is one.

- Added toggle-case-region command.

- Added save-all command. It saves all changed windows.

- Added insert-hard/soft-tab commands.

- Added commands to manage uA's::

    clear-all-uas
    clear-node-uas
    print-all-uas
    print-node-uas
    set-ua
    
- Renamed the 'abbrev-mode' to 'toggle-abbrev-mode'.
</t>
<t tx="ekr.20110601105631.19464">- Added namespace and Leo comment lines to .leo files

- Leo opens leoSettings.leo only once

- Fixed Bug 745824: @doc duplicates comment delims in html files
  https://bugs.launchpad.net/leo-editor/+bug/745824e
  
- Leo no longer wraps @doc lines. This ensures that Leo does not change files
  unnecessarily.
</t>
<t tx="ekr.20110601105631.19473">.. _`Runwith class`: http://groups.google.com/group/leo-editor/browse_thread/thread/b8e8fbf6d97fa9f2/a4537fafaf2442ba

- Added namespace arg in c.executeScript

- Put Kent Tenney's `Runwith class`_ in scripts.leo and contrib.

  Kent writes, "I've had endless problems with interpreter versioning, leading
  me create the Runwith class. It writes a file to disk, makes it executable,
  runs it, captures exitcode, err and output, removes the files, provides
  reports. This provides complete decoupling from Leo."

- Call os.chdir when executing scripts.
</t>
<t tx="ekr.20110601105631.19480">- The --no-splash command-line option suppresses the splash screen.
  Leo puts up no splash screen when the --silent
  or --script command-line options are given.

- Added @bool view-rendered-auto-create setting.
    
- Added @bool use_qcompleter setting.

- Added auto_tab_complete setting.

- Removed @bool use_codewise setting.

- You now may set icon button colors in the Qt stylesheet.

</t>
<t tx="ekr.20110601105631.19481">- Support multiple @language directives in a single node
  As with @color directives, only unambiguous @language directives affect the
  default coloring of descendant nodes.

- Colorize url's in the body text. You can open url's by control-clicking on
  them, or by using the open-url command.

- Use @file extension by default if there is no @language directive in effect.
  This is oh so useful.

- Unified extract commands.  This command creates a child node from the selected
  body text as follows:
    
    1. If the selection starts with a section reference, the section name become the
       child's headline. All following lines become the child's body text. The
       section reference line remains in the original body text.
       
    2. If the selection looks like a Python class or definition line, the
       class/function/method name becomes child's headline and all selected lines
       become the child's body text.
       
    3. Otherwise, the first line becomes the child's headline, and all selected
       lines become the child's body text.

    Note that the extract-section-names command remains.
    The extract-section and extract-python-method commands are gone.

- The import-file commands replaces all the following commands::
    
    import-at-file                    
    import-cweb-files         
    import-derived-file       
    import-flattened-outline      
    import-noweb-files
    
  Leo chooses one of the above commands as follows.  First, if the file looks
  like an external file that Leo wrote, the command works like
  import-derived-file command.  Otherwise, the file's extension determines the
  importer::
        
        .cw, .cweb:     import-cweb-files
        .nw, .noweb:    import-noweb-files
        .txt:           import-flattened-outline
        all others:     import-at-file
    
  The import-at-root command is no longer supported.
</t>
<t tx="ekr.20110601105631.19482">- Improved the clone-find-all command. The descendants of previously found
  (cloned) nodes don't get added again. The clone-find-all pattern now defaults
  to find text.

- Improved the forward and backward by sentences commands Leo's sentence related
  functions now stop at empty lines, skip periods within words, stop at
  sentences ending in non-periods and stop at the end or beginning of the
  buffer.

- Improved the print-bindings command; it now shows were bindings came from.

- Improved the reformat-paragraph command. The command detects paragraphs more
  reliably. The next line is now visible, which is a big improvement.

- Added patch to g.wrap_lines from José Rojas Echenique
  It regularizes the number of spaces after periods.

- Improved expansion of abbreviations. Abbreviations are checked any time a
  non-word character is typed. In particular, newlines trigger abbreviations,
  which I find very helpful, although I did then have to remove newlines from my
  abbreviations. Control sequences do not trigger expansions.

- Improved handling of @url nodes. The new rule is simple: if the body text
  contains any text the first line of the body text is taken to be the url.
  There is no longer any need to put '--' in the headline. More importantly, you
  can put anything you like in the body text following the first line. Other
  url's, notes, even .. graphics:: directives for the viewrendered plugin.

- Improved the clean-all-lines command. It is now much faster and has better
  feedback.
</t>
<t tx="ekr.20110601105631.19484">- Leo no longer supports the Tk gui. The Qt gui now does everything
  the Tk gui did and better.

- Removed show/hide/toggle minibuffer commands. The minibuffer is an essential
  part of Leo.
  
- These settings are no longer used::
    
    @string selected-background-color
    @string selected-command-background-color
    
- The import-at-root command is no longer supported.
</t>
<t tx="ekr.20110602091552.16898">The viewrendered plugin creates a window for *live* rendering of images, movies,
sounds, rst, html, etc. 

Commands
========

viewrendered.py creates the following (``Alt-X``) commands:

``viewrendered (abbreviated vr)``
    Opens a new rendering window.
    
    By default, the rendering pane renders body text as reStructuredText, with
    all Leo directives removed. However, if the body text starts with ``&lt;``
    (after removing directives), the body text is rendered as html.
    
    **Important**: The default rendering just described does not apply to nodes
    whose headlines begin with @image, @html, @movie, @networkx, @svg and @url.
    See the section called **Special Renderings** below.

    Rendering sets the process current directory (os.chdir()) to the path
    to the node being rendered, to allow relative paths to work in ``.. image::`` directives.

``hide-rendering-pane``
    Makes the rendering pane invisible, but does not destroy it.

``lock-unlock-rendering-pane``
    Toggles the locked state of the rendering pane. When unlocked (the initial
    state), the rendering pane renders the contents of the presently selected
    node. When locked, the rendering pane does not change when other nodes are
    selected. This is useful for playing movies in the rendering pane.
    
``pause-play-movie``
    This command has effect only if the rendering pane is presently showing a movie.
    It pauses the movie if playing, or resumes the movie if paused.

``show-rendering-pane``
    Makes the rendering pane visible.

``toggle-rendering-pane``
    Shows the rendering pane if invisible, otherwise hides it.
    
``update-rendering-pane``
    Forces an update of the rendering pane. This is especially useful for
    @graphics-script nodes: such nodes are update automatically only when
    selected, not when the body text changes.
    
Rendering reStructuredText
==========================

For example, both::

    Heading
    -------

    `This` is **really** a line of text.

and::

    &lt;h1&gt;Heading&lt;h1&gt;

    &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text.

will look something like:

    **Heading**

    `This` is **really** a line of text.
    
**Important**: reStructuredText errors and warnings will appear in red in the rendering pane.

Special renderings
===================

This plugin renders @image, @html, @movie, @networkx, @svg and @url nodes in
special ways.

For @image, @movie and @svg nodes, either the headline or the first line of body
text may contain a filename.  If relative, the filename is resolved relative to
Leo's load directory. 

- ``@graphics-script`` executes the script in the body text in a context containing
  two predefined variables:
      
    - gs is the QGraphicsScene for the rendering pane.
    - gv is the QGraphicsView for the rendering pane.
    
  Using these variables, the script in the body text may create graphics to the
  rendering pane.

- ``@image`` renders the file as an image.


- ``@html`` renders the body text as html.


- ``@movie`` plays the file as a movie.  @movie also works for music files.

- ``@networkx`` is non-functional at present.  It is intended to
  render the body text as a networkx graph.
  See http://networkx.lanl.gov/


- ``@svg`` renders the file as a (possibly animated!) svg (Scalable Vector Image).
  See http://en.wikipedia.org/wiki/Scalable_Vector_Graphics
  **Note**: if the first character of the body text is ``&lt;`` after removing Leo directives,
  the contents of body pane is taken to be an svg image.

- ``@url`` is non-functional at present.

Settings
========

- ``@color rendering-pane-background-color = white``
  The background color the rendering pane when rendering text.

- ``@bool view-rendered-auto-create = False``
  When True, show the rendering pane when Leo opens an outline.
  
- ``@bool view-rendered-auto-hide = False``
  When True, hide the rendering pane for text-only renderings.

- ``@string view-rendered-default-kind = rst``
  The default kind of rendering.  One of (big,rst,html)

- ``@bool scrolledmessage_use_viewrendered = True``
  When True the scrolledmessage dialog will use the rendering pane,
  creating it as needed.  In particular, the plugins_menu plugin
  will show plugin docstrings in the rendering pane.
  
Acknowledgment
==============

Terry Brown created this initial version of this plugin,
and the free_layout and NestedSplitter plugins used by viewrendered.
</t>
<t tx="ekr.20110602091552.16899">Terminology: the *legacy* (aka tabbed) autocompleter shows completions in Leo's
tabbed pane. The *new* (aka qcompleter) autocompleter shows completions in or
near the body pane.

Appearance
==========

There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the user
types a backspace the legacy completer now simply deletes a single character
instead of the highlighted text.

One minor change: the legacy completer now *does* insert characters that do
not match the start of any possible completion. This is an experimental feature,
but it might play well with using codewise completions as a fallback to
leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the same way, because they
both use the AutoCompleterClass to compute the list of completions.

The strict "stateless" requirement means that the "intermediate" completions
must be entered into the body pane while completion is active. It works well as
a visual cue when using the tabbed completer: indeed, the tabbed completer would
be difficult to use without this cue.

The situation is slightly different with the qcompleter. Adding code before the
user accepts the completion might be considered an "advanced" feature. However,
it does have two important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it limits what must appear
in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In large part,
this is due to adding the global "self." completions to all class-related
completions (kind == 'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the ContextSniffer class.

Performance
===========

Performance of leo-related completions is *much* better than before. The old
code used Python's inspect module and was horribly complex. The new code uses
eval and is perfectly straightforward.

The present codewise-related code caches completions for all previously-seen
prefixes. This dramatically speeds up backspacing. Global caching is possible
because completions depend *only* one the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions would depend on the
selected node and caching would likely be impractical. Despite these
improvements, the performance of codewise-oriented completions is noticeably
slower than leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it finds a cached prefix.
ac.compute_completion_list then uses this (perhaps-way-too-long-list) as a
starting point, and computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do "prefix AI" based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options lists,
regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to get_completions replace
calls to g.itemsMatchingPrefixInList. However, for short prefixes, the list that
g.g.itemsMatchingPrefixInList scans can have thousands of items. Scanning large
lists can't be helped in any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the completionDict does
*not* define state (it is valid everywhere) and no state variables had to be
added. In short, the new caching scheme is much better than before, and it
probably is close to optimal in most situations.
</t>
<t tx="ekr.20110602091552.16903">- Leo highlights URL's everywhere. Ctrl-click URL's opens them in your web
  browser.
  
- Nodes may contain multiple @language directives.

- Use @file extension by default if there is no @language directive in effect.
  This is oh so useful.

- Unified extract commands.  This command creates a child node from the selected
  body text as follows:
    
    1. If the selection starts with a section reference, the section name become the
       child's headline. All following lines become the child's body text. The
       section reference line remains in the original body text.
       
    2. If the selection looks like a Python class or definition line, the
       class/function/method name becomes child's headline and all selected lines
       become the child's body text.
       
    3. Otherwise, the first line becomes the child's headline, and all selected
       lines become the child's body text.

    Note that the extract-section-names command remains.
    The extract-section and extract-python-method commands are gone.

- The import-file commands replaces all the following commands::
    
    import-at-file                    
    import-cweb-files         
    import-derived-file       
    import-flattened-outline      
    import-noweb-files
    
  Leo chooses one of the above commands as follows.  First, if the file looks
  like an external file that Leo wrote, the command works like
  import-derived-file command.  Otherwise, the file's extension determines the
  importer::
        
        .cw, .cweb:     import-cweb-files
        .nw, .noweb:    import-noweb-files
        .txt:           import-flattened-outline
        all others:     import-at-file
    
  The import-at-root command is no longer supported.
</t>
<t tx="ekr.20110602091552.16904">Terminology: the *legacy* (aka tabbed) autocompleter shows completions in Leo's
tabbed pane. The *new* (aka qcompleter) autocompleter shows completions in or
near the body pane.

Appearance
==========

There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the user
types a backspace the legacy completer now simply deletes a single character
instead of the highlighted text.

One minor change: the legacy completer now *does* insert characters that do
not match the start of any possible completion. This is an experimental feature,
but it might play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the same way, because they
both use the AutoCompleterClass to compute the list of completions.

The strict "stateless" requirement means that the "intermediate" completions
must be entered into the body pane while completion is active. It works well as
a visual cue when using the tabbed completer: indeed, the tabbed completer would
be difficult to use without this cue.

The situation is slightly different with the qcompleter. Adding code before the
user accepts the completion might be considered an "advanced" feature. However,
it does have two important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it limits what must appear
in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In large part,
this is due to adding the global "self." completions to all class-related
completions (kind == 'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than before. The old
code used Python's inspect module and was horribly complex. The new code uses
eval and is perfectly straightforward.

The present codewise-related code caches completions for all previously-seen
prefixes. This dramatically speeds up backspacing. Global caching is possible
because completions depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions would depend on the
selected node and caching would likely be impractical. Despite these
improvements, the performance of codewise-oriented completions is noticeably
slower than Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it finds a cached prefix.
ac.compute_completion_list then uses this (perhaps-way-too-long-list) as a
starting point, and computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do "prefix AI" based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options lists,
regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to get_completions replace
calls to g.itemsMatchingPrefixInList. However, for short prefixes, the list that
g.g.itemsMatchingPrefixInList scans can have thousands of items. Scanning large
lists can't be helped in any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the completionDict does
*not* define state (it is valid everywhere) and no state variables had to be
added. In short, the new caching scheme is much better than before, and it
probably is close to optimal in most situations.

</t>
<t tx="ekr.20110602091552.16905"></t>
<t tx="ekr.20110602091552.16907">- Support multiple @language directives in a single node
  As with @color directives, only unambiguous @language directives affect the
  default coloring of descendant nodes.

- Colorize url's in the body text. You can open url's by control-clicking on
  them, or by using the open-url command.

- Added support for cython colorizing.

- Leo ignores (and does not color) @language directive for unknown languages.

- Leo completely recolors nodes when you change @language directives by typing.
</t>
<t tx="ekr.20110602091552.16909">- The --no-splash command-line option suppresses the splash screen.
  Leo puts up no splash screen when the --silent
  or --script command-line options are given.

- Added @bool view-rendered-auto-create setting.
    
- Added @bool use_qcompleter setting.

- Added @bool auto_tab_complete setting.

- Added @bool single_click_auto_edits_headline setting.

- Removed @bool use_codewise setting.

- You now may set icon button colors in the Qt stylesheet.
</t>
<t tx="ekr.20110602091552.16911">- Added namespace and Leo comment lines to .leo files

- Leo opens leoSettings.leo only once

- Fixed Bug 745824: @doc duplicates comment delims in html files
  https://bugs.launchpad.net/leo-editor/+bug/745824e
  
- Leo no longer wraps @doc lines. This ensures that Leo does not change files
  unnecessarily.
</t>
<t tx="ekr.20110602091552.16913">- If you type a *plain* up/down arrow key while editing a headline, Leo will act
  as if you had typed the corresponding *alt*- arrow key. That is, Leo will end
  editing of the headline and go to the next previous node. Leo will end editing
  even if there is no next/ previous node, which is convenient.

- A single click on an already-selected tree node edits the headline
  Enabled only if @bool single_click_auto_edits_headline = True.

- Added a splash screen

  The --no-splash command-line option suppresses the splash screen. In addition,
  Leo puts up no splash screen when the --silent or --script command-line
  options are given. To change the splash screen, replace
  leo\Icons\SplashScreen.jpg with another image.

- The apropos commands now print in a separate area if possible. The commands
  use the viewrendered plugin by default. This makes the apropos messages much
  more visible.

- Handle click events like alt-x or ctrl-g Clicking in the minibuffer now is
  equivalent to alt-x, provided that the minibuffer is not in use. Clicking most
  places outside the minibuffer is equivalent to ctrl-g. Catching clicks is much
  safer than catching focus events.

- The first loaded file sets tabbed gui size

- Enter insert mode after ctrl-h.  This is a vim-related improvement.

- Disabled find/change text areas in find panel.  This is less confusing.
</t>
<t tx="ekr.20110602091552.16915">- Improved the clone-find-all command. The descendants of previously found
  (cloned) nodes don't get added again. The clone-find-all pattern now defaults
  to find text.

- Improved the forward and backward by sentences commands Leo's sentence related
  functions now stop at empty lines, skip periods within words, stop at
  sentences ending in non-periods and stop at the end or beginning of the
  buffer.

- Improved the print-bindings command; it now shows were bindings came from.

- Improved the reformat-paragraph command. The command detects paragraphs more
  reliably. The next line is now visible, which is a big improvement.

- Added patch to g.wrap_lines from José Rojas Echenique
  It regularizes the number of spaces after periods.

- Improved expansion of abbreviations. Abbreviations are checked any time a
  non-word character is typed. In particular, newlines trigger abbreviations,
  which I find very helpful, although I did then have to remove newlines from my
  abbreviations. Control sequences do not trigger expansions.

- Improved handling of @url nodes. The new rule is simple: if the body text
  contains any text the first line of the body text is taken to be the url.
  There is no longer any need to put '--' in the headline. More importantly, you
  can put anything you like in the body text following the first line. Other
  url's, notes, even .. graphics:: directives for the viewrendered plugin.

- Improved the clean-all-lines command. It is now much faster and has better
  feedback.
</t>
<t tx="ekr.20110602091552.16917">.. _`Runwith class`: http://groups.google.com/group/leo-editor/browse_thread/thread/b8e8fbf6d97fa9f2/a4537fafaf2442ba

- Added namespace arg in c.executeScript

- Put Kent Tenney's `Runwith class`_ in scripts.leo and contrib.

  Kent writes, "I've had endless problems with interpreter versioning, leading
  me create the Runwith class. It writes a file to disk, makes it executable,
  runs it, captures exitcode, err and output, removes the files, provides
  reports. This provides complete decoupling from Leo."

- Call os.chdir when executing scripts.
</t>
<t tx="ekr.20110604043410.17808">- Double-clicking a headline now colorizers the headline exactly the same way as
  when editing the headline with ctrl-H. This was a serious problem for those
  with dark window-color schemes.
  
- The distribution script now ensures that leo\plugins\spellpyx.txt contains
  Linux-style newlines. This prevents crashes in the PyEnchant spell checker.
  
- Leo imports .cfg files just like .ini files.

- Fixed crasher in graphcanvas plugin caused by a bug in CommandChainDispatcher.add.
</t>
<t tx="ekr.20110604043410.17811">- Fixed bug 682561: pyenchant install problem.

  https://bugs.launchpad.net/leo-editor/+bug/682561

- Fix bug 690260: g.es sends to wrong tabbed pane.

  https://bugs.launchpad.net/leo-editor/+bug/690260

- Fixed bug 783617: Can't enter text directly in the Find panel

  https://bugs.launchpad.net/leo-editor/+bug/783617

- Fixed bug 681797: Shift-Delete not working in Qt

  https://bugs.launchpad.net/leo-editor/+bug/681797

- Fixed bug 622819: Ctrl-Shift movement is incorrect

  https://bugs.launchpad.net/leo-editor/+bug/622819

  Ctrl-Shift movement (back-word-extend-selection, forward-word-extend-selection)
  was incorrect when there is an existing selection, which was created by some
  method other than Ctrl-Shift movement.

- Resolved bug 323967: leo overrides minibuffer background color.

  https://bugs.launchpad.net/leo-editor/+bug/323967

- Fixed actionscript colors for parens.

  http://groups.google.com/group/leo-editor/browse_thread/thread/ee09fb2c2a5316f2/490fa7cddab36fab

- Fixed Bug 760531:Spurious overwrite warnings.

  https://bugs.launchpad.net/leo-editor/+bug/760531

- Fixed important bug involving orphan nodes

  http://groups.google.com/group/leo-editor/browse_thread/thread/861a0d156b16090f

  This was an important bug. It's been around for a very long time. What I did:
        
    - putVnode no longer clears the orphan bit.
    
    - at.read issues a warning and does not read the external file if the orphan bit is set.

- Fixed bug: show-invisibles now correctly shows blank lines.

- Fixed bug 766747: fill-paragraph doesn't respect setting from set-fill-column.

  https://bugs.launchpad.net/leo-editor/+bug/766747

  The fill-paragraph, center-line and center-region now all use the fill column
  if it has been explicitly set (and greater than zero). Otherwise, these
  commands use the @pagewidth value. Previously, the fill-paragraph command used
  the page width set by the @pagewidth directive, or an initial value from a
  @setting if no @pagewidth directive was in effect.

- Fixed bug 583878: Leo should warn about @comment/@delims clashes.

  https://bugs.launchpad.net/leo-editor/+bug/583878

  Leo now warns when a node contains both @comment and @delims directives.

- Fixed bug 778204: @verbatim not forbidden in body text.

  https://bugs.launchpad.net/leo-editor/+bug/778204

  Leo now generates an error for sentinels that look like @verbatim.

- Fixed bug 784920: @raw mode does not ignore directives.

  https://bugs.launchpad.net/leo-editor/+bug/784920

- Fixed bug 527717: Qt gui should enable/disable menu items.

  https://bugs.launchpad.net/leo-editor/+bug/527717

- Fixed bug 580328: c.frame.toggleSplitDirection() doesn't preserve existing ratio.

  https://bugs.launchpad.net/leo-editor/+bug/580328

- Fixed bug 581031: Scrollbar position is not preserved when
  c.frame.toggleSplitDirection() is executed.

  https://bugs.launchpad.net/leo-editor/+bug/581031

  toggleSplitDirection new ensures that both the selected outline node *and* the
  cursor in the body pane are visible.


- Fixed bug 525004: bash code not colored properly.

    https://bugs.launchpad.net/leo-editor/+bug/525004

    1. Fixed an off-by-one error in getNextToken. This was causing the havoc in
       the shell coloring.
    
    2. match_mark_following now does *nothing* (fails) if there is no next token.
       This is a major change, and it allows more rules to match in the shell
       colorer.
       
- Fixed bug 626587: Menus &amp; dialogs now say "Flatten Selected Outline".

  https://bugs.launchpad.net/leo-editor/+bug/626587
</t>
<t tx="ekr.20110604043410.17812">** Changing @language directives now forces a recoloring.

  This fixed the most annoying hangnail remaining in Leo.

** Removed remaining tk-isms from Leo's core.

  These were real bugs: they prevent emacs commands from working.

  Completely rewrote transposeWords.
  
** mod_autosave plugin no longer registers redundant idle-time handlers.

** Fixed mod_http plugin.

** Mark external file dirty when dragging node.

- Disabled the rst button in the contextmenu.

- Fixed horizontal scroll glitch in log pane (Python 2.x).
  qtLog.put sets horizontal scrolling to zero.
  This is a workaround to a glitch (Python 2.x only),
  but in fact it's generally useful.

- Fixed bug: auto-rst gives spurious overwrite message.

- Added bindings to all text widgets in the tab frame.

- Fixed goto-global-line problems.

- Restore positions of non-tabbed windows.

- Fixed Python 3.2 ua problems.

- Fixed bug in p._adjustPostionBeforeUnlink and simplified code.

- Fixed crash in archivedPositionToPosition.

- Fixed top-level uA's. There was a misspelling of 'unknownAttributes' in
  putVnode. This caused the uA for the first top level node in the outline to be
  cleared on save and by some copy paste ops.

- Fixed bug: Leo now ignores f-keys in find/replace patterns.

- c.bringToFront now activates the window.

- Fixed nav_qt plugin.

- Fixed completer focus problems.

- Fixed MacOS Command-C bug.

- Fixed major problem with multiple body editors
</t>
<t tx="ekr.20110604105805.16766">- Double-clicking a headline now colorizers the headline exactly the same way as
  when editing the headline with ctrl-H. This was a serious problem for those
  with dark window-color schemes.
  
- The distribution script now ensures that leo\plugins\spellpyx.txt contains
  Linux-style newlines. This prevents crashes in the PyEnchant spell checker.
  
- Leo imports .cfg files just like .ini files.

- Fixed crasher in graphcanvas plugin caused by a bug in CommandChainDispatcher.add.
</t>
<t tx="ekr.20110605121601.18097">###
### Do not use this code. It is extremely slow for large text.
###
def lengthHelper(self):
    '''Return the length of the text.'''
    traceTime = False and not g.unitTesting
    if traceTime: t1 = time.time()
    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    if traceTime:
        delta_t = time.time()-t1
        if delta_t &gt; 0.1: g.trace('=========== %2.3f sec' % (delta_t))
    return n
</t>
<t tx="ekr.20110605121601.18838"></t>
<t tx="ekr.20110605121601.18839">createColorPicker
</t>
<t tx="ekr.20110605121601.18840">leoQtFrame.cascade.
</t>
<t tx="ekr.20110605121601.18841">def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 50,50,50
    for frame in g.app.windowList:

        w = frame and frame.top
        if w:
            r = w.geometry() # a Qt.Rect
            w.setGeometry(x,y,r.width(),r.height())

            # Compute the new offsets.
            x += 30 ; y += 30
            if x &gt; 200:
                x = 10 + delta ; y = 40 + delta
                delta += 10
</t>
<t tx="ekr.20110605121601.18842"></t>
<t tx="ekr.20110609042343.16546"></t>
<t tx="ekr.20110609042343.16548">@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    &lt;vnodes&gt;    &lt;directed-acyclic-graph&gt;
    &lt;tnodes&gt;    &lt;data-list&gt;
    &lt;v&gt;         &lt;node&gt;
    &lt;t&gt;         &lt;data&gt;

- Nesting of &lt;node&gt; elements represents the structure of the DAG,
  just as nesting of &lt;v&gt; elements does at present.
  
- Thus, there will be no &lt;edge&gt; elements.

- Headlines will move from &lt;v&gt; elements to &lt;data&gt; elements.
  This "normalizes" the data: headlines will appear only once.
  
- &lt;attr&gt; elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for &lt;attr&gt; elements.  This is open to discussion. 

- Only &lt;node&gt; elements will contain &lt;attr&gt; elements.

- &lt;node&gt; elements for @file nodes will contain
  &lt;at-file-attributes&gt; elements, representing Leo's "hidden
  machinery" attributes.  &lt;at-file-attributes&gt; will contain
  &lt;attr&gt; elements. 

First lines
===========

Leo file will start with the following::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
        

No session data
===============

There will be no &lt;globals&gt;, &lt;preferences&gt; or
&lt;find_panel_settings&gt; elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
&lt;node&gt; elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;directed-acyclic-graph&gt;
        &lt;node id="gnx"&gt;
            &lt;!-- contained node elements, if any.
        &lt;/node&gt;
        &lt;node id="gnx"&gt;
            &lt;!-- contained v elements, if any.
        &lt;/node&gt;
        ...
    &lt;/directed-acyclic-graph&gt;
    &lt;data-list&gt;
        &lt;data id="gnx"&gt;
            &lt;!-- marked attribute appears only if the tnode/vnode is marked --&gt;
            &lt;head&gt;headline text&lt;/head&gt;
            &lt;attr key="marked"&gt;1&lt;/attr&gt;
            &lt;!-- uA's... --&gt;
            &lt;!-- format="string" is the default --&gt;
            &lt;attr key="a"&gt;a string&lt;/attr&gt;
            &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
            &lt;attr key="c" format="pickle"&gt;a pickled string&lt;/attr&gt;
            &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
            ...
            &lt;body&gt;body text&lt;/body&gt;
        &lt;/data&gt;
        ...
    &lt;/data-list&gt;
    &lt;/leo_file&gt;

&lt;attr&gt; elements
===============

&lt;attr&gt; elements will one of the following forms::

    &lt;attr key="a"&gt;a unicode string&lt;/attr&gt;
    &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
    &lt;attr key="c" format="pickle"&gt;a json string&lt;/attr&gt;
    &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No &lt;attr&gt; element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The &lt;at-file-attributes&gt; element may optionally be contained in
the &lt;node&gt; element for @file nodes::

    &lt;at-file-attributes&gt;
        &lt;attr&gt;key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx"&gt;value
        &lt;/attr&gt;
        ...
    &lt;/at-file-attributes&gt;
</t>
<t tx="ekr.20110611055444.16617"></t>
<t tx="ekr.20110611055444.16618">- Fixed ancient, major bug: F3 now makes sure to save headline changes

- Fixed old bug: set-find-x commands no longer abort find commands

  The commands that switch find scope, set-find-xxx, no longer terminate the
  find command, if one is active.  This is an old bug, and it's good to fix it. 

- Fixed recent bugs in the viewrendered plugin.

  An earlier rev fixed a bug that effectively destroyed the viewrendered plugin.
  It was caused by the new convention that alleviates the need for many
  \@language directives. The fix was simply to enable the update_rst method if
  the massaged p.b is not empty.

- Fixed chapters problems

    http://groups.google.com/group/leo-editor/browse_thread/thread/3f15a855ca38b26e
    
    The new code is more relaxed about where @chapter nodes may reside.  They
    are always *created* as the last child of the first @chapters node in the
    outline (the @chapters, plural, node is created as needed).  However, you may
    move them while in the "main" chapter, with no ill effects.  In fact, you could
    swap @chapter nodes with the same name: when you select a chapter, Leo will use
    (show) the first node it finds. 
    
    The new code is now both more careful and more tolerant of @chapter nodes
    deleted by hand.  The chapter will still appear in the dropdown list: if you
    select it you will give a polite warning.  That's all.  In particular, the
    deleted chapter will *remain* in the dropdown list until you use the proper
    chapter-remove command.  That's about the only sane alternative: it allows you
    to resurrect the chapter, by hand or with an undo. 
    
    This is all made possible because the new code is almost completely stateless.
    The only exception is the saved position used to select a node when selecting a
    chapter. The old position-based findPositionInChapter method has been simplified
    to make it work more reliably. It first looks for a "perfect" match using
    positions, and then degrades to looking for a vnode match. In practice, most
    matches are, in fact, perfect. The "imperfect" case typically happens when the
    user alters nodes in @chapter trees by hand in the "main" chapters.
    
    Technical highlights:
        
    - The check for c.positionExists(p) in c.setCurrentPosition continues to fail
      when deleting @chapter nodes. However, the code now simply falls back to
      c.rootPosition, without any apparent harm.
      
    - The chapterController and chapter classes are now completely stateless, except
      for chapter.p.
      
        A. chapter.findPositionInChapter has been simplified and generalized. It now
           falls back to a reasonable value, based on p.v, if chapter.p does not
           exist.
           
        B. All chapterController code now recomputes the location of @chapters and
           @chapter nodes whenever those locations are needed.
           
        C. All chapter commands are unchanged in their actual workings, but all contain
           a care "preamble" of checking code.
           
- Added unit test for all chapter commands.  All interactive commands now have
  an xByName helper for use by unit tests.
  
- Added lockout to leoQtTreeTab.  This prevents flash during the rename chapter command.

- Rewrote chapter.chapterSelectHelper.  This reduces, but does not eliminate, the
  number of warnings given by c.setCurrentPosition.


- Fixed recent bug: handle 'Escape' character properly

  The fix was a last-minute adjustment in leoQtEventFilter.create_key_event.


- Fixed caps-lock problem

  The fix was yet another last-minute fix leoQtEventFiler.create_key_event.

- Made sure all keys contribute to lossage
</t>
<t tx="ekr.20110611055444.16654">This was a major simplification of Leo's core.

- Eliminated event.keysym from Leo's core: test only ev.char and ev.stroke.

- Replaced all dummy (g.bunch) events in Leo's core and in unitTest.leo.
    
- Replaced w.event_generate by g.app.gui.event_generate everywhere.
    
- Rewrote leoGui.leoKeyEvent.

- Created leoGui.create_key_event and leoQtEventFilter.create_key_event.

- Removed some ugly last-minute hacks in leoQtEventFilter.create_key_event.
</t>
<t tx="ekr.20110611055444.16726">- Changed names of commands so they have common prefixes

    Any custom key bindings (none are bound by default) will have to change.
    
    The new prefixes are::
    
        abbrev-     abbreviation commands
        buffer-     buffer command
        directory-  director commands
        file-       file commands
        gc-         garbage collection
        macro-      macro expansion
        rectangle-  rectangle commands
        register    register commands
        
    The already existing prefixes are::
    
        apropos-    help
        ddabrev-    dynamic abbreviations
        find-       find commands
        isearch-    incremental search
        print-      print information
        run-        run unit tests
        toggle-     toggle settings
        yank-       yank
        

- Finished macros

    The macro-load and macro-save are as simple as possible.

    No further work will be done on macros unless somebody really wants these commands.


- Added support for word-only option for regular expressions

When the word-only option is in effect, Leo ensures that the search pattern
begins and ends with the '\b' anchor.

- Leo's startup code now forces the qt gui: it changes qttabs to qt.

- Added support for expanded sections in plugin.  Added three new options:

    expand_noweb_references
    
       True: Replace references by definitions.
       Definitions must be descendants of the referencing node.
    
    ignore_noweb_definitions
    
        True: ignore section definition nodes.
    
    expand_noweb_recursively
    
        True: recursively expand definitions by expanding any
        references found in definitions.
        
Notes:

- This is an experimental feature: all aspects might changed.

- The code ensures that unbounded expansions can not happen. While expanding any
  section, the rst3 will not expand again any sections that have already
  occurred in the expansion.

- All rst3 options apply to the entire node in which they appear (and all
  descendant nodes until over-ridden), but by splitting nodes one can change the
  settings on an expansion-by-expansion basis. It is easy to split nodes without
  creating new sections using @rst-no-head in the headline.
</t>
<t tx="ekr.20110611085637.5009"></t>
<t tx="ekr.20110611085637.5010">- Fixed ancient, major bug: F3 now makes sure to save headline changes

- Fixed old bug: set-find-x commands no longer abort find commands

  The commands that switch find scope, set-find-xxx, no longer terminate the
  find command, if one is active.  This is an old bug, and it's good to fix it. 

- Fixed recent bugs in the viewrendered and scrolledmessage plugins

  An earlier rev fixed a bug that effectively destroyed the viewrendered plugin.
  It was caused by the new convention that alleviates the need for many
  \@language directives. The fix was simply to enable the update_rst method if
  the massaged p.b is not empty.

  ScrolledMessageDialog.convertMessage now renders rst by default, unless
  *either* the html or text button is pressed.  There really should be three
  radio buttons: text, html or rST, but that's a tiny interface glitch.  The
  actual bug however, was much more serious: rst was never being rendered. 

- Fixed chapters problems

    http://groups.google.com/group/leo-editor/browse_thread/thread/3f15a855ca38b26e
    
    The new code is more relaxed about where @chapter nodes may reside.  They
    are always *created* as the last child of the first @chapters node in the
    outline (the @chapters, plural, node is created as needed).  However, you may
    move them while in the "main" chapter, with no ill effects.  In fact, you could
    swap @chapter nodes with the same name: when you select a chapter, Leo will use
    (show) the first node it finds. 
    
    The new code is now both more careful and more tolerant of @chapter nodes
    deleted by hand.  The chapter will still appear in the dropdown list: if you
    select it you will give a polite warning.  That's all.  In particular, the
    deleted chapter will *remain* in the dropdown list until you use the proper
    chapter-remove command.  That's about the only sane alternative: it allows you
    to resurrect the chapter, by hand or with an undo. 
    
    This is all made possible because the new code is almost completely stateless.
    The only exception is the saved position used to select a node when selecting a
    chapter. The old position-based findPositionInChapter method has been simplified
    to make it work more reliably. It first looks for a "perfect" match using
    positions, and then degrades to looking for a vnode match. In practice, most
    matches are, in fact, perfect. The "imperfect" case typically happens when the
    user alters nodes in @chapter trees by hand in the "main" chapters.
    
    Technical highlights:
        
    - The check for c.positionExists(p) in c.setCurrentPosition continues to fail
      when deleting @chapter nodes. However, the code now simply falls back to
      c.rootPosition, without any apparent harm.
      
    - The chapterController and chapter classes are now completely stateless, except
      for chapter.p.
      
        A. chapter.findPositionInChapter has been simplified and generalized. It now
           falls back to a reasonable value, based on p.v, if chapter.p does not
           exist.
           
        B. All chapterController code now recomputes the location of @chapters and
           @chapter nodes whenever those locations are needed.
           
        C. All chapter commands are unchanged in their actual workings, but all contain
           a care "preamble" of checking code.
           
- Added unit test for all chapter commands.  All interactive commands now have
  an xByName helper for use by unit tests.
  
- Added lockout to leoQtTreeTab.  This prevents flash during the rename chapter command.

- Rewrote chapter.chapterSelectHelper.  This reduces, but does not eliminate, the
  number of warnings given by c.setCurrentPosition.


- Fixed recent bug: handle 'Escape' character properly

  The fix was a last-minute adjustment in leoQtEventFilter.create_key_event.


- Fixed caps-lock problem

  The fix was yet another last-minute fix leoQtEventFiler.create_key_event.

- Made sure all keys contribute to lossage
</t>
<t tx="ekr.20110611085637.5012">- Simplified Leo's key handling, an important improvement to Leo's core.

- Changed names of commands so they have common prefixes

    Any custom key bindings (none are bound by default) will have to change.
    
    The new prefixes are::
    
        abbrev-     abbreviation commands
        buffer-     buffer command
        directory-  director commands
        file-       file commands
        gc-         garbage collection
        macro-      macro expansion
        rectangle-  rectangle commands
        register    register commands
        
    The already existing prefixes are::
    
        apropos-    help
        ddabrev-    dynamic abbreviations
        find-       find commands
        isearch-    incremental search
        print-      print information
        run-        run unit tests
        toggle-     toggle settings
        yank-       yank
        

- Finished macros

    The macro-load and macro-save are as simple as possible.

    No further work will be done on macros unless somebody really wants these commands.


- Added support for word-only option for regular expressions

When the word-only option is in effect, Leo ensures that the search pattern
begins and ends with the '\b' anchor.

- Leo's startup code now forces the qt gui: it changes qttabs to qt.

- Added support for expanded sections in plugin.  Added three new options:

    expand_noweb_references
    
       True: Replace references by definitions.
       Definitions must be descendants of the referencing node.
    
    ignore_noweb_definitions
    
        True: ignore section definition nodes.
    
    expand_noweb_recursively
    
        True: recursively expand definitions by expanding any
        references found in definitions.
</t>
<t tx="ekr.20110611092035.16493">The following Tk settings have been removed from leoSettings.leo::

    @bool center_selected_tree_node
    @bool expanded_click_area
    @bool idle_redraw
    @bool initialClickExpandsOrContractsNode
    @bool invisible_outline_navigation
    @bool look_for_control_drag_on_mouse_down
    @bool outline_pane_scrolls_horizontally
    @bool use_minibuffer
    
The following setting was not active, and has also been removed::

    @bool ignore_caps_lock
</t>
<t tx="ekr.20110612104631.16414">**New in Leo 4.9**: The following three options allow you
to expand noweb section references, much like Leo itself does.

**expand_noweb_references**

   True: Replace references by definitions.
   Definitions must be descendants of the referencing node.

**ignore_noweb_definitions**

    True: ignore section definition nodes.

**expand_noweb_recursively**

    True: recursively expand definitions by expanding any
    references found in definitions.
        
Notes:

- This is an experimental feature: all aspects might changed. The defaults for
  all these options ensure that the rst3 command works as it has always.

- The rst3 command ensures that unbounded expansions can not happen. While
  expanding any section, the rst3 will not expand again any sections that have
  already occurred in the expansion.
</t>
<t tx="ekr.20110613110911.16421"></t>
<t tx="ekr.20110613172008.14775">Old bugs fixed
--------------

- Fixed an ancient bug: everything after @all was put in the wrong node!

- Fixed an ancient bug: wrap-around search now restarts when find pattern changes

- Fixed an ancient bug: F-keys end incremental searches.

Recent bugs fixed
-----------------

- Fixed a recent problem with commands dispatched from menus The Shift modifier
  was deleted from all commands executed by selecting an item in menus! A new
  unit test checks that menus behave as expected.

- Dismiss splash screen before putting up the dialog that asks for an ID.

Other changes
-------------

- Running all unit tests leaves all files unchanged. This was a major annoyance.

- Leo now does a keyboard-quit when deactivating a window.
</t>
<t tx="ekr.20110613172008.15106">- Running all unit tests leaves all files unchanged. This was a major annoyance.

- Leo now does a keyboard-quit when deactivating a window.

- Fixed an ancient bug: everything after @all was put in the wrong node!

- Fixed an ancient bug: wrap-around search now restarts when find pattern changes.

- Fixed an ancient bug: F-keys end incremental searches.

- Fixed a serious recent problem with commands dispatched from menus The Shift
  modifier was deleted from all commands executed by selecting an item in menus!
  A new unit test checks that menus behave as expected.

- Dismiss splash screen before putting up the dialog that asks for an ID.
</t>
<t tx="ekr.20110614123640.6587">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&amp;lt;something&amp;gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
</t>
<t tx="ekr.20110616084347.14800">http://groups.google.com/group/pyxides

On 2010/02/23 I commented about Leo 4.7 as it relates to Robin Dunn's post,
http://groups.google.com/group/leo-editor/browse_thread/thread/4f76a0f57759aba

A few weeks ago Leo 4.9 went out the door. Imo, this version of Leo has
accomplished the mission. Leo has all the important features that Leo's users
have requested. Yes, wishlist items remain. See:
https://bugs.launchpad.net/leo-editor/+bugs

None of these wish-list items interferes in any way with Leo's day-to-day
operation. Furthermore, many of Leo's essential features moot the need for more
traditional features.

For example, Leo 4.9 adds full support for macros. Recording, saving, editing
and retrieving macros is easier in Leo than in other editors because Leo stores
macros in @macro nodes, not external files. But few, if any, of Leo's users are
likely to use macros because Leo's @button nodes make all of Python's scripting
abilities easily available on a node-by-node or outline-wide basis.

It may be that Leo could benefit from some Emacs-like or vim-like features, but
that doesn't seem so likely.  Leo has many users who also use Emacs and vim, and
they seem happy enough :-)

Finally, Leo offers features that have no counterpart at all in editors like
Emacs and vim. For example, the rst3 command converts an outline to restructured
text. See: http://webpages.charter.net/edreamleo/rstplugin3.html Yes, one could
imagine an org-mode command that does this, but the fact is that Leo's outline
orientation has given it abilities possessed by no other editor or IDE.

I invite you to try Leo. If, after using Leo for
real work, you find you would like some new feature, then by all means ask.

Edward
</t>
<t tx="ekr.20110616100929.14794">- When running on MacOS, Leo uses the qt gui when the qttabs gui is requested.

- Leo now looks in home/.leo/Icons directory for icons before looking in the
  leo/Icons directory.
  http://groups.google.com/group/leo-editor/browse_thread/thread/80163aec96b8ea45/4f58418924172252

- Fixed bug 797470: File data sometimes silently erased when the tangler fails.
  https://bugs.launchpad.net/leo-editor/+bug/797470 This was a serious bug, but
  it could happen only when saving an errorneous file twice.

- Fixed bug 798194: --maximized has no effect
  https://bugs.launchpad.net/leo-editor/+bug/798194
  
- Added the @bool forbid_invalid_completions setting.

- Non-plain keys, such as Ctrl-s, abort auto-completion and are interpreted as
  usual.

- Don't mark the .leo file as changed when setting orphan bit. There is no need:
  the orphan bits will ensure errors get reported if the file is saved.

- Disabled the open-compare-window command. It is/was a Tk only command.

- The open-python-window command fails more gracefully It issues a message
  instead of crashing if idlelib does not exist.
</t>
<t tx="ekr.20110616100929.14851">- When running on MacOS, Leo uses the qt gui when the qttabs gui is requested.

- Leo now looks in home/.leo/Icons directory for icons before looking in the
  leo/Icons directory.
  http://groups.google.com/group/leo-editor/browse_thread/thread/80163aec96b8ea45/4f58418924172252

- Fixed bug 797470: File data sometimes silently erased when the tangler fails.
  https://bugs.launchpad.net/leo-editor/+bug/797470 This was a serious bug, but
  it could happen only when saving an erroneous file twice.

- Fixed bug 798194: --maximized has no effect
  https://bugs.launchpad.net/leo-editor/+bug/798194

- Added the @bool forbid_invalid_completions setting.

- Non-plain keys, such as Ctrl-s, abort auto-completion and are interpreted as
  usual.

- Don't mark the .leo file as changed when setting orphan bit. There is no need:
  the orphan bits will ensure errors get reported if the file is saved.

- Disabled the open-compare-window command. It is/was a Tk only command.

- The open-python-window command fails more gracefully It issues a message
  instead of crashing if idlelib does not exist.
</t>
<t tx="ekr.20110619173515.14896">Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
</t>
<t tx="ekr.20110620083705.14901">leoBridge.py requires the nullGui.
</t>
<t tx="ekr.20110620083705.14902">Fixed crash on mouse clicks in minibuffer.
</t>
<t tx="ekr.20110621085435.6532">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window&gt;Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window&gt;Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
</t>
<t tx="ekr.20110918204546.6809"></t>
<t tx="ekr.20110929074744.15449">@nocolor-node

tab-cycle-next makes the following not so important

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

The user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
</t>
<t tx="ekr.20110929074744.15499"></t>
<t tx="ekr.20110930075237.15474"></t>
<t tx="ekr.20111003232155.6988">This would allow us to eliminate @bool put_expansion_bits_in_leo_files.
</t>
<t tx="ekr.20111004090723.15495"></t>
<t tx="ekr.20111009230326.7037"></t>
<t tx="ekr.20111010093113.15548">@nocolor-node

Almost from day one, Leo has defined gui base classes in the core, and
subclasses in gui plugins.

I plan to continue that organization, but I would like to remove some of the
wrapping layers if possible. The present scheme has one or two too many
redirection layers, and they are more of a nuisance than a help.

One idea would be to define **interface classes** that define the desired api's.
Unit tests could test that subclass implements the interface class, without
having to resort to quite as much error-prone machinery as at present.
</t>
<t tx="ekr.20111010122531.15568">@language rest

The free_layout and viewrendered plugins are a huge step forward.  But
the lighter/heavier distinction suggests a new way to use them.

Suppose Leo supports @render-rest or @render-html.

This means that all nodes in the tree will have the body pane become a
rendering pane for rST or html.

Imagine LeoDocs completely rendered at all times.

Of course, for specific purposes, say in Leo's scripting chapter, we
might want to override these rendering directives (which should be
allowed in headlines too) with @no-render.

The point is that having *both* the original text *and* the rendered
text be visible is often too heavy: the user usually does not want to
know about the sources: the rendering is good enough.

I suppose for sophisticated users, something like show/hide-body pane
would be good commands to have, but that doesn't matter: those
commands to not increase the burden on the user while she is reading
the (rendered) docs.
</t>
<t tx="ekr.20111010122531.15569">@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/d302b2715b3ace96

A reminder, the opposite of "light" is "heavy", not "dark" :-)

Leo's print-settings, print-commands and print-bindings commands
create too much text.

Suppose they created outline nodes instead, replacing existing nodes
if they exist.  Something like this:

- Reference (Anywhere you like)
 - @print-settings
    etc.
 - @print-bindings
   etc
 - @print commands
   etc

Doh!  This uses Leo's power.  The subnodes can be as voluminous as
desired, and there can be organizer nodes in each case.  The actual
tree could be specified as in @menus.

Etc., etc.  This could moot the need for separate apropos commands.
Conversely, apropos commands could create their own trees, or
subtrees.

This could be the tip of an iceberg.

The more I think about the light/heavy distinction, the more I think
it is getting close to what makes Leo special.  For example, clones
(and nodes, for that matter) drastically lighten the apparent
complexity of programs or data.
</t>
<t tx="ekr.20111010162047.15678">Especially:
    - Shebang line.
    - Python encoding line.
    
- @auto correctly works for all Python files.
</t>
<t tx="ekr.20111011062533.15693"># It doesn't seem easy.

Related nodes:
editLabelHelper (leoQtTree)
</t>
<t tx="ekr.20111014134653.15672">http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab54f29a6c128
</t>
<t tx="ekr.20111017132257.15882">@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b5c2982778a2df53

Provides commands (Alt-x) for importing and exporting XML from a Leo
outline. These commands are to XML what ``@auto-rst`` is to
reStructuredText.

``xml2leo`` imports an .xml file into the node following the currently
selected node.  ``leo2xml`` exports the current subtree to an .xml file
the user selects.

``xml_validate``, if executed on the top node in the
Leo xml tree, reports any errors in XML generation or DTD validation,
based on the DTD referenced from the XML itself.  If there's no DTD
it reports that as an error.

``leo2xml2leo`` takes the selected Leo subtree representing an XML file,
converts it to XML internally, and then creates a new Leo subtree from
that XML after the original, with 'NEW ' at the start of the top node's
name.  This updates all the headlines, so that the convenience only
previews (see below) are updated.  The original can be deleted if the
new subtree seems correct.

Conventions
===========

This is a valid XML file::

    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!DOCTYPE dml SYSTEM "dml.dtd"&gt;
    &lt;?xml-stylesheet href="common.css"?&gt;
    &lt;dml xmlns='http://example.com/' xmlns:other='http://other.com/'/&gt;
      &lt;block type='example'&gt;Here's &lt;other:b&gt;some&lt;/other:b&gt; text&lt;/block&gt;
    &lt;/dml&gt;
    &lt;!-- This is the last line --&gt;

Note the processing instruction (xml-stylesheet), the DTD (DOCTYPE),
the trailing comment (after the closing tag), and the pernicious
mixed content (three separate pieces of text in the ``&lt;block/&gt;`` element).
These commands attempt to deal with all of this.

 - A top level Leo node is created to hold these top level parts.  Its
   headline is the basename of the file.
 - The xml declaration is placed in the body of
   this top level Leo node
 - Below that, in the same body text, appears a simple namespace map::

     http://example.com/
     other: http://other.com/
     ...

   i.e. the default namespace first, and then any prefixed name spaces.
 - Below that, in the same body text, appears the ``DOCTYPE`` declaration
 - Children are added to this top level Leo node to represent the
   top level elements in the xml file.  Headlines have the following
   meanings:

       - ``? pi-target some="other" __CHK`` - i.e. questionmark,
         space, name of processing instruction target, start of processing
         instruction content.  Only the questionmark, which indicates
         the processing instruction, and the first word, which indicates
         the processing instruction target, matter.  The remainder is just
         a convenience preview of the processing instruction content, which
         is the Leo node's body text.

       - ``# This is *really* imp`` - i.e. hash,
         space, start of comment content.  Only the hash, which indicates
         the comment, matters.  The remainder is just
         a convenience preview of the comment content, which
         is the Leo node's body text.

       - ``tagname name_attribute start of element text`` - i.e. the name
         of an element followed by a convenience preview of the element's
         text content.  If the element has a ``name`` attribute that's
         included at the start of the text preview.  Only the first word
         matters, it's the name of the element.

 - Element's text is placed in the Leo node's body.  If the element has
   tailing text (the ``" text"`` tailing the ``&lt;other:b/&gt;`` element
   in the above example), that occurs in the Leo node's body separated
   by the `tailing text sentinel`::

       @________________________________TAIL_TEXT_______________________________

 - Element's attributes are stored in a dict ``p.v.u['_XML']['_edit']``
   on the Leo node. ``'_XML'`` is the uA prefix for these commands, and
   ``'_edit'`` is used by the ``attrib_edit`` plugin to identify
   attributes it should present to the user for editing. The
   ``attrib_edit`` plugin **should be enabled** and its ``v.u mode``
   activated (through its submenu on the Plugins menu). The attribute
   edit panel initially appears as a tab in the log pane, although it
   can be moved around by right clicking on the pane dividers if the
   ``viewrendered`` and ``free_layout`` plugins are enabled. 
</t>
<t tx="ekr.20111017132257.15883">@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/014fe61ff9480b2b

I don't know if this is relevant or not, but the IPython autocompletion
capability is awesome.

If I'm investigating code I tend to do the following.

list the modules in a package:
In [1]: from fs import &lt;tab&gt;

this lists the modules, in a package so I pick one
In [1]: from fs import osfs
&lt;the osfs entry is tab-completable&gt;

now I can check the usage of fs.osfs
In [2]: osfs? &lt;enter&gt;

or the source:
In [2]: osfs?? &lt;enter&gt;

or the contents of the module
In [2]: osfs. &lt;tab&gt;

I can instantiate a class:
In [3]: myfs = osfs.OSFS('/')

and examine the ivars and methods:
In [4]: myfs. &lt;tab&gt;

It is such an efficient way to learn and remember the details of code.

I know a bunch of work was done on Leo/IPython integration, don't
know the current status, my wish of synchronized IPython and Leo
may well be one of the many granted wishes I have forgotten about.

I certainly think IPython autocompletion is the gold standard. 
</t>
<t tx="ekr.20111018104244.15920">http://groups.google.com/group/leo-editor/browse_thread/thread/fe9cddc0e7ac8199
</t>
<t tx="ekr.20111018104244.15924"></t>
<t tx="ekr.20111018104244.15928">@nocolor-node

- All open files.
- Show all results as in quicksearch.
</t>
<t tx="ekr.20111018104244.15933">@language rest

Command docs
------------

This will create large docs for individual commands from docstrings.

Base this on print-cmd-docstrings.

Plugins docs

Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible. 

Terry wrote plugin_catalog.py.  It is in LeoDocs.leo
</t>
<t tx="ekr.20111018220642.15862"></t>
<t tx="ekr.20111019104425.15863">This has essentially no chance of improving Leo
</t>
<t tx="ekr.20111019104425.15868"></t>
<t tx="ekr.20111019104425.15887"></t>
<t tx="ekr.20111019104425.15888"></t>
<t tx="ekr.20111019104425.15892">Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...
</t>
<t tx="ekr.20111019104425.15894">Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]
</t>
<t tx="ekr.20111019104425.15895">- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

</t>
<t tx="ekr.20111019104425.15896"></t>
<t tx="ekr.20111021035504.9467">http://groups.google.com/group/leo-editor/browse_thread/thread/b851e7d9855a57c2

http://www.voom.net/pyqt-qtest-example
</t>
<t tx="ekr.20111026075003.16481">@language python
@language rest

1. Imo, it is time to consider adding a typical "startup" file to Leo,
~/leo_config.py, similar to ~/.emacs or ipython_config.py.  This will
make Leo "thicker", that is more professional/standard.

IPython adds lots of bells and whistles to configuration.  Leo
emulates most of them, but .leo_config.py would be a good addition.
Think of .leo_config.py as a lightweight plugin.

leo_config.py should execute after settings have been parsed, but
before plugins have been loaded.  If desired, leo_config.py may
register "start2" event handlers, which execute after all plugins have
been loaded, just before starting the main Qt event loop.

2. Leo commands form a good framework for other solutions to Qt
stylesheet issues.  Consider the following commands::

- qt-stylesheet-set-global-stylesheet
- qt-stylesheet-append-to-global-stylesheet
- qt-stylesheet-set-widget-stylesheet
- qt-stylesheet-append-to-widget-stylesheet

</t>
<t tx="ekr.20111027103125.16546">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/19bfe6daf2b324/c50a750606d64f77

Fossil (SCCS) and Leo.

&gt; I think that the interaction of Fossil + Leo could
&gt; solve the idea of having external files in a single "Leo document" that
&gt; would be really a fossil sqlite repository with all the external files in
&gt; it, but syncronizable with the outside world. This kind of instantiated
&gt; image of files in a moment of time in Fossil + Leo, would be like the
&gt; instantiated image of objects in a moment of time of Smalltalk.
</t>
<t tx="ekr.20111027143736.16557">@nocolor-node

Ville mentioned leoremote for driving Leo from the command line.
There's also leoscreen, for driving the command line from Leo,
providing you use screen, which is probably unix/cygwin only.
</t>
<t tx="ekr.20111027143736.16558">@nocolor-node

Considering leo.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/e3ddbe650fc9525b/290e97c593ee950a

&gt; &gt; I think there's a way to search across Leo files: quicksearch multiple
&gt; &gt; files ... ?

&gt; http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab5...

Leo has to have this :-)  It's on my list.  It would be a great way to
find @button nodes.

Furthermore, global searches for attributes in docstrings have
immediate uses.

On the urgent to-do list: drive all aspects of the Nav pane using
keystrokes.

I just reviewed @bookmarks--it's perfect for leo.leo.  The following
would replace all.bat:

- @bookmarks
  - leoPy.leo (url in body)
  - leoPlugins.leo
  - leoSettings.leo
  - myLeoSettings.leo
  - leoDocs.leo
  - leoDist.leo
  - scripts.leo

This way could be said to be much better than all.bat: nothing gets
loaded until needed.  Therefore, even more files could be added.

Imo, URL's in bookmark trees should support {{expression}} notations.

For example, I want the following to work in the body text of a node
in an @bookmarks tree::

file://{{g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo').replace('\\','/')}}

Not bad, eh?  Or maybe the URL logic should do the replace('\\','/')
automatically...

Got to go.  We are nearing a tipping point in Leo's workflow... 
</t>
<t tx="ekr.20111028195854.16607">@nocolor-node

Like @color html::tags_markup_color = blue
</t>
<t tx="ekr.20111101050427.16716">@nocolor-node

That is, make sure it works when called from within itself.
</t>
<t tx="ekr.20111105222316.9706">@nocolor-node

Create a "registry" of unit tests.  Verify that unitTest.leo contains them all.
</t>
<t tx="ekr.20111105222316.9707">@nocolor-node

Menu and plugin registry methods can fail if that *particular* unit test is running.
</t>
<t tx="ekr.20111109083738.9798"></t>
<t tx="ekr.20111114085925.9932">Related nodes:
ic.exportHeadlines
TM.makeImportExportSuite
class ImportExportTestCase
c.exportHeadlines
</t>
<t tx="ekr.20111114151846.9850"></t>
<t tx="ekr.20111114151846.9851"></t>
<t tx="ekr.20111114151846.9852"></t>
<t tx="ekr.20111114151846.9853"></t>
<t tx="ekr.20111114151846.9854"></t>
<t tx="ekr.20111114151846.9855"></t>
<t tx="ekr.20111114151846.9856"></t>
<t tx="ekr.20111115063523.13619">The following puts up a test window when run as a Leo script::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()
    c.my_test = w # &lt;-- Keep a reference to the window!
    
**Important**: Something like the last line is essential. Without it, the window
would immediately disappear after being created.  The assignment::

    c.my_test = w
    
creates a permanent reference to the window so the window won't be garbage
collected after the Leo script exits.
    
</t>
<t tx="ekr.20111123095018.13632"></t>
<t tx="ekr.20111125072438.10204">See https://bugs.launchpad.net/leo-editor/+bug/882243

In Leo, I made this file:

@file test.txt
@others
.....test1
     test: these are clones
.....test2
     @others

      what is going on...?
..........test1 &lt;--- this is cloned
          test: these are clones

The output file does not have the cloned node:

#@+leo-ver=5-thin
#@+node:bill.20111025150533.3528: * @thin test.txt
#@+others
#@+node:bill.20111025150533.3527: ** test1
test: these are clones
#@+node:bill.20111025150533.3529: ** test2
#@+others
#@-others

what is going on...?
#@-others
#@-leo

I don't think it is a conflict with @others; it is just that some files do not retain the clones that are displayed.

Here is the copied node:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;
&lt;leo_header file_format="2"/&gt;
&lt;vnodes&gt;
&lt;v t="bill.20111025150533.3528" a="E"&gt;&lt;vh&gt;@thin test.txt&lt;/vh&gt;
&lt;v t="bill.20111025150533.3527"&gt;&lt;vh&gt;test1&lt;/vh&gt;&lt;/v&gt;
&lt;v t="bill.20111025150533.3529" a="E"&gt;&lt;vh&gt;test2&lt;/vh&gt;
&lt;v t="bill.20111025150533.3527"&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="bill.20111025150533.3527"&gt;test: these are clones
&lt;/t&gt;
&lt;t tx="bill.20111025150533.3528"&gt;@others
&lt;/t&gt;
&lt;t tx="bill.20111025150533.3529"&gt;@others

what is going on...?&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;

Here is the copied leo file:

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5" body_secondary_ratio="0.5"&gt;
 &lt;global_window_position top="50" left="50" height="500" width="700"/&gt;
 &lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes&gt;
&lt;v t="bill.20111025150533.3528" a="E"
expanded="bill.20111025150533.3529,"&gt;&lt;vh&gt;@thin test.txt&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="ekr.20111125072438.10214">email:
http://mail.google.com/mail/#label/Leo%2FBugs/133ac31add8b2c6c

see attachment, shadow file won't get written correctly, and it won't reread
correctly too. Using leo-editor-snapshot- 201111090253.

Hopefully I will be able to look on some bugs myself, but don't know when. Needs
a bit of time, I am not very familiar with python.

===== EKR

Leo doesn't understand .jsp.  @shadow should refuse to work for unknown languages.
</t>
<t tx="ekr.20111125072438.10216">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/0d48b507bc8ffc05

v4.9.1 build 4669
WinXP

If I 'Open' a file, I get the following node header:

@edit E:/Documents/index.html

If I 'Import' the same file, I get the following:

@file E:\Documents\index.html

Just wondering why the difference between

E:/ and E:\

This is probably trivial and of no consequence, but I thought it
curious.

Create unit tests illustrating path ops
</t>
<t tx="ekr.20111125072438.10217">http://groups.google.com/group/leo-editor/browse_thread/thread/07efd66847ac4a64

on linux, parenthesis or angled brackets in @mime headings prevent the file from
being opened, probably because they are interpreted specially by the shell, e.g.
they need to be escaped. Such characters should be escaped before passing the
filename to the shell.

</t>
<t tx="ekr.20111125072438.10219">@nocolor-node

File 'Open' or 'Import File' command to follow @path directive
http://groups.google.com/group/leo-editor/browse_thread/thread/7e508921c85d18bc

Suppose my focus node is under a @path directive, say @path E:
\Documents\Some Folder\

Is there a setting that would cause the 'File&gt;Open' or 'File&gt;Import
File' commands to begin the search dialog in the directory, E:
\Documents\Some Folder\ instead of the last directory used?

Would others find this a useful feature?
</t>
<t tx="ekr.20111127144911.5544">@pagewidth 75

@ @rst-options
call_docutils=False
stylesheet_path=..\doc
write_intermediate_file = True
@c

###############
Downloading Leo
###############

.. links

.. _`latest stable release`: https://sourceforge.net/projects/leo/files/Leo/4.11%20final/
.. _`nightly snapshot`: http://www.greygreen.org/leo/
.. _`SourceForge`: https://sourceforge.net
.. _`Leo's latest sources`: https://github.com/leo-editor/leo-editor
.. _`GitHub`: https://github.com/leo-editor
.. _`git`: http://git-scm.com/

Leo's core code is always being improved and developed. Unit-testing
ensures that the daily commits are as bug-free as possible. Almost all of
the time, downloading the most recent `nightly snapshot`_ of the
development code is going to give you code that is just as stable and much
more up-to-date than the most recent `latest stable release`_ which most
Leonistas would consider already outdated.

If you are just checking Leo out, feel free to use the `latest stable release`_
download if it makes you feel more secure, but once you've
decided to work with Leo on a regular basis, we highly recommend regularly
keeping your installation up to date with the most recent `nightly snapshot`_.

To summarize, you may get Leo in three ways:

1. Download the `latest stable release`_ from `SourceForge`_. This release
   contains an executable installer. This release will usually be a bit out of date.

2. Download `snapshots`_ (see below) from github. You can get the very latest development
   version, or a version from from 1, 2, 5, 10, 30 or 90 days ago.
   
3. Download `Leo's latest sources`_ from `GitHub`_ using `git`_. Once
   git is installed, getting the latest version of Leo is very easy::
   
        git clone https://github.com/leo-editor/leo-editor.git (http access)
    
   or::

        git clone git@github.com:leo-editor/leo-editor.git (ssh access)
</t>
<t tx="ekr.20111216105907.10218">Reposted from http://groups.google.com/group/leo-editor/browse_thread/thread/67a28984616d09c9
About bug 882243: clones sometimes not saved

I'd like to discuss this bug here, because I would like us all to be aware of the situation, and possible changes.

The surprise
=========

To paraphrase the original bug report, suppose we have the following @file tree:

+ @file test.txt
@others
  + node 1 (cloned)
    node 1 text.
  + node 2
     @others
    + node 1 (cloned)
       node 1 text.

As usual, lines preceded by "+" denote headlines: all other lines are body text.

The surprise is that the cloned node1 node is written to the external file only once (as a child of the root node) and hence does not appear as a (cloned) child of the node2 node when Leo next loads the @file tree.

History
=====

I would like to call this a wishlist item because the
present code quite intentionally writes *any* node
(including cloned nodes) only once. That is, the write code
sets a bit when writing a node, and @others ignores any
nodes with that bit set.

You could call this a bug in the @others write logic, but at
one time it was done explicitly and on purpose.

I don't remember why this was so, but I do remember it *was*
so. It may have been an artifact of Leo's old representation
of clones that used both vnodes and tnodes. tnodes no longer
exist in the one-node world that we have been living in for
several years, and it may well be time to revisit the
original design, but I would rather not do that just now
because there are several "real" bugs that need attention
asap.

Workaround
=========

Because this is an issue involving @others, you might assume
that a workaround involving sections would be possible. You
would be correct. The following file works as expected::

+ @file test.txt
&lt;&lt; node 1 &gt;&gt;
&lt;&lt; node 2 &gt;&gt;
  + &lt;&lt; node 1&gt;&gt; (cloned)
     node 1 text.
  + &lt;&lt; node 2 &gt;&gt;
     &lt;&lt; node 1 &gt;&gt;
    + &lt;&lt; node 1 &gt;&gt;(cloned)
       node 1 text.
</t>
<t tx="ekr.20111221102703.10289">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def spam():
    pass
    
# This is the last line.
</t>
<t tx="ekr.20111221114145.10217"># Important: many plugins use g.app.gui.openFileDialog.
</t>
<t tx="ekr.20120205022040.15412">@nocolor-node
    
* Define k factory methods:
    
    k.makeKeyStroke(user_setting_string)
    k.makeKeyStrokeFromData(data)
    k.makeShortcutInfo(...)

* Refactor the Qt input code so it calls k.makeKeyStrokeFromData(data).
  This will require untangling the input code from event handling code.
</t>
<t tx="ekr.20120208062900.10146">@nocolor-node

This will eliminate the hacks for *entry-commands* and *command-prompt keys.

ModeController: a wrapper for g.app.config.modeCommandsDict

Clean up #### in leoKeys
</t>
<t tx="ekr.20120219152142.34262"></t>
<t tx="ekr.20120226180525.10191">@nocolor-node

Getting value from Bret Victor's video

http://groups.google.com/group/leo-editor/browse_thread/thread/9e1785ba4f57faf8

Thus, to associate code with unit tests, we need only create a
convention for associating source code with nodes.  But clones make
this trivial to do!

- @interactive-unit-tests
 - @itest
   - @test spam
   - (clone of) spam

This is all we would need to "declare" that @test spam should be run
whenever the spam node changes!

These are just first thoughts, made up as I am writing this post.  But
clearly, Leo can do more in this area.
</t>
<t tx="ekr.20120226183512.10195">@language rest
</t>
<t tx="ekr.20120226183512.10202">QSignalSpy: doesn't exist on PyQt?
</t>
<t tx="ekr.20120229094652.14053">Leo 4.10 final                                         March 29, 2012

Leo 4.10 final is now available at: http://sourceforge.net/projects/leo/files/Leo/4.10%20final/

Leo is a text editor, data organizer, project manager and much more.
See http://leoeditor.com/tutorial.html

Leo 4.10 contains 9 months of intense work on Leo. Several very important
features are subtle; you could almost call them Easter Eggs, so please read
the following notes carefully.

The highlights of Leo 4.10:
--------------------------

* Dozens of new and improved features and commands, including...
  - Tab completion now shows all @command &amp; @button nodes.
  - Leo tabs may be detached from the main window.
  - The Open With menu now works.
  - The leoInspect module answers questions about Python code.
  - Leo can highlight the pane containing the focus.
  - The bigdash plugin searches across multiple files.
  - Improved abbreviation capabilities.
  - Improved handling of URL's.
  - Improved editing of non-Leo files.
  - Improvements create "weightless" unit testing.
  - Improved Leo's home page.
* Easier installation on MacOS.
* Fixed almost 70 bugs.

The Easter Eggs
---------------

1. Tab completion now shows all @command &amp; @button nodes.

Put all your common scripts in @command nodes in myLeoSettings.leo.
Typing &lt;Alt-X&gt;@c&lt;Tab&gt; will remind you of the names of these scripts.
You can execute the scripts by name without the "@command-" prefix.

2. Improved abbreviation capabilities.

Virtually any kind of abbreviation is possible. For example, ~a to ã.

3. Improved handling of URL's.

URL's can be used as links to other Leo outlines.

4 Weightless unit testing.

The mantra is edit, alt-4 (run-marked-unit-tests-externally), edit,
alt-4,... Several seemingly innocuous changes made this work without
"friction". The result is a remarkable increase in productivity.

Links:
------
Leo:      http://leoeditor.com
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20120229094652.14518"></t>
<t tx="ekr.20120229094652.14520">The following tabs remain.  They are Leo-specific, not jEdit specific:
blank, docpart, leokeyword, link, name, nameBrackets, tab, url.
</t>
<t tx="ekr.20120229094652.14522">Only the high-level interface (baseTextWidget) used the low-level interface.
</t>
<t tx="ekr.20120229094652.14523">Removed the following unused methods::
    
    bind                c.bind also removed.
    configure
    cget
    event_generate      g.app.gui.event_generate does exist.
    getWidth
    indexIsVisible      Also removed for leoEditCommands: scrollHelper and measure.
    mark_set
    onChar              Fortunately, never used anywhere
    pack                Used only in Tk code
    scrollLines
    set_width           Removed do-nothing calls in Leo's core.
    tag_add             Removed do-nothing calls in qt colorizer.
    tag_bind            Removed do-nothing calls in qt colorizer.
    tag_delete          Removed do-nothing calls in qt colorizer.
    tag_names
    tag_ranges
    tag_remove
    update
    update_idletasks
    xyToPythonIndex
    yview
</t>
<t tx="ekr.20120229094652.14525">leoQTextEditWidget overrides base toPythonIndex toPythonIndexRowCol.

The versions that call g.toPythonIndex are much slower than
leoQTextEditWidget.toPythonIndex.

The following classes have a toPythonIndex method:

leoQTextEditWidget (fast)

HighLevelInterface: calls g.toPythonIndex.
baseTextWidget: calls g.toPythonIndex.
leoFind: calls g.toPytonIndex.
leoQtBaseTextWidget: calls g.toPythonIndex.
</t>
<t tx="ekr.20120229094652.14526">This is an important addition to reliability.

It ensures that body/log.widget and body.bodyCtrl/log.logCtrl are always in synch.
</t>
<t tx="ekr.20120229094652.14527">Added eventFilter in createFrame in SDI/TabbedFrameFactory classes
</t>
<t tx="ekr.20120229094652.14528"></t>
<t tx="ekr.20120229094652.14532">All top-level code in leoTest.py now resides in the
TestManager class.

The c.testManager object eliminates the need for imports of
leo.core.leoTest within unitTest.leo, an excellent
simplification.

Furthermore, there is no need to access the testUtils class:
everything is in c.testManager.

The TestManager class substantially clarifies *all* the code
in leoTest.leo. This is surprisingly important because the
testing code is hardly straightforward.
</t>
<t tx="ekr.20120229094652.14533">This is a major restructuring of Leo's code:
    
Initing settings files and local files is now as simple as possible.

g.openWithFileName now simply calls lm.loadLocalFile.

Commands.__init__ now calls c.finshCreate.

g.app.newCommander now simply calls Commands.__init__,
a *huge* collapse in complexity.

===== Details

The g.app.config class is now substantially simpler:
complex methods have moved to the LoadManager.

The new LoadManager class handles all aspects of Leo's
complex startup process, including most importantly the very
complex process by which Leo reads user settings.

As a side effect, c.config.get is now *much* simpler than
before: it search one, and *only* one dictionary to discover
settings.

Reading local files must be done *twice*. The first read
discovers settings, the second read uses those settings to
open the file. The first read always uses a null gui; the
second read uses g.app.gui, whatever that happens to be.

LM.openLocalFile embodies all aspects of the complex
strategy necessary for opening a local file twice. The first
read creates a PreviousSetting object, which is then passed
to LM.openFileByName, which in turn passes the
PreviousSetting object to the ctor for the Commander.
Finally, the PreviousSetting object inits c.config.

Because of the previousSettings object, the call to
LM.openFileByName does *not* need to "synthesize" a link to
c1 using c.hash. This stamps out bug 568452 at its source.

The crucial point is the previous settings get passed along
to the Commander ctor, *before* LM.openFileByName calls
c.fileCommands.openLeoFile to create the outline.

</t>
<t tx="ekr.20120229094652.14534">- Moved findSettingsPosition to LocalConfigManager.

- Moved printSettings to LocalConfigManager.
</t>
<t tx="ekr.20120229094652.14535"></t>
<t tx="ekr.20120229094652.14538">It's important to use only one version of the code.
</t>
<t tx="ekr.20120229094652.14540"></t>
<t tx="ekr.20120229094652.14541">This allows the following pattern to appear in Leo source files::

    class myClass:
        @others
        
    if g.app.testing:
        myClass(c).test()
        
This is better than enabling the test with "if 1:" because c is not defined
while importing the module, so the import will fail if I forget to change
"if 1:" to "if 0" when saving the .leo file.
</t>
<t tx="ekr.20120229094652.14542"></t>
<t tx="ekr.20120229094652.14543">- Generates only @auto, does not do an actual import.

- Creates @path nodes so actual @auto nodes are short.
</t>
<t tx="ekr.20120229094652.14544">Added class CPrettyPrinter &amp; beatifyCCode
</t>
<t tx="ekr.20120229094652.14545">This command is a rewrapping of the first Python script I ever wrote. It
takes much of the scut work away from the task of converting C code to
Python code.
</t>
<t tx="ekr.20120229094652.14567"></t>
<t tx="ekr.20120229094652.14576">The change was to DynamicWindow.createLogPane.
</t>
<t tx="ekr.20120229094652.14577">This was Tk code, and so can not possibly be useful now.

Also removed the settings specific to the Tk colorizer.
</t>
<t tx="ekr.20120229094652.14578">This important new method allows scripts to traverse an outline, deleting nodes
during the traversal. The pattern is::

    p = c.rootPosition()
    while p:
    if &lt;delete p?&gt;:
        next = p.positionAfterDeletedTree()
        p.doDelete()
        p = next
    else:
        p.moveToThreadNext()
        
This method also allows scripts to *move* nodes during a traversal, **provided**
that nodes are moved to a "safe" spot so that moving a node does not change the
position of any other nodes.

For example, the move-marked-nodes command first creates a **move node**, called
'Clones of marked nodes'. All moved nodes become children of this node.
**Inserting** these nodes as children of the "move node" does not change the
positions of other nodes. **Deleting** these nodes *may* change the position of
nodes, but the pattern above handles this complication cleanly.
</t>
<t tx="ekr.20120229094652.14581">Leo creates @file nodes (not @thin nodes) when opening an external file.

Changed g.openWrapperLeoFile to create @file instead of @edit when possible.

Open now shows all files. This is a cue that *any* file may be opened:
non-Leo files are opened in @edit nodes.
</t>
<t tx="ekr.20120229094652.14582"></t>
<t tx="ekr.20120229094652.14583">Rewrote the shellCommand, shellCommandOnRegion and executeSubprocess methods.
</t>
<t tx="ekr.20120229094652.14584"></t>
<t tx="ekr.20120229094652.14585">Leo can act like a drop-in replacement for SciTe. Suppose you do::
    
    leo x.y
    
where y is not "leo". Leo now opens an unnamed .leo file consisting of
@edit x.y. if x.y exists, the @edit node contains the entire file;
otherwise the node is empty.

When you save the .leo files or close the Leo window Leo saves x.y if it
has been changed, but Leo does *not* prompt you to save the "temporary"
.leo file.

https://bugs.launchpad.net/leo-editor/+bug/381527
</t>
<t tx="ekr.20120229094652.14589">Updating Sphinx and using new .js files did the trick.
</t>
<t tx="ekr.20120229094652.14590"></t>
<t tx="ekr.20120229094652.14592">The mod_scripting plugin so that the name of the command created by an @button
nodes does not include any [&lt;tag&gt;] that immediately follows @button. Examples::

    @button [ekr] x
    @button [edit] y
    @button [important] z

These buttons create commands named x, y and z, and the name of the buttons are
x, y and z.

Note that the '[' must be the first non-blank after @button to be recognized and
removed.

The code is a straightforward addition to cleanButtonText in mod_scripting.py:
it is unlikely to have any impact whatsoever to existing @button nodes.

The intended use is for searches of the form @button [some tag].
</t>
<t tx="ekr.20120229094652.14593">Wouldn't it be great if we all could remember what we, and others, have
already done? Now there is an easy way to do so: just put your
commonly-used scripts in global @command nodes. You do this by placing each
@command node as a child of an @commands node in your @settings tree in
myLeoSettings.leo.

Leo's tab completion now shows you all @command nodes, all @button nodes
and all the commands associated with those nodes.  To see the list of
all your @command nodes, simply type::

    &lt;Alt-X&gt;@c&lt;Tab&gt;
    
When I do that, I see::

    @command-align-eq-signs
    @command-c-to-python-clean-docs
    @command-clean-all-blank-lines
    @command-clean-body
    @command-clean-diff
    @command-clean-spellpyx
    @command-cls
    @command-count-pages
    @command-create-@auto-nodes
    @command-create-def-list
    @command-flatten-script
    @command-join-node-above
    @command-join-node-below
    @command-load-all-leo-files
    @command-preview-node
    @command-preview-tree
    @command-print-cmd-docstrings
    @command-promote-bodies
    @command-remove-newlines
    @command-split-defs
    
For each @command (and @button node) Leo creates the correspond commands
without the leading "@command-", so you can use typing completion on the
shorter command name. For example, when writing documentation, I often use
the promote-bodies script. After the reminder above, I can execute the
script with::

    &lt;Alt-X&gt;prom&lt;Tab&gt;-&lt;Tab&gt;&lt;Return&gt;
    
Of course, to rexecute the command later, I can use repeat-complex-command
(Ctrl-P).

Summary
=======

If you put all your commonly-used scripts in @command nodes, you can use
&lt;Alt-X&gt;@c&lt;Tab&gt; to remind yourself of their names. That is, Leo's typing
completion eliminates the need for memory-intensive retrieval. I'm not
likely ever to forget typing completion.

This scheme takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized material
in one place. This allows for easy reorganization: changing command-name
prefixes, for instance, would be straightforward.
</t>
<t tx="ekr.20120229094652.14595"></t>
<t tx="ekr.20120229094652.14596">There is no longer any need for @@button, etc.: just put under an @ignore node.
</t>
<t tx="ekr.20120229094652.14598">Configurable and optional::

    @color focus_border_color = red
    @int focus_border_width = 1
    @bool use_body_focus_border  = True
    @bool use_focus_border = True
</t>
<t tx="ekr.20120229094652.14599">Many editors allow you to jump over, select and delete words, especially
those containing or surrounded by special characters, in a smarter way than
just "going to the beginning of the word before" (back-word) or "going to
the end of the next word" (forward-word).

Patches add "-smart" equivalents of the jump, select and delete commands.
Users wanting to use these commands can set in their myLeoSettings.leo::

  back-word-smart                  = Ctrl-LtArrow
  back-word-smart-extend-selection = Ctrl-Shift-LtArrow

  forward-word-smart                  = Ctrl-RtArrow
  forward-word-smart-extend-selection = Ctrl-Shift-RtArrow

  delete-word-smart          = Ctrl-Delete
  backward-delete-word-smart = Ctrl-BackSpace
</t>
<t tx="ekr.20120229094652.14600">The single-line nodes should end in a newline. Otherwise the created node
will add a newline, and the checkers will complain.

The new class is xmlScanner and htmlScanner in leoImport.py.
</t>
<t tx="ekr.20120229094652.14601">Leo's home page now shows the latest postings on the leo-editor group.
</t>
<t tx="ekr.20120229094652.14602">The new command names and default bindings are::

    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = Alt-4 # The new standard
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = Alt-5 # The new standard
    run-selected-unit-tests-locally     = None
</t>
<t tx="ekr.20120229094652.14606"></t>
<t tx="ekr.20120229094652.14607">http://groups.google.com/group/leo-editor/browse_thread/thread/e2980a2b86af913e

I see the following
- when a file is opened
  - one message listing the root node
  - 7 repeats of the message for the current node

- when the file is saved in a session with several tabs
  - a message is generated for each current node in each tab

- shifting focus from body to headline doesn't generate the message,
  shifting focus with &lt;Ctrl-H&gt; does

- switching from one tab to another doesn't generate the message 
</t>
<t tx="ekr.20120229094652.14608">Unit tests can test this ivar.
</t>
<t tx="ekr.20120229094652.14610">The new code monkey-patches g.doHook to a do-nothing::
    
    if not self.loadPlugins:
        def dummyDoHook(tag,*args,**keys):
            pass
        g.doHook = dummyDoHook
</t>
<t tx="ekr.20120229094652.14611">An useful convenience method now that external unit tests can use config settings.
</t>
<t tx="ekr.20120229094652.14612">Under control of @bool collapse_on_lt_arrow option, default *True*.
</t>
<t tx="ekr.20120229094652.14613">The error message is now part of the failed assert.  Very helpful.
</t>
<t tx="ekr.20120229094652.14615">The default, True, is the legacy operation, which I recommend.

</t>
<t tx="ekr.20120229094652.14616">add-comments preserves trailing whitespace.

delete-comments now works whether or not blanks surround comments delims.
</t>
<t tx="ekr.20120229094652.14618">- print-bindings: Alt/Ctrl+Key+N now printed with plain Alt/Ctrl keys and shown as Alt/Ctrl+N.

- print-commands: Alt/Ctrl+Key+N now printed as Alt/Ctrl+N.

- print-commands &amp; print-bindings do not print 'all'.
</t>
<t tx="ekr.20120229094652.14619">Added show-decoration-selected: 1 to QTreeWidget stylesheet.

This causes the entire headline row to be shown when select, a big improvement, imo.
</t>
<t tx="ekr.20120229094652.14620"></t>
<t tx="ekr.20120229094652.14621">What I did:
    
1. Created c.init_error_dialogs &amp; c.raise_error_dialogs.

These are called from the following methods:
    
c.importAnyFile
c.open
c.readAtAutoNodes
c.readAtFileNodes
at.readAll
c.save
c.saveAs
c.saveTo
fc.writeAtFileNodes
fc.writeAtShadowNodes
fc.writeDirtyAtFileNodes

2. Disabled log messages in several of the above methods during unit testing.

3. Disabled runOpenFileDialog and runSaveFileDialog during unit testing.
</t>
<t tx="ekr.20120229094652.14622">- don't print 'all' in bindings.

- pad bindings properly, as is done in print-commands/bindings.
</t>
<t tx="ekr.20120229094652.14625">The clone-find-all command includes nodes only once: if a node's ancestor
appears in the list, the node is not include again in the top-level list.
The new clone-find-all-flattened command includes every found node in the
top-level list of nodes. I find this less confusing.
</t>
<t tx="ekr.20120229094652.14757"></t>
<t tx="ekr.20120229094652.14758">https://bugs.launchpad.net/leo-editor/+bug/800157

Fixed at rev 5077.
</t>
<t tx="ekr.20120229094652.14759">The code that marks descendant @&lt;file&gt; nodes dirty now tests
p2.isAnyAtFileNode().  The old code tested p2.isAtThinFileNode().
</t>
<t tx="ekr.20120229094652.14761">CAUTION: new double click handling code

http://groups.google.com/group/leo-editor/browse_thread/thread/dbd63b9b38911906

The problem isn't single/double, but double click not stopping the
event processing.  It has the correct form:

if g.doHook('doubleClick1') is None:
   do-normal-double-click-stuff
g.doHook('doubleClick2')

but I think some other route through the code, or additional processing
of the event means that even thought the handler registered on
doubleClick1 returns non-None, the node goes into headline edit mode,
with focus.

This is bad, because the doubleClick1 on an @url node attempts to
select and raise a different commander (tab), so now you're looking at
one commander but focus is in another, so what you type trashes the
headline in the original commander.

The timer shouldn't be needed - a 'doubleClick1' hook which returns
non-None should stop the headline going into edit mode.  If you can
make that be the case, all is well.
</t>
<t tx="ekr.20120229094652.14762"></t>
<t tx="ekr.20120229094652.14763"></t>
<t tx="ekr.20120229094652.14764">- leoCommands.__init__ now sets self.db = {}
- initGlobalDB now returns {} instead of None if there is no cacher.
</t>
<t tx="ekr.20120229094652.14765">readOpenFile reads the private shadow file, detecting the encoding.
</t>
<t tx="ekr.20120229094652.14767"></t>
<t tx="ekr.20120229094652.14769">Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
it converts slashes to backslashes on windows (!!)
</t>
<t tx="ekr.20120229094652.14770">- Added getLanguageFromAncestorAtFileNode.

- Revised code in at.scanAllDirectives &amp; leoQtColorizer.scanColorDirectives.
</t>
<t tx="ekr.20120229094652.14772">qtBody can use the leoBody code.
</t>
<t tx="ekr.20120229094652.14775">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 187, in returnPressed
    self.scon.doSearch(t)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 289, in doSearch
    self.addBodyMatches(bm)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 257, in addBodyMatches
    self.its[it] = (p, None)
TypeError: unhashable type: 'QListWidgetItem'
</t>
<t tx="ekr.20120229094652.14776">The scrolledmessage plugin no longer exists. The runScrolledMessageDialog
*does* still exist, but it now uses the viewrendered plugin.
</t>
<t tx="ekr.20120229094652.14777">Changed doButtons and doCommands kind handlers.

This allows us to put example nodes in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14779"></t>
<t tx="ekr.20120229094652.14780">Changed at.readEndOthers and at.readEndRef so that they
always set at.inCode = True
</t>
<t tx="ekr.20120229094652.14781">Fixed several encoding problems related to this thread: @shadow - @encoding windows-1250 - problem
http://groups.google.com/group/leo-editor/browse_thread/thread/a4ba80559447218a/9a37a4ed6c44d452

There were several real problems fixed.  The summary: @encoding directives were always required.

In detail:

1. at.initWriteIvars now checks for a Python # -*- coding: line.
   If present, it must be the very first line.
   If present, it will override any @encoding directives.

2. g.getPythonEncodingFromString now can deal with either of the following lines:

    @first # -*- coding: utf-8 -*-
    # -*- coding: utf-8 -*-

That is, g.getPythonEncodingFromString can strip the leading @first.

3. g.readlineForceUnixNewline and x.propagate_changes now catch UnicodeDecodeError.
   This is very important: previously decoding errors crashed Leo!.

All unit tests pass with both Python 2.x and 3.x.

</t>
<t tx="ekr.20120229094652.14782">Added configure_hard_tab_width method.
</t>
<t tx="ekr.20120229094652.14783">https://bugs.launchpad.net/leo-editor/+bug/800311

Having set undo to word granularity, I often change something, move to a
different line and continue editing there. When I want to undo my last change,
Leo also undoes the change in the other place, as word granularity currently
only recognizes a new undo step when a new word is started, no matter if we
moved to a completely different position first.

The attached patch fixes the issue by remembering the previous cursor position.

Something else about the undo code:

- oldSel and newSel are never set to None in the constructor -&gt; it's quite hard
  to know they are there without reading the whole code

- It would be cool if there could be some more comments in that section; e.g. to
  tell that oldSel and newSel from which old_row, old_col, new_row and new_col
  actually mean: old = "the position right before doing the change" and new =
  "the position right after doing the change" and that old != "the position
  after the change before" (which I added as prevSel) - it took me ages to
  discover this

- There are duplicate "The new and old characters are not contiguous." checks.
  Are they different/necessary?

- The "We have just inserted a line." section is not only entered on a new line
  (see other attached patch)
</t>
<t tx="ekr.20120229094652.14784">https://bugs.launchpad.net/leo-editor/+bug/800312
</t>
<t tx="ekr.20120229094652.14785">https://bugs.launchpad.net/leo-editor/+bug/880975

Bug: The Meta+Ctrl section [of print-bindings] is always empty and this makes it
misleading.

Fix: the prefix list in k.printBindings must be sure that if two prefixes have a
common leading part the longer prefix appears first in the lists.
</t>
<t tx="ekr.20120229094652.14786">https://bugs.launchpad.net/leo-editor/+bug/823601
</t>
<t tx="ekr.20120229094652.14787">Code that wants to set a particular part of a widget's style sheet calls::

   g.app.gui.update_style_sheet(w,key,value)

where w is the widget whose stylesheet is to be changed, key is unique
to the method (or group of methods), and value is the new version of
the stylesheet **for the particular key** to be added.  Examples::

   # In setEditorColors.
   sheet = 'background-color: %s; color: %s' % (bg,fg)
   g.app.gui.update_style_sheet(obj,'colors',sheet)

   # In add_border.
   sheet = "border: %spx solid %s" % (
       c.focus_border_width,c.focus_border_color)
   self.update_style_sheet(w,'border',sheet)

   # In remove_border.
   sheet = "border: %spx solid white" % (c.focus_border_width)
   self.update_style_sheet(w,'border',sheet)

So add_border and remove_border work together because they use the
same 'border' key.

g.app.gui.update_style_sheet is straightforward: it injects a Python
dict called leo_stylesheet_dict into the widget, and computes the
total stylesheet as follows::

   # Step one: update the dict.
   d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}
   d[key] = value
   w.leo_styles_dict = d

   # Step two: update the stylesheet.
   aList = [d.get(key) for key in list(d.keys())]
   s = ';'.join(aList)
   w.setStyleSheet(s)
</t>
<t tx="ekr.20120229094652.14817">g.importFromPath ('html','C:/leo.repo/trunk/leo/modes/html.py')
returned the standard Python html module!

</t>
<t tx="ekr.20120229094652.14818">The fix was to use lowercase versions of docPart,leoKeyword,nameBrackets.
</t>
<t tx="ekr.20120229094652.14820">Worked around docutils problem in writeToDocutils.
</t>
<t tx="ekr.20120229094652.14822">not written: c:\recent\data3.html
exception removing: 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 5280, in remove
    os.remove(fileName)
WindowsError: [Error 3] The system cannot find the path specified: ''
</t>
<t tx="ekr.20120229094652.14823">There were two bugs:
    
- baseScannerClass.skipWsToken must not skip newlines!
- tokenize must add any remaining whitespace at the end of the loop.
</t>
<t tx="ekr.20120229094652.14824">The code didn't work for c == None.
</t>
<t tx="ekr.20120229094652.14825"></t>
<t tx="ekr.20120229094652.14826">http://groups.google.com/group/leo-editor/browse_thread/thread/3c319daba37cd0ef

- Created a separate html importer, a very simple subclass of the xml scanner
  whose only difference is that it uses @data import_html_tags instead of @data
  import_xml_tags.

- The case of tags in @data import_html_tags and @data import_xml_tags no longer matters.

- checkTrialWrite now writes a file *with* sentinels, to handle @others correctly.
  It then removes the sentinels.
  
  This means that the import tests must use the correct @language directives.
  
- The import check now uses a token-based comparison.  
</t>
<t tx="ekr.20120229094652.14827">The fix was in g.pr:
    
Restored the call to sys.stdout.write(s2) (instead of print)

sys.stdout.write(s2) writes no additional newline at the end of s2.

Aha!  At last I know how to unit test g.pr, g.trace, etc.: redirect stdout!
</t>
<t tx="ekr.20120229094652.14828"> File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in
scanAndCompare
   n1,n2,ok = self.compareTokens(tokens1,tokens2)
 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in
compareTokens
   else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
</t>
<t tx="ekr.20120229094652.14829">- Created stand-alone unit tests from @test import dataN.html.
- All leoImport unit tests may now be run externally.
    The Python unit tests were failing because of intermixed tabs and blanks.
    This was fixed by putting @tabwidth -4 in all @test nodes for Python.
- Made sure lines are printed when unit tests fail unexpectedly.
- Added .js &amp; javascript entries to global data structures for javascript unit tests.
- Completed xmlScanner.filterTokens.
- Don't create declaration nodes for html.
- Make sure html tags are as expected.
- Ignore case of html/xml tags.

Rev 4774.1.1:

Fixed all known html-import problems in a clean way. Unit tests exists, but they
use external files. They will be converted soon.

Important changes:

1. Added hasNestedClasses ivar in the baseScannerClass, True only for xml/html scanners.

When True, scanHelper and skipDecls allocate a substring to be used for all further scanning.
This is the *only* way to limit Leo's scanners properly.

This was, in essence, the fix for duplicate code generation arising from unbalanced tags:
skipToEndOfTag and skipToMatchingTag can't match outside the present tag because
the 's' argument passed to those methods has already been truncated.

This is a simple, elegant solution, and in essence the *only* proper solution.
For example, it would not work to past an 'end' argument to skipToEndOfTag and skipToMatchingTag
because the scanners inside those methods do not understand an 'end' argument.

Thus, the simplest, most efficient solution is for scanHelper and skipDecls to truncate the
string to be scanned. That way, the truncation happens at most once per "class".

2. Added hasDecls in the baseScannerClass, False only for xml/html scanners.

Various methods call skipDecls only if this ivar is True.

Rev 4773:

Fixed recent botch: both single and double quotes are allowed in html. 

Rev 4772:

Solved "between element" problem by extending classes up to the next class.
data.html imports "correctly", but not perfectly due to tag mismatches in
skipToMatchingTag.
</t>
<t tx="ekr.20120229094652.14831">http://groups.google.com/group/leo-editor/browse_thread/thread/421ebf4c3f2d5f59

Adding/deleting body editor 3 times hard-crashed Python

The changes were straightforward:
    
- set w.leo_label to None when calling unpackWidget.

- Test for w.leo_label before using it.

Added a minitest.  To test by hand, add the following @button nodes:
    
    @button add-ed
    w = c.frame.body.addEditor()
    
    @button del-ed
    w = c.frame.body.deleteEditor()
    
Click away in any order...
</t>
<t tx="ekr.20120229094652.14832">The new add-comments command adds the comment character at the leftmost column.

The new delete-comments command will remove the comment characters inserted by
either the old or new version of the add-comments command.
</t>
<t tx="ekr.20120229094652.14833">Example: ctrl-shift-home.

The fix was to set self.widget = contents in leoQtLog.selectTab.
</t>
<t tx="ekr.20120229094652.14835"></t>
<t tx="ekr.20120229094652.14836">The safe default pane is the body pane.  It's also the simplest code.
</t>
<t tx="ekr.20120229094652.14837">The code must be careful that the log widget supports the HighLevelInterface.
</t>
<t tx="ekr.20120229094652.14838"></t>
<t tx="ekr.20120229094652.14839">The bug was in k.handleDefaultChar.  No substantial change made to eventFilter.
</t>
<t tx="ekr.20120229094652.14840">What I did:
    
1. Fixed major bug in settingsTreeParser.visitNode.
   It now does p.copy() to protect the callers traverals.
   This could have significant impacts on people's settings.
   
2. Added g.app.unitTestDict for unit testing.

3. Leo now extends the list of @buttons and @commands, rather than replacing them.
   This is reasonable only because leoSettings.leo should never define *active*
   buttons or commands.
</t>
<t tx="ekr.20120229094652.14841"></t>
<t tx="ekr.20120229094652.14842">https://bugs.launchpad.net/leo-editor/+bug/804960

When we clone a node inside an @shadow (containing @others) node and then
refresh the @shadow node from file, the clone is unlinked and marked as changed.
If we now save, close the .leo file and open it again, the nodes are linked
again! (showing "cloned" symbol) User's thought: "How the heck can the file
change _between save and re-open_ when I changed nothing?"

I think what should be done about this is the check that Leo does when it opens
the file again, and that check should be done immediately after the "refresh
node from file" operation. Also, at this point, the "Recovered nodes" node
should appear (if file and node have both changed), not only after the next .leo
file close/reopen (as that happens quite infrequently, I guess, e.g. once a day
for me). Otherwise, the user can easily lose data.
</t>
<t tx="ekr.20120229094652.14848">&gt;  File "/path/to/leo/core/leoImport.py", line 2070, in reportMismatch
&gt;    line = repr(lines2[i])
&gt; IndexError: list index out of range
</t>
<t tx="ekr.20120229094652.14849"></t>
<t tx="ekr.20120229094652.14850">The fix was to at.putBody.
</t>
<t tx="ekr.20120229094652.14855">http://groups.google.com/group/leo-editor/browse_thread/thread/daf581ace0de871e

"has been modified outside of Leo. Overwrite this file?"

Steps to reproduce:

- Create a node "@edit ~/aaa.txt" assuming aaa.txt does not exist
- Ctrl-S save outline, log reports creating ~/aaa.txt
- Edit text in body
- Ctrl-S save outline, pop-up pops-up erroneously.

The problem was that replaceTargetFileIfDifferent should set root.v.at_read.
Now it does.

Note: both replaceFileWithString methods are part of the @shadow logic,
so there is no need to set any at_read bit in those methods.
</t>
<t tx="ekr.20120229094652.14856">https://bugs.launchpad.net/leo-editor/+bug/889175

I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn.

Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

-----

I now see this happens also if the path change is in a @path node ancestor of the @auto node.
</t>
<t tx="ekr.20120229094652.14891">DynamicWindow.setGeometry now does *not* change the window size when using the qttabs gui.

Added a comment to this effect in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14892">https://bugs.launchpad.net/leo-editor/+bug/87933
    
- Fixed the Shift-Tab buglet by adding lower-case entries in app.tkNamesList
    This matches what is done in k.settingsNameDict.
- Created &lt;&lt; define global key dicts &gt;&gt; in leoApp.py.
- Changed si.val to si.stroke.
- Replaced g.bunch by GeneralSetting &amp; ShortcutInfo.
- Replaced bunchList by aList.
- Removed dynamic_menus "compile-time" constant.
- onAboutToShow now recomputes the contents of menus whenever menus are invoked.
- leo_update_shortcut now shows all shortcuts for a command.
- Wrote and tested merge_settings_dict.
</t>
<t tx="ekr.20120229094652.14893">Bug 879331: Redefining a key binding breaks menu items with same binding

https://bugs.launchpad.net/leo-editor/+bug/879331

&gt; Now I understand.  If I override the shortcut associated with the menu
&gt; item, in this case Alt-A, the menu breaks.

This is a serious bug!  The menu item now executes the command bound
to Alt-A!  Very bad.

=========

http://groups.google.com/group/leo-editor/browse_thread/thread/762e832909c3c530/d99d48eed45d1061

http://mail.google.com/mail/#inbox/1331909dd653f3c9

Redefining a binding, say for Alt-a, in x.leo will cause the sort-siblings menu
(bound to alt-a) to execute the command specified by the command bound to Alt-a!

https://bugs.launchpad.net/leo-editor/+bug/815564

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14894">https://bugs.launchpad.net/leo-editor/+bug/815564

===== Probably the same as bug 879331 =====

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14925">k.computeInversBinding() called by print-commands and for auto-completion.

k.bindKey sets k.bindingsDict.

k.bindKeyToDict sets k.masterBindingDict.
</t>
<t tx="ekr.20120229094652.14934">Created k.kill_one_shortcut, called from k.remove_conflicting_definitions.
</t>
<t tx="ekr.20120229094652.14941">The new TM.findMarkForUnitTestNodes allows both
TM.FindAllUnitTestsNodes and createOutline to be much simpler.
</t>
<t tx="ekr.20120229094652.14942"></t>
<t tx="ekr.20120229094652.14973">The fix was to save/restore YScroll position in body.setSelectionAreas.

Failure case 1:
    - Search for something.
    - Manually scroll the pane.
    - Click scrolls the pane again.
    
Failure case 2:
    - reformat-paragraph.
</t>
<t tx="ekr.20120229094652.15012">Fixing this bug is important: it allows you to set a default
page width in myLeoSettings.leo for use, for example, in the
reformat-paragraph command.

Without a proper default c.page_width setting, you would have
to use @page_width instead, which is much less convenient.

The fix was the following lines in c.initConfigSettings:
    
    c.page_width = getInt('page_width') or 132
        # 2012/02/27: this appears to be a fix of an *ancient* bug.
</t>
<t tx="ekr.20120229094652.15013">The fix was easy: moveWithinLineHelper does *not* call
leoMoveCursorHelper for the case spot == 'end-line'
</t>
<t tx="ekr.20120229094652.15089">http://groups.google.com/group/leo-editor/browse_thread/thread/b17d140b7ceb8fc9

I've added web page bookmarking from your browser to Leo.

Docs., appended to the mod_http plugin, where this functionality lives,
are pasted below.

Screen shot of the form which pops up when you click the Bookmark
button in your browser attached.  The body text of the corresponding
bookmark node created in Leo is:

    Leo's Home Page
        http://leoeditor.com

        Tags: leo, python

        Leo's Home Page

        Collected: Sun 02 Oct 2011 02:52:51 PM CDT

        Keep this under your pillow.

If you had some text selected on the page in your browser that would
also appear in the above, and repeatedly bookmarking the same page with
different selections incrementally adds such quotes to the bookmark
node.

Here are the docs.:

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&amp;name=' + escape(d.title) + '&amp;selection=' + escape(window.getSelection()) + '&amp;url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks--&gt;Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox. 
</t>
<t tx="ekr.20120229094652.15090">http://groups.google.com/group/leo-editor/browse_thread/thread/4686ebad81bb1ea1
</t>
<t tx="ekr.20120229094652.15091">- Selecting any node using arrow keys shows the node in the outline immediately.

- Clicking a node or hitting &lt;return&gt; puts focus in body pane.
</t>
<t tx="ekr.20120229094652.15093">Small improvements the unit testing framework created big results. They
completely eliminate the overhead in running unit tests:

    - The run-marked-unit-tests-externally (Alt-4) command runs all marked
      @test nodes. To choose tests, just mark them.
    - Alt-4 now saves the .leo file first.
    - Almost all unit tests may now be run externally:
        - External unit tests always read config settings.
        - The nullGui now uses a fully capable string-based body widget.
        - The nullGui now uses the regular undoer.
    - Unit tests now always have the sources available.
    - Disabled messages on external unit tests.
    - The unit test commands always run a selected @test node.

These improvements mean that almost all unit tests may be run externally.
In turn, this creates a remarkable work flow::

    Edit
    Alt-4
    Edit
    Alt-4
    ...

The energy difference between weightless and heavy is astounding. Try the
new way: you will surely like it.

**Notes**:

Experience shows that being able to run the desired unit tests *without*
selecting any particular node makes an amazingly large difference. Being
able to run all and only marked unit tests is a big step forward.

If a marked node is neither an @test node nor an @suite node, all nodes in
the tree are considered to be marked.
</t>
<t tx="ekr.20120229094652.15098">.. .. http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

Many thanks to Ludwig Schwardt for the following installation instructions.
Using the HomeBrew installation method is *much* easier than before.

I recently received a new MacBook Pro and did a fresh upgrade to Mac OS
10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is that
the excellent Homebrew (mxcl.github.com/homebrew/) makes things much easier
these days.

Why Homebrew? It does not try to replace every single bit of functionality
on your Mac with their own version, like Macports or fink. It reuses the
existing libraries as far as possible. No need to reinstall Python, for
example (one of my pet gripes when people try to install new software on
their Macs, and the source of much confusion and pain). It installs to
/usr/local, the standard place to find third-party libraries and headers,
instead of the obscure /opt or /sw. It's simple to use and to extend.

Here is my installation write-up:

- Read the Homebrew installation instructions at http://brew.sh/

- Make sure you have Xcode installed (test it by confirming that "gcc" runs
  in the Terminal). Only the smaller command-line tools are required;
  there is no need to get the full Xcode beast.

- In preparation for Homebrew, the best option in my opinion is
  to delete /usr/local via::

    sudo rm -rf /usr/local

  and install any software in it via HomeBrew instead.
  
  Note from EKR: The HomeBrew package manager is so easy to use
  that you will find replacing deleted packages a snap.
  
  If deleting /usr/local fills you with dread (you do not want to lose your
  beloved third-party software), the second-best option is to make sure you
  have write permission for the directory via::

    sudo chown -R &lt;your user name&gt;:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running the
  following command in the Terminal::
    
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

- Run "brew doctor" and check any further suggestions to improve your system.

  EKR note: I thought I had installed command-line tools after installing
  the XCode page. I hadn't, and "brew doctor" told me so.

- Run "brew update" to get the latest formulas

- Install sip and note the caveat::

    brew install sip

  This warns you to add the local python directory to your PYTHONPATH.
  Make a note of what this is (especially if you are not on Lion!).

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard). This is the default for LION::

      export PATH=/usr/local/bin:$PATH
      # This is for SIP (and PyQT) as suggested by Homebrew
      export PYTHONPATH=/usr/local/lib/python2.7/site-packages:$PYTHONPATH

- Install PyQT::

    brew install pyqt
 
- Open a new Terminal tab / window so that the above settings take effect,
  and install Leo. I downloaded the Leo-4.9-final-a.zip, unzipped it, and
  ran "python launchLeo.py" inside the Leo directory.

It would really be great to get a Leo formula going for Homebrew. As
mentioned before, the main question is just where to place all the Leo
files in the /usr/local hierarchy.
</t>
<t tx="ekr.20120229094652.15099">Put @command nodes as children of an @commands node in myLeoSettings.leo.
This makes the the @command nodes available to all opened .leo files.

Using @command rather than @button means that there is never any need to
disable scripts. There is no need for @button. To see the list of your
\@command nodes, type::

    &lt;alt-x&gt;@c&lt;tab&gt;
    
Similarly to see the list of your \@command nodes, type::

    &lt;alt-x&gt;@b&lt;tab&gt;
</t>
<t tx="ekr.20120229094652.15124">It sometimes happens that the focus gets left in a Leo
widget that doesn't support Leo's key bindings. You would
think that you would have to use the mouse to click in, say,
the body pane so that you can use Leo's key bindings again.

But you don't have to do that.  Instead, use Alt-tab once to change
away from Leo, and then use Alt-tab again to change back to Leo.  When
you do this, Leo puts focus in the body pane and you are all set.
</t>
<t tx="ekr.20120229094652.15125">When running unit tests externally, Leo copies any @mark-for-unit-tests nodes
to dynamicUnitTest.leo.  Of course, this is in addition to all @test nodes
and @suite nodes that are to be executed.
You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

**Note**: putting @settings trees as descendants of an @mark-for-unit-test node
will copy the @setting tree, but will *not* actually set the corresponding settings.
</t>
<t tx="ekr.20120229094652.15130">@pagewidth 75

Q. When I run the following script I see a window appear and then
immediately disappear::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()
    
What's going on?

A. When the script exits the sole reference to the window, w, ceases to
exist, so the window is destroyed (garbage collected). To keep the window
open, add the following code as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time you run the
execute-script. If you want something even more permanent, you can do
something like::

    g.app.my_script_w = w
</t>
<t tx="ekr.20120229094652.15131">From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
</t>
<t tx="ekr.20120229094652.15132">import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
</t>
<t tx="ekr.20120229094652.15133">def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) &gt; 0:
       while len(levels[-1]) &gt; 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
</t>
<t tx="ekr.20120229094652.15134"></t>
<t tx="ekr.20120229094652.15135">The leoInspect module provides answers to questions about Python source
code. leoInspect is an elegant and easy-to-use front end for Python's AST
(Abstract Syntax Tree) trees *and* a window into a richly connected set of
semantic data built *from* AST trees.

For details, see http://leoeditor.com/leoInspect.html
</t>
<t tx="ekr.20120229094652.15137">.. .. http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222

1. Archive and remove the previous version of Leo.
2. Download the nightly snapshot zip file.
3. Unzip it into the same place as the previous version.
4. Enjoy your up-to-date Leo code...

To make this work, it's important to keep your folder containing Leo
separate from your .mySettings.leo and any data files.
</t>
<t tx="ekr.20120229094652.15138">http://groups.google.com/group/leo-editor/browse_thread/thread/5fdadfba113e12d9/fa329534654ecfec

Leo now reports bzr version numbers and dates automatically.  Very important.
</t>
<t tx="ekr.20120229094652.15139">Note: in rev 4990, the g.app.newCommander method (formerly called
g.app.newLeoCommanderAndFrame) also returns a single value (a
Commander) rather than the tuple (c,c.frame). 
</t>
<t tx="ekr.20120229094652.15140">http://groups.google.com/group/leo-editor/browse_thread/thread/dd5907529208ee98

The body of @openwith nodes contains one or more lines of the following
form::

   tag: value

The possible tags are::

    kind: &lt;a string&gt;

The value specifies the **opener logic**, that is, the method used to
launch the external editor, one of 'subprocess.Popen', 'os.startfile',
'os.spawnl', 'os.spawnv', 'exec'.

    arg: &lt;a string&gt;

There may be many such arg lines. Each line will be a string to be passed
as an argument to the opener logic, in a format that is compatible with the
specified opener logic.

Quotes in &lt;a string&gt; will be *retained*, allowing the user to specify
exactly the arguments to be passed to opener logic.

..  custom: &lt;a string&gt;
..  Here, &lt;a string&gt; *will* be eval'd, yielding an object to be used as
..  the opener logic.
</t>
<t tx="ekr.20120229094652.15142">http://groups.google.com/group/leo-editor/browse_thread/thread/808ba29fec64e590

For almost 15 years Leo has been written using a limited set of classes.
These were "big" classes, implementing major modules of Leo. There is
nothing wrong with these classes, and they will remain unchanged, except
insofar as they will be simplified by the classes I am about to discuss.

Recently, I have become aware that Leo's code could be considerably
simplified by adding "smallish" classes. Indeed, I now think the
distinction between big and small classes is unhelpful. The most important
part of the design of a class is simply whether a class implements an
understandable concept.

With this introduction, here is a short summary of Leo's new classes. Some
have not been fully implemented. Getting them all to work is a big part of
the rewrite of Leo's config, loading and key-handling code.

</t>
<t tx="ekr.20120229094652.15143"></t>
<t tx="ekr.20120229094652.15144">leoSettings.leo:

table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),

        # Next, &lt;machine-name&gt;leoSettings.leo in the home directories.
        # join(g.app.homeDir,     machine_fn),
        # join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )

myLeoSettings.leo:

    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir,          settings_fn),

        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),
    
        # Next, &lt;machine-name&gt;myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     machine_fn),
        join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
</t>
<t tx="ekr.20120229094652.15146">http://groups.google.com/group/leo-editor/browse_thread/thread/c933b28c27d3b9a7

Ref 4952 of the trunk fixes bug 87933:
"Redefining a key binding breaks menu items with same binding"

This was a difficult bug to fix--I rewrote significant parts of Leo's
code that deals with settings for key binding.

Besides fixing the bug, Leo computes accelerators in menu items
dynamically when the user activates a menu.  The accelerator shows
*all* keys bound to the command associated with the menu item.

From the checkin log:

A major reorganization of the configuration code that fixes bug 87933
Redefining a key binding breaks menu items with same binding

- Replaced g.bunches with ShortcutInfo objects...

- Wrote and tested make_settings_dict and its helpers,
  merge_settings_dicts, invert and uninvert.

- Leo computes menu texts dynamically in onAboutToShow.

- leo_update_shortcut now shows all shortcuts for a command.

- leoMenu.define_enable_dict encapsulates data used to enable/disable
  commands regardless of where those commands appear in Leo's menu. The old
  code assumed that a fixed menu location for all commands that could be
  enabled or disabled.
</t>
<t tx="ekr.20120229094652.15147">End going to only physical line and not to the logical (wrapped) one)... 
</t>
<t tx="ekr.20120229094652.15148">.. _`this posting about BibTeX citations`: http://groups.google.com/group/leo-editor/browse_thread/thread/d36d76174dcd6786/9c2a298049f4f01c

.. _`raw-data`: http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data-pass-through

When using LaTeX and BibTeX, I would like to use inside of Leo a kind of
LaTeX-inline-markup, that after generation of the RsT file through Sphinx
as well as after running of "make latex", generate a LaTeX file containing
the citation call of the form \cite{CITBook001} as described in a file
\*.bib. Is there a way to have Leo/Sphinx/RsT generate the inline raw latex
syntax?

Use the docutils `raw-data`_ syntax. Examples::

    .. role:: raw-role(raw)
      :format: html latex
    .. raw:: latex
      \bibliographystyle{acm}
      \bibliography{myBibliography}
      
For more details, see `this posting about BibTeX citations`_.
</t>
<t tx="ekr.20120229094652.15149">http://groups.google.com/group/leo-editor/browse_thread/thread/ba9eb63337467d42/a3f3750d0ce6e847

&gt; Here's a one line @button node you can add to myLeoSettings.leo
&gt;
&gt; @button set-style
&gt;    c.frame.top.leo_ui.setStyleSheet(p.b)

Cool.  I've added this to my "pre-writing" pile of things to be
included in the next set of docs.

Important:  setStyleSheet *replaces* the previous stylesheet with the
new stylesheet, so you had best set all the attributes of Leo's
default stylesheet.

As an alternative, if w is any Qt widget, w.setStyleSheet(p.b) will
set the stylesheet for that widget only: the top-level stylesheet (the
stylesheet for c.frame.top.leo_ui) remains unchanged.
</t>
<t tx="ekr.20120229094652.15151">http://groups.google.com/group/leo-editor/browse_thread/thread/b49d23010703aa61/32e1271d25ba2cfb
</t>
<t tx="ekr.20120229094652.15152">Some people seem to think that it is difficult to understand how Leo
handles "clone wars": differing values for a cloned nodes that appear in
several external files. That's not true. The rule is::

    **The last clone that Leo reads wins.**

That is, for any cloned node C, Leo takes the value of C.h and C.b to
be the values specified by the last copy that Leo reads.

There is only one complication::

    **Leo reads the entire outline before reading any external files.**

Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value for C
in x.py or y.py, depending on which @&lt;file&gt; node appears later in the
outline.

**Note**: Whenever Leo detects multiple values for C when opening an
outline, Leo creates a "Recovered nodes" tree. This tree contains all the
various values for C, nicely formatted so that it is easy to determine
where the differences are.

</t>
<t tx="ekr.20120229094652.15153">http://groups.google.com/group/leo-editor/browse_thread/thread/3666397da2a0d05f/758071d6d9516ab9

The right-click context menu on the tabs in the tabbed window mode (the
default) has a 'Detach' option, if there's more than one outline/tab, and a
Re-attach all option, if there's a detached outline window out there.

Now there's also 'Horizontal tile', and 'Vertical tile', which detach the
tab and then tile its window with the window from which it was detached.

This is very helpful for moving nodes between outlines, I was rearranging
the windows by hand and setting one to 'always on top' with the window
manager before. Note: there's a @setting to determine whether dragging
nodes between outlines copies or moves them.

Depending on your OS / window manager, tiling / placement may be somewhat
off, and may work better with or without the window being maximized before
tiling, you'll have to experiment.

When you close an outline window created by detaching a tab the outline is
just re-attached as a tab. This means it's now possible to reattach just
one outline, rather than having to use the 'reattach all' option.
</t>
<t tx="ekr.20120229094652.15157"></t>
<t tx="ekr.20120229094652.15158">After so many years of confusion the problem is now apparent:
the Windows console uses code page 437: which is just extended ascii.

chcp 65001 is equivalent to utf-8, and it would be good to use,
but at present bzr goes nuts and changes to another code page!

So for the moment I'll have to live with what is, in effect, plain ascii.
</t>
<t tx="ekr.20120229094652.15159">On Ubuntu only, the auto complete popup is system-wide modal, it should only be modal over Leo windows.

However, there does not seem to be any fix:
http://groups.google.com/group/leo-editor/browse_thread/thread/171aaf79e0bea256

All works well on Windows 7.  I do see the "system-wide" model
behavior on Ubuntu.

This appears to be a Ubuntu-specific bug.  Indeed, the popup is a
QListWidget.  Such widgets have a setWindowModality method::

    setWindowModality ( Qt::WindowModality windowModality )

The valid modalities are at: http://doc.qt.nokia.com/4.7-snapshot/qt.html#WindowModality-enum

NonModal: The window is not modal and does not block input to other
windows.

WindowModal: The window is modal to a single window hierarchy and
blocks input to its parent window, all grandparent windows, and all
siblings of its parent and grandparent windows.

ApplicationModal: The window is modal to the application and blocks
input to all windows.

None of these would appear to be a system-wide modality, and
furthermore, the default is supposed to be NonModal.

Anyway, calling setWindowModality(QtCore.Qt.NonModal) does not seem to
have much effect on Ubuntu, so I think I can safely say there is
nothing more I can do. 
</t>
<t tx="ekr.20120229094652.15162"></t>
<t tx="ekr.20120229094652.15163"></t>
<t tx="ekr.20120229094652.15164"></t>
<t tx="ekr.20120229094652.15165"></t>
<t tx="ekr.20120229094652.15166"></t>
<t tx="ekr.20120229094652.15168"></t>
<t tx="ekr.20120229094652.15169"></t>
<t tx="ekr.20120229094652.15176"></t>
<t tx="ekr.20120229094652.15178"></t>
<t tx="ekr.20120229094652.19777">- open-with hook has changed: it now uses a "d" arg.
</t>
<t tx="ekr.20120229173025.20633">http://groups.google.com/group/leo-editor/browse_thread/thread/d21349c52dabd066

Ever find that you have a whole lot of:

.. sourcecode:: py

  rec[f['analyte']] ... rec[f['sample_type']] ...

expressions in your code, and now things have changed and you want them
all to be:

.. sourcecode:: py

  row.Analyte ... row.Sample_Type ...

basically if str variable s was::

  rec[f['analyte']]

then you want to perform:

.. sourcecode:: py

  s = "row."+s.split("'")[1].title()

on each one.  In general it would be nice to be able to use a python
expression when search and replace doesn't cut it.

The button code below creates a button, ``fac``, which, when pressed,
creates another button, with some name you choose, which, when pressed,
executes some python code to fix the selected text in the body.

You can define the code to be executed in two ways, either in its own
node:

 - insert a new node with a headline which describes the refactor
 - enter code in the node which modifies the string variable ``s``,
   which is initially set to the selected text in the body
 - press the ``fac`` button, which creates a new button named
   after this code node
 - select each offending piece of text and press the button created
   in the previous step to fix

or

 - type some code modifying ``s`` right in the body you're working on
 - press the ``fac`` button, which creates a new button named "fix"
 - select each offending piece of text and press the button created
   in the previous step to fix

Note:

 - unlike regular button nodes, changing the code after the
   button's created (first option above) doesn't change the code
   executed by the button
 - replacing selection text makes Leo reposition the insert point at
   the top of the window, this is annoying but unrelated to this code

Here's the button code:

.. sourcecode:: py

  @button fac
    from leo.plugins.mod_scripting import scriptingController

    sc = scriptingController(c)

    if c.frame.body.hasSelection():
        code = c.frame.body.getSelectedText()
        heading = 'fix'
    else:
        code = p.b
        heading = p.h

    def transform(c=c, code=code):
        s = c.frame.body.getSelectedText()
        g.es(s)
        exec code
        g.es(s)
        c.frame.body.deleteTextSelection()
        i = c.frame.body.getInsertPoint()
        c.frame.body.insert(i, s)
        p.b = c.frame.body.getAllText()
        c.frame.body.setInsertPoint(i)

    b = sc.createIconButton(
        heading,
        command = transform,
        shortcut = None,
        statusLine = 'Make filter button',
        bg = "LightBlue"
    ) 
</t>
<t tx="ekr.20120229173025.20635">@language python

from leo.plugins.mod_scripting import scriptingController

sc = scriptingController(c)

if c.frame.body.hasSelection():
    code = c.frame.body.getSelectedText()
    heading = 'fix'
else:
    code,heading = p.b,p.h

def transform(c=c,code=code):
    w = c.frame.body
    s = w.getSelectedText()
    g.es(s)
    exec(code)
    g.es(s)
    w.deleteTextSelection()
    i = w.getInsertPoint()
    w.insert(i,s)
    p.b = w.getAllText()
    w.setInsertPoint(i)

sc.createIconButton(
    heading,
    command = transform,
    shortcut = None,
    statusLine = 'Make filter button',
    bg = "LightBlue"
)
</t>
<t tx="ekr.20120313074006.14640">Leo's abbreviation code is now simpler and more general than before. The
downside is that you will likely have to revise your abbreviations. I
believe the extra work will be well worthwhile.

Here are the changes:

1. Abbreviations may consist of *any* sequence of characters, including
whitespace or "special" characters. You may include whitespace characters
in definitions using the '\t' and '\n' escapes. However, whitespace may
only appear at the *end* of definitions.

2. You must take care to disambiguate abbreviations if one is a prefix of
   another.

Here is an example of both points.  As always, you define
abbreviations in the body of an @global-abbreviation node or
@abbreviation node::

    nc =@nocolor\n
    nc\n=@nocolor\n
    nc\t=@nocolor\n

    ncn=@nocolor-node\n

As you can see, the definitions uses whitespace at the end
of the definition of "nc" to prevent it from being expanded
when typing "ncn".

3. The reason I call these abbreviations "instant" is that they can be
triggered on *any* keystroke, not just the end of a "word".  This
allows you to define::

    teh=the

Hurray!

4. Two rules limit scans.  They are useful and shouldn't cause
hardships.

A.  The backspace and delete characters *never* trigger substitutions.

B. The scan for definitions ends at the first newline
character. Therefore, whitespace will have effect only at
the *end* of a definition.

**Important**: these rules can cause problems when *defining*
abbreviations:  it's easy to trigger an unwanted definition.  The
solution is to use rule 4B:

I want to type::

    ncn=@nocolor-node\n

But I **cant** type this directly if nc is already defined!  The trick
is to type::

   nxcn=@nocolor-node\n

and then delete the leading x with a backspace character.

Of course, you could also turn abbrevions off while defining abbreviations...

Instant abbreviations solve the problems with Brazilian
keyboards. Just define::

    ~a=ã
    ~A=Ã
    etc.

This works regardless of keyboard, regardless of OS, etc.
You might want to define::

    ~\a=~a
    ~\A=~A

in the somewhat unlikely event that you want to type ~a rather than,
say, ~+a.  Of course, you don't need these, provided you remember to
type ~xa &lt;Right&gt;&lt;Delete&gt; :-)
</t>
<t tx="ekr.20120313074006.14643">k.remove_conflicting_definitions always gives the warning, not just when tracing.

The warning isn't the best, and it is usually duplicated, but it is much better than nothing.
</t>
<t tx="ekr.20120313074006.14648">https://bugs.launchpad.net/leo-editor/+bug/930726

Bug: If the node is not expanded already, then the position
is left on the parent, not the first child.

Function expandNodeAndGoToFirstChild() is referenced only
once in LeoPyRef.leo. This reference is in table of public
Leo commands.

The node in which expandNodeAndGoToFirstChild() is defined
also contains the definition of function
expandNodeOrGoToFirstChild(). At present these two functions
are equivalent. The comments including the header for the
node imply that they should not be equivalent and that
expandNodeAndGoToFirstChild() is not correctly implemented.
</t>
<t tx="ekr.20120313074006.14650">https://bugs.launchpad.net/leo-editor/+bug/869429
Undo and Redo delete from context menu does not redo properly

The fix was to deletenodes_rclick in contextmenu.py.
The fallback position should be c.rootPosition()
</t>
<t tx="ekr.20120313074006.14655"></t>
<t tx="ekr.20120313074006.14657">https://bugs.launchpad.net/leo-editor/+bug/823267

When tabs are closed with the close tab 'X' on the tab, focus
should go to whichever tab becomes visible, but it does not,
it goes to an arbitrary tab which may not be visible. If you
then hit Alt-X expecting to cut the highlighted node in the
visible tab, you cut a node you can not see in a different
commander.

What I did:
    
- Refactored part of g.app.closeLeoWindow into g.app.selectLeoWindow.
- Added the new_c argument to g.app.closeLeoWindow and c.close.
- Changed several event handlers in TabbedFrameFactor so that they
  call g.app.selectLeoWindow as appropriate.
</t>
<t tx="ekr.20120313074006.14663">https://bugs.launchpad.net/leo-editor/+bug/917814
</t>
<t tx="ekr.20120313074006.14697">https://bugs.launchpad.net/leo-editor/+bug/924123

These syntax errors were minor in the sense that they had no
effect on Leo's users, but they were a significant
distribution issue because Linux packages are not to have
such errors.

I removed the following files. Apparently, they are used nowhere in Leo. 
    
    leo/core/leo_Debugger.py
    leo/core/leo_FileList.py"
    leo/core/leo_RemoteDebugger.py
    leo/core/leo_Shell.py
    leo/core/leo_run.py

This files no longer exists:

    leosax.py
</t>
<t tx="ekr.20120313074006.14698">https://bugs.launchpad.net/leo-editor/+bug/844953

1. Open two empty files with the Leo revision 4451/trunk using the qttabs GUI and save them both.
2. Create a new node and write "Abc" in its head.
3. Select "Copy Node" from the outline menu.
4. Select "Paste Node As Clone" from the outline menu:
   Node is not inserted as clone, but inserted as a copy in the second file/tab.

Sometimes even a standard Copy-Paste action results in the node being inserted in the other file.

EKR: This a unity menu problem, not a problem with the paste commands per se.

http://qt-project.org/forums/viewthread/15366/

</t>
<t tx="ekr.20120313074006.14702">https://bugs.launchpad.net/leo-editor/+bug/501636
</t>
<t tx="ekr.20120313074006.14713">https://bugs.launchpad.net/leo-editor/+bug/799695

The fix was simply to call c.recolor_now(incremental=False)
</t>
<t tx="ekr.20120313074006.14714">https://bugs.launchpad.net/leo-editor/+bug/824087

The fix was to bind Ctrl-F4 to close-window, instead of Alt-F4.

I instantly like this new binding.
</t>
<t tx="ekr.20120313074006.14715">https://bugs.launchpad.net/leo-editor/+bug/923301
</t>
<t tx="ekr.20120313074006.14738"></t>
<t tx="ekr.20120313074006.14740">https://bugs.launchpad.net/leo-editor/+bug/875323
</t>
<t tx="ekr.20120313074006.14765">https://bugs.launchpad.net/leo-editor/+bug/831658
</t>
<t tx="ekr.20120313074006.14771">https://bugs.launchpad.net/leo-editor/+bug/875327
</t>
<t tx="ekr.20120313074006.14772">https://bugs.launchpad.net/leo-editor/+bug/807561

The isBinaryFile helper returns True if the file's extension is not known.
This isn't great, but it's safe. The list of known text types includes:
    
1. '.css','.html','.leo','.txt'
2. All extensions in g.app.extension_dict.keys().
</t>
<t tx="ekr.20120313074006.14800">Example: typing in this rest section recolors as *Python*.
The correct coloring is restored when the entire text is recolored.

In this case, a workaround, and a performance improvement, would be to put
the ``@language python`` directive before the ``language rest``.
</t>
<t tx="ekr.20120313074006.14906">- Added scanToCursor argument to c.scanAllDirectives in c.insert/removedComments.

- Added scanToCursor argument to get_directives_dict_list in c.scanAllDirectives.

- get_directives_dict_list sets scanToCursor only for the initial (root) node.

- g.get_directives_dict scans to cursor for @language directives is scanToCursor is True.
</t>
<t tx="ekr.20120313074006.15120">https://bugs.launchpad.net/leo-editor/+bug/952365

Improved error reporting and checking, but the file won't be created if
createActualFile takes an IOError.
</t>
<t tx="ekr.20120313074006.15125">https://bugs.launchpad.net/leo-editor/+bug/951921
</t>
<t tx="ekr.20120313074006.16135">http://groups.google.com/group/leo-editor/browse_thread/thread/f7eaf4dd4e84a535

Screenshot here:

https://plus.google.com/103097156557482112329/posts/6qSngscG38Y

Instructions (with current trunk):

- enable bigdash.py plugin
- alt-x global-search
- Enter "s somesearch" in the line editor and press enter
- Browse the hits. Click on link to navigate to the node.

Caveat:

If the document is not in currently active tab, the navigation is
done "in the background". Correct implementation would be to activate
the tab in order to bring attention to it. 
</t>
<t tx="ekr.20120313134250.14232">Support for the open-with command is now part of Leo's core.
</t>
<t tx="ekr.20120313134250.14294">**Important**: This was all done in Leo 4.9, but not properly documented.

Allow section references in rst3 command.

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

- Added support for the following options:
    - expand_noweb_references:  default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
</t>
<t tx="ekr.20120314095341.14216">There no need to disable buttons and commands with \@@button or \@@command.
</t>
<t tx="ekr.20120317130339.8282">@pagewidth 75

The following script won't work as intended:

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()
    
When the script exits the sole reference to the window, w, ceases to
exist, so the window is destroyed (garbage collected). To keep the window
open, add the following code as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time you run the
execute-script. If you want something even more permanent, you can do
something like::

    g.app.my_script_w = w
</t>
<t tx="ekr.20120318075211.6163"></t>
<t tx="ekr.20120318075211.6164"></t>
<t tx="ekr.20120318075211.6165"></t>
<t tx="ekr.20120318075211.6166"></t>
<t tx="ekr.20120318075211.6167">Leo's core now supports opening URL's in several ways:

1. By Control-Clicking the headline of a node containing a URL in its
   headline or the *first* line of its body text.
   
2. The open-url command opens a URL in a nodes headline or the first
   line of its body text.
   
3. By Control-Clicking any URL in the body text.

Notes::

- URL's may optionally start with ``@url``.  Leo removes this prefix
  before trying to open the URL.

- Names of existing files are considered valid URL's. In that case, Leo
  prepends ``file://`` to the file name.
  
- Relative file names are resolved to c.openDirectory, the directory of the
  .leo file.
  
- You may use the {{expression}} syntax in any ``file://`` URL, including
  ``file://`` URL's created from file names.
  
- The bookmarks.py plugin supports all of the features listed above.
</t>
<t tx="ekr.20120318075211.6168">This class handles all the messy details of loading .leo files at startup.
This class encapsulates almost all the code in runLeo.py, as well as some
methods in leoGlobals.py that really belong somewhere else.

Creating a class simplifies the code to a surprising degree: 5 or 6 ivars
of the class represent command-line options. These ivars are always
available: there is no need to pass them around as arguments.
</t>
<t tx="ekr.20120318075211.6169">The ModeController class represents a collection of modes. The ModeInfo
class represents a single mode.

Without these classes, the code in leoKeys.py is extremely hard to
understand. In fact, the old code was a perfect example of the problems
with procedural programming: client code was burdened with knowing way too
many details about matters that it shouldn't have to know about.
Furthermore, that data itself is hard to understand: it's too "raw". These
classes provide "identity" for data. repr(aModeInfo) is surprisingly
useful.
</t>
<t tx="ekr.20120318075211.6170">This class represents the global log.  It hides the details of the log
from the g.app class and several other pieces of code.

At present, the interface to this class is procedural.  That is, the
present g.app methods that will be moved into this class have a
procedural rather than descriptive nature.  I'm not sure how much this
will change, but creating this class may create opportunities that
were not apparently previously.

</t>
<t tx="ekr.20120318075211.6172">The KeyStroke class is a wrapper for plain strings. It's most important
attribute is its *identity*. It announces that its contents is a
canonicalized value, not a raw user settings string or any other kind of
data associated with key handling.

Similar remarks apply to ShortcutInfo objects. Their identity clarifies the
code. The former code used g.bunches. In complex code such as leoKeys.py,
such anonymous objects really obfuscate matters.

</t>
<t tx="ekr.20120318075211.6173">This class solves a problem that has been annoying me ever since I created
leoEditCommands.py. The problem is this: without this class the classesList
has to be defined at the end of the module, after all classes have been
imported. Worse, several module-level methods were needed to manage the
classesList.

In the new scheme, each Commander creates an EditCommandsManager, and the
code that previously had to call the module-level method
leoEditCommands.x(c) now simply calls c.editCommandManager.x(). This is
much cleaner and avoids several very ugly imports. Which brings me to...
</t>
<t tx="ekr.20120318075211.6174">Now, most modules import only leo.core.leoGlobals. This simplifies Leo's
startup process considerably. This is something that I've wanted to do for
a long time. To make this work, it is *essential* that leoGlobals.py import
*no* other Leo modules.

However, Leo's core still imports leo.core.leoNodes in order to create
positions, vnodes, etc. It would be straightforward to eliminate these by
creating g.app factory methods, but there is no urgent reason to do so.

The ctor for the Commands class imports many modules. This is essential to
break what would otherwise be circular dependencies among Python imports.
We can extend this pattern by creating more classes, as was done with the
EditCommandsManager class.
</t>
<t tx="ekr.20120318075211.6175">leoGlobals.py now contains a section called ``&lt;&lt; global switches &gt;&gt;``

This contains global tracing switches. Experience shows that leoGlobals.py
is the most convenient place for such switches. This section also contains
switches that enable new code bases. Recent examples were::

   new_load = False # True: .leo files are loaded at most once.
   if new_load: print('***** new_load')

   new_modes = False # True: use ModeController and ModeInfo classes.
   if new_modes: print('***** new_modes')
</t>
<t tx="ekr.20120318075211.7524">The new command names and default bindings are::

    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = Alt-4 # The new standard
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = Alt-5 # The new standard
    run-selected-unit-tests-locally     = None
</t>
<t tx="ekr.20120319065417.8788">The following check boxes options appear in the Find pane:

Ignore Case
    When checked, the Find and Change commands ignore the case of
    alphabetic characters when determining matches.
    Alt+Ctrl+I (toggle-find-ignore-case-option) toggles this checkbox.

Mark Changes
    When checked, the Change command marks all headlines whose headline or
    body text are changed by the command.
    Alt+Ctrl+C (toggle-find-mark-changes-option) toggles this checkbox.

Mark Matches
    When checked, the Find and Change commands mark all headlines in which
    a match is found with the pattern.
    Alt+Ctrl+F (toggle-find-mark-finds-option) toggles this checkbox.

Pattern Match
    When checked, the Find and Change commands treat several characters
    specially in the find pattern.
    Alt+Ctrl+X (toggle-find-regex-option) toggles this checkbox.

    - '*'  matches any sequence of zero or more characters.
    - '.'  matches any single character.
    - '^'  matches a newline at the start of a pattern.
    - '$'  matches a newline at the end of a pattern.

Examples::

    "^abc$" matches lines that only contain "abc".
    "^a" matches any line starting with "A".
    "a$" matches any line ending with "a".
    "^*$" matches any line at all.

Search Body Text
    When checked, the Find and Change commands search body text.
    Alt+Ctrl+B (toggle-find-in-body-option) toggles this checkbox.

Search Headline Text
    When checked, the Find and Change commands search headline text.
    Alt+Ctrl+H (toggle-find-in-headline-option) toggles this checkbox.

Whole Word
    When selected, the find pattern must match an entire word. Words consist
    of an alphabetic character or underscore, followed by zero or more
    alphabetic characters, numbers or underscores.
    Alt+Ctrl+W (toggle-find-word-option) toggles this checkbox.

Wrap Around
    When checked, the Find and Change commands continues at the top of the
    file when the command reaches the bottom of the file. For reverse
    searches, the find or change command continues at the bottom of the
    file when the command reaches the top of the file.
    Alt+Ctrl+A (toggle-find-wrap-around-option) toggles this checkbox.
    
</t>
<t tx="ekr.20120319065417.8790">The ``start-search`` (Ctrl-F) command prompts for a
search string. Typing the &lt;Return&gt; key puts the search string in the
Find tab and executes a search based on all the settings in the Find
tab. Type Tab to enter replacement text.

The ``find-next`` (F3) command continues a search started with
``search-with-present-options``. The ``find-previous`` (F2) commands
searches backwards using the present search options. 
The ``replace`` (Ctrl-=) command replaces the selected text with the
'change' text in the Find tab. The ``replace-then-find`` (Ctrl--)
command replaces the selected text with the 'change' text in the Find
tab, then executes the find command again. These commands can simulate
any kind of query-replace command.

The ``find-all`` command prints all matches in the log pane. The
``replace-all`` command changes all occurrences of the 'find' text
with the 'change' text.

The ``clone-find-all`` command searches the outline and creates a new
root node called Found: *&lt;your search pattern&gt;*. This node contains
clones of the found nodes. The ``clone-find-all-flattened`` commands
includes all found nodes, even if they are also children of previously
found nodes.
</t>
<t tx="ekr.20120319065417.8795">The following commands set an option in the Find tab, then work
exactly like the ``start-search`` command.

- The ``search-backward`` and ``search-forward`` commands set the
  'Whole Word' checkbox to False.

- The ``word-search-backward`` and ``word-search-forward`` set the
  'Whole Word' checkbox to True.

- The ``re-search-forward`` and ``re-search-backward`` set the
  'Regexp' checkbox to True.
</t>
<t tx="ekr.20120319065417.8798">Incremental find commands move through the text as you type individual
characters. Typing &lt;BackSpace&gt; backtracks the search. To repeat an
incremental search, type the shortcut for that command again. Here are
Leo's incremental find commands::

    Alt+R isearch-backward
          isearch-backward-regexp
    Alt+S isearch-forward
          isearch-forward-regexp
          isearch-with-present-options
</t>
<t tx="ekr.20120319170934.6094">Leo has many commands that select nodes in the outline. These commands can be
found in the Outline:Go To menu.

As described in the tutorial, you can move about the outline by clicking on the
headlines or using Alt+arrow keys.
</t>
<t tx="ekr.20120319170934.6095">You can expand or contract a node by clicking in the tree view icon to the
left of the headline. The icon in the Qt gui matches the native OS's tree
view icon, i.e. for Mac's, a triangle pointing right or down; on Windows, a
square containing a plus or minus. Expanding a node shows its immediate
children; contracting a node hides all its children.

The ``expand-node`` and ``contract-node`` commands also expand and contract
nodes. For more convenient navigation, there are ``expand-and-go-right``
(Alt-Right) and ``contract-or-go-up`` (Alt-Left) commands.

The ``expand-all`` command expands every node in the outline.
``contract-all`` (Alt-hyphen) contracts every node in the outline. In all
but the smallest outlines, ``expand-all`` is rarely used, and it does not
have a default key binding.
</t>
<t tx="ekr.20120319170934.6096">The ``insert-node`` (Ctrl-I or Insert) command inserts a new node into the
outline. When invoked, (from any pane), it inserts a new node below the
presently selected node, and at the same level as that node, or at the
child level if it has a visible child. The ``delete-node`` command deletes
a node and all its children. To retain the children, just promote all the
children before you do the delete.
</t>
<t tx="ekr.20120319170934.6097">The ``cut-node`` (Ctrl-Shift-X) ``paste-node`` (Ctrl-Shift-V),
``copy-node`` (Ctrl-Shift-C) and ``delete-node`` commands work on nodes
rather than text. The ``cut-node`` and ``copy-node`` commands copy a text
representation of the outline to the clipboard. This representation is the
same as Leo's .leo file format with some information deleted. You may copy
this text representation into a body pane (or into any other text editor)
using Edit-&gt;Paste in the menus, Ctrl-V, or Alt-X paste-text.

**Warning**: If you want to preserve the "cloned" attribute of a node, or
want to paste the node as a clone of the node you cut or copied, use the
``past-retaining-clones`` command, which in the Outline menu is called
"Paste Node as Clone". The ``paste-node`` command instead creates a new,
distinct version of the node you previously cut or copied, though if there
were descendant nodes which were clones of each other, the new version will
have parallel, distinct nodes that are also clones of each other (just not
of the originals). You may paste a node between .leo files, but there can
be no clone relationship across files.

The ``paste-retaining-clones`` command is disabled if it would cause a node
to become a parent of itself. The Leo outline is thus mathematically a
*directed acyclic graph*: clones make it more flexible than a tree, but not
a generalized graph.
</t>
<t tx="ekr.20120319170934.6098">The ``move-outline-up`` (Ctrl-U or Alt-Shift-Up), ``move-outline-down``
(Ctrl-D or Alt-Shift-Down), ``move-outline-left`` (Ctrl-L or
Alt-Shift-Left), and ``move-outline-right`` (Ctrl-R or Alt-Shift-Right)
commands move the currently selected node. **Important**: When focus is in
the outline pane, you can move nodes without adding the Alt modifier.
Shift-Up moves the select node up, etc.

The ``promote`` (Ctrl-[) command makes all the children of
a node siblings of the node. The ``demote`` (Ctrl-]) command makes all following
siblings of a node children of the node.
</t>
<t tx="ekr.20120319170934.6099">A cloned node is a copy of a node that changes when the original changes.
One may also think of it as a single node that is hooked into the outline
at multiple positions. Because that single node brings along all its
descendants, changes are maintained across all the the clones of a node,
along with changes to its offspring (children, grandchildren, etc.), i.e.,
any changes are simultaneously made to the corresponding offspring of all
of those clones. A small red arrow in the icon box marks cloned nodes. You
can think of the arrow as pointing out that there are other paths to get to
this same node. There is no real distinction between the "original" node
and any of its clones. Any headline or body update of a clone headed
subtree affects all of its clones simultaneously. A cloned node becomes a
regular node whenever deletion of its other clones makes it the only one
left. Clones are useful for making alternate views of a program. See
`Clones`_ for full details.

The ``clone-node`` (Ctrl-\`) command creates a clone as the immediate
sibling of a selected node. You have to place it where you want it by
either using move commands, or cutting and paste the clone.
</t>
<t tx="ekr.20120319170934.6100">The ``mark`` (Ctrl-M) marks a node if it is unmarked, and unmarks the node
if it is already marked. The ``mark-subheads`` command marks all offspring
of the presently selected node. The ``mark-changed-items`` command marks
all nodes whose headline or body text has been changed since the file
was last saved.

Leo's find and change commands mark nodes if the "Mark Changes" and "Mark
Finds" checkboxes are checked. You can change these checkboxes with the
``toggle-find-mark-changes-option`` and ``toggle-find-mark-finds-option``
commands.

The ``goto-next-marked`` command selects the next marked node.
</t>
<t tx="ekr.20120319170934.6101">You may drag a node (including all its descendants) from one place to
another in an outline. To start a drag, press the main (left) mouse button
while the cursor is over the icon for a node. The cursor will change to a
hand icon. If you release the mouse button while the hand cursor is above
another node, Leo will move the dragged node after that node.
If you release the mouse button when the hand cursor is not over a node,
Leo will leave the outline pane as it is. Leo scrolls the outline pane as
the result of mouse-moved events, so to continue scrolling you must keep
moving the mouse.

If the recipient node has children and is expanded, the dropped node will
be inserted as the first child of the recipient node, otherwise the
dropped node will be inserted after the recipient node.

Holding down Alt before releasing the node will force insertion as a
child of the recipient node, even if the recipient node is not expanded.

Holding down Control before releasing the node will cause a clone to be
dropped, leaving the original where it was.
</t>
<t tx="ekr.20120319170934.6104">Leo auto indents unless @nocolor is in effect.  Typing a newline
automatically inserts the same leading whitespace present on the previous line.

If Python is the present language, Leo inserts an additional tab if the previous
line ends with a colon.  When the smart_auto_indent setting is True, Leo uses Emacs-style
auto-indentation instead.  This style of auto-indent aligns newly created lines
with unmatched ( [ or { brackets in the previous line.
</t>
<t tx="ekr.20120319170934.6105">The ``add-editor`` command adds a new editor in the body pane and gives it
the body editor focus. The ``delete-editor`` command deletes the editor
with body editor focus. The ``cycle-editor-focus`` command cycles body
editor focus between editors in the body text. The editor that has focus
shows the content of the selected outline node; the other body editors
continue to show the node contents they last had when they had the body
editor focus.
</t>
<t tx="ekr.20120319170934.6109">Leo checks that the URL is valid before attempting to open it. A valid
URL is:

-   3 or more lowercase alphas
-   followed by one :
-   followed by one or more of:
-   ``$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~``
-   followed by one of: ``$%&amp;'()*+/0-9:=?@A-Z_a-z}~`` 

That is, a comma, hyphen and open curly brace may not be the last character.

URL's in Leo should contain no spaces: use %20 to indicate spaces.

You may use any type of URL that your browser supports: http, mailto,
ftp, file, etc.
</t>
<t tx="ekr.20120319170934.6110">Chapters are regions of a Leo outline whose root is an ``@chapter`` node. They
are available in an outline if the ``@bool usechapters`` option is True.
``@chapter`` nodes may appear anywhere in an outline, but the ``create-chapter``
command (see below) creates ``@chapter`` nodes as children of the first
``@chapters`` (note the ``s``) node in the outline.

One selects a chapter with the ``select-chapter`` command, after which Leo shows
only the nodes in the selected chapter; in this respect, chapters are like
hoists. The ``main`` chapter represents the entire outline and can not be
deleted by name. When chapters are in effect, Leo creates an ``@chapters`` node
for the use of ``create-chapter``.

Associated settings:

- The ``@bool use_chapters`` setting determines whether chapters are enabled.
- The ``@bool use_chapter_tabs`` setting determines whether the chapters
  pop-up menu appears in the icon area. Choosing a chapter name from this list selects a chapter.

When chapters are enabled, the Cmds-&gt;Chapters menu shows all available chapter commands:

- The ``chapter-create`` command creates an @chapter node and populates it with a single node.
- The ``chapter-remove`` command deletes the currently selected chapter.
- The ``chapter-select`` command prompts for a chapter name and makes only the nodes of the selected chapter visible.
- The ``chapter-move-node-to``, ``chapter-clone-node-to`` and ``chapter-copy-node-to`` commands
  prompt for a chapter name and add the currently selected node (and its descendants) to another chapter.
</t>
<t tx="ekr.20120320153011.8551"></t>
<t tx="ekr.20120327163022.9744">Also the import commands.

Especially:
    - Shebang line.
    - Python encoding line.
</t>
<t tx="ekr.20120328102352.5897">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 553, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 2120, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "c:\leo.repo\trunk\leo\core\leoImport.py", line 479, in flattenOutline
    theFile.write(s)
TypeError: must be str, not bytes
</t>
<t tx="ekr.20120328102352.5899">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoPlugins.py", line 337, in callTagHandler
    result = handler(tag,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 560, in update
    f(s,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 655, in update_graphics_script
    pc.gs = QtGui.QGraphicsScene(pc.splitter)
AttributeError: 'ViewRenderedController' object has no attribute 'splitter'
</t>
<t tx="ekr.20120328102352.5900">Selecting body editor with clicks doesn't save/restore visual ivars.
The solution would be to create a new onClick event handler...
</t>
<t tx="ekr.20120328102352.5936">In earlier version of Leo if one runs test externally with the selected
position under @test node, that @test was executed with (run-marked-unit-tests-externally)

The fix was to the "important special case" in TM.findAllUnitTestNodes.
</t>
<t tx="ekr.20120328102352.5938">http://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3#

The fix is simply to special-case file:/// on Windows in g.computeFileUrl.
</t>
<t tx="ekr.20120328102352.5942"></t>
<t tx="ekr.20120328102352.5946">http://leoeditor.com

- Added link to home page from the TOC.

- Removed online-tutorial link.

- Added search box to Leo's home page.

- Added link to glossary from Leo's home page.

- Added scaled screen shot to Leo's home page.

- Brought screen shots up to date.
</t>
<t tx="ekr.20120515193246.10083"></t>
<t tx="ekr.20120515193246.10084"></t>
<t tx="ekr.20120515193246.10085"></t>
<t tx="ekr.20120515193246.10087"></t>
<t tx="ekr.20120516140545.9987">The big picture:

- The dog that isn't barking: newbies seem to be having an easier time learning Leo.
- A gallery showing what rST &amp; css can do in Leo.
- Leo as a web app.
</t>
<t tx="ekr.20120516140545.9992">As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".

Or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
</t>
<t tx="ekr.20120516140545.9993"></t>
<t tx="ekr.20120520055508.11873">These would be an alternative to the Easter Egg interface.
</t>
<t tx="ekr.20120520113447.9874">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3593116
By: ktenney

When I have a traceback in the log pane, I'd love
to be able to select an item and cause the file
to appear in a node.
It would be cool to have 'Next' and 'Prev' 
capability while in this mode, effortlessly 
traversing views of the source of the stack items.
</t>
<t tx="ekr.20120527053550.10117">@nocolor-node

The find-def command (with ctrl-click support) would do
the hyperlinking.

It shouldn't be too hard: create an auto-completion-like popup if there are
multiple possibilities.  Use leoInspect.
</t>
<t tx="ekr.20120527053550.12058"></t>
<t tx="ekr.20120604071051.10187"># Terry will do this, or help with it.
</t>
<t tx="ekr.20121005105428.10095"># s = '["foo", {"bar":["baz", null, 1.0, 2]}]'

s = '''
{
  "metadata": {
    "name": "Part 2: Dataset Basics and Concepts"
  }, 
  "nbformat": 3, 
  "nbformat_minor": 0, 
  "worksheets": [
    {
      "cells": [
        {
          "cell_type": "heading", 
          "level": 1, 
          "metadata": {}, 
          "source": [
            "Part 2: Dataset Basics and Concepts"
          ]
        }
      ]
    }
  ]
}
'''

s2 = '''
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "This tutorial part is also available for download as an ", 
            "[IPython notebook][IPython notebook]:\n[", 
            "[ipynb][ipynb]]", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "A ", 
            "[Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It\nserves as the primary form of input data storage, but also as container for\nmore complex results returned by some algorithm. In this tutorial part we will\ntake a look at what a dataset consists of, and how it works.\n\n", 
            "In the simplest case, a dataset only contains ", 
            "*data* that is a matrix of\nnumerical values."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from mvpa2.tutorial_suite import *\n", 
            "data = [[  1,  1, -1],\n        [  2,  0,  0],\n        [  3,  1,  1],\n        [  4,  0, -1]]\n", 
            "ds = Dataset(data)\n", 
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the above example, every row vector in the `data` matrix becomes an\nobservation or a ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector\nrepresents an individual variable or a ", 
            "[feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples\nand features are essential for a dataset, hence we take a further, closer look.\n\n", 
            "The dataset assumes the first axis of the data to be the samples separating\ndimension. If the dataset is created using a one-dimensional vector it will\ntherefore have as many samples as elements in the vector, and only one feature."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "one_d = [ 0, 1, 2, 3 ]\n", 
            "one_ds = Dataset(one_d)\n", 
            "one_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "On the other hand, if a dataset is created from multi-dimensional data, only its\nsecond axis represents the features"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import numpy as np\n", 
            "m_ds = Dataset(np.random.random((3, 4, 2, 3)))\n", 
            "m_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "m_ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In this case we have a dataset with three samples and four features, where each\nfeature is a 2x3 matrix. In case somebody is wondering now, why not simply each\nvalue in the data array is considered as its own feature (yielding 24 features)\n-- stay tuned, as this is going to be of importance later on."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Attributes"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "What we have seen so far does not really warrant the use of a dataset over a\nplain array or a matrix with samples. However, in the MVPA context we often need\nto know more about each samples than just the value of its features.  In the\nprevious tutorial part we have already seen that per-sample ", 
            "[target](http://pymvpa.org/glossary.html#term-target)\nvalues are required for supervised-learning algorithms, and that a dataset\noften has to be split based on the origin of specific groups of samples.  For\nthis type of auxiliary information a dataset can also contain collections of\nthree types of ", 
            "[attribute](http://pymvpa.org/glossary.html#term-attribute)s: ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), ", 
            "[feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and\n", 
            "[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute)."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Samples"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In a dataset each ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional\nattributes. They are stored as vectors of the same length as the number of samples\nin a collection, and are accessible via the `sa` attribute. A collection is\nderived from a standard Python ", 
            "`dict`, and hence adding sample attributes\nworks identical to adding elements to a dictionary:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'] = [ 0., 1, 1, 3 ]\n", 
            "ds.sa.keys()"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, sample attributes are not directly stored as plain data, but for\nvarious reasons as a so-called ", 
            "[Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in\nturn embeds a NumPy array with the actual attribute:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "type(ds.sa['some_attr'])"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].value"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "This \"complication\" is done to be able to extend attributes with additional\nfunctionality that is often needed and can offer significant speed-up of\nprocessing. For example, sample attributes carry a list of their unique values.\nThis list is only computed once (upon first request) and can subsequently be\naccessed directly without repeated and expensive searches:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].unique"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, for most interactive uses of PyMVPA this type of access to attributes'\n`.value` is relatively cumbersome (too much typing), therefore collections offer direct\nattribute access by name:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Another purpose of the sample attribute collection is to preserve data\nintegrity, by disallowing improper attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = 4"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "But other than basic plausibility checks no further constraints on values of\nsamples attributes exist. As long as the length of the attribute vector matches\nthe number of samples in the dataset, and the attributes values can be stored\nin a NumPy array, any value is allowed. For example, it is perfectly possible\nand supported to store literal attributes. It should also be noted that each\nattribute may have its own individual data type, hence it is possible to have\nliteral and numeric attributes in the same dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['literal'] = ['one', 'two', 'three', 'four']\n", 
            "sorted(ds.sa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "for attr in ds.sa:\n   print \"%s: %s\" % (attr, ds.sa[attr].value.dtype.name)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Features"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the ", 
            "*only* difference is that instead of having one attribute value per\nsample, feature attributes have one value per (guess what? ...) ", 
            "*feature*.\nMoreover, they are stored in a separate collection in the datasets that is\ncalled `fa`:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa['my_fav'] = [0, 1, 0]\n", 
            "ds.fa['responsible'] = ['me', 'you', 'nobody']\n", 
            "sorted(ds.fa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For The Dataset"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Finally, there can be also attributes, not per each sample, or each\nfeature, but for the dataset as a whole: so called ", 
            "[dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in\nexactly the same way as for the other two types of attributes, except that dataset\nattributes are stored in their own collection which is accessible via the\n`a` property of the dataset.  However, in contrast to sample and feature\nattribute no constraints on the type or size are imposed -- anything can be\nstored. Let's store a list with all files in the current directory, just\nbecause we can:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from glob import glob\n", 
            "ds.a['pointless'] = glob(\"*\")\n", 
            "'setup.py' in ds.a.pointless"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Slicing, resampling, feature selection"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "At this point we can already construct a dataset from simple arrays and\nenrich it with an arbitrary number of additional attributes. But just\nhaving a dataset isn't enough. From part one of this tutorial we already\nknow that we need to be able to select subsets of a dataset for further\nprocessing, and we also know that this is possible with PyMVPA's datasets.\nNow it is time to have a closer look into how it works.\n\n", 
            "Slicing a dataset (i.e. selecting specific subsets) is very similar to\nslicing a NumPy array. It actually works ", 
            "*almost* identical. A dataset\nsupports Python's ", 
            "`slice` syntax, but also selection by boolean masks, and\nindices. The following three slicing operations\nresult in equivalent output datasets, by always selecting every other samples\nin the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[::2].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "mask = np.array([True, False, True, False])\n", 
            "ds[mask].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[[0, 2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Search the `NumPy documentation`_ for the difference between \"basic slicing\"\nand \"advanced indexing\". Especially the aspect of memory consumption\napplies to dataset slicing as well, and being aware of this fact might\nhelp to write more efficient analysis scripts. Which of the three slicing\napproaches above is the most memory-efficient?  Which of the three slicing\napproaches above might lead to unexpected side-effects if output dataset\ngets modified?"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "All three slicing-styles are equally applicable to the selection of feature\nsubsets within a dataset. Remember, features are represented on the second axis\nof a dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[:, [1,2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "By applying a selection by indices to the second axis, we can easily get\nthe last two features of our example dataset. Please note the ", 
            "`:` is supplied\nas first axis slicing. This is the Python way to indicate ", 
            "*take everything\nalong this axis*, hence including all samples.\n\n", 
            "As you can guess, it is also possible to select subsets of samples and\nfeatures at the same time."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "subds = ds[[0,1], [0,2]]\n", 
            "subds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "If you have prior experience with NumPy you might be confused now. What you\nmight have expected is this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples[[0,1], [0,2]]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "The above code applies the same slicing directly to the NumPy array with\nthe samples, and the result is fundamentally different. For NumPy arrays\nthis style of slicing allows to select specific elements by their indices on\neach axis of an array. For PyMVPA's datasets this mode is not very useful,\ninstead we typically want to select rows and columns, i.e. samples and\nfeatures given by their indices."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Try to select samples [0,1] and features [0,2,3] simultaneously using\ndataset slicing.  Now apply the same slicing to the samples array itself\n(`ds.samples`) -- make sure that the result doesn't surprise you and find\na pure NumPy way to achieve similar selection."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "One last interesting thing to look at, in the context of dataset slicing\nare the attributes. What happens to them when a subset of samples and/or\nfeatures is chosen? Our original dataset had both samples and feature attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Now let's look at what they became in the subset-dataset we previously\ncreated:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We see that both attributes are still there and, moreover, also the\nappropriate subsets have been selected."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Loading fMRI data"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Enough of theoretical foreplay -- let's look at a concrete example of an\nfMRI dataset. PyMVPA has several helper functions to load data from\nspecialized formats, and the one for fMRI data is\n", 
            "[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to\nlook at is a single subject from Haxby et al. (2001) that we already\nloaded in part one of this tutorial. For more convenience, and less typing\nwe first specify the path of the directory with the fMRI data."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "path=os.path.join(tutorial_data_path, 'data')"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the simplest case, we now let ", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just\npointing it to the fMRI data file. The data is stored as a NIfTI file that has\nall runs of the experiment concatenated into a single file."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can notice two things. First, it worked! Second, we get a\ntwo-dimensional dataset with 1452 samples (these are volumes in the NIfTI\nfile), and over 160k features (these are voxels in the volume). The voxels\nare represented as a one-dimensional vector, and it seems that they have\nlost their association with the 3D-voxel-space. However, this is not the\ncase, as we will see in the next chapter.  PyMVPA represents\ndata in this simple format to make it compatible with a vast range of generic\nalgorithms that expect data to be a simple matrix.\n\n", 
            "We just loaded all data from that NIfTI file, but usually we would be\ninterested in a subset only, i.e. \"brain voxels\".\n", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to\nspecify a mask image. Such mask image is generated in pretty much any fMRI\nanalysis pipeline -- may it be a full-brain mask computed during\nskull-stripping, or an activation map from a functional localizer. We are going\nto use the original GLM-based localizer mask of ventral temporal cortex\nfrom Haxby et al. (2001). We already know that it comprises 577 voxels.\nLet's reload the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),\n                  mask=os.path.join(path, 'mask_vt.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "As expected, we get the same number of samples and also only 577 features\n-- voxels corresponding to non-zero elements in the mask image. Now, let's\nexplore this dataset a little further.\n\n", 
            "Besides samples the dataset offers number of attributes that enhance the\ndata with information that is present in the NIfTI image header in the file. Each sample has\ninformation about its volume ID in the time series and the actual acquisition\ntime (relative to the beginning of the file). Moreover, the original voxel\nindex (sometimes referred to as `ijk`) for each feature is available too.\nFinally, the dataset also contains information about the dimensionality\nof the input volumes, voxel size, and any other NIfTI-specific information\nsince it also includes a dump of the full NIfTI image header."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "Previously (0.4.x versions and 0.5 development prior March 03, 2010),\nPyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`\n(corresponds to `tzyx` if volumes were axial slices in\nneurologic convention) order of dimensions.  Now it uses more convenient\norder `tijk` (corresponding to `txyz`), which will match the order exposed\nby NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_coords[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa.voxel_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_eldim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_dim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "'imghdr' in ds.a"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In addition to all this information, the dataset also carries a key\nattribute: the ", 
            "*mapper*. A mapper is an important concept in PyMVPA, and\nhence worth devoting the whole ", 
            "*next tutorial chapter* to it."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.a.mapper"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Having all these attributes being part of a dataset is often a useful thing\nto have, but in some cases (e.g. when it comes to efficiency, and/or very\nlarge datasets) one might want to have a leaner dataset with just the\ninformation that is really necessary. One way to achieve this, is to strip\nall unwanted attributes. The Dataset class'\n", 
            "[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])\n", 
            "print stripped"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can see that all attributes besides `time_coords` have been filtered out.\nSetting the `deep` arguments to `False` causes the copy function to reuse the\ndata from the source dataset to generate the new stripped one, without\nduplicating all data in memory -- meaning both datasets now share the sample\ndata and any change done to `ds` will also affect `stripped`."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Storage"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Some data preprocessing can take a long time.  One would rather prevent\ndoing it over and over again, and instead just store the preprocessed data\ninto a file for subsequent analyses. PyMVPA offers functionality to store a\nlarge variety of objects, including datasets, into ", 
            "[HDF5][HDF5] files. A variant\nof this format is also used by recent versions of Matlab to store data.\n\n", 
            "For HDF5 support PyMVPA depends on the ", 
            "[h5py][h5py] package. If it is available,\nany dataset can be saved to a file by simply calling\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import tempfile, shutil\n", 
            "tempdir = tempfile.mkdtemp()\n", 
            "ds.save(os.path.join(tempdir, 'mydataset.hdf5'))"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "HDF5 is a flexible format that also supports, for example, data\ncompression. To enable it, you can pass additional arguments to\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by\n", 
            "`Group.create_dataset()`. Instead of using\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the ", 
            "[h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)\nfunction in a similar way. Saving the same dataset with maximum\ngzip-compression looks like this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)\n", 
            "h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Loading datasets from a file is easy too. ", 
            "[h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as\nan argument and returns the stored dataset. Compressed data will be handled\ntransparently."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))\n", 
            "np.all(ds.samples == loaded.samples)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "shutil.rmtree(tempdir, ignore_errors=True)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }
      ], 
      "metadata": {}
    }
  ]
}
'''
</t>
<t tx="ekr.20121005105428.10097">_reader = JSONReader()
reads = _reader.reads
read =  _reader.read
to_notebook = _reader.to_notebook
</t>
<t tx="ekr.20121005105428.10098"></t>
<t tx="ekr.20121005105428.10102">class NotebookReader(object): # From rwbase.py
    """A class for reading notebooks."""

    def reads(self, s, **kwargs):
        """Read a notebook from a string."""
        raise NotImplementedError("loads must be implemented in a subclass")

    def read(self, fp, **kwargs):
        """Read a notebook from a file like object"""
        nbs = fp.read()
        if not py3compat.PY3 and not isinstance(nbs, unicode):
            nbs = py3compat.str_to_unicode(nbs)
        return self.reads(nbs, **kwargs)
</t>
<t tx="ekr.20121005105428.10103">def from_dict(d):
    if isinstance(d, dict):
        newd = NotebookNode()
        for k,v in d.items():
            newd[k] = from_dict(v)
        return newd
    elif isinstance(d, (tuple, list)):
        return [from_dict(i) for i in d]
    else:
        return d
</t>
<t tx="ekr.20121005105428.10104">def restore_bytes(nb):
    """Restore bytes of image data from unicode-only formats.
    
    Base64 encoding is handled elsewhere.  Bytes objects in the notebook are
    always b64-encoded. We DO NOT encode/decode around file formats.
    """
    for ws in nb.worksheets:
        for cell in ws.cells:
            if cell.cell_type == 'code':
                for output in cell.outputs:
                    if 'png' in output:
                        output.png = str_to_bytes(output.png, 'ascii')
                    if 'jpeg' in output:
                        output.jpeg = str_to_bytes(output.jpeg, 'ascii')
    return nb
</t>
<t tx="ekr.20121005105428.10105">def _join_lines(lines):
    """join lines that have been written by splitlines()
    
    Has logic to protect against `splitlines()`, which
    should have been `splitlines(True)`
    """
    if lines and lines[0].endswith(('\n', '\r')):
        # created by splitlines(True)
        return u''.join(lines)
    else:
        # created by splitlines()
        return u'\n'.join(lines)
</t>
<t tx="ekr.20121005105428.10106">def rejoin_lines(nb):
    """rejoin multiline text into strings
    
    For reversing effects of ``split_lines(nb)``.
    
    This only rejoins lines that have been split, so if text objects were not split
    they will pass through unchanged.
    
    Used when reading JSON files that may have been passed through split_lines.
    """
    for ws in nb.worksheets:
        for cell in ws.cells:
            if cell.cell_type == 'code':
                if 'input' in cell and isinstance(cell.input, list):
                    cell.input = _join_lines(cell.input)
                for output in cell.outputs:
                    for key in _multiline_outputs:
                        item = output.get(key, None)
                        if isinstance(item, list):
                            output[key] = _join_lines(item)
            else: # text, heading cell
                for key in ['source', 'rendered']:
                    item = cell.get(key, None)
                    if isinstance(item, list):
                        cell[key] = _join_lines(item)
    return nb
</t>
<t tx="ekr.20121005105428.10107">class BytesEncoder(json.JSONEncoder):
    """A JSON encoder that accepts b64 (and other *ascii*) bytestrings."""
    def default(self, obj):
        if isinstance(obj, bytes):
            return obj.decode('ascii')
        return json.JSONEncoder.default(self, obj)

</t>
<t tx="ekr.20121005105428.10108">class JSONReader(NotebookReader):

    def reads(self, s, **kwargs):
        nb = json.loads(s, **kwargs)
        nb = self.to_notebook(nb, **kwargs)
        return nb

    def to_notebook(self, d, **kwargs):
        return restore_bytes(
            rejoin_lines(from_dict(d))) # from_dict and rejoin_lines are in nbbase.
</t>
<t tx="ekr.20121005105428.10109">if 0:
    @others
</t>
<t tx="ekr.20121005105428.10112">{
  "metadata": {
    "name": "Part 2: Dataset Basics and Concepts"
  }, 
  "nbformat": 3, 
  "nbformat_minor": 0, 
  "worksheets": [
    {
      "cells": [
        {
          "cell_type": "heading", 
          "level": 1, 
          "metadata": {}, 
          "source": [
            "Part 2: Dataset Basics and Concepts"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "This tutorial part is also available for download as an ", 
            "[IPython notebook][IPython notebook]:\n[", 
            "[ipynb][ipynb]]", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "A ", 
            "[Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It\nserves as the primary form of input data storage, but also as container for\nmore complex results returned by some algorithm. In this tutorial part we will\ntake a look at what a dataset consists of, and how it works.\n\n", 
            "In the simplest case, a dataset only contains ", 
            "*data* that is a matrix of\nnumerical values."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from mvpa2.tutorial_suite import *\n", 
            "data = [[  1,  1, -1],\n        [  2,  0,  0],\n        [  3,  1,  1],\n        [  4,  0, -1]]\n", 
            "ds = Dataset(data)\n", 
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the above example, every row vector in the `data` matrix becomes an\nobservation or a ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector\nrepresents an individual variable or a ", 
            "[feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples\nand features are essential for a dataset, hence we take a further, closer look.\n\n", 
            "The dataset assumes the first axis of the data to be the samples separating\ndimension. If the dataset is created using a one-dimensional vector it will\ntherefore have as many samples as elements in the vector, and only one feature."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "one_d = [ 0, 1, 2, 3 ]\n", 
            "one_ds = Dataset(one_d)\n", 
            "one_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "On the other hand, if a dataset is created from multi-dimensional data, only its\nsecond axis represents the features"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import numpy as np\n", 
            "m_ds = Dataset(np.random.random((3, 4, 2, 3)))\n", 
            "m_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "m_ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In this case we have a dataset with three samples and four features, where each\nfeature is a 2x3 matrix. In case somebody is wondering now, why not simply each\nvalue in the data array is considered as its own feature (yielding 24 features)\n-- stay tuned, as this is going to be of importance later on."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Attributes"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "What we have seen so far does not really warrant the use of a dataset over a\nplain array or a matrix with samples. However, in the MVPA context we often need\nto know more about each samples than just the value of its features.  In the\nprevious tutorial part we have already seen that per-sample ", 
            "[target](http://pymvpa.org/glossary.html#term-target)\nvalues are required for supervised-learning algorithms, and that a dataset\noften has to be split based on the origin of specific groups of samples.  For\nthis type of auxiliary information a dataset can also contain collections of\nthree types of ", 
            "[attribute](http://pymvpa.org/glossary.html#term-attribute)s: ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), ", 
            "[feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and\n", 
            "[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute)."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Samples"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In a dataset each ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional\nattributes. They are stored as vectors of the same length as the number of samples\nin a collection, and are accessible via the `sa` attribute. A collection is\nderived from a standard Python ", 
            "`dict`, and hence adding sample attributes\nworks identical to adding elements to a dictionary:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'] = [ 0., 1, 1, 3 ]\n", 
            "ds.sa.keys()"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, sample attributes are not directly stored as plain data, but for\nvarious reasons as a so-called ", 
            "[Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in\nturn embeds a NumPy array with the actual attribute:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "type(ds.sa['some_attr'])"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].value"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "This \"complication\" is done to be able to extend attributes with additional\nfunctionality that is often needed and can offer significant speed-up of\nprocessing. For example, sample attributes carry a list of their unique values.\nThis list is only computed once (upon first request) and can subsequently be\naccessed directly without repeated and expensive searches:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].unique"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, for most interactive uses of PyMVPA this type of access to attributes'\n`.value` is relatively cumbersome (too much typing), therefore collections offer direct\nattribute access by name:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Another purpose of the sample attribute collection is to preserve data\nintegrity, by disallowing improper attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = 4"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "But other than basic plausibility checks no further constraints on values of\nsamples attributes exist. As long as the length of the attribute vector matches\nthe number of samples in the dataset, and the attributes values can be stored\nin a NumPy array, any value is allowed. For example, it is perfectly possible\nand supported to store literal attributes. It should also be noted that each\nattribute may have its own individual data type, hence it is possible to have\nliteral and numeric attributes in the same dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['literal'] = ['one', 'two', 'three', 'four']\n", 
            "sorted(ds.sa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "for attr in ds.sa:\n   print \"%s: %s\" % (attr, ds.sa[attr].value.dtype.name)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Features"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the ", 
            "*only* difference is that instead of having one attribute value per\nsample, feature attributes have one value per (guess what? ...) ", 
            "*feature*.\nMoreover, they are stored in a separate collection in the datasets that is\ncalled `fa`:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa['my_fav'] = [0, 1, 0]\n", 
            "ds.fa['responsible'] = ['me', 'you', 'nobody']\n", 
            "sorted(ds.fa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For The Dataset"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Finally, there can be also attributes, not per each sample, or each\nfeature, but for the dataset as a whole: so called ", 
            "[dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in\nexactly the same way as for the other two types of attributes, except that dataset\nattributes are stored in their own collection which is accessible via the\n`a` property of the dataset.  However, in contrast to sample and feature\nattribute no constraints on the type or size are imposed -- anything can be\nstored. Let's store a list with all files in the current directory, just\nbecause we can:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from glob import glob\n", 
            "ds.a['pointless'] = glob(\"*\")\n", 
            "'setup.py' in ds.a.pointless"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Slicing, resampling, feature selection"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "At this point we can already construct a dataset from simple arrays and\nenrich it with an arbitrary number of additional attributes. But just\nhaving a dataset isn't enough. From part one of this tutorial we already\nknow that we need to be able to select subsets of a dataset for further\nprocessing, and we also know that this is possible with PyMVPA's datasets.\nNow it is time to have a closer look into how it works.\n\n", 
            "Slicing a dataset (i.e. selecting specific subsets) is very similar to\nslicing a NumPy array. It actually works ", 
            "*almost* identical. A dataset\nsupports Python's ", 
            "`slice` syntax, but also selection by boolean masks, and\nindices. The following three slicing operations\nresult in equivalent output datasets, by always selecting every other samples\nin the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[::2].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "mask = np.array([True, False, True, False])\n", 
            "ds[mask].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[[0, 2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Search the `NumPy documentation`_ for the difference between \"basic slicing\"\nand \"advanced indexing\". Especially the aspect of memory consumption\napplies to dataset slicing as well, and being aware of this fact might\nhelp to write more efficient analysis scripts. Which of the three slicing\napproaches above is the most memory-efficient?  Which of the three slicing\napproaches above might lead to unexpected side-effects if output dataset\ngets modified?"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "All three slicing-styles are equally applicable to the selection of feature\nsubsets within a dataset. Remember, features are represented on the second axis\nof a dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[:, [1,2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "By applying a selection by indices to the second axis, we can easily get\nthe last two features of our example dataset. Please note the ", 
            "`:` is supplied\nas first axis slicing. This is the Python way to indicate ", 
            "*take everything\nalong this axis*, hence including all samples.\n\n", 
            "As you can guess, it is also possible to select subsets of samples and\nfeatures at the same time."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "subds = ds[[0,1], [0,2]]\n", 
            "subds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "If you have prior experience with NumPy you might be confused now. What you\nmight have expected is this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples[[0,1], [0,2]]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "The above code applies the same slicing directly to the NumPy array with\nthe samples, and the result is fundamentally different. For NumPy arrays\nthis style of slicing allows to select specific elements by their indices on\neach axis of an array. For PyMVPA's datasets this mode is not very useful,\ninstead we typically want to select rows and columns, i.e. samples and\nfeatures given by their indices."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Try to select samples [0,1] and features [0,2,3] simultaneously using\ndataset slicing.  Now apply the same slicing to the samples array itself\n(`ds.samples`) -- make sure that the result doesn't surprise you and find\na pure NumPy way to achieve similar selection."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "One last interesting thing to look at, in the context of dataset slicing\nare the attributes. What happens to them when a subset of samples and/or\nfeatures is chosen? Our original dataset had both samples and feature attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Now let's look at what they became in the subset-dataset we previously\ncreated:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We see that both attributes are still there and, moreover, also the\nappropriate subsets have been selected."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Loading fMRI data"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Enough of theoretical foreplay -- let's look at a concrete example of an\nfMRI dataset. PyMVPA has several helper functions to load data from\nspecialized formats, and the one for fMRI data is\n", 
            "[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to\nlook at is a single subject from Haxby et al. (2001) that we already\nloaded in part one of this tutorial. For more convenience, and less typing\nwe first specify the path of the directory with the fMRI data."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "path=os.path.join(tutorial_data_path, 'data')"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the simplest case, we now let ", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just\npointing it to the fMRI data file. The data is stored as a NIfTI file that has\nall runs of the experiment concatenated into a single file."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can notice two things. First, it worked! Second, we get a\ntwo-dimensional dataset with 1452 samples (these are volumes in the NIfTI\nfile), and over 160k features (these are voxels in the volume). The voxels\nare represented as a one-dimensional vector, and it seems that they have\nlost their association with the 3D-voxel-space. However, this is not the\ncase, as we will see in the next chapter.  PyMVPA represents\ndata in this simple format to make it compatible with a vast range of generic\nalgorithms that expect data to be a simple matrix.\n\n", 
            "We just loaded all data from that NIfTI file, but usually we would be\ninterested in a subset only, i.e. \"brain voxels\".\n", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to\nspecify a mask image. Such mask image is generated in pretty much any fMRI\nanalysis pipeline -- may it be a full-brain mask computed during\nskull-stripping, or an activation map from a functional localizer. We are going\nto use the original GLM-based localizer mask of ventral temporal cortex\nfrom Haxby et al. (2001). We already know that it comprises 577 voxels.\nLet's reload the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),\n                  mask=os.path.join(path, 'mask_vt.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "As expected, we get the same number of samples and also only 577 features\n-- voxels corresponding to non-zero elements in the mask image. Now, let's\nexplore this dataset a little further.\n\n", 
            "Besides samples the dataset offers number of attributes that enhance the\ndata with information that is present in the NIfTI image header in the file. Each sample has\ninformation about its volume ID in the time series and the actual acquisition\ntime (relative to the beginning of the file). Moreover, the original voxel\nindex (sometimes referred to as `ijk`) for each feature is available too.\nFinally, the dataset also contains information about the dimensionality\nof the input volumes, voxel size, and any other NIfTI-specific information\nsince it also includes a dump of the full NIfTI image header."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "Previously (0.4.x versions and 0.5 development prior March 03, 2010),\nPyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`\n(corresponds to `tzyx` if volumes were axial slices in\nneurologic convention) order of dimensions.  Now it uses more convenient\norder `tijk` (corresponding to `txyz`), which will match the order exposed\nby NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_coords[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa.voxel_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_eldim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_dim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "'imghdr' in ds.a"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In addition to all this information, the dataset also carries a key\nattribute: the ", 
            "*mapper*. A mapper is an important concept in PyMVPA, and\nhence worth devoting the whole ", 
            "*next tutorial chapter* to it."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.a.mapper"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Having all these attributes being part of a dataset is often a useful thing\nto have, but in some cases (e.g. when it comes to efficiency, and/or very\nlarge datasets) one might want to have a leaner dataset with just the\ninformation that is really necessary. One way to achieve this, is to strip\nall unwanted attributes. The Dataset class'\n", 
            "[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])\n", 
            "print stripped"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can see that all attributes besides `time_coords` have been filtered out.\nSetting the `deep` arguments to `False` causes the copy function to reuse the\ndata from the source dataset to generate the new stripped one, without\nduplicating all data in memory -- meaning both datasets now share the sample\ndata and any change done to `ds` will also affect `stripped`."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Storage"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Some data preprocessing can take a long time.  One would rather prevent\ndoing it over and over again, and instead just store the preprocessed data\ninto a file for subsequent analyses. PyMVPA offers functionality to store a\nlarge variety of objects, including datasets, into ", 
            "[HDF5][HDF5] files. A variant\nof this format is also used by recent versions of Matlab to store data.\n\n", 
            "For HDF5 support PyMVPA depends on the ", 
            "[h5py][h5py] package. If it is available,\nany dataset can be saved to a file by simply calling\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import tempfile, shutil\n", 
            "tempdir = tempfile.mkdtemp()\n", 
            "ds.save(os.path.join(tempdir, 'mydataset.hdf5'))"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "HDF5 is a flexible format that also supports, for example, data\ncompression. To enable it, you can pass additional arguments to\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by\n", 
            "`Group.create_dataset()`. Instead of using\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the ", 
            "[h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)\nfunction in a similar way. Saving the same dataset with maximum\ngzip-compression looks like this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)\n", 
            "h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Loading datasets from a file is easy too. ", 
            "[h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as\nan argument and returns the stored dataset. Compressed data will be handled\ntransparently."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))\n", 
            "np.all(ds.samples == loaded.samples)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "shutil.rmtree(tempdir, ignore_errors=True)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }
      ], 
      "metadata": {}
    }
  ]
}
</t>
<t tx="ekr.20121005105428.12866"></t>
<t tx="ekr.20121008100945.10295">@nocolor-node

- Downloaded and ran ipython-0.13.py2-win32.exe
- Uninstalled several older IPython's using the Windows Control Panel

Linux
=====

- Installed pip: sudo apt-get install python-pip
- distribute was already installed in python2.7
- Installed curl: sudo apt-get install curl.
- Upgraded ipython: easy_install ipython[zmq,qtconsole,notebook,test] ipython==0.13
- Tested Ipython: iptest  Works!!!  not available:  oct2py rpy2
- removed home/.ipython/ipythonrc this removed the warnings on startup.

Windows:
========

- Download c:\apps\distribute_setup.py.
- python26 distribute_setup.py
- Removed all former versions of Enthought and ActiveState Python and IPython.
</t>
<t tx="ekr.20130502104323.10581">Used for Leo's blog.

bzr ci =&gt; git commit -a
bzr add =&gt; git add
bzr push =&gt; git push
bzr revert =&gt; git reset --hard
</t>
<t tx="ekr.20130503061707.10515">fj = g.os_path_finalize_join
f  = g.os_path_finalize
eu = g.os_path_expanduser

if g.app.isExternalUnitTest:
    loadDir = fj(g.app.loadDir,'..','test')
else:
    loadDir = g.app.loadDir

table = (
    (fj,'@@file fj-test-1',fj(loadDir,'rel-path')),
)

for func,h,expected in table:
    p = g.findNodeAnywhere(c,h)
    assert p,'not found: "%s"' % (h)
    assert p.h.startswith('@@')
    p.h = p.h[1:] # Remove the first @ sign.
    
    try:
        d = c.scanAllDirectives(p)
        result = d.get('path')
        assert result == expected,'expected "%s", got "%s"' % (
            expected,result)
    finally:
        p.h = '@' + p.h
        c.redraw()
</t>
<t tx="ekr.20130503061707.10516"></t>
<t tx="ekr.20130503061707.10517"></t>
<t tx="ekr.20130503155210.24814">@nocolor-node

Rewrite in screencast-script style:
- Docstrings for the most important plugins.
- All help-for-&lt;topic&gt; text.
- Leo's tutorials.

** Screencast style for plugins docstrings.
* Screencast style for help messages.
* Screencast style for tutorials.
* Create YouTube channel for Leo screencasts.

Topics:
- Minibuffer: alt-x, tab-completion.
- @button.
- @rclick
- Find/Change (done)
- execute-script.
- bookmarks.py.

</t>
<t tx="ekr.20130508084413.10631">How easy is this to do?
</t>
<t tx="ekr.20130508084413.10634"></t>
<t tx="ekr.20130803073926.12442">- Waiting for answer to solarized question:
    http://qt-project.org/forums/viewthread/30838/
    https://groups.google.com/forum/#!topic/leo-editor/W1_LVrQxdwQ
</t>
<t tx="ekr.20130803125244.17077">@nocolor

From: ne1uno &lt;eltronis@gmail.com&gt;

http://groups.google.com/group/leo-editor/about

still has the old home page webpages.charter.net
though it also has leoeditor.com/ for discussions.

The google docs state that it is not possible to change the web site for a google group.
</t>
<t tx="ekr.20130803125244.17100"></t>
<t tx="ekr.20130805080841.21380">@language javascript

https://groups.google.com/forum/#!topic/leo-editor/dmC8iIKlF7g

Bug 
https://bugs.launchpad.net/leo-editor/+bug/1222947

Here is the test file::

    var express = require('express');
     
    var app = express.createServer(express.logger());
     
    app.get('/', function(request, response) {
    response.send('Hello World!');
    });
     
    var port = process.env.PORT || 5000;
    app.listen(port, function() {
    console.log("Listening on " + port);
    });
</t>
<t tx="ekr.20130806072439.20369">From: &lt;offray@riseup.net&gt;

I have been using txt2tags + Nested Editor to produce structured docs in 
a light markup and exporting them to HTML and LaTeX &gt; pdf. The fine 
tunning on the pdf output is done by editing the LaTeX source in Leo. I 
like the aesthetic of the source code and the outputs and I have 
contacted the Nested author in order to get some cross-pollination 
between it and Leo [1].

[1] 
https://groups.google.com/group/nestededitor/browse_thread/thread/7068e3cd229d4614 

Now I think that is time to start hacking Leo for a better support of my 
work flow and the first thing I would like to have is a "@paragraph" 
directive that works the same as @rst-no-head but can be used in any 
part of a (sub)tree, even if is not @rst (sub)tree. This would come 
handy in chunking and reassembling LaTeX docs without marking up the 
parts with "&lt;&lt;chunk&gt;&gt;" tags.

===== EKR

Interesting idea. Please file a wishlist bug at https://bugs.launchpad.net/leo-editor.

===== offray As I have say repeatedly I'm an "end user" 
of Leo and I have browse the doc about developing in Leo in [2] and I 
plan to follow it as a tutorial, but any pointer to a more detailed 
section to pay attention or to the Leo trees to start hacking is welcomed

[2] http://webpages.charter.net/edreamleo/scripting.html

</t>
<t tx="ekr.20130806072439.20371">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

The title pretty much says it all.  This is a significant improvement, and 
makes Leo suitable for authoring text.  It should have been done ages ago. 
Please let me know immediately if this new behavior causes problems for you.

There is one glitch.  If you add @wrap, the directive won't be in effect 
until you leave the node and revisit it.

===== redla &lt;radim.halir@gmail.com&gt;

There is one problem which is (IMHO) caused by this change: I have @wrap 
active and see my "plain" text wrapped properly. But if there is any "long 
enough" URL on the page (i.e. longer than the screen width), this is not 
wrapped (as there is no space in the string) nor I can see the end of it 
(as there is no horizontal scrollbar either) ;-(

===== EKR

The workaround is to disable @wrap in order to see the url, but this is
clumsy.
</t>
<t tx="ekr.20130806072439.20374">From: HaveF &lt;iamaplayer@gmail.com&gt;

1. Aha Sometimes, I just wonder, I write a script (say, @button button-1)
in leo-file-A.leo, and reuse it by copy(ctrl+shift+c) the button to
leo-file-B.leo.

When I'm working on leo-file-B.leo, I may have ideas to improve the
@button button-1, but at that time(working on leo-file-B.leo), I may
forget where the original place of @button button-1 is. Even I store
the original scripts in the default workbook.leo is a tedious work to
deal with(open it, locate where the original script is, update it...)

But! After I add the @url at the first line of @button button-1, I can
decide if the improvements what I made on leo-file-B.leo's @button button-1
should or shouldn't be merged to the original and upstream @button
button-1(in leo-file-A.leo) easily by just a click.

And if I work on leo-file-C.leo, I want to use the same script, but I just
only remember I use the script in the leo-file-B.leo instead of original
place. With @url I can easily jump to original place, and copy it to
leo-file-C.leo.

Using @url in the leo script, I can make the scripts consistency and
diversity at same time.

Great! But, Wait, wait!

2. Feature request.  At this time, you can use this idea by comment the @url
line after jump. If @url isn't comment, the leo-editor will say...
SyntaxError: invalid syntax at the @url line.

Maybe it is a good idea to omit the @url line in the script when executing
script?

===== EKR

Yes.  I think this is a good idea.  A similar idea occurred to me when
looking at @rclick nodes.  At present, the context_menu plugin contains an
ugly hack:  it allows an @rclick node to *follow* an @button node.  This is
needed at present when the @button node contains @others: the @rclick node
can't be part of the script "pulled in" by @others.

It would be much more elegant to ignore @rclick nodes when computing the
script.  This would require a change to the @others logic, but I think it
is worthwhile.

===== Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I do this kind of thing by keeping buttons in @files...

@file ~/.leo/gen  # general utility buttons
@file ~/.leo/dml  # tools for editing an XML dialect I use
@file ~/.leo/sql  # tools for editing SQL / interacting with server

so changes made in one outline are automatically propagated to other
outlines next time they're reloaded.  You just reference the files
in each outline where you want those buttons.

&gt; 2. Feature request
&gt; At this time, you can use this idea by comment the @url line
&gt; after jump. If @url isn't comment, the leo-editor will say...
&gt; SyntaxError: invalid syntax
&gt; at the @url line.
&gt; 
&gt; Maybe it is a good idea to omit the @url line in the script when executing
&gt; script?

This probably would make sense, already the scripting machinery is
ignoring things like @nocolor or @language cobol or @nowrap etc.

Maybe you could file a wish-list bug item for tracking.
</t>
<t tx="ekr.20130806072439.20377">From: HaveF &lt;iamaplayer@gmail.com&gt;

When I use @url node in @shadow file, the node
should not be in public file, right?
</t>
<t tx="ekr.20130806072439.20380">From: HaveF &lt;iamaplayer@gmail.com&gt;

When I use auto-rst import rst file, sometimes, the author write extra
characters which aren't harm, but the leo says it is a error...like this
one:

reading: @auto-rst README

Error: @auto did not import @auto-rst README perfectly
The clean-all-lines command may help fix whitespace problems
first mismatched line: 20 (original) = 20 (imported)

Original file...

  18 u'how the learning experiment went.\\n'
  19 u'Step 1: Create the dataset\\n'
  20 u'----------------------------\\n'
  21 u'From this directory, run\\n'
  22 u'python make_dataset.py\\n'

Imported file...

  18 u'how the learning experiment went.\\n'
  19 u'Step 1: Create the dataset\\n'
  20 u'--------------------------\\n'
  21 u'From this directory, run\\n'
  22 u'python make_dataset.py\\n'

inserting @ignore

errors inhibited read @auto
D:\\OpenCourses\\ufldl\\ref\\pylearn2\\pylearn2\\scripts\\tutorials\\grbm_smd\\README

reading entire file into @auto node.

reading: @edit README

finished

The problem is the line 20 has two extra '-', when I remove it manually,
the import works.

Do you have a better idea to do this than do it manually?

===== From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sat, 18 May 2013 16:50:12 +0800
HaveF &lt;iamaplayer@gmail.com&gt; wrote:

&gt; Original file...
&gt; 
&gt;   18 u'how the learning experiment went.\\n'
&gt;   19 u'Step 1: Create the dataset\\n'
&gt;   20 u'----------------------------\\n'
&gt;   21 u'From this directory, run\\n'
&gt;   22 u'python make_dataset.py\\n'

At first I thought that the rst was invalid, but the docs. say
  The underline/overline must be at 
  least as long as the title text. 
http://docutils.sourceforge.net/docs/user/rst/quickref.html#section-structure
so I guess it's not.  But leo has nowhere to store the length of the
underlining.  Also, this is related to the issue where Leo changes the
underline characters used, e.g. = -&gt; - and * -&gt; # etc.

I think the easiest solution is going to be to do the import and just
remove the @ignore afterwards, checking that there are no changes that
matter.  Perhaps the wording of the @ignore message could make it
clearer that the import may not have failed, but just needs checking.

===== HaveF &lt;iamaplayer@gmail.com&gt;


But in fact, the @auto-rst load this rst file like @auto, no @ignore node 
at all.

My import procedure is like this:
1. make a node name:
@auto-rst models.txt
2. right click it, and select "refresh from disk"


And I just find another problem...
If the rst file like this:

MLP
===

It also occurs error:

reading: @auto-rst models.txt

Error: @auto did not import @auto-rst models.txt perfectly
The clean-all-lines command may help fix whitespace problems
first mismatched line: 10 (original) = 10 (imported)

Original file...

   8 u'    :members:\\n'
   9 u'MLP\\n'
  10 u'===\\n'
  11 u'.. automodule:: pylearn2.models.mlp\\n'
  12 u'    :members:\\n'

Imported file...

   8 u'    :members:\\n'
   9 u'MLP\\n'
  10 u'====\\n'
  11 u'.. automodule:: pylearn2.models.mlp\\n'
  12 u'    :members:\\n'

inserting @ignore

errors inhibited read @auto D:\\OpenCourses\\ufldl\\ref\\pylearn2\\doc\\library\\models.txt

reading entire file into @auto node.

reading: @edit models.txt

finished

It says I need a extra "="...

I have attached this file, for someone has interest to reproduce the error.

</t>
<t tx="ekr.20130806072439.20387">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Just an idea:

After discovering sublime edit, I have started using external editor mode
more (rclick -&gt; Edit in...). Annoyance there is that once you save in
external editor, you still have to go to leo and save there, or your
changes will be lost if you close leo without saving.

This can lead to loss of data if you don't routinely agree to save changes
when closing Leo. I often don't do this, as I save all the time when I
type, and don't want to save accidental changes I might have done to the
leo document; I don't usually have time to review changes when closing a
document.

Maybe .leo could automatically save the tree if and only if the externally
edited node is the only dirty one.

===== EKR

I agree there is a problem, but I don't believe hacking Leo's save logic is
a good idea, for several reasons:

1. There might be several dirty nodes, and you could still lose data
(strictly following your suggestion) in that case.

2. The write logic for external files is complex, mainly due to file
caching.  I tolerate that complexity because caching is such a big win.
But it would not be easy to do @file AI to discover the special case you
mention.

3. Imo, the proper place to handle this problem is in the vim and xemacs
plugins.  These plugins are responsible for the interaction with Leo.

Would it work for you if the xemacs and vim plugins automatically saved an
external file whenever the plugin caused a node in that file to become
dirty?  This would likely solve the problem you mention, although I
wouldn't be my life on it.

Your comments, please.

===== Matt Wilkie &lt;maphew@gmail.com&gt;

I've been bit by this several times too.

It's lead to me relying on pyscripter (my usual external editor these days,
has more useful to me command completion than leo) more and more, when I
otherwise might just nip out, do a few things and come back.

===== EKR

One thing that must be done in any case is to provide alt-x commands for
all context-menu entries.  There is something wrong with having to use the
mouse at all...

===== Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Coincidentally I added the alt-X command 'context-menu-open' a week or
so ago, letting you open the context menu with a keyboard binding so
you can then navigate the menu with the cursor keys.

This is because not all menu entries can have alt-X commands,
specifically the quickMove plugins commands for moving nodes to
pre-defined destinations in other outlines, this is basically a list
selection operation, but being on a sub-sub-menu it's a pain with the
mouse, and easier with the cursor keys.

This is part of my method for handling todo items for different
projects, they are imported from email to one outline, and then I file
them to the relevant project outline's todo node.  Which creates a
management problem I just found a surprisingly viable solution for I'll
mention in another post.

===== From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

I wouldn't change the save logic, I'd just execute "save" for the full .leo
document when

- Node has changed in external editor.
- The node that changed is the only dirty node in the whole leo document.

I don't use xemacs/vim plugin, but rather "edit in" in right click menu
(contextmenu.py plugin IIRC).

I agree that this is not an elegant proposal, in that it involves a
potentially surprising (if useful) special case.

I have to think this a bit more. Perhaps some kind of extra warning in the
UI for this scenario would do the trick as well.

</t>
<t tx="ekr.20130806072439.20394">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Nov 29, 2012 at 6:30 AM, Ville M. Vainio wrote:

&gt; I wouldn't change the save logic, I'd just execute "save" for the full 
&gt;&gt; .leo document when 
&gt;&gt;
&gt;&gt; - Node has changed in external editor.
&gt;&gt; - The node that changed is the only dirty node in the whole leo document.
&gt;&gt;
&gt;&gt; I don't use xemacs/vim plugin, but rather "edit in" in right click menu 
&gt;&gt; (contextmenu.py plugin IIRC).
&gt;&gt;
&gt;
&gt; Ok.  In that case the contextmenu plugin should handle this. 
&gt;

I believe that c.openWith should be able to deal with this problem.  
c.openWith creates a temporary external file and updates a node when the 
user changes that file.  This logic is independent of the editor being 
used; it works, for example, with Scite, my default external editor.

Clearly, c.openWith (or rather, one of its helpers) is able to update the 
node and to mark it dirty.  So at the time the node is marked dirty 
c.openWith has an opportunity to automatically save the file containing the 
vnode.  c.openWith can issue a colored message to the log pane, but that 
should be the only "warning" necessary.

My present plan is to write a helper, say c.write_vnode, that will discover 
the external file (if any) containing the vnode, and immediately write that 
external file *without* a prompt.  If there is no external file, 
c.write_vnode could just do an ordinary save of the .leo file and all dirty 
external files.  Alternatively, c.write_vnode could write only the .leo 
file (the write-outline-only command) *without* clearing the c.changed bit.

I believe c.write_vnode will solve this problem fairly completely.  What do 
you think, Amigos?

Edward
</t>
<t tx="ekr.20130806072439.20395">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Nov 29, 2012 at 9:17 AM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote:

&gt;
&gt; Clearly, c.openWith (or rather, one of its helpers) is able to update the
&gt; node and to mark it dirty.
&gt;

The "helper" is the idle-time hook,  editnode_on_idle, in contextmenu.py.
You could call this good news, because our experiments with auto-saving can
be confined to the contextmenu plugin.  If our experiments end happily we
can use the same techniques in the vim and xemacs plugins.

I'll wait awhile for your comments before going ahead with the proposed
changes.
</t>
<t tx="ekr.20130806072439.20396">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Tue, Dec 11, 2012 at 5:55 AM, Ville M. Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; """
&gt; My present plan is to write a helper, say c.write_vnode, that will
&gt; discover the external file (if any) containing the vnode, and immediately
&gt; write that external file *without* a prompt.  If there is no external file,
&gt; c.write_vnode could just do an ordinary save of the .leo file and all dirty
&gt; external files.
&gt; """
&gt;
&gt; Maybe a relatively safe solution is to do this:
&gt;
&gt; 1) My present plan is to write a helper, say c.write_vnode, that will
&gt; discover the external file (if any) containing the vnode, and immediately
&gt; write that external file *without* a prompt.
&gt;
&gt; But not do this:
&gt;
&gt; 2) If there is no external file, c.write_vnode could just do an ordinary
&gt; save of the .leo file and all dirty external files.
&gt;
&gt; This way, if you "want to be safe", you will create an external @file for
&gt; the content.
&gt;
&gt; For situation 2), some kind of loud warning is in order, not sure of what
&gt; kind though. Red g.es?
&gt;

Thanks for this suggestion.  I have a great distrust of all operations
containing "if" statements in their explanation.  Somehow, we need a
simpler approach, but I don't know what it is.

</t>
<t tx="ekr.20130806072439.20397">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Nov 29, 2012 at 6:30 AM, Ville M. Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; I wouldn't change the save logic, I'd just execute "save" for the full
&gt; .leo document when
&gt;
&gt; - Node has changed in external editor.
&gt; - The node that changed is the only dirty node in the whole leo document.
&gt;
&gt; I don't use xemacs/vim plugin, but rather "edit in" in right click menu
&gt; (contextmenu.py plugin IIRC).
&gt;

Ok.  In that case the contextmenu plugin should handle this.

&gt;
&gt; I agree that this is not an elegant proposal, in that it involves a
&gt; potentially surprising (if useful) special case.
&gt;
&gt; I have to think this a bit more. Perhaps some kind of extra warning in the
&gt; UI for this scenario would do the trick as well.
&gt;

I agree that if the code is going to do something like this it should issue
a clear warning that something has happened.  Otoh, such "clear warnings"
tend to get ignored :-)  Indeed, the problem is that you are *already*
ignoring such a clear warning!  Adding another warning is not likely to be
a big help...

Edward
</t>
<t tx="ekr.20130806072439.20430">was: Does dabbrev work?
From: "F.S." &lt;speech.free@gmail.com&gt;

The answer seems to be based on the exchange here:
https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/dabbrev/leo-editor/3A4JOHqhJSU/W1DjTvooNCkJ

Summary: Alt-/ always shows a completion list. Backspace works as expected:
showing more and more items.  Nothing needs to be done.

**Possible minor improvements**

In Emacs M-/ (dabbrev-expand) just expands to the first choice. You then
cycle through the choices by repeating M-/. If you go too far you can cycle
back with C-/. C-M-/ (dabbrev-completion) expands to the longest common
prefix.

With 5473: I seem to already get the behavior you are talking about: that on
M-/ I get a completion list. I agree that getting a list is nice, esp if
&lt;backspace&gt;&lt;tab&gt; show more choices. (It does).


I think there are a few use cases here:
1) I know exactly what I want but I just don't want to type it again (I may 
be lazy or I don't want to create a typo) so give it to me with as few key 
strokes as possible
2) I am not quite sure so let me see the choices
3) None of the choices is what I need so let me go back and show me some 
more choices

Maybe a combination of behavior is the best. With M-/ and C-/ one just 
cycles through the choices (auto inserted), which takes care of 1). 
With C-M-/ (dabbrev-completion) one gets the longest prefix auto inserted 
and a list of choices. Now it would be truly great that if we can easily 
just &lt;backspace&gt;&lt;tab&gt; to see potentially more choices. But how do you 
interface with both? For 2) one desires to type just one more letter so as 
to make a choice in the choice list. For 3) we need to go back but may need 
backspace quite a bit to get back to before where we started (the only 
place where we can get new choices) -- can that be achieved with a single 
backspace instead?

For example suppose I have abcdefg and abwxyz. I type abc, C-M-/ and 
abcdefg is the sole completion. I may not want it but it would be nice to 
not have to backspace all the way to b to see the other choice. In other 
word if I backspace at all it is understood that I want to go before where 
I started (before where the auto insertion takes place). That would be neat!


@language python
</t>
<t tx="ekr.20130806072439.20485">Importing java file using @auto. How do I adjust Leo to ignore whitespace and indentation irregularities?
From: Eoin &lt;eoinmccarthy@fastmail.fm&gt;

I'm using @auto to import java files into my Leo project. I'm then cloning 
various methods as sub-nodes of new feature nodes. 
It's helping keep my development focussed - and is useful to look back and 
see what parts of the codebase I've worked on for each feature. 

However, the whitespace in the Java files isn't completely regular. In 
particular, debug logging is always placed in column 1 - regardless of the 
surrounding indentation. 
Other people are also working on these files, so I'd rather not mess with 
the established convention. 

As things stand, when Leo imports a file its outputting a bunch of error 
messages:
* error: underindented line. Extra leading whitespace will be added
* warning: intermixed blanks and tabs

The creation of the auto node goes fine - though the final result has an 
@ignore directive in its root node. 
When working, I just take the @ignore away and clone the methods I want to 
work on. 
The problem is when I close the Leo file and re-open it later on, the same 
errors occur during the building of the auto node and the previous cloned 
information is lost. 
To restart work on a feature, I need to reclone the appropriate nodes. Not 
a showstopper, but not ideal. 

I tried adjusting the info in the JavaScanner class in the core 
leoImport.py file as follows:

        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.classTags = ['class','interface']
        self.functionTags = []
        self.sigFailTokens = [';','='] # Just like c.
        self.strict=False

I deleted the pyc file and restarted Leo. A new pyc file appears, so the 
compiled to bytecode seems to be ok.

I was hoping the the setting of self.strict = False would allow the parsing 
to ignore the whitespace and indentation issues. 
I'm still getting the same errors though. 

Any help appreciated. I'm using Leo 4.10-final. 

===== EKR

There is no easy way to do this at present, but it's probably reasonable to
disable errors (and not add @ignore) for underindented comments for
non-strict languages.

Please file a wishlist bug for this.  Thanks.
</t>
<t tx="ekr.20130806072439.20497">@language rest

From: Viktor Ransmayr &lt;viktor.ransmayr@gmail.com&gt;

even at the latest revision (rev. 5500) Leo does not display all content of 
larger nodes
- Larger nodes approximately defined as &gt;= 150 lines ...

That is searching for example for a 'TO-DO' item just return this 
particular line w/o the
context  around. - Going up - or - down does not refresh the screen &amp; 
content ...

I thought I could provide you with an outline, where this problem 
consistently shows up.
- However, whenever I trim the personal outline I'm using the problem 
disappears.

This problem is really annoying - and - I would gladly provide more input, 
but so far I
fail. - Any suggestion?

With kind regards,

Viktor

PS: For completeness here's the log from Leo's startup:

&lt;log&gt;

Leo Log Window
Leo 4.11 devel, build 5500, 2012-10-19 18:35:23
Python 3.2.2, qt version 4.8.0
Windows 6, 1, 7601, 2, Service Pack 1
leoID=VR20100603 (in D:\\Users\\Viktor Ransmayr\\.leo)
load dir: D:\\Branches\\leo-editor\\leo\\core
global config dir: D:\\Branches\\leo-editor\\leo\\config
home dir: D:\\Users\\Viktor Ransmayr
reading settings in D:\\Branches\\leo-editor\\leo\\config\\leoSettings.leo
reading settings in D:\\Users\\Viktor Ransmayr\\.leo\\myLeoSettings.leo
reading settings in D:\\Users\\Viktor Ransmayr\\Documents\\Leo-BR-r5500.leo
reading: D:\\Users\\Viktor Ransmayr\\Documents\\Leo-BR-r5500.leo

&lt;/log&gt;
</t>
<t tx="ekr.20130806072439.20498">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I can confirm that this type of bug is still present in 5500 also.

Yesterday I was noticing this:

 - editing a node (A)
 - create new node by accidentally hitting insert
 - delete new node immediately while still in headline edit mode using
   cut-node 
 - node A is displayed incorrectly, a line is missing, selecting the
   body restores the missing line

vs. the above but selecting the body of the inserted node, then
deleting it, in which case A is displayed correctly without selecting
its body.

Today (the outline's changed) it's not doing that, but I still
notice the difference between inserting and immediately deleting a node
(scroll position in A restored incorrectly), vs. inserting a node,
selecting its body, and then deleting it (scroll position in A restored
correctly).

So, there's some execution path difference between A being selected
after an inserted node is deleted immediately (still in headline edit
mode) vs. after selection of its body.

Not a very helpful report, but maybe the difference between deletion of
the node immediately and after selecting its body guides you to a
particular piece of code.
</t>
<t tx="ekr.20130806072439.20499">From: resi147 &lt;scalet@yebu.de&gt;

I also have the same problem, using the official 4.10 final.
I.e. a couple of lines are missing in the node (the linecounter
increments and decrements but the cursor does not move).

Not sure what report could be useful.
I also feel like it occurs on larger body nodes.
</t>
<t tx="ekr.20130806072439.20501">From: lewis &lt;lewisneal@operamail.com&gt;

Same issue for me has been occurring on a large node. Interestingly, I can
only reproduce the display error when 'Leo Log Window' is at bottom left
position which is my ''initial_split_orientation' setting (horizontal: body
pane to the right). I can use Window&gt;Toggle Split Direction to correct the
initial display error.

For me, the display error always becomes evident at line 95. My line
numbers 95,96 are visible then skips to 118. Lines 97 thru 117 are not
displayed. It appears to be graphics performance time lag; if I return to
the file after having switched to another leo tab the previously invisible
lines are visible.

Leo Log Window
Leo 4.11 devel, build 5647, 2013-04-02 08:03:37
Python 3.3.1, qt version 4.8.4
Windows 6, 1, 7601, 2, Service Pack 1
</t>
<t tx="ekr.20130806072439.20523">From: Craig Johnson &lt;craig@hivemind.net&gt;

I'm trying to use rst tables by using the table markup in the body text, 
with one node per table row.  However it seems that the nodes are being 
preceded with a line-feed even-though @rst-no-head is in effect.
 
Can anybody help with preventing that line-feed, it breaks the rst table 
formatting.

===== EKR

Hmm.  My guess is that a new @rst directive would be needed.  The
workaround would seem to be to put the entire table in a single node, but
presumably you have your reasons for not wanting to do that.

Feel free to file a wish-list bug.

===== Craig Johnson &lt;craig@hivemind.net&gt;
 
I've been creating rst tables using rst markup directly in the body text.  
For field lists.  As the same field apears in multiple programs, I would 
like to use Leo's cloning to reproduce a table row in several locations in 
the tree.  The issue that prevents me from doing this, is that an 
@rst-no-head headline seems to generate a line-feed preceeding the body 
text in the derived file which breaks the table parse.
 
Maybe a example:
The Leo tree:
 
+Program1
  +Parameters
       =================== ========
       Field Name          Format
       =================== ========
    +@rst-no-head Field1
        prmField1          Integer
 
Results in the following markup
Program1
^^^^^^^^^
Parameters
~~~~~~~~~
=================== ========
Field Name          Format
=================== ========

prmField1           Integer
That blank line in the markup before the node body text breaks the table.
 
===== wgw &lt;wgwinder@gmail.com&gt;


No fix (sorry), but can confirm the problem -- it should go in the bug
list. (I looked at the rst code, and fainted)

I note that your format wouldn't work without closing the table off:


Field Name                       Format
 add                                    add

But you are right: @rst-no-head doesn't work properly.

Looks like you can only post process the rst intermediate file and=20
eliminate that extra line.
</t>
<t tx="ekr.20130806072439.20531">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

(This is a response to the invisible line glitch, but not directly
related, so a new thread)

Remember this:

http://groups.google.com/group/leo-editor/browse_thread/thread/ee869a0a70f2d765

Some time ago I was working on styling Leo from a single top level
stylesheet using a mechanism similar to CSS classes, so instead of:
    
    # widget is active
    w.setStyle("QTextEdit { color: red; font-weight: bold; }")
    
    ...
    
    # widget is inactive
    w.setStyle("QTextEdit { color: black; font-weight: normal; }")
    
you'd have

    # widget is active
    w.setAttribute('active', True)
    
    ...
    
    # widget is inactive
    w.setAttribute('active', False)

and in the single global style sheet

    QTextEdit[active="true"] { color: red; font-weight: bold; }
    QTextEdit[active="false"] { color: red; font-weight: bold; }

This isn't a perfect example because if active == focused then you
could probably just use the pseudo-state :focus and let Qt do all the
work, and also Leo would .setStyle() a string defined in @settings, not
something hard coded.

Qt styles are different from CSS in that CSS has a single attribute,
`class`, which can contain a space separated list of tags, whereas Qt
has arbitrary attributes like the `active` I just made up above.
</t>
<t tx="ekr.20130806072439.20643">From: HaveF &lt;iamaplayer@gmail.com&gt;

I used python xy before. After I finish install python xy, the leo is ready
to use.

Today I try EPD(https://www.enthought.com/downloads/), and install pyqt4 at
its package manager.

After that, I try to start Leo, it failed, but I success at last.

the batch file should be:

C:\Users\HaveF\AppData\Local\Enthought\Canopy\User\Scripts\python.exe
D:\lib\leo\leo-editor-snapshot\launchLeo.py %*

not:

C:\Users\HaveF\AppData\Local\Enthought\Canopy\App\python.exe
D:\lib\leo\leo-editor-snapshot\launchLeo.py %*

or:

C:\Users\HaveF\AppData\Local\Enthought\Canopy\System\Scripts\python.exe
D:\lib\leo\leo-editor-snapshot\launchLeo.py %*

===== From: HaveF &lt;iamaplayer@gmail.com&gt;

the tip is for install Canopy just for yourself (per-user install)
</t>
<t tx="ekr.20130806072439.20650">From: Winn Dixie &lt;incredible0n3@gmail.com&gt;

Would be stellar to have a brew install leo. http://brew.sh/

Homebrew formulae are simple Ruby scripts::

    require "formula"
    
    class Wget &lt; Formula
      homepage "http://www.gnu.org/software/wget/"
      url "http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"
      sha1 "f3c925f19dfe5ed386daae4f339175c108c50574"
    
      def install
        system "./configure", "--prefix=#{prefix}"
        system "make", "install"
      end
    end

To install homebrew, paste this in a terminal::

    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

The script explains what it will do and then pauses before it does it.
</t>
<t tx="ekr.20130806072439.20664">From: Geoff Evans &lt;gtevansai@nl.rogers.com&gt;

The Leo installation instructions for Ubuntu still say merely "find and
install the debian package". Can someone tell me where to find it? Several
minutes searching on google has not got me anywhere.

===== From: Matt Wilkie &lt;maphew@gmail.com&gt;

Please try the instructions here and report if they are still relevant:
https://groups.google.com/d/msg/leo-editor/9yqhWD90Vtg/yCR8O_FBvIwJ ?

===== From: Geoff Evans &lt;gtevansai@nl.rogers.com&gt;

Excellent! Thanks very much Matt (and Ville for creating it). There was one
error message about a signature that could not be verified, and a syntax
error while compiling /usr/lib/pymodules/python2.7/leo/external/edb.py but
they haven't stopped leo from opening files from my previous computer. The
new one is running precise, in case it matters.

Minor supplementary question: What search strategy would have led me there
on my own? I agree that "Leo now apt-gettable" is perfectly understandable
once I see it (and indeed I have a vague memory of having seen it before),
but I don't know how I would have arrived at it without your help.

</t>
<t tx="ekr.20130806072439.20677">On Monday, 15 April 2013 13:06:39 UTC-7, Matt Wilkie wrote:

Installing pip on Windows is easy enough, but involves silly monkey work
(install this pre-requiste, copy this text and paste it there, twiddling
X,Y,Z for your machine. etc.) It's easy to make small stupid mistakes that
make one have to repeat parts of the operation. So I automated installing
pip all in one go. Nothing but an available python interpreter is required
(and an internet connection).

http://www.maphew.com/2013/install-pip-script/
</t>
<t tx="ekr.20130806072439.20683">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Can someone on linux please test whether

   pip install -i https://testpypi.python.org/pypi leo-editor

successfully installs a working Leo on their system?

You can use `virtualenv` to create an isolated test environment
http://www.virtualenv.org/en/latest/ if needed.

===== From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

seemed to work for my in a fresh python 3.3 virtualenv

i.e.
import leo
leo.run()
ImportError: No module named 'PyQt4'

so in the shell

cp -rv /usr/lib/python3/dist-packages/PyQt4 p3/lib/python3.3/site-packages/
cp -rv /usr/lib/python3/dist-packages/sip* p3/lib/python3.3/site-packages/

and then the above worked.

remember also:

https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/Runnable$20Leo$20in$20one$20.zip$20file./leo-editor/jnpkrQeo9Hk/Ds3QsUe1W-QJ

including HansBKK's good point.

===== Matt

The take away is that there is a pure python method to install pip, which
in turn can easily install Leo and docutils, meaning the two don't have to
be bundled.

There is still more work to do get PyQt + SIP install automated in a way
that integrates nicely with Start Menu etc., but we have proof of concept
that it is possible.

At the very least we have a recipe that can easily build a complete ready
to run all-in-one zip bundle for Windows. I'll work on this next, and then
dig more into the pyqt+sip aspect.

</t>
<t tx="ekr.20130806072439.20707">@language rest

Edward, Ville, please pay attention to this message even if just nodding at
the others passing by.

&gt;pip install -i https://testpypi.python.org/pypi leo-editor

I built and uploaded to this package to the pypi testing server. Other than
the fact it seems to work in so far as it installs without spewing errors
I've no idea if it was done properly. Or even if it was appropriate for me
to build a leo package. This is the first pypi package I've built.

The package page: https://testpypi.python.org/pypi/leo-editor/4.10-final

I'll upload the changed `setup.py` and the build recipe I used for your
inspection after I re-learn how to create a branch and issue a pull/merge
request in bazaar.


===== Matt

https://code.launchpad.net/~maphew/leo-editor/pypi-packaging/+merge/159561

Description of the Change

Updated `setup.py` for Leo-4.10-final, added "Classifiers" as made sense to
me. The resultant source build package was uploaded to the testing Python
Package Index server, from which `pip install leo-editor` is successful.

A windows binary distribution build does not appear to be necessary.

Known limitations: __py-cache__ files are included, but shouldn't be.

===== Matt

The created .zip file:

Here is the result of that recipe, with some very small hand edits,
packaged up in an all-in-one ready to go portable Leo zipfile (52mb).
Simply unpack somewhere and run Leo.bat.

https://googledrive.com/host/0BxjYoJ7VMm5VbE11NHM3Q3RIRVk/
</t>
<t tx="ekr.20130806072439.20712">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt;call root\\osgeo4w.bat

Adds ...\\bin (for python) and ...\\apps\\python27\\scripts (for pip) to PATH,
and sets PYTHONHOME.

&gt;wget --no-check-certificate
http://gist.github.com/maphew/5393935/raw/install-pip.py
&gt;python install-pip.py GO
&gt;python install-pip.py GO

Download and install `distribute` and `pip`, the python tools which enable
automated downloading and installing of programs and modules from the
Python Package Index. `install-pip.py` is of my own devising. All it does
is reduce the dependency on curl or wget by one step, using native urlib
(py3) or urllib2 (py2) instead.

   http://pythonhosted.org/distribute/
   http://www.pip-installer.org/en/latest/
   https://pypi.python.org/pypi

&gt;pip install -i https://testpypi.python.org/pypi leo-editor

Install Leo (more background for this one in next message).

&gt; python apps\\Python27\\Scripts\\leo

All done, let's run Leo! :)
</t>
<t tx="ekr.20130806072439.20722">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Use the `apt` command line package management tool from Osgeo4w
http://trac.osgeo.org/osgeo4w/ to install python and all the other
requirements that can't be installed with `pip` or `easy_install`, meaning
PyQt and SIP.

The resultant dir structure follows a cygwin model, which in turn follows
linux:

    \apps\Python27 - python libraries, site-packages, etc. This is PYTHONHOME.
    \bin - exe's and dll's, including python.exe, qt*.dll, etc.

There are also `etc, include, lib, var` which can all be discarded, unless
you intend to use apt again or other programs from the osgeo4w ecosystem).
`var` in particular you might want to clean out, it is the local cache for
apt downloaded packages.


===== Whoa, apt on windows, cool.

Thanks! It's been the gravity well powering my plunge into python. It's a
testament to python's power that it enables someone like me, with no
programming background, to build something that does real work.

The original genius is Jan Nieuwenhuizen, who wrote `cyg-apt` in python but
made lots of calls to bash and tools like tar and curl. All I've done is
take each function and convert them as best I could to pure python, to the
point where it now has zero dependencies on cygwin (though it does still
use the cygwin package and mirror structure).

More history and details at http://trac.osgeo.org/osgeo4w/wiki/pkg-apt
</t>
<t tx="ekr.20130806072439.20730">From: Matt Wilkie &lt;maphew@gmail.com&gt;

I've just uploaded Leo-4.11-devel-build-5769 to the Python Package Index:
https://pypi.python.org/pypi/leo

(todo: fix the readme, which is for 4.10, the 4.11 version remains to be
written)

It can be downloaded from there and installed manually or, better yet,
installed with `pip install leo`.

Pre-requisites are:

1. Python
2. PyQt
3. Distribute / Setuptools

Improvements over previous pypi package:

 - Sports Leo splash screen while installing on Windows

 - Installs "leo" and "leoc" wrappers to PYTHONHOME\\Scripts, so as long as
this directory is in PATH you don't need to create your own launcher (this
is the part that requires Distribute. I'm working an way to include this
automatically, http://stackoverflow.com/questions/16702658). It is common
for this to be set.

- all the other changes in trunk over the last couple of weeks (
http://bazaar.launchpad.net/~leo-editor-team/leo-editor/trunk3/changes)
</t>
<t tx="ekr.20130806072439.20732">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Summary - it's easy to make a .zip file containing Leo and all it's
dependencies.

Inspired by Matt's recipe, using VirtualBox throw away 1GB Windows XP
32 bit machines, I tried the following.

Install Python (installer from python.org) 2.7.2 to 

  C:\Docouments and Settings\someuser\Desktop\leo\python27

Install PyQt (installer from Riverbank) 4.9 into the same folder (it
goes there by default)

Unzip http://www.greygreen.org/leo/leo-editor-latest.zip into

  C:\Docouments and Settings\someuser\Desktop\leo\leo-editor-latest

Make leo.zip from C:\Docouments and Settings\someuser\Desktop\leo

Delete the virtual machine, purging any registry entries etc. created
by the two installers.

On a fresh machine, searched the registry for 'python' just to be sure,
found nothing.

Unzip the .zip file, then

  cd C:\Docouments and Settings\someuser\Desktop\leo
  python27\python.exe leo-editor-latest\launchLeo.py

And Leo opens a blank outline, after asking for an ID, as it's supposed
to.  Didn't test it beyond that.

So, the .zip file contains all Leo needs to run, and obviously
runLeo.bat could be added in the top level to actually launch it.

Of course this is for Windows, so I think it's an improvement over
asking people to install Python and PyQt first, but neither of those
steps was that hard in Windows anyway.

===== EKR

Is this a technique that we could use for official Windows releases?
If so, what exactly would we do?

===== Terry

I guess, perhaps as an all-in-one option with a system integrated
option for those who want to use system python/qt.  Don't know if it
violates and licensing on Python / Qt, everything's being distributed
unaltered, so I wouldn't think so.

So basically you'd give people a large .zip file and tell them to
extract it to a folder and run the batchfile at the top level.  If they
can't do that, they might not be ready for Leo :-)  I guess you could
make it a self-extracting .zip, for that matter.

Also, the daily snapshot could be made this way, seeing once Python and
Qt are installed in the folder the Leo version can just be copied in.

It's not uncommon for FLOSS to be distributed this way, both Blender
and Inkscape use this approach, particularly for recent builds.

===== From: HansBKK &lt;hansbkk@gmail.com&gt;

If something like this **is** done, it should IMO be packaged as an
alternative to the normal installation procedure.

You would definitely get marketing exposure by getting the specs from
PortableApps.com and let them host it there as  "Portable Leo", tracking
the "official" Portable Python (currently 2.7.2) as a dependency, obviously
including QT etc as well. But it would need to be kept up to date. . .

Most Windows users would be better served by following the normal
installation procedure and ending up with a
registry-and-environment-variables-complete install of Python et al which
they can use for other things beyond Leo. Ending up with multiple instances
of Python to maintain is likely to cause more problems.

And the normal Windows install just isn't that hard, really! Improving the
current instructions, by providing a step-by-step "cookbook" with direct
links to the download packages etc might make it a **little** easier (IMO
only for the clueless), but then of course that would be a doc that would
need pretty frequent updates, which if I may be so bold doesn't seem to
happen too quickly on the doc side.
</t>
<t tx="ekr.20130806072439.20736">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Since this topical today, almost a year later, I thought I'd take a run at 
repeating this using Portable Python (http://www.portablepython.com) as a 
base. It didn't work, but I think it should. Maybe someone else knows why. 

I ran the installer for 2.7.3 since 3.2 doesn't include PyQt4. At install 
time I selected only the Python and PyQt4 packages. Then from a fresh 
command shell:

{{{
path=c:\windows;c:\windows\system32
pushd x:\portapy27\App
path=%cd%;%cd%\Scripts;%cd%\Lib\site-packages\PyQt4;%path%
set pythonhome=%cd%
set pythonpath=%cd%\Lib

popd

python --version
Python 2.7.3

python -c "import PyQt4"
:: no error returned, we're good.

python c:\apps\leo-editor-latest\launchLeo.py
Leo requires Qt to be installed.
}}}

oh well.
</t>
<t tx="ekr.20130806072439.20744">From: HansBKK &lt;hansbkk@gmail.com&gt;

&gt; PortableApps version would be FANTASTIC!!

A couple of versions have been posted here already, including Terry's very
simple sequence in the first message of this thread. Of course, we're only
talking about Windows, but note that it works equally well either syncing
with whatever tool (I favor Unison over SSH) or carrying around on an
arbitrary-path'd external device, including flash drives (but they can be
slow).

Here's my more robust (hence more complex) version, xx indicating your 
python version (mine is 27):

Use the normal .MSI, setup.exe etc processes to Install a clean "canonical" 
version of your "python dev stack" to say C:\PythonXX, reboot if needed, 
test thoroughly. Note any new environment variables pointing to your new 
binary locations.

Now create a corresponding PythonXX folder in your "PortableApps" location 
(I put it under "CommonFiles" along with GTK and Java) and copy everything 
from your installed location to the portable one.

You can then use the project-provided tools on the "master" computer to 
keep your binaries updated, and they will see any local Registry entries 
and the environment variables they created and operate normally wrt your 
installed location (e.g. C:\PythonXX).

If you have a local folder sync tool (I use Unison and WinMerge) you can 
add to/remove from/configure your Python environment from either location, 
otherwise just keep your installed location as the "master" and just copy 
the whole stack over each time you do so.

The whole PortableApps tree can then be sync'd/copied to any other 
desktop(s) you like, either over the wire or via an external device, and 
the latter can be carried for use in say an Internet cafe or client-site 
situation.

====================

For use on those other computers, for running in portable mode, I use a
"portable start menu" (PStart) which allows for its own "autolaunch" batch
files, where I set some global environment variables to be used by
app-specific launch batch files, including :

%Path% (I add my batch folder and a general utility/tools folder)
%HOME% (usually "E:\aasync\Data\H_HOME"
and a custom one called %h_pa%, which points to the root of my PortableApps 
parent (usually "D:\aasync\PortableApps")

Then for each environment that requires its own custom settings, I create a 
launch batch file that builds on that base. In the case of Python apps, 
here's an example that opens a CMD console window:

@ECHO OFF
set 
PATH=%PATH%;%h_pa%\CommonFiles\Python27;%h_pa%\CommonFiles\Python27\Lib\site-packages\PyQt4;%h_pa%\CommonFiles\Python27\Lib\idlelib;%h_pa%\CommonFiles\Python27\Scripts;
set PROMPT=$p_python$g
E:
cd \aasync
CMD.exe

I'm not sure which if any of the environment stuff Leo requires, but I 
figure it might as well have the same environment as my Python CLI, since 
I'll be testing shell integration, including iPython. In my leo-win.bat, 
the last three lines above are replaced with:

D:
cd \aasync\PortableApps\leo-editor
start "" "..\CommonFiles\Python27\pythonw.exe" 
"..\CommonFiles\Python27\Lib\site-packages\leo-editor4\launchLeo.py" %*

====================

Note this is more than the minimum you need to just run Leo - you could of 
course simplify it; for example, only set the environment variables Leo 
requires, or you could just set the master computer' installation routines 
to use a single location under PortableApps, but I prefer to keep them 
separate for testing purposes.

I hope you (and others googling this later) find this useful.
</t>
<t tx="ekr.20130806072439.21204">From: Todd Mars &lt;tamnt54@gmail.com&gt;

I remember reading -somewhere- about comparing various multi-parent or
multi-copy of node outline types (clones vs. backlinks or whatever) but I
can't find where I read that. Where is it? Desire to read analysis, isn't
that in the leo docs somewhere?

Terry

Personally I think Leo could navigate cyclic graphs, see
http://leo.zwiki.org/GraphsInTrees particularly the 'Older notes' section
towards the end. But it's a major issue with regard to all the algorithms
which don't expect to run in to loops. And the extra layer of connections
from the backlinks plugin allows the same functionality, so it may be that
it's more an interface issue than a data model issue.

I'd like Leo to be able to behave like CmapTools, http://cmap.ihmc.us/ but
maybe it can, essentially, and it's really a matter of defining some new
interface bells and whistle's.
</t>
<t tx="ekr.20130806072439.21225">From: Miles Fidelman &lt;mfidelman@meetinghouse.net&gt;

A big Leo fan pointed me at Leo, and this group - indicated that sharing 
Leo documents has been talked about over the years, but not really 
implemented, and suggested that I post some details about a project that 
I've been working on.  So....

Basic model is synchronized copies of documents, linked by an asynchronous 
pub-sub channel.  Think of a personal Wiki (like TiddlyWiki) - linked to 
copies of itself, that's the general idea.  Compose a document, email 
copies to collaborators, everyone saves a local copy - those copies link to 
each other via a pub-sub protocol to distribute updates.  All in 
JavaScript, embedded in the "smart documents" - nothing special to install.

If you're interested, details are at:
http://www.kickstarter.com/projects/1947703258/smart-notebooks-keeping-on-the-same-page-across-th
and Andy Oram wrote a background piece for O'Reilly Radar, at:
http://radar.oreilly.com/2012/08/smart-notebooks-for-linking-virtual-teams-across-the-net.html

I'd welcome comments, support, likes, tweets, blogs, ...

Thank you very much,

Miles Fidelman

EKR

My apologies for not responding sooner.  That was really unfortunate.  In
my experience, the best way to ruin good ideas is to ignore them :-(

As you may have gathered, I've been overwhelmed with good ideas, bugs that
should have been fixed years ago, sometimes pathetic or non-existent
documentation.  I'm getting less overwhelmed, but I won't be able to follow
up on this idea for now.

I encourage some of Leo's more web-aware users to take a look at this. For
now, I just have to file this under Leo/Ideas :-)
</t>
<t tx="ekr.20130806072439.21241">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I suspect that if body editors could be made just slightly more
flexible it would open up whole new ways of using Leo.  It seems they
just need two or three things to make them really flexible.

- a flag to indicate whether the tree pane should select the body
    editor's node when the body editor is focused.  To see an
    example of editing bodies without the tree selecting the node you're
    editing, see the stickynotes plugin

 - a flag to indicate whether the body editor should track the node
   currently selected in the tree

 - it needs to not care about what it's contained in, GUI wise.  I
   don't know how much work's involved in this.

I'll try and contribute to things moving in this direction when I have
time, just throwing it out there for others to think on.

If you could have a body editor edit the node indicated by an UNL, it
would basically be a clone...

</t>
<t tx="ekr.20130806072439.21248">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Often, I find myself wanting to execute system commands in serial fashion
(first in, first out), capture their output, and allow browsing it, BUT not
blocking Leo or ipython terminal.

I'd like to show stderr and stdout in g.es, or separate log page, and
provide callback after task has been completed.

Unless anyone has something like this already, I plan to create it "later"
with QProcess.

===== Ville

Now I have basic functionality pushed to trunk.

If you want to "spawn" (posibbly several) system commands to background,
use g.procs.add(), like this ctrl+b script:

def L(*args):
    g.es("callback", args)

g.procs.add(['sleep', '4'], "que1")
g.procs.add(['sleep', '3'], "que1", L)
g.procs.add(['sleep', '2'], "que1")
g.procs.add(['sleep', '2'], "que2")

Note how que2 completes first. Idea is that commands in same queue depend
on each other, and thus need to run in sequential order.

This should make waiting for long lasting operations easier as the whole
Leo won't freeze until they are over (but you can still use the stdout /
stderr output from these calls, thanks to the optional callback)

API may change once I start using it (soon).

===== Terry

There's the leoscreen stuff for integration with the GNU `screen`
terminal switcher / manager.  Push lines from the body to the terminal,
pull lines back the other way.  But more for interactive interaction
with terminal programs than batch oriented work.  Leo doesn't block.

===== Ville

A challenge I can imagine with the "screen" workflow is detecting when a
command has been executed (and capturing stderr/stdout). Do you have a
solution for that in mind?

===== Terry

I tried more direct communication (subprocess.Popen.communicate())
before the screen approach, it's hard and probably app. specific.
leoscreen avoids that by basically being interactive, so it might not
be a fit for your case.  Basically it's leveraging the intelligence of
the user to keep track of execution.
</t>
<t tx="ekr.20130806072439.21254">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Problem: I find myself repeating a bunch of alt-x commands in the same
document. There is more than one, so ctrl-p (repeat last command) is not
useful.

Idea: specify that keys from alt-1 to alt-9 are "easy macro keys". They
would be easy to bind to various alt-x command without editing preferences.

How they can be bound:

Do e.g. alt-x ipython-exec

BUT instead of pressing ENTER in the end, press alt-1. This would bind the
command to alt-1.

Store them it c.db, so they will be remembered for every leo document, but
won't clutter bindings of other people editing the same file.

===== Matt

From: Matt Wilkie &lt;maphew@gmail.com&gt;

I often find myself in the same situation with regards to clipboards. If
alt-# were macros, ctrl-# could be clipboards perhaps?

It could be even more important then to have some sort UI method for
inspecting/previewing the contents of them. Maybe thumbnail preview a la
Sublime's right hand document overview.

===== Fidel

I am still studying (and have much more to study yet) Leo, but I think that 
two things can be archieved by integrating it with libraries like pywinauto 
&lt;https://code.google.com/p/pywinauto/&gt; or
dragonfly&lt;https://code.google.com/p/dragonfly/&gt;


- First of all, it could track all the keystrokes of the user, relate it to
  the window, then offer the user possibility to repeat (even complex
  sequences)

- Second, It would be great to have a Leo tab with buttons showing the
  hotkeys related to the current action (IE when the user has the cursor on
  a node, or the edit pane, etc) (or even the current window in front). So
  when the user uses those hotkeys, Leo will track them, so the next
  scenario could happen:

User copyes a link from Leo
User sets an excel file to front
User pastes it in an excel cell and hits down.

If both the user did those through hotkeys, and they were tracked, Leo 
could automatically offer repeat the same action with the next links held 
in the same category.

This is a pretty raw explanation but I hope it makes the point. 
Nevertheless, I will continue to study, research and try to help with those 
features by myself.
</t>
<t tx="ekr.20130806072439.21298">Ville
https://plus.google.com/_/notifications/emlink?emr=02870587547267324596&amp;emid=CLiiydTt8rUCFaY6MQodYAsAAA&amp;path=%2F103097156557482112329%2Fposts%2FVp5ansTdLwq&amp;dt=1362942818945&amp;ub=63

How could we  treat leo tree as flat, contiguous memory structure (something that's easy to memcpy, pass as shared memory or flush to disk in one write)?

Some ideas could be: 

- Use Redis to store tree
- Keep the "clean" body texts in contiguous block (most bodies will always be clean), append dirty (modified) body texts after it
- Keeping the outline structure in memory block is quite easy, since there is not a lot of data. You could have just a list of [parent, child] id's or whatever
</t>
<t tx="ekr.20130806072439.21299">From: Kent Tenney &lt;ktenney@gmail.com&gt;

The ipython integration is great, any chance of connecting the the web notebook?

# ipython notebook

then, from the ipython dashboard in browser, click to open a notebook

the console reports:
[IPKernelApp] To connect another client to this kernel, use:
[IPKernelApp] --existing kernel-a25b19a2-55d6-43a2-aa05-dfeffb55136b.json

could &lt;ctl-x&gt; push-to-ipython send the contents of current Leo node
to the current cell in the ipython notebook?

It would be great to be able to jump between Leo's nodes and IPython's
cells, each offering a different set of cool functionality.

===== From: Alia K &lt;alia_khouri@yahoo.com&gt;

Incidentally look at this recent IPEP (Ipython Enhancement Proposal)
which allows for leo like cell-level directives (which in Ipython are
called magic commands): https://github.com/ipython/ipython/issues/1611

Leo + Ipython notebook integration is a killer app indeed.
</t>
<t tx="ekr.20130806072439.21301">From: HansBKK &lt;hansbkk@gmail.com&gt;

This is highly off-topic for most on the list, so feel free to ignore, but 
anyone using Leo for single-source documentation generation/conversion, 
including future googlers, please reply with comments or notes on your 
experiences.

I have been advocating the idea of pushing Leo-derived content to DokuWiki 
as a platform for "wiki-publishing" to enable collaborative/community 
editing of content (1 &lt;../d/msg/leo-editor/fSzVi1Rh5Tg/uu85satgb9YJ&gt;, 2&lt;../d/msg/leo-editor/xf6_HBxlV_c/4RgGYdDh8ywJ&gt;). 
I've also talked about the markup syntax/doc generation tool Txt2tags (1&lt;https://groups.google.com/d/msg/leo-editor/nNEnxoohFBM/XkMPQhqhDRsJ&gt;, 
2 &lt;https://groups.google.com/d/msg/leo-editor/HBhBnAyVG3E/UXHC1jq50iYJ&gt; ).

However, I have recently learned of the wiki platform Gitit&lt;https://github.com/jgm/gitit#readme&gt;, 
which apparently, like DW, also uses plain-text files rather than a 
database back-end, and integrates not only with git but mercurial (and 
darcs).

Gitit also incorporates the Pandoc &lt;http://johnmacfarlane.net/pandoc/&gt;project for its markup syntax, therefore enabling not only markdown but 
reST as a master source input format, while DokuWiki has its own (yet 
another unique) markup syntax 8-( 

With the increasing likelihood that I'll be using Leo as the centerpiece of 
my toolchain, plus the fact that Pandoc is much more actively maintained, 
it's starting to look worth my while to consider switching my "master 
source" content syntax over from Txt2tags to reST. The only downsides are 
that Gitit is a Haskell project rather than Python, and one thing I like 
about Txt2tags is its support for conversion to AsciiDoc, rather than 
Pandoc's direct output to full-blown DocBook XML - but apparently even 
that's in the works in Pandoc's dev version.

Anyone in the Leo community using Gitit, especially for use beyond simple 
code documentation?
</t>
<t tx="ekr.20130806072439.21302">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Jan 19, 2012 at 8:09 PM, HansBKK &lt;hansbkk@gmail.com&gt; wrote:
&gt; This is highly off-topic for most on the list, so feel free to ignore, but
&gt; anyone using Leo for single-source documentation generation/conversion,
&gt; including future googlers, please reply with comments or notes on your
&gt; experiences.

No experience myself, but thanks for these interesting links.

EKR
</t>
<t tx="ekr.20130806072439.21303">From: =?UTF-8?B?T2ZmcmF5IFZsYWRpbWlyIEx1bmEgQ8OhcmRlbmFz?= &lt;offray@riseup.net&gt;

Hi,

I made some errors.

In this part:

El lun 23 ene 2012 07:22:21 COT, Offray Vladimir Luna C=E1rdenas escribi=F3=
:
&gt;
&gt; but at the end we could not intervene MoinMoin as much as we would=20
&gt; like because of the server permissions, that why I started to look=20
&gt; more integrated solutions of the development and deployment=20
&gt; environment as web2py or seaside, but they're not wiki engines=20
&gt; properly but web application frameworks (where you could build a=20
&gt; wiki-engine if needed). But surely
&gt;

"But surely" was not intended.

Cheers,

Offray

</t>
<t tx="ekr.20130806072439.21304">From: &lt;offray@riseup.net&gt;

El jue 19 ene 2012 21:09:26 COT, HansBKK escribi=F3:
&gt; This is highly off-topic for most on the list, so feel free to ignore, bu=
t
&gt; anyone using Leo for single-source documentation generation/conversion,
&gt; including future googlers, please reply with comments or notes on your ex=
periences.

I'm using Leo in that scenario (for writing my Thesis and I hope my=20
students will use it in a similar fashion), so is not off-topic for me=20
and not for people who is using Leo primary for documentation.

&gt; I have been advocating the idea of pushing Leo-derived content to DokuWik=
i as a
&gt; platform for "wiki-publishing" to enable collaborative/community editing =
of
&gt; content (1&lt;../d/msg/leo-editor/fSzVi1Rh5Tg/uu85satgb9YJ&gt;, 2
&gt; &lt;../d/msg/leo-editor/xf6_HBxlV_c/4RgGYdDh8ywJ&gt;). I've also talked about t=
he
&gt; markup syntax/doc generation tool Txt2tags (1
&gt; &lt;https://groups.google.com/d/msg/leo-editor/nNEnxoohFBM/XkMPQhqhDRsJ&gt;, 2
&gt; &lt;https://groups.google.com/d/msg/leo-editor/HBhBnAyVG3E/UXHC1jq50iYJ&gt;  ).


When you suggested DocuWiki I thought of MoinMoin which has also=20
support of plain files as storage mechanism but is also scalable to=20
databases if this is needed and it supports reStructuredText and is=20
made in python, a language that "leonizens" are familiar with.

&gt; However, I have recently learned of the wiki platform Gitit
&gt; &lt;https://github.com/jgm/gitit#readme&gt;, which apparently, like DW, also us=
es
&gt; plain-text files rather than a database back-end, and integrates not only=
 with
&gt; git but mercurial (and darcs).
&gt;
&gt; Gitit also incorporates the Pandoc&lt;http://johnmacfarlane.net/pandoc/&gt;  pr=
oject
&gt; for its markup syntax, therefore enabling not only markdown but reST as a=
 master
&gt; source input format, while DokuWiki has its own (yet another unique) mark=
up
&gt; syntax 8-(
&gt;
&gt; With the increasing likelihood that I'll be using Leo as the centerpiece =
of my
&gt; toolchain, plus the fact that Pandoc is much more actively maintained, it=
's
&gt; starting to look worth my while to consider switching my "master source" =
content
&gt; syntax over from Txt2tags to reST. The only downsides are that Gitit is a
&gt; Haskell project rather than Python, and one thing I like about Txt2tags i=
s its
&gt; support for conversion to AsciiDoc, rather than Pandoc's direct output to
&gt; full-blown DocBook XML - but apparently even that's in the works in Pando=
c's dev
&gt; version.
&gt;
&gt; Anyone in the Leo community using Gitit, especially for use beyond simple=
 code
&gt; documentation?

Now that I'm using Leo + Fossil for my documentation related matters=20
and distributed work I certainly think that a distributed off-line=20
collaboration system for documentation is needed and, if MoinMoin can't=20
support the use of distributed wikis (and seems is not planned or in=20
development [1][2]) Gitit would be a nice place to start with this idea=20
and would offer advantages over the non-distributed and outdated Zope's=20
actual implementation, so, interested ones in the community could offer=20
an implementation of Gitit. On a related matter one of the problems I=20
see with actual server technology is its gigantism which concentrates=20
power in the people who has the resources, knowledge and time to=20
possess, understand and administer/intervene this technology so a=20
Global South Test for me about which server technology to choose is:=20
"it runs from a USB thumb drive?". This, for example, favors=20
Web2py/Smalltalk instead of Zope and Fossil instead of GitHub. May be=20
you should put this in the panorama when you judge GitIt or=20
Haskell/Pandoc. Pandoc, by the way, was for me a compelling reason to=20
learn Haskell[3] (but I thought that I would learn Smalltalk before)=20
because it deals elegantly with a problem in the diversity of markup=20
languages (txt2tags makes something similar but only in one way=20
translation) and for me the point of using Leo is having a tool to deal=20
consistently with diversity in the "sub-optimal distopic world of=20
everything is a file".

[1] http://moinmo.in/PawelPacana/MercurialBackend
[2] http://moinmo.in/MoinMoin2.0
[3] http://learnyouahaskell.com/

We could get philosophical here, and think about different programming=20
paradigms and languages that implement them with elegant syntaxes, like=20
Smalltalk, Haskell and Python versus the non elegant ones of .java, php=20
or ... (put your hated language here) and how this elegant syntaxes,=20
languages and computer using experience could cross-pollinate. If that=20
is the case, may be reading some about Combined Object Lambda=20
Architecture[4] and the comprehensive "Concepts, Techniques, and Models=20
of Computer Programming" by Van Roy and Haridi would be a nice reading.=20
Some times I dream of a world connected diversity where all the=20
problems of computer interaction can be solved by expressing that=20
diversity in fundamental constructs that respect it at the same time=20
that bring consistency and interface solving the apparent chaos and=20
noise.

[4] https://en.wikipedia.org/wiki/COLA_%28software_architecture%29

Cheers,

Offray

</t>
<t tx="ekr.20130806072439.21305">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; Wow I think that this is the first time I have the opportunity to
&gt; write (curiously in English instead of my native tongue) about
&gt; that dystopy, because most of the time I just talk about this
&gt; with my students or friends but not as detailed and contextually,
&gt; so thanks for bring this up Hans, and thanks everyone else
&gt; here who is still reading :-)

I am reading, and enjoying. The clouds you've placed in my mind are
making interesting shapes and I am intrigued. ;-)
</t>
<t tx="ekr.20130806072439.21306">From: =?UTF-8?B?T2ZmcmF5IFZsYWRpbWlyIEx1bmEgQ8OhcmRlbmFz?= &lt;offray@riseup.net&gt;

Hi,

El lun 23 ene 2012 01:18:48 COT, HansBKK escribi=F3:
&gt; Thanks Offray for your detailed and informative response.

Well I'm enjoying also these talks with you. I think that putting=20
documentation also in the center is required if we want to break the=20
Leo's self-fulfilled prophesy about being a "ghetto tool" for=20
programmers only and I want this in the best way.

[..]
&gt;
&gt; I for some reason missed the MoinMoin's "simple page storage" option - th=
anks so
&gt; much for pointing that out. For all the reasons you cite, and most import=
antly
&gt; is much more mainstream, more actively developed and well-supported than =
Gitit,
&gt; I'll definitely give it a higher priority in my testing.
[...]

I enjoyed using MoinMoin for this project:

http://el-directorio.org/

but at the end we could not intervene MoinMoin as much as we would like=20
because of the server permissions, that why I started to look more=20
integrated solutions of the development and deployment environment as=20
web2py or seaside, but they're not wiki engines properly but web=20
application frameworks (where you could build a wiki-engine if needed).=20
But surely

&gt;      the "sub-optimal distopic world of everything is a file".
&gt;
&gt;
&gt; I personally disagree with your dislike for "everything is a file" - I se=
e that
&gt; principle as a fundamental part of the *nix tool philosophy, and IMO this=
 is a
&gt; perfect example:
&gt;
&gt;      I certainly think that a distributed off-line collaboration system f=
or
&gt;      documentation is needed and, if MoinMoin can't
&gt;
&gt;      support the use of distributed wikis (and seems is not planned or in=
 development
&gt;
&gt; To my mind, any wiki platform that can store the page data as plain text =
(as
&gt; opposed to binary/database), in a format suitable for diff tools ("light"=
 markup
&gt; as opposed to html/xml) can make use of whatever VCS for distribution/rep=
lication.

You're right and I like the idea of "everything is a something" when=20
that something is powerful unifying idea. That's the case with Unix's=20
"everything is a file" or Smalltalk's "everything is an object" (in=20
Unix you have also every tool makes one thing and makes it right,=20
combined with pipes). For me these two paradigm's were the ones that,=20
in 70's, were fighting for the mind share  about computer experience of=20
today and both of them won in a dystopic way, but for me "taking genius=20
to understand Unix simplicity"[0], was even more dystopic. When you're=20
trying to empower users the impedance between development and=20
deployment shows the dystopia, at least compared with the original=20
visions, so most of the "end users" cant change the tool that changes=20
them, so, someone else is making decisions about that changes and that=20
users.

[0] https://en.wikipedia.org/wiki/Unix_philosophy#Quotes

I like the simplicity of light markups and I try myself of not using=20
explicitly nothing as xml and I like also the idea of the light markup=20
being used by VCS tools. That's not where dystopia lies. The problem is=20
not about files or structure but about "meta-structure" (structure=20
talking about structure, as in meta-languages), specially=20
self-referential meta-structure, because self-referential=20
meta-structures are the key for self-directed change, as opposed with=20
change directed by others. When you see how the "world of everything is=20
a file" talks about itself, there is a lot of impedance and=20
discontinuity between source code, binary, apps and docs and there is a=20
long path for the user who is confined to using apps to create docs,=20
but never change the apps that could let she/he to change his/her=20
writing and that's why I want to use Leo this semester with=20
non-technical writers to explore the way that writing change the tool=20
that writes and not only the human who does.

For me a unified emergent meta-structure in the world of "everything is=20
a file" is where lies the power of Leo. You can use an outline to=20
change the way that Leo behaves and that's why having the Leo's=20
self-referential meta-structure is more powerful that the "dystopic=20
world of everything is a file" (in that world you don't have=20
meta-structure, only structure, mostly for storage purposes and the=20
intelligence to read/process it is mostly outside the file, in the=20
human reader, the compiler or the binary). What Leo does is to create=20
self-referentiality in the world of everything is a file by introducing=20
outlines that can talk/structure the files and that can talk about=20
outlines, i.e outlines that can talk about files and about themselves=20
and can reprogram the way Leo itself works, and so Leo is bridging the=20
gap between objects and files in a valuable and unique way.  But we=20
need still to improve, specifically we need a more elegant way to talk=20
about that files, specially about their changes in time, because is in=20
that change where talking with the distopic world has more problems and=20
possibilities, and that way I'm making the Fossil/VCS experiment and=20
also.

Wow I think that this is the first time I have the opportunity to write=20
(curiously in English instead of my native tongue) about that dystopy,=20
because most of the time I just talk about this with my students or=20
friends but not as detailed and contextually, so thanks for bring this=20
up Hans, and thanks everyone else here who is still reading :-)

&gt;      On a related matter one of the problems I see with actual server tec=
hnology
&gt;      is its gigantism which concentrates
&gt;      power in the people who has the resources, knowledge and time to pos=
sess,
&gt;      understand and administer/intervene this technology so a Global Sout=
h Test
&gt;      for me about which server technology to choose is: "it runs from a U=
SB thumb
&gt;      drive?".
&gt;
&gt; IMO "server" is a function, not a question of scale or complexity - the b=
etter
&gt; question for my workflow is "does the app run portably?". I personally fi=
nd
&gt; actually running stuff from flash drives too slow and data-dangerous.

I'm agree with you. Server and gigantism have not to be equal, but=20
unfortunately in the "dystopic informatic world" (where the previous=20
dystopia is just a part) they're most of the time. Portability is the=20
key, not flash drives. In my context they're just a medium to ask the=20
same as you, but also a way to let people take the technology with=20
them, no matter if they have access to a "classical" server.

&gt;
&gt; So far I've found that anything that runs under Linux is inherently porta=
ble in
&gt; that sense.

Agreed. Having Leo + Fossil + Laptop ( ;-P ) gives me some kind of=20
portability, but we need more. That's why I think that we need a self=20
contained version of Leo with a default discourse about file flat world=20
change in time (at least for Windows), but ideally would be nice to=20
have something like the self-contained multiplatform Pharo's One Click=20
Experience[1]

[1] http://www.pharo-project.org/pharo-download

&gt;      This, for example, favors Web2py/Smalltalk instead of Zope and Fossi=
l
&gt;      instead of GitHub.
&gt;
&gt; I haven't any experience with these others, but note that Git does not =
=3D GitHub.
&gt; I share your dislike for server/storage platforms out of my direct contro=
l, not
&gt; least for privacy/security issues for many use cases. If I used Git for d=
ata
&gt; distribution I wouldn't use GitHub, and my understanding is that even "Gi=
t for
&gt; Windows" is already fully portable.

Oohh I don't make myself clear, sorry. Fossil compared with GitHub was=20
not because of the equivalence of Git and GitHub, but because of the=20
integration of web characteristics of GitHub in Fossil (wiki, tickets,=20
web interface and so on).

&gt; For myself, I think mercurial would be a good fit, but my main point is t=
hat any
&gt; moves toward a "distributed Leo" should IMO be VCS-agnostic, just as my p=
lans
&gt; for enabling community editing of Leo-managed content will be wiki-platfo=
rm
&gt; agnostic.

I fully share your opinion on that subjects, but in this case I want to=20
start by some specific implementation from which one start to abstract=20
that to think abstractly without any particular implementation in the=20
road, which is not your case, I just point to different implementation=20
strategies based on the same agnosticism/diversity as a valuable thing=20
to preserve.

&gt; To me, the key enabler for that is "everything as a file". . .

For me the enabler is self-referential meta-structure

Thanks,

Offray

</t>
<t tx="ekr.20130806072439.21307">From: HansBKK &lt;hansbkk@gmail.com&gt;



Content-Transfer-Encoding: quoted-printable

On Monday, January 23, 2012 7:22:21 PM UTC+7, Offray Vladimir Luna C=E1rden=
as=20
wrote:
&gt;
&gt;
&gt; documentation also in the center is required if we want to break the Leo'=
s=20
&gt; self-fulfilled prophesy about being a "ghetto tool" for programmers only


Usability for clueless noobs is a lot of work, probably harder than the=20
complex whiz-bang functionality part.

And to take something as powerful and flexible as Leo and make it=20
accessible for noobs would require "lobotomizing" it to some extent, at=20
least hiding those features that weren't relevant to the intended=20
more-mainstream task at hand.

I imagine something like "application mode" flag at launch time=20
  - Leo as a journaling tool (like Rednotebook on steroids)
  - Leo as an Evernote-style note-taking brain extension
    - with user-accessible tagging, perhaps multiple headings per node?
  - Leo as a delicous-replacement (import/export/backup) bookmarks=20
management tool
  - Leo as a single-source multiple-output documentation management=20
meta-organizer and conversion-supporting tool

etc - very different UX - pane layouts, menu structures etc - for each=20
mode, but the same underlying code and data structures

but at the end we could not intervene MoinMoin as much as we would like=20
&gt; because of the server permissions


ACLs is one of DokuWiki's strengths, as they target the corporate world (as=
=20
much as a FOSS tool can 8-)

&gt; So far I've found that anything that runs under Linux is inherently=20
&gt; portable in
&gt;
&gt; &gt; that sense.
&gt;
&gt; Agreed. Having Leo + Fossil + Laptop ( ;-P ) gives me some kind of=20
&gt; portability, but we need more.
&gt;
Pocket-size portable HDD with USB2 / SATA2  (will soon start converting to=
=20
v3 of both, used to use Firewire), booted up using any arbitrary internet=
=20
cafe / friend / customer desktop.

ideally would be nice to have something like the self-contained=20
&gt; multiplatform Pharo's One Click=20
&gt; Experience[1]
&gt;
&gt; [1] http://www.pharo-project.org/pharo-download
&gt;
Most of the mainstream distros now have easy-to-customize=20
create-your-own-distro LiveCD/USB+persistent storage projects. I've got a=
=20
portable drive that launches a GRUB2 boot menu letting me choose between=20
various configs of Fedora, Red Hat, Debian, Ubuntu and Slax, all of which=
=20
access shared /home and server-data partitions (which gets sync'd with my=
=20
central filer). Check out Sardu &lt;http://www.sarducd.it/&gt;, which also=20
handles all the mainstream recovery/rescue/sysadmin tools like grml,=20
pmagic, sysresccd - even BartPE, Win7 repair etc all on the same pocket=20
drive. . .
=20

&gt; integration of web characteristics of GitHub in Fossil (wiki, tickets, we=
b=20
&gt; interface and so on).
&gt;
=20

&gt; agnosticism/diversity as a valuable thing to preserve.

=20
Personally I prefer using CLI batch/scripts and/or TortoiseXX rather than a=
=20
web interface for my VCS usage, and my ticket/project management/GTD system=
=20
of choice is Redmine (likely Chili soon).=20

Both of these integrate well with the important VCSs, so when I finally get=
=20
away from SVN and get familiar with the distributed new kids, I can keep my=
=20
other tools - Redmine/Chili now has such a custom-infrastructure encrusted=
=20
around it sync'ing with gcal, printing pocketmods for my calendar and=20
@context to-do's that have become indispensable to my day-to-day life=20
management.

=20

&gt; "dystopic world of everything is a file" (in that world you don't have=20
&gt; meta-structure, only structure, mostly for storage purposes and the=20
&gt; intelligence to read/process it is mostly outside the file, in the human=
=20
&gt; reader, the compiler or the binary). What Leo does is to create=20
&gt; self-referentiality in the world of everything is a file by introducing=
=20
&gt; outlines that can talk/structure the files and that can talk about=20
&gt; outlines, i.e outlines that can talk about files and about themselves=20
&gt; and can reprogram the way Leo itself works, and so Leo is bridging the ga=
p=20
&gt; between objects and files in a valuable and unique way.  But we need stil=
l=20
&gt; to improve, specifically we need a more elegant way to talk about that=20
&gt; files, specially about their changes in time, because is in that change=
=20
&gt; where talking with the distopic world has more problems and=20
&gt; possibilities, and that way I'm making the Fossil/VCS experiment and also=
.
&gt;

&gt; To me, the key enabler for that is "everything as a file". . .
&gt;
&gt; For me the enabler is self-referential meta-structure
&gt;
=20
I don't see any conflict between the two, IOW no inherent limitations to=20
"everything is a file" other than (to me, at least within the personal-use=
=20
prototyping context) unimportant factors like relative speed/scaleability -=
=20
it's "just" an implementation detail.=20

The various levels of structural overlays as presented within Leo as=20
"uber-manager of the metadata" can be as flexible and complex as can be,=20
and still be stored/distributed as diffed/versionable/convertable files at=
=20
whatever appropriate level of granularity to support integration with=20
outside toolchains. To the extent design choices are made that "lock in" to=
=20
a particular "higher level" technology bet, e.g. a specific database engine=
=20
or DVCS, then much higher-level programming/sysadmin skills are required in=
=20
order to integrate Leo into the thousands of mainstream tools that have=20
evolved over time to support structured-plain-text.

Look at source code - after all these decades, it's still stored as plain=
=20
text in a filesystem. There's a reason for that - any language that=20
required its modules/functions/objects whatever to be stored in a=20
"proprietary" database engine for example would have very limited uptake,=
=20
because coders would have to put so much effort into infrastructure=20
overhead work to be able to keep working with their preferred toolset.=20
Anyway 'nuff said on that.

</t>
<t tx="ekr.20130806072439.21308">From: Largo84 &lt;Largo84@gmail.com&gt;

This topic is of much interest to me as I use Leo primarily for writing 
documentation (mostly LaTex, some html and some rST). I haven't worked w/ 
Pandoc yet but am interested in some of the possibilities. Thanks for the 
links, I'll check them out.
</t>
<t tx="ekr.20130806072439.21309">From: HansBKK &lt;hansbkk@gmail.com&gt;



Content-Transfer-Encoding: quoted-printable

Thanks Offray for your detailed and informative response.

On Friday, January 20, 2012 5:34:21 PM UTC+7, Offray Vladimir Luna C=E1rden=
as=20
wrote:
&gt;
&gt; When you suggested DocuWiki I thought of MoinMoin which has also support=
=20
&gt; of plain files as storage mechanism but is also scalable to databases if=
=20
&gt; this is needed and it supports reStructuredText and is made in python, a=
=20
&gt; language that "leonizens" are familiar with.
&gt;
 I for some reason missed the MoinMoin's "simple page storage" option -=20
thanks so much for pointing that out. For all the reasons you cite, and=20
most importantly is much more mainstream, more actively developed and=20
well-supported than Gitit, I'll definitely give it a higher priority in my=
=20
testing.

=20

&gt; the "sub-optimal distopic world of everything is a file".
&gt;
 =20
I personally disagree with your dislike for "everything is a file" - I see=
=20
that principle as a fundamental part of the *nix tool philosophy, and IMO=
=20
this is a perfect example:

 I certainly think that a distributed off-line collaboration system for=20
&gt; documentation is needed and, if MoinMoin can't=20
&gt;
&gt; support the use of distributed wikis (and seems is not planned or in=20
&gt; development
&gt;
To my mind, any wiki platform that can store the page data as plain text=20
(as opposed to binary/database), in a format suitable for diff tools=20
("light" markup as opposed to html/xml) can make use of whatever VCS for=20
distribution/replication.

=20

&gt; On a related matter one of the problems I see with actual server=20
&gt; technology is its gigantism which concentrates=20
&gt; power in the people who has the resources, knowledge and time to possess,=
=20
&gt; understand and administer/intervene this technology so a Global South Tes=
t=20
&gt; for me about which server technology to choose is: "it runs from a USB=20
&gt; thumb drive?".
&gt;
IMO "server" is a function, not a question of scale or complexity - the=20
better question for my workflow is "does the app run portably?". I=20
personally find actually running stuff from flash drives too slow and=20
data-dangerous.

In my workflow, at the beginning of a session I first sync the relevant=20
data and "portable apps" filesystem branches, then run everything off the=
=20
local HD. At the end of a session I sync it all back - most of the time=20
these days this is to/from a central filer, but I do have portable drives I=
=20
use for this when that's required or more convenient, which then get sync'd=
=20
to the filer next chance I get.

So far I've found that anything that runs under Linux is inherently=20
portable in that sense.
=20

&gt; This, for example, favors Web2py/Smalltalk instead of Zope and Fossil=20
&gt; instead of GitHub.
&gt;
I haven't any experience with these others, but note that Git does not =3D=
=20
GitHub. I share your dislike for server/storage platforms out of my direct=
=20
control, not least for privacy/security issues for many use cases. If I=20
used Git for data distribution I wouldn't use GitHub, and my understanding=
=20
is that even "Git for Windows" is already fully portable.

For myself, I think mercurial would be a good fit, but my main point is=20
that any moves toward a "distributed Leo" should IMO be VCS-agnostic, just=
=20
as my plans for enabling community editing of Leo-managed content will be=
=20
wiki-platform agnostic.

To me, the key enabler for that is "everything as a file". . .
</t>
<t tx="ekr.20130806072439.21323">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

I want to do some technology evaluation, so I will start doing a Leo
file reader for mobile devices using:

- jQuery mobile
- CoffeeScript

This can be deployed on web or locally. Interesting use cases are
browsing Leo notes you composed elsewhere on your tablet, and
publishing leo docs on the web (e.g. we could host fully browseable
leo source outline on Leo website)

I will notify the mailing list on the progress; it may be slow since I
don't have much contiguous time slots for hobby projects at the
moment. If someone wants to hop along, all the better; I'll probably
start the project at github once I have something that runs on a
desktop browser properly.

===== &lt;offray@riseup.net&gt;

Me and some friends where just thinking (but still I can not express my 
thoughts in code) in having something like and Etherpad[1] + Leo real 
time outliner and document creator. And I thought that would be nice to 
learn web2py in order to create the app and may be have jstree[2] or 
dynatree[3][4] as a way to create the heads of the nodes and put them in 
the web. Every node would be an etherpad-lite document ready for 
collaboration. At this point I have only links and no development now or 
in the coming times, but may be this can be helpful for your project.

[1] http://etherpad.org/
[2] http://dev.s-cubism.com/plugin_jstree
[3] https://code.google.com/p/dynatree/
[4] http://wwwendt.de/tech/dynatree/doc/samples.html

By the way I have been using txt2tags again for writing real-time 
structured docs with my students using etherpads and is really easy. Now 
I have found a txt2tags multiplataform editor at:

http://nestededitor.sourceforge.net/about.html

may that project be of some inspiration,
</t>
<t tx="ekr.20130806072439.21332">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Does leo need tags for nodes?

===== Kent

Yes. My view of Leo as a data manager means I want tags. I've been thinking
I'd address them in the context of the db of nodes, all the better if they
were native.

===== EKR

A very quick first response.

- Support for tags as uA's would be natural.
- User interface issues more complicated, of course.
- In general, Leo has not paid enough attention to searches/tags as alternatives to clones.
- Finding by tag, cloning by tag, etc. all seem natural.
- Kent's and Terry's suggestions are always worth consideration :-)

===== Jacob Peck &lt;gatesphere@gmail.com&gt;

I sort of implemented tags in my rpg.leo project - basically a series of
buttons that interacted with the nav pane to search for hashtags, which
were simply part of headlines.

It worked, it was simple, and to be honest, I don't think that Leo really
needs them. I'm sure there is some functionality that I'm missing out on,
though. Perhaps for those who don't wish to maintain lists of clones, or
for sorting into groups based on common tags. Perhaps even a view-rendered
extension that would render a clickable tag cloud of an entire outline?

===== Terry

Interface wise I see something similar to the the bookmarks.py
interface, shown in the attached, colored strings indicating the tags a
node has, probably a bit smaller.  Various commands and clicks for
adding or removing tags and navigating through the nodes with a
particular tag, or set of tags.

===== Kent

Display location, maybe a tab in the output pane.
Maybe enter them via minibuffer?
&lt;alt-x&gt; tags= ideas, terry, tagging

Maybe they could display in the minibuffer until &lt;alt-x&gt; was pressed. IE;
tags for current node on display until minibuffer is needed.

===== Terry

This would be useful for all sorts of things, but Leo, being Leo,
already has features that overlap functionality wise.  You could
collect clones of all the nodes you want to identify with a particular
tag, under a single parent node, which becomes the tag proxy thing.

You can do something similar with the backlinks.py plugin which provides
unrestricted node linking, just link all the nodes which need a
particular tag to a particular node.

But I'm guessing only a tag centric UI component will give the quick
and easy use you'd want from a tagging system.  Data wise I guess tags
could be a simple list of string, p.v.u['_tags'], with Leo maintaining
an index of tag to node list mappings.

===== Kent

wish list:
- tab completion / drop-down list to prevent creating similar tags
- import / export of tags, encourage consistent ontologies
- hooks which parse the node content, create tags from them
</t>
<t tx="ekr.20130806072439.21337">From: ne1uno &lt;eltronis@gmail.com&gt;

wouldn't it be great to have a first class c importer?
hiding the complexity of platform &amp; compiler/option #defines.
invisible (TM) nodes would be fruitful here. switched on by @#define.
with an @#define=3D collection node or using a bunch of headlines.
and an rclick flipper for true/false, defined/not defined
declarations.

we know c isn't disappearing. quite a few people still regard
any so called scripting language as a nuisance.
maybe ok for prototyping but not for the final product.
pyqt would be near zilch useful w/o Qt, at least currently.
I guess that's as far as I ever got, wouldn't it be great if...

meanwhile I wait for the inspiration or someone else to nail down
a regular expression c language parser. maybe a tokenizer is enough.
I did run c code through AStyle then through your old c2py via
buttons.
for code that would remain in c,
in SciTE through google CPPlint program to point up flaws,
and to get the context sensitive help from various CHM.
running flawfinder good to do now and then old or new code.
post processing and displaying the report in a browser.
but it doesn't go far enough &amp; too many false positives.

there is splint, maybe the only free lint left. the need to inject
"hints" all over the code make it less than ideal for perusing
unknown source and generally a deal breaker for project code.
sometimes all you need is a function/var list to get by.
deeper static analysis is quite the serious business. so, it's
not a surprise those programs are not easily found, or used.
there are a few code flow programs that could be harnessed
to colorize headlines indicating relations.
taking all this in, marking nodes that need work with a popup
or tooltip action event when you view that node with the
details of one or another parser to annotate what needs work.

we have had a few plugins/buttons/attempts at designing an
interface to get a program node compiled. this is also a decent
way to get info on the quality of code by turning all warnings on.
fails for snippits. never quite simple to hookup or modify painless.
perhaps the biggest problem is knowing what is available and where.
more toolbars, no reason they can't dock. drag &amp; dropping buttons.
one of the huge advantages of Qt over Tk so far barely tapped.
you begin to accept the fact that you need to create a temp file
instead of real process control. managing program quirks
&amp; options becomes more trouble than it's worth just to
protect the purity of the operation sans temp files.
QTprocess has more options than the process in pythons libs.
if it ever works as well as it should. but, a little hard to wrap.
not going to venture a guess if pyqt gets it right or not.
not to mention how bungled up OS process control still is.
process control will be essential to any inter-process operations.
that is, unless you backslide into wanting to build everything "in"
and invent everything new again. re: blender, I haven't looked at
blender code in a while, but I would be shocked if there weren't
some well established way to hook into a script.
sounds like noone has found them yet.

not sure how to grab a window handle on other OS but for windows
it's fairly straight forward. blender or GTK could setup blocks.
another great Qt based project is universal indenter, a front end

for many indenters for many languages. this would be a good place
to look for how to manage inter-process communication in Qt.
a first class editor will have to include first class importer for
javascript at the least and probably lua and one or two others.
one could imagine niceties like clickable links on #include files.
right clickable options on them such as import, simple view, htmlize.

also about styles, astyle has the options on the commandline, the
builtin/compiled in defaults and an ~/.astyle.rc for personal style.
some will find an indenter that has no options useless. I know the
indenter created is purely for internal use, as it were, at this
point.
adding selectable options later will complicate the program and for
most use will have little payback. you may as well expect to have some
want a plugable option for style.
exposing a general use tokenizer could have many callers.
</t>
<t tx="ekr.20130806072439.21341">From: Kent Tenney &lt;ktenney@gmail.com&gt;

The editor envy resulting from the Light Table demo has me revisiting
a feature that's been percolating.

Sending output to the log pane is very useful, it's how Leo talks back.

Executing from the command line means one space for input and output.

Executing in a Leo node and writing to the log improves on this by providing
different spaces for input and output.

Could Leo generalize this concept such that any node could be designated as
a destination for output?

Given multiple visible nodes, akin to Terry's stickynotes, or Ville's
recent grid
suggestion, Leo could duplicate the power of simultaneous feedback shown
by Light Table.

I guess 'rendering' addresses this to some degree.

Reminds me of the power graph database folks talk about, where you can
define nodes and edges to be whatever you want.

The nodes could be sources or sinks.
Sources: code or commands ...
Sinks: standard out, tail -f logfile, network traffic, introspection ...

The edges would define handlers for the content of the sources, format the
results and send to the sinks.

So, as I write code in one node, I can see a node displaying stdout, another
watching a log file, another showing docstrings, another showing test
results ...

===== Ville

The 'ileo workbook' concept is relevant; it allowed you to easily reference
other nodes in your scripts (wb.foo meant node with headline 'foo').

It's nice in theory, but the rigid ui model where we show only one node at
a time made it hard to visualize. Tabula or grid would make it more
concrete and intuitive - you could show input, output and the manipulator
script at the same time. Or make small nodes with intermedote results etc.

How this would relate to 'pipeline' - you would have explicit way to say
what nodes are input, whan nodes are output and what are the scripts that
transform input to output. Editing inputs or scriyts would ping you somehow
that outputs are out of date, allowing you to easily press button to
recalculate outputs.
</t>
<t tx="ekr.20130806072439.21342">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wed, Apr 18, 2012 at 9:48 AM, Kent Tenney &lt;ktenney@gmail.com&gt; wrote:

&gt; Could...any node...be designated as a destination for output?

Certainly.  Just assign to v.b in the appropriate place.

&gt; could [Leo] duplicate the power of simultaneous feedback shown by Light Table.

Yes, provided somebody understands what the simultaneous feedback is ;-)

Tabula might be natural for that, perhaps enhanced via free_layout.

&gt; I guess 'rendering' addresses this to some degree.

Interesting connection.  We might want to render to tabula nodes.

&gt; Reminds me of the power graph database folks talk about, where you can
&gt; define nodes and edges to be whatever you want.

This is coming.  Redefining edges would be easy provided that they had
different colors from the "main" edges.

&gt; The nodes could be sources or sinks.
&gt; Sources: code or commands ...
&gt; Sinks: standard out, tail -f logfile, network traffic, introspection ...

Yes.  This is a straightforward generalization of your first question.

&gt; The edges would define handlers for the content of the sources, format the
&gt; results and send to the sinks.

A new idea!  This could be revolutionary!

&gt; So, as I write code in one node, I can see a node displaying stdout, another
&gt; watching a log file, another showing docstrings, another showing test
&gt; results ...

To paraphrase: nodes and links are not simply ways to represent
structure.  They may have independent identity and function.  A
brilliant idea.

Edward
</t>
<t tx="ekr.20130806072439.21344">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wed, Apr 18, 2012 at 11:47 AM, Kent Tenney &lt;ktenney@gmail.com&gt; wrote:

&gt;&gt; Certainly. Just assign to v.b in the appropriate place.
&gt;
&gt; Right. Leo can be considered a programming language, it is able
&gt; to do most anything one dreams up. Here we are discussing what
&gt; features are appropriate to add to the 'standard library' IE: put the
&gt; effort into making the capability an API call instead of a bunch of code.

In fact, the inadequacy of my remark that assigning to v.b was all
that was needed lead me to consider the broadcaster/listener
framework.

The idea is that the v.b setter property would broadcast the fact that
v.b has changed to all the listeners connected to v.  Presumably,
those listeners will be UI elements that will update their text from
v.b and recolor as appropriate.

We might generalize this concept to update outline structure in those
UI elements that show outlines.

&gt; My impression of the Light Table demo is that the right side of the scree=
n was reporting interesting information about what was being typed on the l=
eft side. Seems like it could be called "simultaneous feedback"

An excellent generalization.  We can use this without knowing exactly
what the feedback is, or where it comes from.

&gt; I'm unable to keep up, unaware of the capability of free_layout,
&gt; tabula, rendering, but I expect most if not all of the tools are availabl=
e.

Keeping up with ourselves these days seems like a full-time job.

I believe a broadcaster/listener event framework is an essential
ingredient.  It shouldn't be too hard to do, it will simplify existing
code, and it will be an enabling technology that will stimulate
further development.
</t>
<t tx="ekr.20130806072439.21349">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

I've been blind all these years!  @nosent should put headlines as nodes a 
comments.  They would be very useful and I can see no reason not to put 
such comments.  If, for some reason, they are not desired, you could use 
@asis.

===== Ville

I use @nosent for non-code text mostly, and it's not clear what "comment"
should mean in that context.

I for sure would like this kind of feature, but sometimes I'd like to have
the headlines written as reST style headlines (underlines), etc.

So this is not a complete no-brainer modification.

===== EKR

I agree.  Some more thought is needed.

===== Ville

Instead of changing how Leo fundamentally behaves (@nosent is part of
that), how about adding a new @directive that allows things like this? E.g.
"@write a.txt" would be nice &amp; "obvious".

===== EKR

In this case, adding support for a new directive might be more complicated
than changing @nosent :-)

</t>
<t tx="ekr.20130806072439.21370">From: Alexandre_Toledo?= &lt;jalexandretoledo@gmail.com&gt;

As I use Leo to write PL/SQL code, I need to write similar text several
times, changing only small parts of it. It would be great if I could create
a node with the "template" and then clone it everywhere it should be
written, and then providing the parameters to be used in this writing.

Let me try to clarify it. I'd like to create a tree like this:

 +- @file something.sql
           +- Section 1
              + &lt;&lt; Clone &gt;&gt; with Parameters A, B
           +- Section 2
              + &lt;&lt; Clone &gt;&gt; with Parameters C, D

In this tree, both "Clone" nodes would be generated from a template
specified somewhere in the tree, and would have parts of its text replaced
with values "A" and "B" in Section 1, and "C" and "D" in Section 2.

I've searched but couldn't find anything like this, then I've thought of
trying to write a hook to intercept the "save" command, but couldn't think
of a way to pass the parameters; I think the obvious way would be to put
the parameters after the "&lt;&lt; &gt;&gt;", but then all cloned nodes are changed, so
it wouldn't work.

Another alternative would be creating some kind of directive @something,
but I have no idea of how to do that.

Any ideas?

===== EKR

Variants of this seem to be wanted by many people.  Most recently, there is
the thread, "Templates with macro expansions",
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/nF2lUEUtaUE

Does that do what you want?
</t>
<t tx="ekr.20130806072439.21371">@nocolor

From: &lt;fidelperez@gmail.com&gt;

I know a programming IDE
&lt;http://sourceforge.net/projects/doublesvsoop/&gt;which bases its existence in
that concept:

You write "code Masks" and whenever you call a piece of code it will ask
only for the parameters, and write the rest of the code. There are already
some languages with most of the masks (all the primary functions and some
complex ones) and its growing.

For instance, if you write:

"window" it will add the window to the code and let you edit the params.

Their functionality would be awesome in Leo and when I know a bit better I
will try to emulate on it. Sticking to Leo tho since it has a much superior
way of managing data.
</t>
<t tx="ekr.20130806072439.21372">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sun, 5 May 2013 16:35:59 -0700 (PDT) &lt;fidelperez@gmail.com&gt; wrote:

&gt; I know a programming IDE &lt;http://sourceforge.net/projects/doublesvsoop/&gt;which bases its existence in that concept:
&gt;
&gt; You write "code Masks" and whenever you call a piece of code it will ask
&gt; only for the parameters, and write the rest of the code. There are already
&gt; some languages with most of the masks (all the primary functions and some
&gt; complex ones) and its growing.

I suspect different people have different things in mind when they talk
about templates.

Leo's abbreviation system is already quite advanced when it comes to
filling in skeletons of common code layouts.  I type

  def;;

and I get

  def foo(this, that=3D3):
      """foo - Return
 
      :Parameters:
      - `this`: &lt;|describe this|&gt;
      - `that`: &lt;|describe that|&gt;
      """
 
      &lt;|code|&gt;

Two "parameters" are interactively requested, the function name, and
the list of arguments.  The node name is presented as the default for
the function name, and 'self' is included in the list of arguments, so,
assuming the node was already called 'foo', all I type is this, that=3D3.
The layout above is the rst form of the epydoc/sphinx docstring with
formally identified parameters.

The cursor is positioned after Return, where the was an empty &lt;||&gt;
placeholder.  Pressing ,, selects the next placeholder so that typing
replaces it.

There's more, see
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/5ni2PwfmBz8
and the screencast linked from there
http://www.greygreen.org/tmp/leoabbrev.ogv

Other people, Jacob etc. I think, have been talking about templates
where the input parameters are stored in the outline, allowing for
some of them to be altered and the template generation step re-run.
More like generating a website from data etc.
</t>
<t tx="ekr.20130806072439.21375">@nocolor

From: &lt;jalexandretoledo@gmail.com&gt;

I've tried it and it's great, I think it will be useful, but it's not what
I was thinking of...

Let me try to explain what I had tougth about... What I would like to do is:

 1. create a new .leo file
 2. add a "template" node (eventually with sub nodes) with some ${schema}
and ${table} macro place holders in its contents
 3. add a @file node to the .leo file
 4. add to this @file node a new one with definitions such as
schema=3DSCHEMA_NAME and table=3DTABLE_NAME
 5. add as a sub node to this last one a clone from the "template" node;
 6. then, when I save everything, the @file would have "SCHEMA_NAME" and
"TABLE_NAME" everywhere a "${schema}" or a "${table}" were in the original
template node.

It would be important that, when I reopen the .leo file later, the macros
in the @file node where shown as ${schema} and ${table}, and not as it's
substituted text.

Now that I've described it, I can't see how it would be done... The
${macro} place holders should be on the contents of the @file node, so
after substitution, how could we recover it?

That's also why the code from Jacob is not what I need (but I'm already
thinking of other uses for it :) ): it will create a text when the button
is pressed, but the generated nodes will be just static text.
</t>
<t tx="ekr.20130806072439.21380">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

This thread will need Ville to set it on the right track, I barely know
the names of the technologies, but Qt has been advancing with, quoting
from their site:

Qt Quick

The Qt UI Creation Kit lets you create rich, touch-enabled UIs and
apps...quickly.

  * QML - CSS &amp; JavaScript like language, same code base for UI
    designers &amp; developers

  * Supported by Qt Creator IDE for rapid prototyping and development

  * Qt Quick UI runtime - Direct access to native APIs, performance
    boost with C++

I think the first bullet is most relevant to Leo.  Could we embed this
kind of environment in Leo?  Can it be integrated effectively with the
current GUI?

That route might make adding task specific GUIs in Leo quick and easy.

Not for the touch part (although Leo on a tablet would be fun), but as
a way of quickly creating task specific GUIs, "forms" if you like, for
accessing / interacting with the data in a Leo outline.  I'm assuming
that QML is higher level / less coding the regular PyQt programming,
but I don't know that, not having tried it.

===== Ville

QML is actually lower level than QWidgets / "regular" PyQt
programming. Key selling point of QML is that the UI's are more free
form, "custom" and much faster than QWidget UI's (in Qt5, QML maps
quite naturally to OpenGL, making it fly on mobile phone/tablet
hardware).

QML would be natural for graphcanvas / tabula / other "custom" ui
plugins, but it doesn't yet have text editor as powerful as QTextEdit,
not tree widget as powerful as QTreeWidget / QTreeView.

I expect QML to be first used in mobile version of Leo (I have one
actually, that I will publish "at later date" ;-). For desktop, QML is
not yet as attractive as the "old stuff".


</t>
<t tx="ekr.20130806072439.21428">From: tfer &lt;tfetherston@aol.com&gt;

Having played with Jacob Peck's markdown fork, I now get what leo is doing 
to provide a preview of text using a markup type. It is converting that 
markup, (rst: built-in, markdown: proposed).  What is being done is to run 
the text through a xxx2html converter and then using a Qt window widget 
that renders the generated html.

There have been requests to extend the built in rst functionality to other 
markup types, (Peck has an experimental one for markdown).  Rather than 
added them piecemeal, I think we could incorporate the code github uses to 
allow people to use their preferred markup language for their projects 
readme file.  Although a number of the converters are written in ruby, some 
are python and one is even pearl.  It is an extensible scheme.  The license 
for the library is basically, "keep the copyright notice and have at it", 
so it shouldn't cause any problem.

The code is here:
  https://github.com/github/markup

The current "see the selected node's body text" in the view-render-pane 
should work, the only thing lacking is a way to preview an entire file. 
 How about adding an option to preview it in the context menu for a right 
click on an @file node?

===== From: Jacob Peck &lt;gatesphere@gmail.com&gt;

That was actually my first thought when approaching the markdown 
implementation.  The major problem here is that the wrapper program, and 
several of the assorted converters are in ruby.  The only python one is 
rest2html, which we already have (via docutils).  I don't think adding 
ruby and perl as dependencies for one small feature of Leo would be 
wise...  that seems to me to be the very definition of bloatware.

That being said, github-markup supports the following formats, which are 
supported by python libs:

markdown (markdown)
rst (docutils)
textile (textile)
org mode (pyorgmode)
creole (python-creole)
mediawiki (mw2html)
asciidoc (asciidoc)

The following do not have a python equivalent (to my knowledge):

rdoc (ruby documentation)
perlpod (perl documentation)

I could certainly keep hacking on viewrendered to support the first 
list, if interest is high.

&gt; The current "see the selected node's body text" in the 
&gt; view-render-pane should work, the only thing lacking is a way to 
&gt; preview an entire file.  How about adding an option to preview it in 
&gt; the context menu for a right click on an @file node?
I could look into this suggestion too, if someone would point me in the 
right direction with respect to 2 things (I'm really new to Leo, so I 
have no idea where these things are in the source):

1. How to add a context menu item for a node
2. How to get a "full file" without saving it, i.e., fill in the &lt;&lt; 
references &gt;&gt;, @others, and @all directives.

</t>
<t tx="ekr.20130806072439.21443">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I guess this is a wishlist item - I suspect it is a result of my
workflow that might be quite different from other peoples, but I often
need to save 4, 6, even more open changed Leo files at once.  Mainly
when I'm filing / adjusting todo items, although at the end of a
session having 4 changed files open can't be that unlikely.

So it would be really nice if c.saveAll() could be threaded.  Even as I
write this, it gets more complicated as I think about it :-}

  - each thread should do no user interface calls, or at least no calls
    that aren't deferred to the main thread

    - that's ok, would take quite a bit of tracing to catch them all,
      but doable - except - plugins called from save hooks might break
      the rule

  - updating recent files list would have to be done properly, not a
    big deal

  - multiple threads saving to the same external files would be a
    problem, that's the complication that only just occurred to me

I don't typically have the same external file referenced from multiple
Leo files, why would you do that... so the last problem, although
potentially major, might be theoretical more than practical.

Hmm, well it's a thought.  First thing to check, is saving IO bound or
CPU bound...
</t>
<t tx="ekr.20130806072439.21444">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Since the flat document is a sort of "rambling" blue sky topic, I added
some more thought on G+ leo community instead of increasing mailing list
noise:

https://plus.google.com/103097156557482112329/posts/Vp5ansTdLwq
</t>
<t tx="ekr.20130806072439.21445">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

--f46d042fd84e36bae704d78bf5db


I'm pretty sure saving is cpu bound; for "normal" size documents, flushing
that kind of stuff to disk (or memory buffers that are to be written to
disk) shouldn't take significant amount of time.

</t>
<t tx="ekr.20130806072439.21446">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sat, 9 Mar 2013 14:46:09 -0600
Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; I guess this is a wishlist item - I suspect it's a result of my
&gt; workflow that might be quite different from other peoples, but I often
&gt; need to save 4, 6, even more open changed Leo files at once.  Mainly
&gt; when I'm filing / adjusting todo items, although at the end of a
&gt; session having 4 changed files open can't be that unlikely.

I've just found that, because these todo items are always in the
outline itself and not external files, I can just do 
'write outline only' on all the open outlines, and this is much faster
and smooths out the bump in my workflow that got me started thinking
about this.
</t>
<t tx="ekr.20130806072439.21447">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sun, 10 Mar 2013 08:13:41 +0200
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; I'm pretty sure saving is cpu bound; for "normal" size documents, flushing
&gt; that kind of stuff to disk (or memory buffers that are to be written to
&gt; disk) shouldn't take significant amount of time.

Probably right, so could you use `multiprocessing` instead of
`threading`?  More challenging implementation wise, but I'm wondering
if it's even possible, in terms of handing over the in-memory data
structure?
</t>
<t tx="ekr.20130806072439.21448">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

--14dae9340445ec94c604d796bde2


Multiprocessing based implementation will likely be quite hard, and once
you walk the trees anyway and copy the data over the process boundary, it
could cause bad pauses in execution.

I have often thought how nice it would be to have "flat" storage for the
leo document, so that you could just copy over a flat chunk of memory and
let other processes traverse that. Doing that is a somewhat nontrivial
undertaking, to say the least :).

I'd just start with threads, despite the GIL problems.
</t>
<t tx="ekr.20130806072439.21464">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Hey,

No time to mock this up right now, just throwing it out there.

"tabula" plugin allowed you to edit many nodes simultaneously in an
MDI canvas - i.e. you could move the body editors around freely.

How about taking this idea further and locking the body editors in a
grid, or column?

One fun idea would by layout like this

            | Child 1
Outline  | Child 2
            | Child3

That is, you would edit and view all the children of the currently
focused node all at once. We can already do two body editors at once,
so this would seem like natural extension.

Of course you could only see a small amount of text per body, but for
a "workbook" / sheet like use cases it would be fine.
</t>
<t tx="ekr.20130806072439.21465">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Apr 18, 10:53=A0am, Terry Brown &lt;terry_n_br...@yahoo.com&gt; wrote:

&gt; When the body editor is a well behaved widget it should be straight
&gt; forward to place them where ever you want in using the free-layout
&gt; mechanism.

Yes.  This might the key.

As I was thinking about doing body editors with free_layout (and by
extension, the tabula editors) I had another new thought: it's time to
replace the present difficult selection code with a broadcaster/
listener framework.

In particular, the multiple body editor code is on the verge of
collapse because it tries to figure out too much in a spaghetti-like
mass of logic.  This doesn't generalize, and Leo is becoming so
"exuberant" in its IDE that a simpler, more general mechanism is
becoming essential.

Edward

</t>
<t tx="ekr.20130806072439.21466">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wed, Apr 18, 2012 at 4:37 AM, Ville M. Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; "tabula" plugin allowed you to edit many nodes simultaneously in an
&gt; MDI canvas - i.e. you could move the body editors around freely.

Tabula is part of the stickynotes plugin.  It creates the following commands:

         tabula
         tabula-marked
         tabula-show
         tabula-subtree

The "windowlets" show the node's headline. So this is the "sea of nodes" view!

The tabula nodes are "live": changes made in the tabula window
instantly affect the corresponding nodes in the regular outline.

An easter egg: double-clicking the title of a windowlet fills the
tabula window with the windowlet.  Another double-click undoes the
expansion.

&gt; How about taking this idea further and locking the body editors in a
&gt; grid, or column?

Good idea.  The tabula window is a great playground for invention.

In the "multi-colored link" world (coming soon, I hope), we could
imagine commands that create "tabula-colored" links, so that the
tabula window would work like a chapter.  (And each chapter would have
its own links).

The Light Table video suggested something else that I never considered
before.  Suppose each node "carries" its own mini-context outline,
showing just the parents of the node.  The tabula window might be
natural for that.

The idea is that each windowlet would have two parts:  the top would
show the parents, the bottom would show the body pane.  This allows
context to be visible without actually having to show the outline
pane.

Edward
</t>
<t tx="ekr.20130806072439.21467">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wed, Apr 18, 2012 at 10:53 AM, Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:
&gt; On Wed, 18 Apr 2012 12:37:22 +0300

&gt; When the body editor is a well behaved widget it should be straight
&gt; forward to place them where ever you want in using the free-layout
&gt; mechanism.

Are you suggesting doing free-layout in tabula?

EKR
</t>
<t tx="ekr.20130806072439.21468">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

--20cf3005df0ef84cc304be0227bb


If you fill the cells with stickynotes (as in tabula), the editors would at
least stick to the nodes.

Otoh, if more felxible body editors are just around the corner, it may not
be worth the hassle.

</t>
<t tx="ekr.20130806072439.21469">From: Kent Tenney &lt;ktenney@gmail.com&gt;

On Wed, Apr 18, 2012 at 2:57 PM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote=
:
&gt; On Apr 18, 10:53=A0am, Terry Brown &lt;terry_n_br...@yahoo.com&gt; wrote:
&gt;
&gt;&gt; When the body editor is a well behaved widget it should be straight
&gt;&gt; forward to place them where ever you want in using the free-layout
&gt;&gt; mechanism.
&gt;
&gt; Yes. =A0This might the key.
&gt;
&gt; As I was thinking about doing body editors with free_layout (and by
&gt; extension, the tabula editors) I had another new thought: it's time to
&gt; replace the present difficult selection code with a broadcaster/
&gt; listener framework.

'publish / subscribe' has buzzword cred these days, there are several
protocols out there, reportedly fairly simple to implement, don't know
if any are a fit here.
</t>
<t tx="ekr.20130806072439.21470">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

--MP_/YLiyZOi3S=ZU5mZC9llHxW5

Content-Disposition: inline

On Wed, 18 Apr 2012 12:48:42 -0700
Ville Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; &gt; Expanding the scope to a grid, we could have a grid-lock-column that would
&gt; &gt; freeze the current column, allowing you to move the selected position in
&gt; &gt; the tree to another node, and locking the nodes for column 2 etc etc  

Attached screen-shot shows the potential for free-layout with the new
Open Window command to open a separate window as a 'grid' editor.  Here
instead of body editors I just have 5 view-rendered panes open, and
they're all looking at the same node because there's no mechanism for
locking them to separate nodes presently(*).  Free layout could handle
body editors in the same way, if they were more agnostic about their
containers.

Cheers -Terry

(*) I think there's a way to lock/unlock a special case singleton
view-rendered pane, but not a flock of them like this.
</t>
<t tx="ekr.20130806072439.21471">From: Ville Vainio &lt;vivainio@gmail.com&gt;

You are probably right. We Could also adjust the sizes dynamically
based on the amount of text in the nodes

Sent from my Windows Phone
From: Terry Brown
Sent: 4/18/2012 10:31 PM
To: leo-editor@googlegroups.com
Re: UI idea: body editors in a grid
On Wed, 18 Apr 2012 21:42:21 +0300
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; I am bringing another angle into play here - systematic selection of what
&gt; nodes are shown in the editors, in the proposed scheme we would have a
&gt; single column of editors, each displaying every child of currently selected
&gt; node.
&gt;
&gt; Expanding the scope to a grid, we could have a grid-lock-column that would
&gt; freeze the current column, allowing you to move the selected position in
&gt; the tree to another node, and locking the nodes for column 2 etc etc

Ok, but I still think it makes sense to implement this with the
free-layout system, so that your grid could be a separate window, or
not, as desired.  free-layout is basically nested QSplitters, so it can
represent a grid, but with more flexibility (cell 1,0 doesn't have to
be the same height as cell 0,0, etc.)
</t>
<t tx="ekr.20130806072439.21472">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; That is, you would edit and view all the children of the currently
&gt; focused node all at once.

I often use "Edit in notepad" (or more likely pyscripter) for this
purpose. It would be nice to stay inside Leo; I sometimes lose data by
forgetting which editor has the most current version.
</t>
<t tx="ekr.20130806072439.21473">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 18 Apr 2012 21:42:21 +0300
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; I am bringing another angle into play here - systematic selection of what
&gt; nodes are shown in the editors, in the proposed scheme we would have a
&gt; single column of editors, each displaying every child of currently selected
&gt; node.
&gt; 
&gt; Expanding the scope to a grid, we could have a grid-lock-column that would
&gt; freeze the current column, allowing you to move the selected position in
&gt; the tree to another node, and locking the nodes for column 2 etc etc

Ok, but I still think it makes sense to implement this with the
free-layout system, so that your grid could be a separate window, or
not, as desired.  free-layout is basically nested QSplitters, so it can
represent a grid, but with more flexibility (cell 1,0 doesn't have to
be the same height as cell 0,0, etc.)
</t>
<t tx="ekr.20130806072439.21474">From: Kent Tenney &lt;ktenney@gmail.com&gt;

On Wed, Apr 18, 2012 at 10:53 AM, Terry Brown &lt;terry_n_brown@yahoo.com&gt; wro=
te:
&gt; On Wed, 18 Apr 2012 12:37:22 +0300
&gt; "Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:
&gt;
&gt;&gt; How about taking this idea further and locking the body editors in a
&gt;&gt; grid, or column?
&gt;
&gt; When the body editor is a well behaved widget it should be straight
&gt; forward to place them where ever you want in using the free-layout
&gt; mechanism.

Plus, free-layout provides persistence: it's worth putting effort into
configuring pane configuration because it will be available next time.

(I guess I'm persistent about wanting persistence)
</t>
<t tx="ekr.20130806072439.21475">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 18 Apr 2012 12:57:03 -0700 (PDT)
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; As I was thinking about doing body editors with free_layout (and by
&gt; extension, the tabula editors) I had another new thought: it's time to
&gt; replace the present difficult selection code with a broadcaster/
&gt; listener framework.

Although such a framework might be quite useful, I can't help thinking
it would insert a big delay between now and getting flexible body
editors implemented.

&gt; In particular, the multiple body editor code is on the verge of
&gt; collapse because it tries to figure out too much in a spaghetti-like
&gt; mass of logic.  This doesn't generalize, and Leo is becoming so
&gt; "exuberant" in its IDE that a simpler, more general mechanism is
&gt; becoming essential.

I think that getting body editors working as described in my recently
bumped "Free range body editors" post would not be that hard, certainly
simpler and faster than a broadcaster / listener framework.  And the
current multiple body editors code could just be dropped completely, so
while I suspect you're right about it being on the edge of implosion, I
don't think that's a problem :-)
</t>
<t tx="ekr.20130806072439.21476">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

--20cf305b11c06d69c404bdf86a61


I am bringing another angle into play here - systematic selection of what
nodes are shown in the editors, in the proposed scheme we would have a
single column of editors, each displaying every child of currently selected
node.

Expanding the scope to a grid, we could have a grid-lock-column that would
freeze the current column, allowing you to move the selected position in
the tree to another node, and locking the nodes for column 2 etc etc

</t>
<t tx="ekr.20130806072439.21477">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Have you tried alt-x stickynote from stickynotes plugin?

</t>
<t tx="ekr.20130806072439.21478">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 18 Apr 2012 11:45:25 -0500
Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; Another feature I've wanted to add to free_layout is popping out any
&gt; element into its own window (replacing sticky-notes).  You could go one
&gt; better and pop-out free-layout frames which could contain multiple
&gt; widgets, like tabula currently does.
&gt; 
&gt; I'll try and get those features into free-layout.

Woohoo - done and pushed.  Went for the second option, instead of
pop-out windows holding a single widget, they hold a whole new
free-layout hierarchy, which of course can be a single widget, or much
more, if you want.  See the 'Open Window' command on the free-layout
splitter handle context menu.

Even made a screencast to demonstrate, but unfortunately the sound was
useless, despite being ok in trials before hand.  Might try again later.
</t>
<t tx="ekr.20130806072439.21479">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 18 Apr 2012 12:37:22 +0300
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; How about taking this idea further and locking the body editors in a
&gt; grid, or column?

When the body editor is a well behaved widget it should be straight
forward to place them where ever you want in using the free-layout
mechanism.  I think that's a better goal, it allows you more
flexibility in terms of maybe one small (both dimensions) and one large
editor, for example.
</t>
<t tx="ekr.20130806072439.21480">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Apr 18, 1:42=A0pm, "Ville M. Vainio" &lt;vivai...@gmail.com&gt; wrote:
&gt; I am bringing another angle into play here - systematic selection of what
&gt; nodes are shown in the editors, in the proposed scheme we would have a
&gt; single column of editors, each displaying every child of currently select=
ed
&gt; node.

The new broadcaster/listener framework should probably be designed to
handle this.  That is, in the new framework it should explicitly be
possible to select multiple nodes.


&gt; Expanding the scope to a grid, we could have a grid-lock-column that woul=
d
&gt; freeze the current column, allowing you to move the selected position in
&gt; the tree to another node, and locking the nodes for column 2 etc etc
&gt; On Apr 18, 2012 6:53 PM, "Terry Brown" &lt;terry_n_br...@yahoo.com&gt; wrote:

Interesting.  For some purposes the column would be like a "super
node", that is, an explicit collection of nodes.

EKR

</t>
<t tx="ekr.20130806072439.21481">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 18 Apr 2012 11:12:45 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; &gt; When the body editor is a well behaved widget it should be straight
&gt; &gt; forward to place them where ever you want in using the free-layout
&gt; &gt; mechanism.  
&gt; 
&gt; Are you suggesting doing free-layout in tabula?

No, although that gives me another idea...

Another feature I've wanted to add to free_layout is popping out any
element into its own window (replacing sticky-notes).  You could go one
better and pop-out free-layout frames which could contain multiple
widgets, like tabula currently does.

I'll try and get those features into free-layout.  Note that a couple
of widgets already have their own pop-out capability, the body editor
and view-rendered.

Also some frame manipulation tools in free-layout would be good.  To
maximize / restore one frame, and layout frames in a grid, if there was
an intent to replace tabula.

Not that tabular needs replacing, but I think it's benefits can be
generalized.
</t>
<t tx="ekr.20130806072439.21482">@nocolor

From: wgw &lt;wgwinder@gmail.com&gt;

Xiki.org gives a demo of a "wiki" shell for command execution. Leo should 
be able to do the same thing (and more!), in the sense that leoscreen, for 
example, has two way communication with the command line. I suppose a 
"Lxiki" is really just a question of setting up the right shortcuts (like a 
shift-ctrl-b that would run highlighted python code from the command 
line... with a tmp file?).

Just an idea for the Leo melting pot. 

</t>
<t tx="ekr.20130806072439.21483">@nocolor

From: wgw &lt;wgwinder@gmail.com&gt;

Thanks for the tip -- it will take me a while to get my head around vspace
(will keep an eye on Ville's blog post).

I'm just beginning to appreciate (or imagine) what Ipython, sublime text
editor, leo, xiki, etc could mean for some kind of intelligent document
workbench. Of course the big hurdle is not so much the string processing
(sublime is a good example of how that can be done), but rather the syntax
processing -- i.e. the docbench  (to coin a phrase) should understand the
syntax of whatever is being input and then offer syntax-aware functions....
Sorry, getting a little obscure: all I mean by syntax-aware is the ability
to propose text completions (Leo's autocompletion is a good example --
everything should work like autocomplete!) and allow for intelligent text
changes depending on a database of information (for example, a search and
replace that would  know how to search on "caterpillar" and turn it into
"butterfly" but would not touch "caterpillar truck").

Seems like Leo is not far from doing that synthesis, but it would require
more database integration. So for example, even the python help system does
not have autocomplete. (No criticism there! The great thing about Leo is
that if you want something, you just have to dive in and build it. My day
job might just let me do that!)
</t>
<t tx="ekr.20130806072439.21484">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

&gt; Thanks for the tip -- it will take me a while to get my head around vspace
&gt; (will keep an eye on Ville's blog post).

Just to clarify, vs-eval, vs-last, vs-last-pretty are quite straight
forward, as I described them below, and do not require comprehension of
the esoterica of value-space :-) I just put them in that plugin (a) to
avoid creating yet another plugin, and (b) because it seemed sensible
to have them use the value-space namespace c.vs, but all that means for
vs-eval, vs-last, vs-last-pretty is that

  a =3D 7

executed by vs-eval assigns a value to a which can be used by
subsequent vs-eval calls (persistent for the lifetime of the session).

For example, make a body with this text

a =3D 7
b =3D 3
a + b

and place the cursor in front of the first 'a'

execute (Alt-x or key binding) vs-eval 4 times

 - first time executes the empty selection and selects the next line
 - second time assigns 7 to a and report 7 in the log
 - third time assigns 3 to b and report 3 in the log
 - forth time calculates a + b and report 10 in the log

executing vs-last(-pretty) would insert the last result (None, 7, 3,
10) in the body.
</t>
<t tx="ekr.20130806072439.21485">@nocolor

From: wgw &lt;wgwinder@gmail.com&gt;

Got it! The value of valuespace (!) is that that you can make a pythonesque
session persist. I did not realize that there was no direct two-way bridge
to the python window that leo launches. Even if there were, we would want
to make the session persist by logging it into the outline, as
valuespace (vs-create-tree) does.
</t>
<t tx="ekr.20130806072439.21487">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

In addition to the outline as a active data document functions of
Ville's value-space plugin, I recently added some simple ;-) commands:

Alt+A vs-eval
Alt+S vs-last
Alt+D vs-last-pretty
(my key bindings)

vs-eval evaluates the selected python in the c.vs namespace.  It makes
an effort to workout what the output should be, and puts it in the
log.  It captures print output to the log too.  It selects the next
line, ready for execution.

vs-last inserts the last result into the body, and vs-last-pretty
does the same, but using pprint formatting.

Ctrl-B also runs the script in the body, but not in a persistent
namespace, running only the selected text doesn't seem to be working,
and it doesn't work so hard to work out the output.

I guess leoscreen would do the same things as the vs-* commands if you
used it against a python shell.  The inspiration for the vs-* commands
was wanting Leo to tell you what 3.57 * 365 / 12 was without a lot of
effort, but of course you can define functions etc. etc.
</t>
<t tx="ekr.20130806211959.17365">Josef &lt;joe_da@gmx.net&gt; 7/30/12
		
Recently I evaluated docear - a mind-mapping tool for collecting reference
data (written in Java). It automatically extracts bookmarks and annotations
from PDF files, and more, but it's support for authoring is still not up to
the task. I think it would be great if Leo could do some of the tasks
docear is doing.

Leo is primarily a literate programming editor, but also quite good at
organizing bits of information. Dragging a PDF into Leo currently just
creates an url to the PDF. This could be expanded to also extract data
(bookmarks, notes) from the PDF and to sync this data between Leo and the
PDF. This info could be placed in child nodes: bookmarks and notes could
even jump directly to the page in the PDF (although each PDF viewer seems
to have a different syntax for doing that). This would be a great way to
organize data sheets and specifications stemming from external sources.

Combining the above with an improved LaTeX support, one would get a very
powerful research and authoring tool - in my opinion with a much more
convenient interface than docear.

Perhaps it is too much work to duplicate all the work docear is doing. An
alternative may be to sync data somehow between docear and Leo. Docear
stores the data in a freeplane mind-map. Has anyone else thoughts about
this? Offray Vladimir Luna Cárdenas offray@riseup.net via googlegroups.com
	
7/30/12
		
I have been using Leo to write my thesis. I didn't know about Docear, but
my use was in some sense similar. I have a lot of @url links pointint to
the pdfs files and in a subtree I cut and paste the text of the pdf I want
to comment and made the comments inside the tree. These pdf were part of my
bibliographic entries and I'm now writing a .bib file for these, so I can
have in only one Leo tree all my thesis, with all the references to
external files and the annotations and bibtex entries for them. For me the
key point of Leo in academic writing is the tree view plus the clones and
ignore nodes. My thesis can have several layers, the external ones being
the actual writing and the deeper ones the references, texts, images, tools
that enable me to do that writing. Using clones and @rst-no-head directives
I can have the level of granularity of a paragraph, something that is not
possible on traditional word processor which are the writing tool of tools
like docear. This approach have some glitches:

* I still need to do some fine tunning to the LaTeX export for writing the
pdf as I want. I imagine that putting sphinx in the tool chain could change
that.

* I can not get much people of my companions using this advangages, besides
of myself, because of the difficult installation process of Leo in
Windows/Mac and the not so friendly interface for non-programmers. Other
light markup structured text writing programs like Nested[1] are more
easily used and understood despite of not having all the advantages and
flexibility of Leo.

So, in resume, may be the better approach is connecting Leo to Docear, so
you can have the advantages of both in terms of easy multiplataform
installation and friendly interface of the later and programmability,
flexibility and deeper organic structure of the former.

Offray

Terry Brown &lt;terry_n_brown@yahoo.com&gt;


&gt; Recently I evaluated docear - a mind-mapping tool for collecting reference
&gt; data (written in Java). It automatically extracts bookmarks and annotations
&gt; from PDF files, and more, but it's support for authoring is still not up to
&gt; the task. I think it would be great if Leo could do some of the tasks
&gt; docear is doing.
&gt;
&gt; Leo is primarily a literate programming editor, but also quite good at
&gt; organizing bits of information.

I would describe it as an general purpose outline that's very good at
editing code.

&gt; Dragging a PDF into Leo currently just
&gt; creates an url to the PDF. This could be expanded to also extract data
&gt; (bookmarks, notes) from the PDF and to sync this data between Leo and the
&gt; PDF. This info could be placed in child nodes: bookmarks and notes could
&gt; even jump directly to the page in the PDF (although each PDF viewer seems
&gt; to have a different syntax for doing that). This would be a great way to
&gt; organize data sheets and specifications stemming from external sources.

I'm not really sure how notes get embedded in PDFs.  As an aside, there
is also capability for using Leo to manage bookmarks to web pages, with
notes, tags, and snippets.  Look at the mod_http plugin.  It uses a
javascript bookmark button in your browser to communicate with Leo.

&gt; Combining the above with an improved LaTeX support, one would get a very
&gt; powerful research and authoring tool - in my opinion with a much more
&gt; convenient interface than docear.
&gt;
&gt; Perhaps it is too much work to duplicate all the work docear is doing. An
&gt; alternative may be to sync data somehow between docear and Leo. Docear
&gt; stores the data in a freeplane mind-map. Has anyone else thoughts about
&gt; this?

Syncing between the two sounds a little cumbersome to me.  I wonder if
the PDF stuff could be integrated with some sort of BibTeX .bib file
management?

Do you really need the mindmap UI of docear?  I used to use Freemind
which has a very similar interface, but switched to Leo.  I like what
http://cmap.ihmc.us/ does, but it only does idea organization, no
authoring etc.  To me cmaptools is better at idea organizing than
mindmaps.

There is also the backlinks plugin for Leo, which allows arbitrary
networks of links instead of just the directed tree, and graphcanvas,
which allows graph layout of nodes.  There aren't comparable with the
mindmap layouts, but they head in that direction.  Also note Leo's
hidden UI flexibility in the context menus on the pane dividers, you
can open a new window for the graphcanvas plugin, which gives it much
needed screen real estate.

Cheers -Terry

Josef &lt;joe_da@gmx.net&gt;
7/30/12
		
no, I do not need the mindmap stuff at all. I had a look at short look at
cmaptools, and I agree the generalized graph approach seems better than a
standard mindmap. But I am quite happy with the tree view in Leo and as you
already mentioned, this can be extended with backlinks etc. I have used Leo
already to organize reference documents and write documentation (using
Latex).

What I do want is links to a particular page of a PDF - links to just a
file are not enough when you refer to documents with 100+ pages.
Unfortunately this seems to be difficult to achieve in a cross-platform
way, particular when trying to support different PDF viewers. Docear is
solving this (and other compatibility problems) by developing its own
integrated viewer (I do not suggest to do this for Leo).

On second thought, I don't think that extracting the bookmark and
annotation info is really important to me - I would keep that info in the
PDF, anyhow. I would write inside Leo addional notes, and the output text
(in Latex).

Some integration of Bibtex may be a good thing and needs to be thought out
- perhaps by using JabRef for this, or by recycling some pyBibliographer
code, but this is also low on my priority list.

Offray seems to have a very similar use case as I - although I do not write
a thesis, but specifications for scientific instruments. The point about
cross-platform installation ease is also well taken, so I will look into
some inter-operability here (either with docear or cmaptools). I see Leo
mainly as a personal project / information manager: the leo tree is not
easily shared with others, while the files Leo points to with @url, @auto,
@file etc can be shared quite easily. In this I use Leo as *my personal*
view on the project.

Ville Vainio &lt;vivainio@gmail.com&gt;
7/30/12
		
It seems that e.g. w/ foxit reader, you can open selected page from command
line (-n 123). Abstracting this for other pdf readers that support such a
thing should be no problem.
 
On Monday, July 30, 2012 8:08:23 PM UTC+2, Ville M. Vainio wrote:
     
    It seems that e.g. w/ foxit reader, you can open selected page from
    command line (-n 123). Abstracting this for other pdf readers that
    support such a thing should be no problem.
    
Yes, I suppose one could translate from a canonical representation inside
Leo to whatever the tool needs (using @setting). Ideally, one would even
have a choice between opening the new page in a different or in the same
PDF viewer instance as the last page, but few viewers support that (Okular
does - but I don't know any cross-platform solution).
</t>
<t tx="ekr.20130806211959.17373">From: Haroldo Stenger &lt;haroldo.stenger@gmail.com&gt;

I'm slowly trying to grok leo. I love meld, it's simply the best text
comparison I've ever seen. I wonder if a greater bit of integration between
meld and leo is possible, and in which ways. Undoubtedly calling it as an
external process is better than anything.
</t>
<t tx="ekr.20130806211959.17377">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

Just yesterday I was looking into the CoffeeScript/XUL combination as
part of my study of FireBug. JQuery looks at first glance like a more
portable alternative.

As I write this, I realize that Leo would benefit from a CoffeeScript
importer.  I'll get on it :-)

</t>
<t tx="ekr.20130807090137.11461"></t>
<t tx="ekr.20130807090137.11462"></t>
<t tx="ekr.20130807090137.11463">@language python
@ Matt Wilkie &lt;maphew@gmail.com&gt;

Here is a recipe for installing Leo from scratch on Windows (Win7 tested).
The only prerequisites are command line `wget` in PATH and an internet
connection.

About 50mb of files are downloaded and 200mb consumed when done.

Run this script from a console.

After this the directory "X:\\testing\\root" can be renamed and/or moved
anywhere.

To run leo in future sessions, simply call "x:\\path\\to\\root\\osgeo4w.bat
python apps\\Python27\\Scripts\\leo", either as a batch file or windows
shortcut.

**Important**: this is just a proof of concept. It is not ready for prime
time. Feedback welcome.
@c

mkdir X:\\testing
pushd X:\\testing

wget -O apt.exe --no-clobber
http://download.osgeo.org/osgeo4w/release/apt/apt-r1193M.exe
SET OSGEO4W_ROOT=%~dp0\\root
apt setup
apt update
apt install pyqt4 sip

call root\\osgeo4w.bat

wget --no-check-certificate
http://gist.github.com/maphew/5393935/raw/install-pip.py
python install-pip.py GO
python install-pip.py GO

pip install -i https://testpypi.python.org/pypi leo-editor

python apps\\Python27\\Scripts\\leo
</t>
<t tx="ekr.20130807203905.16526">When I study a program, I like to import it into Leo. I have several
scripts that do this: some create @auto nodes; others create @file nodes.
Whatever the method used, the import process has the potential to change
many files. Usually, I just change @auto and @file to @@auto or @@file, so
that any changes I make while studying the code won't affect the originals.

But this "safety first" approach means that I can't actually use Leo to
insert tracing statements (or for any other changes.) Happily, there is a
way to import "live" code into Leo safely::

   Create a bzr repository for the code before importing it

The Aha is to create the repository *wherever the code is*, including,
say, python/Lib/site-packages.

- bzr qdiff ensures that import hasn't significantly altered the code,
- bzr revert undoes any unwise or unwanted changes.

This is exactly what I need:  I can make changes to important tools
*safely* within Leo.
</t>
<t tx="ekr.20130807203905.16594">@language rest

From the thread: "Associate .Leo files to open with Leo when double click"
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

From: &lt;fidelperez@gmail.com&gt;

1. Include a small file within the Quickstart guide which would associate
   files automatically. (Or maybe asking for imput, which can be done
   through a Leo node and this way the user learns about its
   functionality).

2. More buttons or scripts in quick start guide, preferably before the
   "programming" section, so when a new user opens it, he has had the
   opportunity to do Ctrl+B on several scripts (for instance, showing in
   the log the name of all the nodes within the selected one, having some
   subnodes with numbers and doing math on them and showing the result on
   the log pane, and as much "silly" but visual functions as possible so
   the user, by going pressing ctrl+b on each, gets a bigger chance to
   understand what is Leo. In my oppinion some users will just stop in the
   quickguide if they are not presented with such a thing before going to
   docs.leo etc.

3. The description of the plugins is not as accessible as it should be. A
   script for activating them easier, been a week using Leo and still cant
   quite activate, find the descriptions or use them freely... And if each
   plugin or script had an example of use that would be priceless, for
   instance, including them all in quickstart (both scripts, plugins
   branchs) and then the new user could just go through all clicking on the
   examples and just seeing Leo work and show its potential. I know some of
   those are done but as I said, after a week or so I still am very
   confused...

4. Quickstart should be open by default (instead of current Leo workbook)
   at least until the user changes some config and prevents that from
   happening. Is there any "load previous tabs" functionality? (IE open the
   Leo files which where open when it was closed the last time)
</t>
<t tx="ekr.20130807203905.16596">From the thread: Cannot open Leo files by double-click in Windows Explorer?
https://groups.google.com/d/msg/leo-editor/KwrqYGMH20Q/z1uc-99vsnsJ

From: HansBKK &lt;hansbkk@gmail.com&gt;

For those like me who work in "portable" mode, there's a very cool tool
called "PortableFileAssociator" that allows you to create a set of windows
file associations, icons etc and enable/disable the whole profile at one
time, without messing with the local system's registry.

Also handy for those not in portable mode, but working on different windows
boxes and bored with having to tweak each one separately.
</t>
<t tx="ekr.20130807203905.16597">*Important*: Leo's binary Windows installer sets file associations
automatically, so this section is needed only if you are installing Leo
from a .zip file or other sources.

There are two ways of associating .leo files with Leo. The first uses the
Windows control panel, the second, the Windows console.

**Method 1: Using the Windows Control Panel**

The goal is that you want to associate .leo files with the following command::

    "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1"
    
Before Windows 7, you do this with using the Folder Options control panel.
In Windows 7, you do this with the Default Programs control panel.

*Note*: "%1" passes just the file being clicked on, quoted for spaces etc.
The quotation marks are needed to handle file paths containing spaces.

*Warning:* In a batch file, %1 passes just the first command line parameter.
It is logical to expect %* to work for file associations just as in batch
files. Alas, it does not.

**Method 2: Using the Windows Console**

Open a Windows console with administrator privileges, then type::

    ftype LeoFile="&lt;path to python&gt;\pythonw.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1" %*
    assoc .leo=LeoFile

And put this leo.bat in %PATH%::

    @start /b "Leo" "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" %*
    
You may omit the /b option if you want to create a separate console window for Leo.
</t>
<t tx="ekr.20130807203905.16602">Leo has a binary installer for Windows, available at
http://sourceforge.net/projects/leo/files/Leo/ The binary installer
installs Leo and sets Windows file associations. Now see `Running Leo`_ for
how to run Leo after installing it.
</t>
<t tx="ekr.20130807203905.16603">You may download Leo's sources in one of three ways, as described at:
http://leoeditor.com/download.html If the sources are zipped, unpack them
into a temp folder. You may place the sources anywhere you like, including
Python's \*site-packages* folder, for example,
C:\\Python26\\Lib\\site-packages.

Next, you will find it convenient to create Windows files associations for
.leo files, as described in the next section.
</t>
<t tx="ekr.20130807203905.16650">https://groups.google.com/forum/#!topic/leo-editor/lgHE4OJSLzw

In a Nutshell, The Leo Editor...

- has had 15,508 commits made by 47 contributors
  representing 1,064,650 lines of code
- is mostly written in Python
  with an average number of source code comments
- has a well established, mature codebase
  maintained by a large development team
  with decreasing Y-O-Y commits
- took an estimated 292 years of effort (COCOMO model)
  starting with its first commit in February, 2002
  ending with its most recent commit 2 days ago 
</t>
<t tx="ekr.20130807203905.16679">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

I am having some problems wrapping my head around how focus behaves
throughout leo.

IMO it would be a good idea to have only one place in Leo where focus is
explicitly set. E.g. g.setFocus(widget). This implementetation would
suffice:

def setFocus(widget):
  widget.setFocus()

Reasoning: it would be handy to add debugging stuff here, to see why my
focus stuff is failing in alt-x go-anywhere handling.

(My guess is treeFocusHelper only understanding focus being either in tree
or body, but no time to explore further now)

===== EKR

In fact, there is only one such place: c.outerUpdate.  The various
xWantsFocus methods simply set ivars, which c.outerUpdate uses to set the
focus when a command completes.

The various xWantsFocusNow methods call c.outerUpdate immediately.  Usually
we don't want to do this, because it could cause screen flash, but
sometimes the immediate update is essential.

I've marked this thread as a topic for implementers.  Such things will form
the basis for documentation for my successors.
</t>
<t tx="ekr.20130807203905.16681">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Someone may be interested in investigating a free CI system for Leo:

https://travis-ci.org/

This could e.g. create debian packages for daily builds, run unit tests,
check stuff with lint, try compiling with python3 so we (*cough*) wouldn't
have accidental print statements in the source...
</t>
<t tx="ekr.20130807203905.16683">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

As the title indicates, this thread will consist of what could be
called an online engineering notebook.  Please feel free to ignore.

Key bindings are one of the most difficult and complex parts of Leo.
This can't be helped: Leo's goals for key bindings are ambitious.

The present bug, https://bugs.launchpad.net/leo-editor/+bug/879331, is
due to a significant design oversight.  Redefining a binding for a
command x to key y affects not just command x but all other commands
presently bound to y!

Alas, the present binding tables are already complex.  I am almost at
the limit of what I can hold in working memory as it is.  Adding
significant additional complexity risks creating virtually impossible-
to-understand code.

There are two conflicting desires in play here:

1. To make the minimum changes needed.  While reasonable in itself,
this promises to increase overall complexity.

2. To decrease overall complexity.  While reasonable in itself, this
promises significant overall changes to the code.

Combining these two desires yields a strategy of finding a minimal
change that reduces overall complexity :-)  It's a big ask.
</t>
<t tx="ekr.20130807203905.16727"># This project has failed.
</t>
<t tx="ekr.20130807203905.16728">A fixes:
--fix=except
--fix=raise 
--fix=print
--fix=callable # no changes.
--fix=dict # changes suggested, but they don't look like they are needed.
--fix=exec # no changes.
--fix=execfile # no changes.
--fix=filter # one change, but this should be needed.
--fix=funcattrs # no changes.
--fix=has_key # changes suggested, but this code is weird.  Not sure it is wise to do this.
--fix=idioms # optional.  Not made yet.
--fix=input # no changes.
--fix=intern # no changes.
--fix=isinstance # no changes.
--fix=itertool_imports # no changes.
--fix=itertoos # no changes.
--fix=long # no changes.
--fix=map # one change suggested, suppressed by adding from future_builtins import map.
--fix=metaclass # no changes.
--fix=methodattrs # no changes.
--fix=ne # no changes.
--fix=numliterals # no changes.
--fix=paren # no changes.
--fix=raw_input # no changes.
--fix=reduce # no changes.
--fix=renames # two files changed automatically.
--fix=repr # no changes.
--fix=set_literal # no changes.
--fix=standard_error # no such fixer!
--fix=sys_exc # no changes.
--fix=throw # no changes.
--fix=tuple_params # no changes.
--fix=xrange ### Several changes.  Can be done automatically.
--fix=xreadlines # no changes.

B fixes:
--fix=basestring
    OK: docutils\nodes.py
    docutils\utils\math\math2html.py
--fix=buffer # no changes.
--fix=getcwdu # *** applied change by hand.
--fix=imports2 # no changes.
--fix=imports # see below
    These must be modified:
        docutils\writers\docutils_xml.py
        docutils\writers\odf_odt\__init__.py
--fix=next # Changes suggested.  Not sure what to do about them.
--fix=nonzero # changed nodes.py by hand.
--fix=types ### Two changes needed.
--fix=unicode # This removes U from U'string', and is probably not necessary (because the files compile correctly)
--fix=urrlib ### Several changes needed.
</t>
<t tx="ekr.20130807203905.16729"># The python-modernize package makes these unnecessary.
</t>
<t tx="ekr.20130807203905.16730">"""Fixer that changes u"..." into u("...") and ur("...") into u(r"...").

"""

@language python
@tabwidth -4

import re
from .. import fixer_base

_literal_re = re.compile(ur"[uU][rR]?[\'\"]")

class FixUnifiedUnicode(fixer_base.BaseFix):
    
    BM_compatible = True
    PATTERN = "STRING"

    def transform(self, node, results):
        if _literal_re.match(node.value):
            node.value = "u(%s)" % node.value[1:]
            node.changed()
</t>
<t tx="ekr.20130807203905.16731">"""
Fix incompatible imports and module references so the work with Python 2 and 3.
"""

# Authors: Collin Winter, Nick Edds, Edward K. Ream.

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;
&lt;&lt; define mapping &gt;&gt;

@others
</t>
<t tx="ekr.20130807203905.16732">
# Local imports
from .. import fixer_base
from ..fixer_util import Name,Newline,Node,Leaf,String,attr_chain,find_binding

# EKR imports
from ..pgen2 import token

import pprint
pp = pprint.PrettyPrinter(indent=4)

import leo.core.leoGlobals as g
</t>
<t tx="ekr.20130807203905.16733">MAPPING = {
    'StringIO':  'io',
    'cStringIO': 'io',
    'cPickle': 'pickle',
    '__builtin__' : 'builtins',
    'copy_reg': 'copyreg',
    'Queue': 'queue',
    'SocketServer': 'socketserver',
    'ConfigParser': 'configparser',
    'repr': 'reprlib',
    'FileDialog': 'tkinter.filedialog',
    'tkFileDialog': 'tkinter.filedialog',
    'SimpleDialog': 'tkinter.simpledialog',
    'tkSimpleDialog': 'tkinter.simpledialog',
    'tkColorChooser': 'tkinter.colorchooser',
    'tkCommonDialog': 'tkinter.commondialog',
    'Dialog': 'tkinter.dialog',
    'Tkdnd': 'tkinter.dnd',
    'tkFont': 'tkinter.font',
    'tkMessageBox': 'tkinter.messagebox',
    'ScrolledText': 'tkinter.scrolledtext',
    'Tkconstants': 'tkinter.constants',
    'Tix': 'tkinter.tix',
    'ttk': 'tkinter.ttk',
    'Tkinter': 'tkinter',
    'markupbase': '_markupbase',
    '_winreg': 'winreg',
    'thread': '_thread',
    'dummy_thread': '_dummy_thread',
    # anydbm and whichdb are handled by fix_imports2
    'dbhash': 'dbm.bsd',
    'dumbdbm': 'dbm.dumb',
    'dbm': 'dbm.ndbm',
    'gdbm': 'dbm.gnu',
    'xmlrpclib': 'xmlrpc.client',
    'DocXMLRPCServer': 'xmlrpc.server',
    'SimpleXMLRPCServer': 'xmlrpc.server',
    'httplib': 'http.client',
    'htmlentitydefs' : 'html.entities',
    'HTMLParser' : 'html.parser',
    'Cookie': 'http.cookies',
    'cookielib': 'http.cookiejar',
    'BaseHTTPServer': 'http.server',
    'SimpleHTTPServer': 'http.server',
    'CGIHTTPServer': 'http.server',
    #'test.test_support': 'test.support',
    'commands': 'subprocess',
    'UserString' : 'collections',
    'UserList' : 'collections',
    'urlparse' : 'urllib.parse',
    'robotparser' : 'urllib.robotparser',
}
</t>
<t tx="ekr.20130807203905.16734">def alternates(members):
    return "(" + "|".join(map(repr, members)) + ")"

</t>
<t tx="ekr.20130807203905.16735">def build_pattern(mapping=MAPPING):
    mod_list = ' | '.join(["module_name='%s'" % key for key in mapping])
    bare_names = alternates(mapping.keys())
    yield """name_import=import_name&lt; 'import' ((%s) |
               multiple_imports=dotted_as_names&lt; any* (%s) any* &gt;) &gt;
          """ % (mod_list, mod_list)
    yield """import_from&lt; 'from' (%s) 'import' ['(']
              ( any | import_as_name&lt; any 'as' any &gt; |
                import_as_names&lt; any* &gt;)  [')'] &gt;
          """ % mod_list
    yield """import_name&lt; 'import' (dotted_as_name&lt; (%s) 'as' any &gt; |
               multiple_imports=dotted_as_names&lt;
                 any* dotted_as_name&lt; (%s) 'as' any &gt; any* &gt;) &gt;
          """ % (mod_list, mod_list)

    # Find usages of module members in code e.g. thread.foo(bar)
    yield "power&lt; bare_with_attr=(%s) trailer&lt;'.' any &gt; any* &gt;" % bare_names

</t>
<t tx="ekr.20130807203905.16736">class FixUnifiedImports(fixer_base.BaseFix):

    BM_compatible = True
    keep_line_order = True
    # This is overridden in fix_imports2.
    mapping = MAPPING

    # We want to run this fixer late, so fix_import doesn't try to make stdlib
    # renames into relative imports.
    run_order = 6

    @others
</t>
<t tx="ekr.20130807203905.16737">def build_pattern(self):
    return "|".join(build_pattern(self.mapping))

</t>
<t tx="ekr.20130807203905.16738">def compile_pattern(self):
    # We override this, so MAPPING can be pragmatically altered and the
    # changes will be reflected in PATTERN.
    self.PATTERN = self.build_pattern()
    super(FixUnifiedImports, self).compile_pattern()

</t>
<t tx="ekr.20130807203905.16739">def dump(self,aDict):
    if not aDict: return '&lt;None&gt;'
    result = []
    for key in aDict:
        result.append('')
        val = aDict.get(key)
        result.append('%s: %s' % (key,pp.pformat(val)))
    return '\n'.join(result)

</t>
<t tx="ekr.20130807203905.16740"># Don't match the node if it's within another match.

def match(self, node):
    match = super(FixUnifiedImports, self).match
    results = match(node)
    if results:
        # Module usage could be in the trailer of an attribute lookup, so we
        # might have nested matches when "bare_with_attr" is present.
        if (
            "bare_with_attr" not in results and 
            any(match(obj) for obj in attr_chain(node, "parent"))
        ):
            return False
        return results
    return False

</t>
<t tx="ekr.20130807203905.16741">def start_tree(self, tree, filename):
    super(FixUnifiedImports, self).start_tree(tree, filename)
    self.replace = {}
    
</t>
<t tx="ekr.20130807203905.16742">@
mod_list = ' | '.join(["module_name='%s'" % key for key in mapping])

bare_names = alternates(mapping.keys())
    
"""name_import=import_name&lt;
    'import' ((%s) |
    multiple_imports=dotted_as_names&lt; any* (%s) any* &gt;)
&gt;
""" % (mod_list, mod_list)
          
"""import_from&lt;
    'from' (%s) 'import' ['('] ( any |
    import_as_name&lt; any 'as' any &gt; |
    import_as_names&lt; any* &gt;)  [')']
&gt;
""" % mod_list

"""import_name&lt;
    'import' (dotted_as_name&lt; (%s) 'as' any &gt; |
    multiple_imports=dotted_as_names&lt; any* dotted_as_name&lt; (%s) 'as' any &gt; any* &gt;)
&gt;
""" % (mod_list, mod_list)
@c


def transform(self, node, results):
    trace = False
    if 0:
        # print('\ntransform: node:\n%s' % node)
        print('\ntransform: results: %s\n' % self.dump(results))
    # g.trace(sorted(results.keys()))
    import_mod = results.get("module_name")
    name_import = results.get('name_import')
    # print('transform',import_mod,sorted(results.keys()))
    if import_mod:
        mod_name = import_mod.value
        new_name = unicode(self.mapping[mod_name])
        if 0: #original
            import_mod.replace(Name(new_name, prefix=import_mod.prefix))
        else:
            prefix = node.prefix # was import_mod.prefix
            clone = node.clone()
            clone2 = node.clone()
            node2 = self.find_name(clone2,mod_name)
            node2.replace(Name(new_name,prefix=import_mod.prefix))
            indent = Name('    ',prefix=prefix) # A hack.
            node.replace([ # was node.replace.
                String('if sys.version_info &lt; (3,):',prefix=prefix),
                Newline(),indent,
                clone,
                Newline(),
                Name('else:',prefix=prefix),
                Newline(),indent,
                clone2,
                Newline(),
            ])
            
        if 1: # old code.
            if "name_import" in results:
                # If it's not a "from x import x, y" or "import x as y" import,
                # marked its usage to be replaced.
                g.trace('******',mod_name,new_name)
                self.replace[mod_name] = new_name
            if "multiple_imports" in results:
                # This is a nasty hack to fix multiple imports on a line (e.g.,
                # "import StringIO, urlparse"). The problem is that I can't
                # figure out an easy way to make a pattern recognize the keys of
                # MAPPING randomly sprinkled in an import statement.
                results = self.match(node)
                if results:
                    self.transform(node, results)
    elif 1:
        # Replace usage of the module.
        bare_name = results["bare_with_attr"][0]
        new_name = self.replace.get(bare_name.value)
        old = results.get('node').clone()
        if trace: g.trace('==== old',old)
        if new_name:
            if trace: g.trace('===== replace',bare_name,bare_name.value,new_name)
            if 0:
                bare_name.replace(Name(new_name, prefix=bare_name.prefix))
            else:
                bare_name.replace([
                    old,
                    String(' if sys.version_info &lt; (3,) else '),
                    Name(new_name),
                ])
</t>
<t tx="ekr.20130807203905.16743">def find_name(self,root,name):
    '''Find a Name subnode of root defining name'''
    
    # print('find_name',name,root)
    for node in root.post_order():
        # print('find_name',node)
        if node.type == 1 and node.value == name:
            # print('find_name: found',node)
            return node
    return None
</t>
<t tx="ekr.20130807203905.16744">transform: node:
    Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'StringIO'),
        Leaf(1, u'import'),
        Node(import_as_name, [
            Leaf(1, u'StringIO'),
            Leaf(1, u'as'),
            Leaf(1, u'BytesIO')
        ])
    ])

transform: results: {
    'module_name': Leaf(1, u'StringIO'),
    'node': Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'StringIO'),
        Leaf(1, u'import'),
        Node(import_as_name, [
            Leaf(1,u'StringIO'),
            Leaf(1, u'as'),
            Leaf(1, u'BytesIO')
        ])
    ])
}

transform: node:
    Node(import_name, [
        Leaf(1, u'import'),
        Leaf(1, u'__builtin__')
    ])

transform: results: {
    'module_name': Leaf(1, u'__builtin__'),
    'name_import': Node(import_name, [Leaf(1, u'import'), Leaf(1, u'__builtin__')]),
    'node': Node(import_name, [
        Leaf(1, u'import'),
        Leaf(1, u'__builtin__')
    ])
}

transform: node:
    Node(power, [
        Leaf(1, u'__builtin__'),
        Node(trailer, [
            Leaf(23, u'.'), Leaf(1, u'__import__')
        ]),
        Node(trailer, [
            Leaf(7, u'('), Node(arglist, [
                Leaf(1, u'name'),
                Leaf(12, u','),
                Leaf(1, u'globals'),
                Leaf(12, u','),
                Leaf(1, u'locals'), Leaf(12, u','),
                Leaf(1, u'fromlist')
            ]),
            Leaf(8, u')')
        ])
    ])

transform: results: {
    'bare_with_attr': [Leaf(1, u'__builtin__')],
    'node': Node(power, [
        Leaf(1, u'__builtin__'),
        Node(trailer, [
            Leaf(23, u'.'),
            Leaf(1, u'__import__')
        ]),
        Node(trailer, [
            Leaf(7, u'('),
            Node(arglist, [
                Leaf(1, u'name'),
                Leaf(12, u','),
                Leaf(1, u'globals'),
                Leaf(12, u','),
                Leaf(1, u'locals'),
                Leaf(12, u','),
                Leaf(1, u'fromlist')
            ]), 
            Leaf(8, u')')
        ])
    ])
}

RefactoringTool: Refactored docutils\_compat.py
--- docutils\_compat.py (original)
+++ docutils\_compat.py (refactored)
@@ -20,7 +20,7 @@
 if sys.version_info &lt; (3,0):
     b = bytes = str
     u_prefix = 'u'
-    from StringIO import StringIO as BytesIO
+    from io import StringIO as BytesIO
 else:
     import builtins
     bytes = builtins.bytes
@@ -37,7 +37,7 @@
     BytesIO = __import__('io').BytesIO

 if sys.version_info &lt; (2,5):
-    import __builtin__
+    import builtins

     def __import__(name, globals={}, locals={}, fromlist=[], level=-1):
         """Compatibility definition for Python 2.4.
@@ -45,4 +45,4 @@
         Silently ignore the `level` argument missing in Python &lt; 2.5.
         """
         # we need the level arg because the default changed in Python 3.3
-        return __builtin__.__import__(name, globals, locals, fromlist)
+        return builtins.__import__(name, globals, locals, fromlist)

transform: node:
    Node(import_name, [
        Leaf(1, u'import'),
        Node(dotted_as_name, [
            Leaf(1, u'ConfigParser'),
            Leaf(1, u'as'),
            Leaf(1, u'CP')
        ])
    )]

transform: results: {
    'module_name': Leaf(1, u'ConfigParser'),
    'node': Node(import_name, [
        Leaf(1, u'import'),
        Node(dotted_as_name, [
            Leaf(1, u'ConfigParser'),
            Leaf(1, u'as'),
            Leaf(1, u'CP')
        ])
    ])
}

RefactoringTool: Refactored docutils\frontend.py
--- docutils\frontend.py        (original)
+++ docutils\frontend.py        (refactored)
@@ -35,7 +35,7 @@
 import warnings
 ### 2to3.
 if sys.version_info &lt; (3,0):
-    import ConfigParser as CP
+    import configparser as CP
 else:
     import configparser as CP
 import codecs

transform: node:
    Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'StringIO'),
        Leaf(1, u'import'),
        Leaf(1, u'StringIO')
    ])

transform: results: {
    'module_name': Leaf(1, u'StringIO'),
    'node': Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'StringIO'),
        Leaf(1, u'import'),
        Leaf(1, u'StringIO')
    ])
}

RefactoringTool: Refactored docutils\writers\docutils_xml.py
--- docutils\writers\docutils_xml.py    (original)
+++ docutils\writers\docutils_xml.py    (refactored)
@@ -25,7 +25,7 @@
     xml.__path__.reverse() # If both are available, prefer stdlib over PyXML

 import xml.sax.saxutils
-from StringIO import StringIO
+from io import StringIO

 import docutils
 from docutils import frontend, writers, nodes

transform: node:
    Node(import_name, [
        Leaf(1, u'import'),
        Leaf(1, u'StringIO')
    ])

transform: results: {
    'module_name': Leaf(1, u'StringIO'),
    'name_import': Node(import_name, [
        Leaf(1, u'import'),
        Leaf(1, u'StringIO')
    ]),
    'node': Node(import_name, [
        Leaf(1, u'import'),
        Leaf(1, u'StringIO')
    ])
}

transform: node:
    Node(power, [
        Leaf(1, u'StringIO'),
        Node(trailer, [
            Leaf(23, u'.'),
            Leaf(1, u'StringIO')
        ]), 
        Node(trailer, [
            Leaf(7, u'('),
            Leaf(8, u')')
        ])
    ])

transform: results: {
    'bare_with_attr': [Leaf(1, u'StringIO')],
    'node': Node(power, [
        Leaf(1, u'StringIO'),
        Node(trailer, [
            Leaf(23, u'.'),
            Leaf(1, u'StringIO')
        ]),
        Node(trailer, [
            Leaf(7, u'('),
            Leaf(8, u')')
        ])
    ])
}

transform: node:
    Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'ConfigParser'),
        Leaf(1, u'import'),
        Leaf(1, u'ConfigParser')
    ])

transform: results: {
    'module_name': Leaf(1, u'ConfigParser'),
    'node': Node(import_from, [
        Leaf(1, u'from'),
        Leaf(1, u'ConfigParser'),
        Leaf(1, u'import'),
        Leaf(1, u'ConfigParser')
    ])
}

RefactoringTool: Refactored docutils\writers\odf_odt\__init__.py
--- docutils\writers\odf_odt\__init__.py        (original)
+++ docutils\writers\odf_odt\__init__.py        (refactored)
@@ -22,7 +22,7 @@
 from xml.dom import minidom
 import time
 import re
-import StringIO
+import io
 import copy
 import urllib2
 import docutils
@@ -306,7 +306,7 @@
     return tag

 def ToString(et):
-    outstream = StringIO.StringIO()
+    outstream = io.StringIO()
     if sys.version_info &gt;= (3, 2):
         et.write(outstream, encoding="unicode")
     else:
@@ -795,7 +795,7 @@
         self.language = languages.get_language(lcode, document.reporter)
         self.format_map = { }
         if self.settings.odf_config_file:
-            from ConfigParser import ConfigParser
+            from configparser import ConfigParser

             parser = ConfigParser()
             parser.read(self.settings.odf_config_file)
</t>
<t tx="ekr.20130807203905.16745"></t>
<t tx="ekr.20130807203905.16746"># -*- coding: utf8 -*-

# Define the constants for the define_xxx functions in the new punctuations_chars.py.
import unicodedata
s =  ur"\.\,\;\!\?"
assert not g.isPython3
d = {}
for uc in s:
    assert isinstance(uc,(str,unicode)),type(uc)
    comment = unicodedata.name(uc,'Unknown') if isinstance(uc,unicode) else 'ascii'
    d[ord(uc)] = comment
for i in sorted(d.keys()):
    g.es('%5s, # %s' % (i,d.get(i)))
</t>
<t tx="ekr.20130807203905.16747"># The following files fail on Python 3 because of Python 2.x syntax for unicode characters:
# (now passes) utils/punctuation_chars.py, 
# utils/math/latex2mathml.py,
# writers/manpage.py,
# writers/latex2e/__init__.py

g.cls()
import os
path = g.os_path_finalize_join(g.app.loadDir,'..','extensions','docutils')
if g.isPython3:
    exclude = ('punctuation2.py',)
else:
    exclude = ('punctuation3.py',)
for root, dirs, files in os.walk(path):
    for fn in files:
        if fn.endswith('.py'):
            fn = g.os_path_join(root,fn)
            if not g.shortFileName(fn) in exclude:
                s,e = g.readFileIntoString(fn)
                c.testManager.checkFileSyntax(fn,s,reraise=False,suppress=False)
print('all files in leo/extensions/docutils pass')
</t>
<t tx="ekr.20130807203905.16748"># From Python/tools/scripts/crlf.py
"Replace CRLF with LF in docutils files."

g.cls()
write = True
import os
def fix(filename):
    if os.path.isdir(filename):
        # print filename, "Directory!"
        return
    data = open(filename,"rb").read()
    if '\0' in data:
        print('binary: %s' % filename)
        return
    newdata = data.replace("\r\n","\n")
    if newdata != data:
        print('changed: %s' % g.shortFileName(filename,2))
        if write:
            f = open(filename,"wb")
            f.write(newdata)
            f.close()

path = g.os_path_finalize_join(g.app.loadDir,'..','extensions','docutils')
for root, dirs, files in os.walk(path):
    for fn in files:
        if fn.endswith('.py'):
            fn = g.os_path_join(root,fn)
            fix(fn)
print('done')
</t>
<t tx="ekr.20130807203905.16749"># -*- coding: utf8 -*-
import sys
import unicodedata

@others

openers_original = ur"""\"\'\(\&lt;\[\{༺༼᚛⁅⁽₍〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨〈《「『【〔〖〘〚〝〝﴾︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢«‘“‹⸂⸄⸉⸌⸜⸠‚„»’”›⸃⸅⸊⸍⸝⸡‛‟"""
openers_ords = [ord(ch) for ch in openers_original if unicodedata.name(ch,'Unknown') != 'Unknown']
openers = ''.join([unichr(n) for n in openers_ords])
assert openers_original == openers

closers_original = ur"""\"\'\)\&gt;\]\}༻༽᚜⁆⁾₎〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩〉》」』】〕〗〙〛〞〟﴿︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣»’”›⸃⸅⸊⸍⸝⸡‛‟«‘“‹⸂⸄⸉⸌⸜⸠‚„"""
closers_ords = [ord(ch) for ch in closers_original if unicodedata.name(ch,'Unknown') != 'Unknown']
closers = ''.join([unichr(n) for n in closers_ords])
assert closers_original == closers

delimiters_original = u"\\-\\/\\:֊־᐀᠆‐‑‒–—―⸗⸚〜〰゠︱︲﹘﹣－¡·¿;·՚՛՜՝՞՟։׀׃׆׳״؉؊،؍؛؞؟٪٫٬٭۔܀܁܂܃܄܅܆܇܈܉܊܋܌܍߷߸߹࠰࠱࠲࠳࠴࠵࠶࠷࠸࠹࠺࠻࠼࠽࠾।॥॰෴๏๚๛༄༅༆༇༈༉༊་༌།༎༏༐༑༒྅࿐࿑࿒࿓࿔၊။၌၍၎၏჻፡።፣፤፥፦፧፨᙭᙮᛫᛬᛭᜵᜶។៕៖៘៙៚᠀᠁᠂᠃᠄᠅᠇᠈᠉᠊᥄᥅᧞᧟᨞᨟᪠᪡᪢᪣᪤᪥᪦᪨᪩᪪᪫᪬᪭᭚᭛᭜᭝᭞᭟᭠᰻᰼᰽᰾᰿᱾᱿᳓‖‗†‡•‣․‥…‧‰‱′″‴‵‶‷‸※‼‽‾⁁⁂⁃⁇⁈⁉⁊⁋⁌⁍⁎⁏⁐⁑⁓⁕⁖⁗⁘⁙⁚⁛⁜⁝⁞⳹⳺⳻⳼⳾⳿⸀⸁⸆⸇⸈⸋⸎⸏⸐⸑⸒⸓⸔⸕⸖⸘⸙⸛⸞⸟⸪⸫⸬⸭⸮⸰⸱、。〃〽・꓾꓿꘍꘎꘏꙳꙾꛲꛳꛴꛵꛶꛷꡴꡵꡶꡷꣎꣏꣸꣹꣺꤮꤯꥟꧁꧂꧃꧄꧅꧆꧇꧈꧉꧊꧋꧌꧍꧞꧟꩜꩝꩞꩟꫞꫟꯫︐︑︒︓︔︕︖︙︰﹅﹆﹉﹊﹋﹌﹐﹑﹒﹔﹕﹖﹗﹟﹠﹡﹨﹪﹫！＂＃％＆＇＊，．／：；？＠＼｡､･"
delimiter_ords = [ord(ch) for ch in delimiters_original if unicodedata.name(ch,'Unknown') != 'Unknown']
delimiters = ''.join([unichr(n) for n in delimiter_ords])

quote_pairs_original = {
    u'\xbb':   u'\xbb',         # Swedish
    u'\u2018': u'\u201a',       # Greek
    u'\u2019': u'\u2019',       # Swedish
    u'\u201a': u'\u2018\u2019', # German, Polish
    u'\u201c': u'\u201e',       # German
    u'\u201e': u'\u201c\u201d',
    u'\u201d': u'\u201d',       # Swedish
    u'\u203a': u'\u203a',       # Swedish
}

# Compute the quote pairs array.
d = quote_pairs_original
d2 = {}
for ch in d.keys():
    val = d.get(ch)
    n = ord(ch)
    d2[n] = [ord(z) for z in val]
for n in sorted(d2.keys()):
    g.es('0x%x: [%s],' % (n,','.join(['0x%x' % (z) for z in d2.get(n)])))


# No need to compute 

assert compare(openers_original,openers)
assert compare(closers_original,closers)
assert compare(delimiters_original,delimiters)

if 0: # Create the ords array.
    for n in closers_ords:
        ch = unichr(n)
        g.es('%s, # %s' % (n,unicodedata.name(ch,'Unknown')))
    
print('done')
</t>
<t tx="ekr.20130807203905.16750">def unknown(ch):
    return unicodedata.name(ch,'Unknown') == 'Unknown'

def compare(s1,s2):
    i1,i2,n1,n2 = 0,0,len(s1),len(s2)
    while True:
        while i1 &lt; n1 and unknown(s1[i1]):
            i1 += 1
        # while i2 &lt; n2 and unknown(s2[i2]):
            # i2 += 1
        if i1 &lt; n1 and i2 &lt; n2 and s1[i1] == s2[i2]:
            i1 += 1 ; i2 += 1
        else:
            return i1 == n1 and i2 == n2
</t>
<t tx="ekr.20130807203905.16751">quote_pairs_original = {
    u'\xbb':   u'\xbb', # Swedish
    u'\u2018': u'\u201a', # Greek
    u'\u2019': u'\u2019', # Swedish
    u'\u201a': u'\u2018\u2019', # German, Polish
    u'\u201c': u'\u201e', # German
    u'\u201e': u'\u201c\u201d',
    u'\u201d': u'\u201d', # Swedish
    u'\u203a': u'\u203a', # Swedish
}
          
quote_pairs_ord_d = {
    0xbb:   [0xbb],
    0x2018: [0x201a],
    0x2019: [0x2019],
    0x201a: [0x2018,0x2019],
    0x201c: [0x201e],
    0x201d: [0x201d],
    0x201e: [0x201c,0x201d],
    0x203a: [0x203a],
}

quote_pairs = {}
d = quote_pairs_ord_d
for n in d.keys():
    ch = unichr(n)
    quote_pairs [ch] = ''.join([unichr(n2) for n2 in d.get(n)])
d = quote_pairs
for ch in sorted(d.keys()):
    g.es('0x%x: %s' % (ord(ch),['0x%s' % (ord(z)) for z in d.get(ch)]))
    
assert quote_pairs == quote_pairs_original
g.es('pass!')
</t>
<t tx="ekr.20130807203905.16752"></t>
<t tx="ekr.20130807203905.16753"># -*- coding: utf8 -*-

from __future__ import print_function

g.cls()

import re
import sys
import unicodedata

openers = ur"""\"\'\(\&lt;\[\{༺༼᚛⁅⁽₍〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨〈《「『【〔〖〘〚〝〝﴾︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢«‘“‹⸂⸄⸉⸌⸜⸠‚„»’”›⸃⸅⸊⸍⸝⸡‛‟"""
closers = ur"""\"\'\)\&gt;\]\}༻༽᚜⁆⁾₎〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩〉》」』】〕〗〙〛〞〟﴿︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣»’”›⸃⸅⸊⸍⸝⸡‛‟«‘“‹⸂⸄⸉⸌⸜⸠‚„"""
delimiters = ur"\-\/\:֊־᐀᠆‐‑‒–—―⸗⸚〜〰゠︱︲﹘﹣－¡·¿;·՚՛՜՝՞՟։׀׃׆׳״؉؊،؍؛؞؟٪٫٬٭۔܀܁܂܃܄܅܆܇܈܉܊܋܌܍߷߸߹࠰࠱࠲࠳࠴࠵࠶࠷࠸࠹࠺࠻࠼࠽࠾।॥॰෴๏๚๛༄༅༆༇༈༉༊་༌།༎༏༐༑༒྅࿐࿑࿒࿓࿔၊။၌၍၎၏჻፡።፣፤፥፦፧፨᙭᙮᛫᛬᛭᜵᜶។៕៖៘៙៚᠀᠁᠂᠃᠄᠅᠇᠈᠉᠊᥄᥅᧞᧟᨞᨟᪠᪡᪢᪣᪤᪥᪦᪨᪩᪪᪫᪬᪭᭚᭛᭜᭝᭞᭟᭠᰻᰼᰽᰾᰿᱾᱿᳓‖‗†‡•‣․‥…‧‰‱′″‴‵‶‷‸※‼‽‾⁁⁂⁃⁇⁈⁉⁊⁋⁌⁍⁎⁏⁐⁑⁓⁕⁖⁗⁘⁙⁚⁛⁜⁝⁞⳹⳺⳻⳼⳾⳿⸀⸁⸆⸇⸈⸋⸎⸏⸐⸑⸒⸓⸔⸕⸖⸘⸙⸛⸞⸟⸪⸫⸬⸭⸮⸰⸱、。〃〽・꓾꓿꘍꘎꘏꙳꙾꛲꛳꛴꛵꛶꛷꡴꡵꡶꡷꣎꣏꣸꣹꣺꤮꤯꥟꧁꧂꧃꧄꧅꧆꧇꧈꧉꧊꧋꧌꧍꧞꧟꩜꩝꩞꩟꫞꫟꯫︐︑︒︓︔︕︖︙︰﹅﹆﹉﹊﹋﹌﹐﹑﹒﹔﹕﹖﹗﹟﹠﹡﹨﹪﹫！＂＃％＆＇＊，．／：；？＠＼｡､･𐄀𐄁𐎟𐏐𐡗𐤟𐤿𐩐𐩑𐩒𐩓𐩔𐩕𐩖𐩗𐩘𐩿𐬹𐬺𐬻𐬼𐬽𐬾𐬿𑂻𑂼𑂾𑂿𑃀𑃁𒑰𒑱𒑲𒑳"
closing_delimiters = ur"\.\,\;\!\?"

unicode_punctuation_categories = {
    # 'Pc': 'Connector', # not used in Docutils inline markup recognition
    'Pd': 'Dash',
    'Ps': 'Open',
    'Pe': 'Close',
    'Pi': 'Initial quote', # may behave like Ps or Pe depending on usage
    'Pf': 'Final quote', # may behave like Ps or Pe depending on usage
    'Po': 'Other'
    }
"""Unicode character categories for punctuation"""

@others

test()
</t>
<t tx="ekr.20130807203905.16754">def punctuation_samples():

    """Docutils punctuation category sample strings.

    Return list of sample strings for the categories "Open", "Close",
    "Delimiters" and "Closing-Delimiters" used in the `inline markup
    recognition rules`_.
    """

    # Lists with characters in Unicode punctuation character categories
    cp_min = 160 # ASCII chars have special rules for backwards compatibility
    ucharlists = unicode_charlists(unicode_punctuation_categories, cp_min)

    # match opening/closing characters
    # --------------------------------
    # Rearange the lists to ensure matching characters at the same
    # index position.

    # low quotation marks are also used as closers (e.g. in Greek)
    # move them to category Pi:
    ucharlists['Ps'].remove(u'‚') # 201A  SINGLE LOW-9 QUOTATION MARK
    ucharlists['Ps'].remove(u'„') # 201E  DOUBLE LOW-9 QUOTATION MARK
    ucharlists['Pi'] += [u'‚', u'„']

    ucharlists['Pi'].remove(u'‛') # 201B  SINGLE HIGH-REVERSED-9 QUOTATION MARK
    ucharlists['Pi'].remove(u'‟') # 201F  DOUBLE HIGH-REVERSED-9 QUOTATION MARK
    ucharlists['Pf'] += [u'‛', u'‟']

    # 301F  LOW DOUBLE PRIME QUOTATION MARK misses the opening pendant:
    ucharlists['Ps'].insert(ucharlists['Pe'].index(u'\u301f'), u'\u301d')

    # print u''.join(ucharlists['Ps']).encode('utf8')
    # print u''.join(ucharlists['Pe']).encode('utf8')
    # print u''.join(ucharlists['Pi']).encode('utf8')
    # print u''.join(ucharlists['Pf']).encode('utf8')

    # The Docutils character categories
    # ---------------------------------
    #
    # The categorization of ASCII chars is non-standard to reduce both
    # false positives and need for escaping. (see `inline markup recognition
    # rules`_)

    # matching, allowed before markup
    openers = [re.escape('"\'(&lt;[{')]
    for cat in ('Ps', 'Pi', 'Pf'):
        openers.extend(ucharlists[cat])

    # matching, allowed after markup
    closers = [re.escape('"\')&gt;]}')]
    for cat in ('Pe', 'Pf', 'Pi'):
        closers.extend(ucharlists[cat])

    # non-matching, allowed on both sides
    delimiters = [re.escape('-/:')]
    for cat in ('Pd', 'Po'):
        delimiters.extend(ucharlists[cat])

    # non-matching, after markup
    closing_delimiters = [re.escape('.,;!?')]

    # # Test open/close matching:
    # for i in range(min(len(openers),len(closers))):
    #     print '%4d    %s    %s' % (i, openers[i].encode('utf8'),
    #                                closers[i].encode('utf8'))
    # dump(delimiters)
    
    return [u''.join(chars)
            for chars in (openers, closers, delimiters, closing_delimiters)]
</t>
<t tx="ekr.20130807203905.16755">def unicode_charlists(categories, cp_min=0, cp_max=None):
    """Return dictionary of Unicode character lists.

    For each of the `catagories`, an item contains a list with all Unicode
    characters with `cp_min` &lt;= code-point &lt;= `cp_max` that belong to the
    category. (The default values check every code-point supported by Python.)
    """
    # Determine highest code point with one of the given categories
    # (may shorten the search time considerably if there are many
    # categories with not too high characters):
    if cp_max is None:
        cp_max = max(x for x in xrange(sys.maxunicode + 1)
                     if unicodedata.category(unichr(x)) in categories)
        # print cp_max # =&gt; 74867 for unicode_punctuation_categories
    charlists = {}
    for cat in categories:
        charlists[cat] = [unichr(x) for x in xrange(cp_min, cp_max+1)
                          if unicodedata.category(unichr(x)) == cat]
    return charlists
</t>
<t tx="ekr.20130807203905.16756">def compare(s1,s2):
    
    print(len(s1),len(s2))
    d1,d2 = {},{}
    for uc in s1:
        assert isinstance(uc,(str,unicode)),type(uc)
        n = ord(uc)
        d1[n] = uc
    for uc in s2:
        assert isinstance(uc,(str,unicode)),type(uc)
        n = ord(uc)
        d2[n] = uc
    nset = set()
    for n in d1.keys():
        nset.add(n)
    for n in d2.keys():
        nset.add(n)
    matches = 0
    for n in sorted(nset):
        uc1 = d1.get(n)
        uc2 = d2.get(n)
        if uc1 is None and uc2 is None:
            print('%5s hu??' % (n))
        elif uc1 is None:
            print('%5s' % (n),'missing1',uc2,unicodedata.name(uc2,'Unknown'))
        elif uc2 is None:
            pass # print('%5s' % (n),'missing2',uc1,unicodedata.name(uc1,'Unknown'))
        elif uc1 == uc2:
            # print('%5s' % (n),'match',uc1,unicodedata.name(uc1,'Unknown'))
            # print('%s, # %s' % (n,unicodedata.name(uc1,'Unknown').lower()))
            matches += 1
        else:
            print('%5s' % (n),uc1,unicodedata.name(uc1,'Unknown'),uc2,unicodedata.name(uc2,'Unknown'))
    print('matches: %s' % matches)
</t>
<t tx="ekr.20130807203905.16757">def dump(s):
    for uc in s:
        assert isinstance(uc,(str,unicode)),type(uc)
        if isinstance(uc,unicode):
            print('%5s' % (ord(uc)),uc,unicodedata.name(uc,'Unknown'))
</t>
<t tx="ekr.20130807203905.16758"># The if __name__ == '__main__' part of puntuation_chars.py

def test():
    
    # (re) create and compare the samples:
    (o, c, d, cd) = punctuation_samples()
    if o != openers:
        print('- openers = ur"""%s"""' % openers.encode('utf8'))
        print('+ openers = ur"""%s"""' % o.encode('utf8'))
    if c != closers:
        print('- closers = ur"""%s"""' % closers.encode('utf8'))
        print('+ closers = ur"""%s"""' % c.encode('utf8'))
    if d != delimiters:
        print('- delimiters = ur"%s"' % delimiters.encode('utf8'))
        # dump(delimiters)
        print('+ delimiters = ur"%s"' % d.encode('utf8'))
        # dump(d)
        compare(delimiters,d)
    if cd != closing_delimiters:
        print('- closing_delimiters = ur"%s"' % closing_delimiters.encode('utf8'))
        print('+ closing_delimiters = ur"%s"' % cd.encode('utf8'))
</t>
<t tx="ekr.20130807203905.16759">import sys, re
import unicodedata

# Unicode punctuation character categories
# ----------------------------------------

unicode_punctuation_categories = {
    # 'Pc': 'Connector', # not used in Docutils inline markup recognition
    'Pd': 'Dash',
    'Ps': 'Open',
    'Pe': 'Close',
    'Pi': 'Initial quote', # may behave like Ps or Pe depending on usage
    'Pf': 'Final quote', # may behave like Ps or Pe depending on usage
    'Po': 'Other'
    }
"""Unicode character categories for punctuation"""


# generate character pattern strings
# ==================================

def unicode_charlists(categories, cp_min=0, cp_max=None):
    """Return dictionary of Unicode character lists.

    For each of the `catagories`, an item contains a list with all Unicode
    characters with `cp_min` &lt;= code-point &lt;= `cp_max` that belong to the
    category. (The default values check every code-point supported by Python.)
    """
    # Determine highest code point with one of the given categories
    # (may shorten the search time considerably if there are many
    # categories with not too high characters):
    if cp_max is None:
        cp_max = max(x for x in xrange(sys.maxunicode + 1)
                     if unicodedata.category(unichr(x)) in categories)
        # print cp_max # =&gt; 74867 for unicode_punctuation_categories
    charlists = {}
    for cat in categories:
        charlists[cat] = [unichr(x) for x in xrange(cp_min, cp_max+1)
                          if unicodedata.category(unichr(x)) == cat]
    return charlists


# Character categories in Docutils
# --------------------------------

def punctuation_samples():

    """Docutils punctuation category sample strings.

    Return list of sample strings for the categories "Open", "Close",
    "Delimiters" and "Closing-Delimiters" used in the `inline markup
    recognition rules`_.
    """

    # Lists with characters in Unicode punctuation character categories
    cp_min = 160 # ASCII chars have special rules for backwards compatibility
    ucharlists = unicode_charlists(unicode_punctuation_categories, cp_min)

    # match opening/closing characters
    # --------------------------------
    # Rearange the lists to ensure matching characters at the same
    # index position.

    # low quotation marks are also used as closers (e.g. in Greek)
    # move them to category Pi:
    ucharlists['Ps'].remove(u'‚') # 201A  SINGLE LOW-9 QUOTATION MARK
    ucharlists['Ps'].remove(u'„') # 201E  DOUBLE LOW-9 QUOTATION MARK
    ucharlists['Pi'] += [u'‚', u'„']

    ucharlists['Pi'].remove(u'‛') # 201B  SINGLE HIGH-REVERSED-9 QUOTATION MARK
    ucharlists['Pi'].remove(u'‟') # 201F  DOUBLE HIGH-REVERSED-9 QUOTATION MARK
    ucharlists['Pf'] += [u'‛', u'‟']

    # 301F  LOW DOUBLE PRIME QUOTATION MARK misses the opening pendant:
    ucharlists['Ps'].insert(ucharlists['Pe'].index(u'\u301f'), u'\u301d')

    # print u''.join(ucharlists['Ps']).encode('utf8')
    # print u''.join(ucharlists['Pe']).encode('utf8')
    # print u''.join(ucharlists['Pi']).encode('utf8')
    # print u''.join(ucharlists['Pf']).encode('utf8')

    # The Docutils character categories
    # ---------------------------------
    #
    # The categorization of ASCII chars is non-standard to reduce both
    # false positives and need for escaping. (see `inline markup recognition
    # rules`_)

    # matching, allowed before markup
    openers = [re.escape('"\'(&lt;[{')]
    for cat in ('Ps', 'Pi', 'Pf'):
        openers.extend(ucharlists[cat])

    # matching, allowed after markup
    closers = [re.escape('"\')&gt;]}')]
    for cat in ('Pe', 'Pf', 'Pi'):
        closers.extend(ucharlists[cat])

    # non-matching, allowed on both sides
    delimiters = [re.escape('-/:')]
    for cat in ('Pd', 'Po'):
        delimiters.extend(ucharlists[cat])

    # non-matching, after markup
    closing_delimiters = [re.escape('.,;!?')]

    # # Test open/close matching:
    # for i in range(min(len(openers),len(closers))):
    #     print '%4d    %s    %s' % (i, openers[i].encode('utf8'),
    #                                closers[i].encode('utf8'))

    return [u''.join(chars)
            for chars in (openers, closers, delimiters, closing_delimiters)]


# Matching open/close quotes
# --------------------------

# Rule (5) requires determination of matching open/close pairs. However,
# the pairing of open/close quotes is ambigue due to  different typographic
# conventions in different languages.

quote_pairs = {u'\xbb': u'\xbb', # Swedish
               u'\u2018': u'\u201a', # Greek
               u'\u2019': u'\u2019', # Swedish
               u'\u201a': u'\u2018\u2019', # German, Polish
               u'\u201c': u'\u201e', # German
               u'\u201e': u'\u201c\u201d',
               u'\u201d': u'\u201d', # Swedish
               u'\u203a': u'\u203a', # Swedish
              }

def match_chars(c1, c2):
    try:
        i = openers.index(c1)
    except ValueError:  # c1 not in openers
        return False
    return c2 == closers[i] or c2 in quote_pairs.get(c1, '')




# print results
# =============

if __name__ == '__main__':

    # (re) create and compare the samples:
    (o, c, d, cd) = punctuation_samples()
    if o != openers:
        print '- openers = ur"""%s"""' % openers.encode('utf8')
        print '+ openers = ur"""%s"""' % o.encode('utf8')
    if c != closers:
        print '- closers = ur"""%s"""' % closers.encode('utf8')
        print '+ closers = ur"""%s"""' % c.encode('utf8')
    if d != delimiters:
        print '- delimiters = ur"%s"' % delimiters.encode('utf8')
        print '+ delimiters = ur"%s"' % d.encode('utf8')
    if cd != closing_delimiters:
        print '- closing_delimiters = ur"%s"' % closing_delimiters.encode('utf8')
        print '+ closing_delimiters = ur"%s"' % cd.encode('utf8')

    # # test prints
    # print 'openers = ', repr(openers)
    # print 'closers = ', repr(closers)
    # print 'delimiters = ', repr(delimiters)
    # print 'closing_delimiters = ', repr(closing_delimiters)

    # ucharlists = unicode_charlists(unicode_punctuation_categories)
    # for cat, chars in ucharlists.items():
    #     # print cat, chars
    #     # compact output (visible with a comprehensive font):
    #     print (u":%s: %s" % (cat, u''.join(chars))).encode('utf8')
</t>
<t tx="ekr.20130807203905.16760">docutils = g.importExtension('docutils',pluginName='leoRst.py',verbose=True)
print(docutils)
from docutils import parsers
print(parsers)
from docutils.parsers import rst
print(rst)
import docutils.parsers.rst
print(docutils.parsers.rst)
from docutils.parsers.rst import directives
</t>
<t tx="ekr.20130807203905.16761"># -*- coding: utf8 -*-
g.cls()
import leo.extensions.six as six
# import imp
# imp.reload(six)
# u = six.u
&lt;&lt; tex2unichar dicts &gt;&gt;
result = []
i = 0
for d in (
    mathaccent,
    mathalpha,
    mathbin,
    mathclose,
    mathfence,
    mathop,
    mathopen,
    mathord,
    mathover,
    mathradical,
    mathrel,
    mathunder,
    space,
):
    for key in d:
        ch = d.get(key)
        result.append(ch)
        six.u(ch)
    i += 1
g.es('\n'.join(result))
print('done')
</t>
<t tx="ekr.20130807203905.16762"># -*- coding: utf8 -*-

# LaTeX math to Unicode symbols translation dictionaries.
# Generated with ``write_tex2unichar.py`` from the data in
# http://milde.users.sourceforge.net/LUCR/Math/

# Includes commands from: wasysym, stmaryrd, mathdots, mathabx, esint, bbold, amsxtra, amsmath, amssymb, standard LaTeX

mathaccent = {
    'acute': u('\u0301'), # xÌ COMBINING ACUTE ACCENT
    'bar': u('\u0304'), # xÌ„ COMBINING MACRON
    'breve': u('\u0306'), # xÌ† COMBINING BREVE
    'check': u('\u030c'), # xÌŒ COMBINING CARON
    'ddddot': u('\u20dc'), # xâƒœ COMBINING FOUR DOTS ABOVE
    'dddot': u('\u20db'), # xâƒ› COMBINING THREE DOTS ABOVE
    'ddot': u('\u0308'), # xÌˆ COMBINING DIAERESIS
    'dot': u('\u0307'), # xÌ‡ COMBINING DOT ABOVE
    'grave': u('\u0300'), # xÌ€ COMBINING GRAVE ACCENT
    'hat': u('\u0302'), # xÌ‚ COMBINING CIRCUMFLEX ACCENT
    'mathring': u('\u030a'), # xÌŠ COMBINING RING ABOVE
    'not': u('\u0338'), # xÌ¸ COMBINING LONG SOLIDUS OVERLAY
    'overleftarrow': u('\u20d6'), # xâƒ– COMBINING LEFT ARROW ABOVE
    'overleftrightarrow': u('\u20e1'), # xâƒ¡ COMBINING LEFT RIGHT ARROW ABOVE
    'overline': u('\u0305'), # xÌ… COMBINING OVERLINE
    'overrightarrow': u('\u20d7'), # xâƒ— COMBINING RIGHT ARROW ABOVE
    'tilde': u('\u0303'), # xÌƒ COMBINING TILDE
    'underbar': u('\u0331'), # xÌ± COMBINING MACRON BELOW
    'underleftarrow': u('\u20ee'), # xâƒ® COMBINING LEFT ARROW BELOW
    'underline': u('\u0332'), # xÌ² COMBINING LOW LINE
    'underrightarrow': u('\u20ef'), # xâƒ¯ COMBINING RIGHT ARROW BELOW
    'vec': u('\u20d7'), # xâƒ— COMBINING RIGHT ARROW ABOVE
    'widehat': u('\u0302'), # xÌ‚ COMBINING CIRCUMFLEX ACCENT
    'widetilde': u('\u0303'), # xÌƒ COMBINING TILDE
    }
mathalpha = {
    'Bbbk': u('\U0001d55c'), # ð•œ MATHEMATICAL DOUBLE-STRUCK SMALL K
    'Delta': u('\u0394'), # Î” GREEK CAPITAL LETTER DELTA
    'Gamma': u('\u0393'), # Î“ GREEK CAPITAL LETTER GAMMA
    'Im': u('\u2111'), # â„‘ BLACK-LETTER CAPITAL I
    'Lambda': u('\u039b'), # Î› GREEK CAPITAL LETTER LAMDA
    'Omega': u('\u03a9'), # Î© GREEK CAPITAL LETTER OMEGA
    'Phi': u('\u03a6'), # Î¦ GREEK CAPITAL LETTER PHI
    'Pi': u('\u03a0'), # Î  GREEK CAPITAL LETTER PI
    'Psi': u('\u03a8'), # Î¨ GREEK CAPITAL LETTER PSI
    'Re': u('\u211c'), # â„œ BLACK-LETTER CAPITAL R
    'Sigma': u('\u03a3'), # Î£ GREEK CAPITAL LETTER SIGMA
    'Theta': u('\u0398'), # Î˜ GREEK CAPITAL LETTER THETA
    'Upsilon': u('\u03a5'), # Î¥ GREEK CAPITAL LETTER UPSILON
    'Xi': u('\u039e'), # Îž GREEK CAPITAL LETTER XI
    'aleph': u('\u2135'), # â„µ ALEF SYMBOL
    'alpha': u('\u03b1'), # Î± GREEK SMALL LETTER ALPHA
    'beta': u('\u03b2'), # Î² GREEK SMALL LETTER BETA
    'beth': u('\u2136'), # â„¶ BET SYMBOL
    'chi': u('\u03c7'), # Ï‡ GREEK SMALL LETTER CHI
    'daleth': u('\u2138'), # â„¸ DALET SYMBOL
    'delta': u('\u03b4'), # Î´ GREEK SMALL LETTER DELTA
    'digamma': u('\u03dc'), # Ïœ GREEK LETTER DIGAMMA
    'ell': u('\u2113'), # â„“ SCRIPT SMALL L
    'epsilon': u('\u03f5'), # Ïµ GREEK LUNATE EPSILON SYMBOL
    'eta': u('\u03b7'), # Î· GREEK SMALL LETTER ETA
    'eth': u('\xf0'), # Ã° LATIN SMALL LETTER ETH
    'gamma': u('\u03b3'), # Î³ GREEK SMALL LETTER GAMMA
    'gimel': u('\u2137'), # â„· GIMEL SYMBOL
    'hbar': u('\u210f'), # â„ PLANCK CONSTANT OVER TWO PI
    'hslash': u('\u210f'), # â„ PLANCK CONSTANT OVER TWO PI
    'imath': u('\u0131'), # Ä± LATIN SMALL LETTER DOTLESS I
    'iota': u('\u03b9'), # Î¹ GREEK SMALL LETTER IOTA
    'jmath': u('\u0237'), # È· LATIN SMALL LETTER DOTLESS J
    'kappa': u('\u03ba'), # Îº GREEK SMALL LETTER KAPPA
    'lambda': u('\u03bb'), # Î» GREEK SMALL LETTER LAMDA
    'mu': u('\u03bc'), # Î¼ GREEK SMALL LETTER MU
    'nu': u('\u03bd'), # Î½ GREEK SMALL LETTER NU
    'omega': u('\u03c9'), # Ï‰ GREEK SMALL LETTER OMEGA
    'phi': u('\u03d5'), # Ï• GREEK PHI SYMBOL
    'pi': u('\u03c0'), # Ï€ GREEK SMALL LETTER PI
    'psi': u('\u03c8'), # Ïˆ GREEK SMALL LETTER PSI
    'rho': u('\u03c1'), # Ï GREEK SMALL LETTER RHO
    'sigma': u('\u03c3'), # Ïƒ GREEK SMALL LETTER SIGMA
    'tau': u('\u03c4'), # Ï„ GREEK SMALL LETTER TAU
    'theta': u('\u03b8'), # Î¸ GREEK SMALL LETTER THETA
    'upsilon': u('\u03c5'), # Ï… GREEK SMALL LETTER UPSILON
    'varDelta': u('\U0001d6e5'), # ð›¥ MATHEMATICAL ITALIC CAPITAL DELTA
    'varGamma': u('\U0001d6e4'), # ð›¤ MATHEMATICAL ITALIC CAPITAL GAMMA
    'varLambda': u('\U0001d6ec'), # ð›¬ MATHEMATICAL ITALIC CAPITAL LAMDA
    'varOmega': u('\U0001d6fa'), # ð›º MATHEMATICAL ITALIC CAPITAL OMEGA
    'varPhi': u('\U0001d6f7'), # ð›· MATHEMATICAL ITALIC CAPITAL PHI
    'varPi': u('\U0001d6f1'), # ð›± MATHEMATICAL ITALIC CAPITAL PI
    'varPsi': u('\U0001d6f9'), # ð›¹ MATHEMATICAL ITALIC CAPITAL PSI
    'varSigma': u('\U0001d6f4'), # ð›´ MATHEMATICAL ITALIC CAPITAL SIGMA
    'varTheta': u('\U0001d6e9'), # ð›© MATHEMATICAL ITALIC CAPITAL THETA
    'varUpsilon': u('\U0001d6f6'), # ð›¶ MATHEMATICAL ITALIC CAPITAL UPSILON
    'varXi': u('\U0001d6ef'), # ð›¯ MATHEMATICAL ITALIC CAPITAL XI
    'varepsilon': u('\u03b5'), # Îµ GREEK SMALL LETTER EPSILON
    'varkappa': u('\U0001d718'), # ðœ˜ MATHEMATICAL ITALIC KAPPA SYMBOL
    'varphi': u('\u03c6'), # Ï† GREEK SMALL LETTER PHI
    'varpi': u('\u03d6'), # Ï– GREEK PI SYMBOL
    'varrho': u('\u03f1'), # Ï± GREEK RHO SYMBOL
    'varsigma': u('\u03c2'), # Ï‚ GREEK SMALL LETTER FINAL SIGMA
    'vartheta': u('\u03d1'), # Ï‘ GREEK THETA SYMBOL
    'wp': u('\u2118'), # â„˜ SCRIPT CAPITAL P
    'xi': u('\u03be'), # Î¾ GREEK SMALL LETTER XI
    'zeta': u('\u03b6'), # Î¶ GREEK SMALL LETTER ZETA
    }
mathbin = {
    'Cap': u('\u22d2'), # â‹’ DOUBLE INTERSECTION
    'Circle': u('\u25cb'), # â—‹ WHITE CIRCLE
    'Cup': u('\u22d3'), # â‹“ DOUBLE UNION
    'LHD': u('\u25c0'), # â—€ BLACK LEFT-POINTING TRIANGLE
    'RHD': u('\u25b6'), # â–¶ BLACK RIGHT-POINTING TRIANGLE
    'amalg': u('\u2a3f'), # â¨¿ AMALGAMATION OR COPRODUCT
    'ast': u('\u2217'), # âˆ— ASTERISK OPERATOR
    'barwedge': u('\u22bc'), # âŠ¼ NAND
    'bigtriangledown': u('\u25bd'), # â–½ WHITE DOWN-POINTING TRIANGLE
    'bigtriangleup': u('\u25b3'), # â–³ WHITE UP-POINTING TRIANGLE
    'bindnasrepma': u('\u214b'), # â…‹ TURNED AMPERSAND
    'blacklozenge': u('\u29eb'), # â§« BLACK LOZENGE
    'blacktriangledown': u('\u25be'), # â–¾ BLACK DOWN-POINTING SMALL TRIANGLE
    'blacktriangleleft': u('\u25c2'), # â—‚ BLACK LEFT-POINTING SMALL TRIANGLE
    'blacktriangleright': u('\u25b8'), # â–¸ BLACK RIGHT-POINTING SMALL TRIANGLE
    'blacktriangleup': u('\u25b4'), # â–´ BLACK UP-POINTING SMALL TRIANGLE
    'boxast': u('\u29c6'), # â§† SQUARED ASTERISK
    'boxbar': u('\u25eb'), # â—« WHITE SQUARE WITH VERTICAL BISECTING LINE
    'boxbox': u('\u29c8'), # â§ˆ SQUARED SQUARE
    'boxbslash': u('\u29c5'), # â§… SQUARED FALLING DIAGONAL SLASH
    'boxcircle': u('\u29c7'), # â§‡ SQUARED SMALL CIRCLE
    'boxdot': u('\u22a1'), # âŠ¡ SQUARED DOT OPERATOR
    'boxminus': u('\u229f'), # âŠŸ SQUARED MINUS
    'boxplus': u('\u229e'), # âŠž SQUARED PLUS
    'boxslash': u('\u29c4'), # â§„ SQUARED RISING DIAGONAL SLASH
    'boxtimes': u('\u22a0'), # âŠ  SQUARED TIMES
    'bullet': u('\u2219'), # âˆ™ BULLET OPERATOR
    'cap': u('\u2229'), # âˆ© INTERSECTION
    'cdot': u('\u22c5'), # â‹… DOT OPERATOR
    'circ': u('\u2218'), # âˆ˜ RING OPERATOR
    'circledast': u('\u229b'), # âŠ› CIRCLED ASTERISK OPERATOR
    'circledcirc': u('\u229a'), # âŠš CIRCLED RING OPERATOR
    'circleddash': u('\u229d'), # âŠ CIRCLED DASH
    'cup': u('\u222a'), # âˆª UNION
    'curlyvee': u('\u22ce'), # â‹Ž CURLY LOGICAL OR
    'curlywedge': u('\u22cf'), # â‹ CURLY LOGICAL AND
    'dagger': u('\u2020'), # â€  DAGGER
    'ddagger': u('\u2021'), # â€¡ DOUBLE DAGGER
    'diamond': u('\u22c4'), # â‹„ DIAMOND OPERATOR
    'div': u('\xf7'), # Ã· DIVISION SIGN
    'divideontimes': u('\u22c7'), # â‹‡ DIVISION TIMES
    'dotplus': u('\u2214'), # âˆ” DOT PLUS
    'doublebarwedge': u('\u2a5e'), # â©ž LOGICAL AND WITH DOUBLE OVERBAR
    'intercal': u('\u22ba'), # âŠº INTERCALATE
    'interleave': u('\u2af4'), # â«´ TRIPLE VERTICAL BAR BINARY RELATION
    'land': u('\u2227'), # âˆ§ LOGICAL AND
    'leftthreetimes': u('\u22cb'), # â‹‹ LEFT SEMIDIRECT PRODUCT
    'lhd': u('\u25c1'), # â— WHITE LEFT-POINTING TRIANGLE
    'lor': u('\u2228'), # âˆ¨ LOGICAL OR
    'ltimes': u('\u22c9'), # â‹‰ LEFT NORMAL FACTOR SEMIDIRECT PRODUCT
    'mp': u('\u2213'), # âˆ“ MINUS-OR-PLUS SIGN
    'odot': u('\u2299'), # âŠ™ CIRCLED DOT OPERATOR
    'ominus': u('\u2296'), # âŠ– CIRCLED MINUS
    'oplus': u('\u2295'), # âŠ• CIRCLED PLUS
    'oslash': u('\u2298'), # âŠ˜ CIRCLED DIVISION SLASH
    'otimes': u('\u2297'), # âŠ— CIRCLED TIMES
    'pm': u('\xb1'), # Â± PLUS-MINUS SIGN
    'rhd': u('\u25b7'), # â–· WHITE RIGHT-POINTING TRIANGLE
    'rightthreetimes': u('\u22cc'), # â‹Œ RIGHT SEMIDIRECT PRODUCT
    'rtimes': u('\u22ca'), # â‹Š RIGHT NORMAL FACTOR SEMIDIRECT PRODUCT
    'setminus': u('\u29f5'), # â§µ REVERSE SOLIDUS OPERATOR
    'slash': u('\u2215'), # âˆ• DIVISION SLASH
    'smallsetminus': u('\u2216'), # âˆ– SET MINUS
    'smalltriangledown': u('\u25bf'), # â–¿ WHITE DOWN-POINTING SMALL TRIANGLE
    'smalltriangleleft': u('\u25c3'), # â—ƒ WHITE LEFT-POINTING SMALL TRIANGLE
    'smalltriangleright': u('\u25b9'), # â–¹ WHITE RIGHT-POINTING SMALL TRIANGLE
    'smalltriangleup': u('\u25b5'), # â–µ WHITE UP-POINTING SMALL TRIANGLE
    'sqcap': u('\u2293'), # âŠ“ SQUARE CAP
    'sqcup': u('\u2294'), # âŠ” SQUARE CUP
    'sslash': u('\u2afd'), # â«½ DOUBLE SOLIDUS OPERATOR
    'star': u('\u22c6'), # â‹† STAR OPERATOR
    'talloblong': u('\u2afe'), # â«¾ WHITE VERTICAL BAR
    'times': u('\xd7'), # Ã— MULTIPLICATION SIGN
    'triangle': u('\u25b3'), # â–³ WHITE UP-POINTING TRIANGLE
    'triangledown': u('\u25bf'), # â–¿ WHITE DOWN-POINTING SMALL TRIANGLE
    'triangleleft': u('\u25c3'), # â—ƒ WHITE LEFT-POINTING SMALL TRIANGLE
    'triangleright': u('\u25b9'), # â–¹ WHITE RIGHT-POINTING SMALL TRIANGLE
    'uplus': u('\u228e'), # âŠŽ MULTISET UNION
    'vartriangle': u('\u25b3'), # â–³ WHITE UP-POINTING TRIANGLE
    'vee': u('\u2228'), # âˆ¨ LOGICAL OR
    'veebar': u('\u22bb'), # âŠ» XOR
    'wedge': u('\u2227'), # âˆ§ LOGICAL AND
    'wr': u('\u2240'), # â‰€ WREATH PRODUCT
    }
mathclose = {
    'Rbag': u('\u27c6'), # âŸ† RIGHT S-SHAPED BAG DELIMITER
    'lrcorner': u('\u231f'), # âŒŸ BOTTOM RIGHT CORNER
    'rangle': u('\u27e9'), # âŸ© MATHEMATICAL RIGHT ANGLE BRACKET
    'rbag': u('\u27c6'), # âŸ† RIGHT S-SHAPED BAG DELIMITER
    'rbrace': u('}'), # } RIGHT CURLY BRACKET
    'rbrack': u(']'), # ] RIGHT SQUARE BRACKET
    'rceil': u('\u2309'), # âŒ‰ RIGHT CEILING
    'rfloor': u('\u230b'), # âŒ‹ RIGHT FLOOR
    'rgroup': u('\u27ef'), # âŸ¯ MATHEMATICAL RIGHT FLATTENED PARENTHESIS
    'rrbracket': u('\u27e7'), # âŸ§ MATHEMATICAL RIGHT WHITE SQUARE BRACKET
    'rrparenthesis': u('\u2988'), # â¦ˆ Z NOTATION RIGHT IMAGE BRACKET
    'urcorner': u('\u231d'), # âŒ TOP RIGHT CORNER
    '}': u('}'), # } RIGHT CURLY BRACKET
    }
mathfence = {
    'Vert': u('\u2016'), # â€– DOUBLE VERTICAL LINE
    'vert': u('|'), # | VERTICAL LINE
    '|': u('\u2016'), # â€– DOUBLE VERTICAL LINE
    }
mathop = {
    'Join': u('\u2a1d'), # â¨ JOIN
    'bigcap': u('\u22c2'), # â‹‚ N-ARY INTERSECTION
    'bigcup': u('\u22c3'), # â‹ƒ N-ARY UNION
    'biginterleave': u('\u2afc'), # â«¼ LARGE TRIPLE VERTICAL BAR OPERATOR
    'bigodot': u('\u2a00'), # â¨€ N-ARY CIRCLED DOT OPERATOR
    'bigoplus': u('\u2a01'), # â¨ N-ARY CIRCLED PLUS OPERATOR
    'bigotimes': u('\u2a02'), # â¨‚ N-ARY CIRCLED TIMES OPERATOR
    'bigsqcup': u('\u2a06'), # â¨† N-ARY SQUARE UNION OPERATOR
    'biguplus': u('\u2a04'), # â¨„ N-ARY UNION OPERATOR WITH PLUS
    'bigvee': u('\u22c1'), # â‹ N-ARY LOGICAL OR
    'bigwedge': u('\u22c0'), # â‹€ N-ARY LOGICAL AND
    'coprod': u('\u2210'), # âˆ N-ARY COPRODUCT
    'fatsemi': u('\u2a1f'), # â¨Ÿ Z NOTATION SCHEMA COMPOSITION
    'fint': u('\u2a0f'), # â¨ INTEGRAL AVERAGE WITH SLASH
    'iiiint': u('\u2a0c'), # â¨Œ QUADRUPLE INTEGRAL OPERATOR
    'iiint': u('\u222d'), # âˆ­ TRIPLE INTEGRAL
    'iint': u('\u222c'), # âˆ¬ DOUBLE INTEGRAL
    'int': u('\u222b'), # âˆ« INTEGRAL
    'oiint': u('\u222f'), # âˆ¯ SURFACE INTEGRAL
    'oint': u('\u222e'), # âˆ® CONTOUR INTEGRAL
    'ointctrclockwise': u('\u2233'), # âˆ³ ANTICLOCKWISE CONTOUR INTEGRAL
    'prod': u('\u220f'), # âˆ N-ARY PRODUCT
    'sqint': u('\u2a16'), # â¨– QUATERNION INTEGRAL OPERATOR
    'sum': u('\u2211'), # âˆ‘ N-ARY SUMMATION
    'varointclockwise': u('\u2232'), # âˆ² CLOCKWISE CONTOUR INTEGRAL
    }
mathopen = {
    'Lbag': u('\u27c5'), # âŸ… LEFT S-SHAPED BAG DELIMITER
    'langle': u('\u27e8'), # âŸ¨ MATHEMATICAL LEFT ANGLE BRACKET
    'lbag': u('\u27c5'), # âŸ… LEFT S-SHAPED BAG DELIMITER
    'lbrace': u('{'), # { LEFT CURLY BRACKET
    'lbrack': u('['), # [ LEFT SQUARE BRACKET
    'lceil': u('\u2308'), # âŒˆ LEFT CEILING
    'lfloor': u('\u230a'), # âŒŠ LEFT FLOOR
    'lgroup': u('\u27ee'), # âŸ® MATHEMATICAL LEFT FLATTENED PARENTHESIS
    'llbracket': u('\u27e6'), # âŸ¦ MATHEMATICAL LEFT WHITE SQUARE BRACKET
    'llcorner': u('\u231e'), # âŒž BOTTOM LEFT CORNER
    'llparenthesis': u('\u2987'), # â¦‡ Z NOTATION LEFT IMAGE BRACKET
    'ulcorner': u('\u231c'), # âŒœ TOP LEFT CORNER
    '{': u('{'), # { LEFT CURLY BRACKET
    }
mathord = {
    '#': u('#'), # # NUMBER SIGN
    '$': u('$'), # $ DOLLAR SIGN
    '%': u('%'), # % PERCENT SIGN
    '&amp;': u('&amp;'), # &amp; AMPERSAND
    'AC': u('\u223f'), # âˆ¿ SINE WAVE
    'APLcomment': u('\u235d'), # â APL FUNCTIONAL SYMBOL UP SHOE JOT
    'APLdownarrowbox': u('\u2357'), # â— APL FUNCTIONAL SYMBOL QUAD DOWNWARDS ARROW
    'APLinput': u('\u235e'), # âž APL FUNCTIONAL SYMBOL QUOTE QUAD
    'APLinv': u('\u2339'), # âŒ¹ APL FUNCTIONAL SYMBOL QUAD DIVIDE
    'APLleftarrowbox': u('\u2347'), # â‡ APL FUNCTIONAL SYMBOL QUAD LEFTWARDS ARROW
    'APLlog': u('\u235f'), # âŸ APL FUNCTIONAL SYMBOL CIRCLE STAR
    'APLrightarrowbox': u('\u2348'), # âˆ APL FUNCTIONAL SYMBOL QUAD RIGHTWARDS ARROW
    'APLuparrowbox': u('\u2350'), # â APL FUNCTIONAL SYMBOL QUAD UPWARDS ARROW
    'Aries': u('\u2648'), # â™ˆ ARIES
    'CIRCLE': u('\u25cf'), # â— BLACK CIRCLE
    'CheckedBox': u('\u2611'), # â˜‘ BALLOT BOX WITH CHECK
    'Diamond': u('\u25c7'), # â—‡ WHITE DIAMOND
    'Finv': u('\u2132'), # â„² TURNED CAPITAL F
    'Game': u('\u2141'), # â… TURNED SANS-SERIF CAPITAL G
    'Gemini': u('\u264a'), # â™Š GEMINI
    'Jupiter': u('\u2643'), # â™ƒ JUPITER
    'LEFTCIRCLE': u('\u25d6'), # â—– LEFT HALF BLACK CIRCLE
    'LEFTcircle': u('\u25d0'), # â— CIRCLE WITH LEFT HALF BLACK
    'Leo': u('\u264c'), # â™Œ LEO
    'Libra': u('\u264e'), # â™Ž LIBRA
    'Mars': u('\u2642'), # â™‚ MALE SIGN
    'Mercury': u('\u263f'), # â˜¿ MERCURY
    'Neptune': u('\u2646'), # â™† NEPTUNE
    'Pluto': u('\u2647'), # â™‡ PLUTO
    'RIGHTCIRCLE': u('\u25d7'), # â—— RIGHT HALF BLACK CIRCLE
    'RIGHTcircle': u('\u25d1'), # â—‘ CIRCLE WITH RIGHT HALF BLACK
    'Saturn': u('\u2644'), # â™„ SATURN
    'Scorpio': u('\u264f'), # â™ SCORPIUS
    'Square': u('\u2610'), # â˜ BALLOT BOX
    'Sun': u('\u2609'), # â˜‰ SUN
    'Taurus': u('\u2649'), # â™‰ TAURUS
    'Uranus': u('\u2645'), # â™… URANUS
    'Venus': u('\u2640'), # â™€ FEMALE SIGN
    'XBox': u('\u2612'), # â˜’ BALLOT BOX WITH X
    'Yup': u('\u2144'), # â…„ TURNED SANS-SERIF CAPITAL Y
    '_': u('_'), # _ LOW LINE
    'angle': u('\u2220'), # âˆ  ANGLE
    'aquarius': u('\u2652'), # â™’ AQUARIUS
    'aries': u('\u2648'), # â™ˆ ARIES
    'ast': u('*'), # * ASTERISK
    'backepsilon': u('\u03f6'), # Ï¶ GREEK REVERSED LUNATE EPSILON SYMBOL
    'backprime': u('\u2035'), # â€µ REVERSED PRIME
    'backslash': unicode('\\'), # \ REVERSE SOLIDUS  #### Changed. was u'\'
    'because': u('\u2235'), # âˆµ BECAUSE
    'bigstar': u('\u2605'), # â˜… BLACK STAR
    'binampersand': u('&amp;'), # &amp; AMPERSAND
    'blacklozenge': u('\u2b27'), # â¬§ BLACK MEDIUM LOZENGE
    'blacksmiley': u('\u263b'), # â˜» BLACK SMILING FACE
    'blacksquare': u('\u25fc'), # â—¼ BLACK MEDIUM SQUARE
    'bot': u('\u22a5'), # âŠ¥ UP TACK
    'boy': u('\u2642'), # â™‚ MALE SIGN
    'cancer': u('\u264b'), # â™‹ CANCER
    'capricornus': u('\u2651'), # â™‘ CAPRICORN
    'cdots': u('\u22ef'), # â‹¯ MIDLINE HORIZONTAL ELLIPSIS
    'cent': u('\xa2'), # Â¢ CENT SIGN
    'centerdot': u('\u2b1d'), # â¬ BLACK VERY SMALL SQUARE
    'checkmark': u('\u2713'), # âœ“ CHECK MARK
    'circlearrowleft': u('\u21ba'), # â†º ANTICLOCKWISE OPEN CIRCLE ARROW
    'circlearrowright': u('\u21bb'), # â†» CLOCKWISE OPEN CIRCLE ARROW
    'circledR': u('\xae'), # Â® REGISTERED SIGN
    'circledcirc': u('\u25ce'), # â—Ž BULLSEYE
    'clubsuit': u('\u2663'), # â™£ BLACK CLUB SUIT
    'complement': u('\u2201'), # âˆ COMPLEMENT
    'dasharrow': u('\u21e2'), # â‡¢ RIGHTWARDS DASHED ARROW
    'dashleftarrow': u('\u21e0'), # â‡  LEFTWARDS DASHED ARROW
    'dashrightarrow': u('\u21e2'), # â‡¢ RIGHTWARDS DASHED ARROW
    'diameter': u('\u2300'), # âŒ€ DIAMETER SIGN
    'diamondsuit': u('\u2662'), # â™¢ WHITE DIAMOND SUIT
    'earth': u('\u2641'), # â™ EARTH
    'exists': u('\u2203'), # âˆƒ THERE EXISTS
    'female': u('\u2640'), # â™€ FEMALE SIGN
    'flat': u('\u266d'), # â™­ MUSIC FLAT SIGN
    'forall': u('\u2200'), # âˆ€ FOR ALL
    'fourth': u('\u2057'), # â— QUADRUPLE PRIME
    'frownie': u('\u2639'), # â˜¹ WHITE FROWNING FACE
    'gemini': u('\u264a'), # â™Š GEMINI
    'girl': u('\u2640'), # â™€ FEMALE SIGN
    'heartsuit': u('\u2661'), # â™¡ WHITE HEART SUIT
    'infty': u('\u221e'), # âˆž INFINITY
    'invneg': u('\u2310'), # âŒ REVERSED NOT SIGN
    'jupiter': u('\u2643'), # â™ƒ JUPITER
    'ldots': u('\u2026'), # â€¦ HORIZONTAL ELLIPSIS
    'leftmoon': u('\u263e'), # â˜¾ LAST QUARTER MOON
    'leftturn': u('\u21ba'), # â†º ANTICLOCKWISE OPEN CIRCLE ARROW
    'leo': u('\u264c'), # â™Œ LEO
    'libra': u('\u264e'), # â™Ž LIBRA
    'lnot': u('\xac'), # Â¬ NOT SIGN
    'lozenge': u('\u25ca'), # â—Š LOZENGE
    'male': u('\u2642'), # â™‚ MALE SIGN
    'maltese': u('\u2720'), # âœ  MALTESE CROSS
    'mathdollar': u('$'), # $ DOLLAR SIGN
    'measuredangle': u('\u2221'), # âˆ¡ MEASURED ANGLE
    'mercury': u('\u263f'), # â˜¿ MERCURY
    'mho': u('\u2127'), # â„§ INVERTED OHM SIGN
    'nabla': u('\u2207'), # âˆ‡ NABLA
    'natural': u('\u266e'), # â™® MUSIC NATURAL SIGN
    'neg': u('\xac'), # Â¬ NOT SIGN
    'neptune': u('\u2646'), # â™† NEPTUNE
    'nexists': u('\u2204'), # âˆ„ THERE DOES NOT EXIST
    'notbackslash': u('\u2340'), # â€ APL FUNCTIONAL SYMBOL BACKSLASH BAR
    'partial': u('\u2202'), # âˆ‚ PARTIAL DIFFERENTIAL
    'pisces': u('\u2653'), # â™“ PISCES
    'pluto': u('\u2647'), # â™‡ PLUTO
    'pounds': u('\xa3'), # Â£ POUND SIGN
    'prime': u('\u2032'), # â€² PRIME
    'quarternote': u('\u2669'), # â™© QUARTER NOTE
    'rightmoon': u('\u263d'), # â˜½ FIRST QUARTER MOON
    'rightturn': u('\u21bb'), # â†» CLOCKWISE OPEN CIRCLE ARROW
    'sagittarius': u('\u2650'), # â™ SAGITTARIUS
    'saturn': u('\u2644'), # â™„ SATURN
    'scorpio': u('\u264f'), # â™ SCORPIUS
    'second': u('\u2033'), # â€³ DOUBLE PRIME
    'sharp': u('\u266f'), # â™¯ MUSIC SHARP SIGN
    'sim': u('~'), # ~ TILDE
    'slash': u('/'), # / SOLIDUS
    'smiley': u('\u263a'), # â˜º WHITE SMILING FACE
    'spadesuit': u('\u2660'), # â™  BLACK SPADE SUIT
    'spddot': u('\xa8'), # Â¨ DIAERESIS
    'sphat': u('^'), # ^ CIRCUMFLEX ACCENT
    'sphericalangle': u('\u2222'), # âˆ¢ SPHERICAL ANGLE
    'sptilde': u('~'), # ~ TILDE
    'square': u('\u25fb'), # â—» WHITE MEDIUM SQUARE
    'sun': u('\u263c'), # â˜¼ WHITE SUN WITH RAYS
    'taurus': u('\u2649'), # â™‰ TAURUS
    'therefore': u('\u2234'), # âˆ´ THEREFORE
    'third': u('\u2034'), # â€´ TRIPLE PRIME
    'top': u('\u22a4'), # âŠ¤ DOWN TACK
    'triangleleft': u('\u25c5'), # â—… WHITE LEFT-POINTING POINTER
    'triangleright': u('\u25bb'), # â–» WHITE RIGHT-POINTING POINTER
    'twonotes': u('\u266b'), # â™« BEAMED EIGHTH NOTES
    'uranus': u('\u2645'), # â™… URANUS
    'varEarth': u('\u2641'), # â™ EARTH
    'varnothing': u('\u2205'), # âˆ… EMPTY SET
    'virgo': u('\u264d'), # â™ VIRGO
    'wasylozenge': u('\u2311'), # âŒ‘ SQUARE LOZENGE
    'wasytherefore': u('\u2234'), # âˆ´ THEREFORE
    'yen': u('\xa5'), # Â¥ YEN SIGN
    }
mathover = {
    'overbrace': u('\u23de'), # âž TOP CURLY BRACKET
    'wideparen': u('\u23dc'), # âœ TOP PARENTHESIS
    }
mathradical = {
    'sqrt': u('\u221a'), # âˆš SQUARE ROOT
    'sqrt[3]': u('\u221b'), # âˆ› CUBE ROOT
    'sqrt[4]': u('\u221c'), # âˆœ FOURTH ROOT
    }
mathrel = {
    'Bumpeq': u('\u224e'), # â‰Ž GEOMETRICALLY EQUIVALENT TO
    'Doteq': u('\u2251'), # â‰‘ GEOMETRICALLY EQUAL TO
    'Downarrow': u('\u21d3'), # â‡“ DOWNWARDS DOUBLE ARROW
    'Leftarrow': u('\u21d0'), # â‡ LEFTWARDS DOUBLE ARROW
    'Leftrightarrow': u('\u21d4'), # â‡” LEFT RIGHT DOUBLE ARROW
    'Lleftarrow': u('\u21da'), # â‡š LEFTWARDS TRIPLE ARROW
    'Longleftarrow': u('\u27f8'), # âŸ¸ LONG LEFTWARDS DOUBLE ARROW
    'Longleftrightarrow': u('\u27fa'), # âŸº LONG LEFT RIGHT DOUBLE ARROW
    'Longmapsfrom': u('\u27fd'), # âŸ½ LONG LEFTWARDS DOUBLE ARROW FROM BAR
    'Longmapsto': u('\u27fe'), # âŸ¾ LONG RIGHTWARDS DOUBLE ARROW FROM BAR
    'Longrightarrow': u('\u27f9'), # âŸ¹ LONG RIGHTWARDS DOUBLE ARROW
    'Lsh': u('\u21b0'), # â†° UPWARDS ARROW WITH TIP LEFTWARDS
    'Mapsfrom': u('\u2906'), # â¤† LEFTWARDS DOUBLE ARROW FROM BAR
    'Mapsto': u('\u2907'), # â¤‡ RIGHTWARDS DOUBLE ARROW FROM BAR
    'Rightarrow': u('\u21d2'), # â‡’ RIGHTWARDS DOUBLE ARROW
    'Rrightarrow': u('\u21db'), # â‡› RIGHTWARDS TRIPLE ARROW
    'Rsh': u('\u21b1'), # â†± UPWARDS ARROW WITH TIP RIGHTWARDS
    'Subset': u('\u22d0'), # â‹ DOUBLE SUBSET
    'Supset': u('\u22d1'), # â‹‘ DOUBLE SUPERSET
    'Uparrow': u('\u21d1'), # â‡‘ UPWARDS DOUBLE ARROW
    'Updownarrow': u('\u21d5'), # â‡• UP DOWN DOUBLE ARROW
    'VDash': u('\u22ab'), # âŠ« DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
    'Vdash': u('\u22a9'), # âŠ© FORCES
    'Vvdash': u('\u22aa'), # âŠª TRIPLE VERTICAL BAR RIGHT TURNSTILE
    'apprge': u('\u2273'), # â‰³ GREATER-THAN OR EQUIVALENT TO
    'apprle': u('\u2272'), # â‰² LESS-THAN OR EQUIVALENT TO
    'approx': u('\u2248'), # â‰ˆ ALMOST EQUAL TO
    'approxeq': u('\u224a'), # â‰Š ALMOST EQUAL OR EQUAL TO
    'asymp': u('\u224d'), # â‰ EQUIVALENT TO
    'backsim': u('\u223d'), # âˆ½ REVERSED TILDE
    'backsimeq': u('\u22cd'), # â‹ REVERSED TILDE EQUALS
    'barin': u('\u22f6'), # â‹¶ ELEMENT OF WITH OVERBAR
    'barleftharpoon': u('\u296b'), # â¥« LEFTWARDS HARPOON WITH BARB DOWN BELOW LONG DASH
    'barrightharpoon': u('\u296d'), # â¥­ RIGHTWARDS HARPOON WITH BARB DOWN BELOW LONG DASH
    'between': u('\u226c'), # â‰¬ BETWEEN
    'bowtie': u('\u22c8'), # â‹ˆ BOWTIE
    'bumpeq': u('\u224f'), # â‰ DIFFERENCE BETWEEN
    'circeq': u('\u2257'), # â‰— RING EQUAL TO
    'coloneq': u('\u2254'), # â‰” COLON EQUALS
    'cong': u('\u2245'), # â‰… APPROXIMATELY EQUAL TO
    'corresponds': u('\u2259'), # â‰™ ESTIMATES
    'curlyeqprec': u('\u22de'), # â‹ž EQUAL TO OR PRECEDES
    'curlyeqsucc': u('\u22df'), # â‹Ÿ EQUAL TO OR SUCCEEDS
    'curvearrowleft': u('\u21b6'), # â†¶ ANTICLOCKWISE TOP SEMICIRCLE ARROW
    'curvearrowright': u('\u21b7'), # â†· CLOCKWISE TOP SEMICIRCLE ARROW
    'dashv': u('\u22a3'), # âŠ£ LEFT TACK
    'ddots': u('\u22f1'), # â‹± DOWN RIGHT DIAGONAL ELLIPSIS
    'dlsh': u('\u21b2'), # â†² DOWNWARDS ARROW WITH TIP LEFTWARDS
    'doteq': u('\u2250'), # â‰ APPROACHES THE LIMIT
    'doteqdot': u('\u2251'), # â‰‘ GEOMETRICALLY EQUAL TO
    'downarrow': u('\u2193'), # â†“ DOWNWARDS ARROW
    'downdownarrows': u('\u21ca'), # â‡Š DOWNWARDS PAIRED ARROWS
    'downdownharpoons': u('\u2965'), # â¥¥ DOWNWARDS HARPOON WITH BARB LEFT BESIDE DOWNWARDS HARPOON WITH BARB RIGHT
    'downharpoonleft': u('\u21c3'), # â‡ƒ DOWNWARDS HARPOON WITH BARB LEFTWARDS
    'downharpoonright': u('\u21c2'), # â‡‚ DOWNWARDS HARPOON WITH BARB RIGHTWARDS
    'downuparrows': u('\u21f5'), # â‡µ DOWNWARDS ARROW LEFTWARDS OF UPWARDS ARROW
    'downupharpoons': u('\u296f'), # â¥¯ DOWNWARDS HARPOON WITH BARB LEFT BESIDE UPWARDS HARPOON WITH BARB RIGHT
    'drsh': u('\u21b3'), # â†³ DOWNWARDS ARROW WITH TIP RIGHTWARDS
    'eqcirc': u('\u2256'), # â‰– RING IN EQUAL TO
    'eqcolon': u('\u2255'), # â‰• EQUALS COLON
    'eqsim': u('\u2242'), # â‰‚ MINUS TILDE
    'eqslantgtr': u('\u2a96'), # âª– SLANTED EQUAL TO OR GREATER-THAN
    'eqslantless': u('\u2a95'), # âª• SLANTED EQUAL TO OR LESS-THAN
    'equiv': u('\u2261'), # â‰¡ IDENTICAL TO
    'fallingdotseq': u('\u2252'), # â‰’ APPROXIMATELY EQUAL TO OR THE IMAGE OF
    'frown': u('\u2322'), # âŒ¢ FROWN
    'ge': u('\u2265'), # â‰¥ GREATER-THAN OR EQUAL TO
    'geq': u('\u2265'), # â‰¥ GREATER-THAN OR EQUAL TO
    'geqq': u('\u2267'), # â‰§ GREATER-THAN OVER EQUAL TO
    'geqslant': u('\u2a7e'), # â©¾ GREATER-THAN OR SLANTED EQUAL TO
    'gets': u('\u2190'), # â† LEFTWARDS ARROW
    'gg': u('\u226b'), # â‰« MUCH GREATER-THAN
    'ggcurly': u('\u2abc'), # âª¼ DOUBLE SUCCEEDS
    'ggg': u('\u22d9'), # â‹™ VERY MUCH GREATER-THAN
    'gnapprox': u('\u2a8a'), # âªŠ GREATER-THAN AND NOT APPROXIMATE
    'gneq': u('\u2a88'), # âªˆ GREATER-THAN AND SINGLE-LINE NOT EQUAL TO
    'gneqq': u('\u2269'), # â‰© GREATER-THAN BUT NOT EQUAL TO
    'gnsim': u('\u22e7'), # â‹§ GREATER-THAN BUT NOT EQUIVALENT TO
    'gtrapprox': u('\u2a86'), # âª† GREATER-THAN OR APPROXIMATE
    'gtrdot': u('\u22d7'), # â‹— GREATER-THAN WITH DOT
    'gtreqless': u('\u22db'), # â‹› GREATER-THAN EQUAL TO OR LESS-THAN
    'gtreqqless': u('\u2a8c'), # âªŒ GREATER-THAN ABOVE DOUBLE-LINE EQUAL ABOVE LESS-THAN
    'gtrless': u('\u2277'), # â‰· GREATER-THAN OR LESS-THAN
    'gtrsim': u('\u2273'), # â‰³ GREATER-THAN OR EQUIVALENT TO
    'hash': u('\u22d5'), # â‹• EQUAL AND PARALLEL TO
    'hookleftarrow': u('\u21a9'), # â†© LEFTWARDS ARROW WITH HOOK
    'hookrightarrow': u('\u21aa'), # â†ª RIGHTWARDS ARROW WITH HOOK
    'iddots': u('\u22f0'), # â‹° UP RIGHT DIAGONAL ELLIPSIS
    'impliedby': u('\u27f8'), # âŸ¸ LONG LEFTWARDS DOUBLE ARROW
    'implies': u('\u27f9'), # âŸ¹ LONG RIGHTWARDS DOUBLE ARROW
    'in': u('\u2208'), # âˆˆ ELEMENT OF
    'le': u('\u2264'), # â‰¤ LESS-THAN OR EQUAL TO
    'leftarrow': u('\u2190'), # â† LEFTWARDS ARROW
    'leftarrowtail': u('\u21a2'), # â†¢ LEFTWARDS ARROW WITH TAIL
    'leftarrowtriangle': u('\u21fd'), # â‡½ LEFTWARDS OPEN-HEADED ARROW
    'leftbarharpoon': u('\u296a'), # â¥ª LEFTWARDS HARPOON WITH BARB UP ABOVE LONG DASH
    'leftharpoondown': u('\u21bd'), # â†½ LEFTWARDS HARPOON WITH BARB DOWNWARDS
    'leftharpoonup': u('\u21bc'), # â†¼ LEFTWARDS HARPOON WITH BARB UPWARDS
    'leftleftarrows': u('\u21c7'), # â‡‡ LEFTWARDS PAIRED ARROWS
    'leftleftharpoons': u('\u2962'), # â¥¢ LEFTWARDS HARPOON WITH BARB UP ABOVE LEFTWARDS HARPOON WITH BARB DOWN
    'leftrightarrow': u('\u2194'), # â†” LEFT RIGHT ARROW
    'leftrightarrows': u('\u21c6'), # â‡† LEFTWARDS ARROW OVER RIGHTWARDS ARROW
    'leftrightarrowtriangle': u('\u21ff'), # â‡¿ LEFT RIGHT OPEN-HEADED ARROW
    'leftrightharpoon': u('\u294a'), # â¥Š LEFT BARB UP RIGHT BARB DOWN HARPOON
    'leftrightharpoons': u('\u21cb'), # â‡‹ LEFTWARDS HARPOON OVER RIGHTWARDS HARPOON
    'leftrightsquigarrow': u('\u21ad'), # â†­ LEFT RIGHT WAVE ARROW
    'leftslice': u('\u2aa6'), # âª¦ LESS-THAN CLOSED BY CURVE
    'leftsquigarrow': u('\u21dc'), # â‡œ LEFTWARDS SQUIGGLE ARROW
    'leq': u('\u2264'), # â‰¤ LESS-THAN OR EQUAL TO
    'leqq': u('\u2266'), # â‰¦ LESS-THAN OVER EQUAL TO
    'leqslant': u('\u2a7d'), # â©½ LESS-THAN OR SLANTED EQUAL TO
    'lessapprox': u('\u2a85'), # âª… LESS-THAN OR APPROXIMATE
    'lessdot': u('\u22d6'), # â‹– LESS-THAN WITH DOT
    'lesseqgtr': u('\u22da'), # â‹š LESS-THAN EQUAL TO OR GREATER-THAN
    'lesseqqgtr': u('\u2a8b'), # âª‹ LESS-THAN ABOVE DOUBLE-LINE EQUAL ABOVE GREATER-THAN
    'lessgtr': u('\u2276'), # â‰¶ LESS-THAN OR GREATER-THAN
    'lesssim': u('\u2272'), # â‰² LESS-THAN OR EQUIVALENT TO
    'lightning': u('\u21af'), # â†¯ DOWNWARDS ZIGZAG ARROW
    'll': u('\u226a'), # â‰ª MUCH LESS-THAN
    'llcurly': u('\u2abb'), # âª» DOUBLE PRECEDES
    'lll': u('\u22d8'), # â‹˜ VERY MUCH LESS-THAN
    'lnapprox': u('\u2a89'), # âª‰ LESS-THAN AND NOT APPROXIMATE
    'lneq': u('\u2a87'), # âª‡ LESS-THAN AND SINGLE-LINE NOT EQUAL TO
    'lneqq': u('\u2268'), # â‰¨ LESS-THAN BUT NOT EQUAL TO
    'lnsim': u('\u22e6'), # â‹¦ LESS-THAN BUT NOT EQUIVALENT TO
    'longleftarrow': u('\u27f5'), # âŸµ LONG LEFTWARDS ARROW
    'longleftrightarrow': u('\u27f7'), # âŸ· LONG LEFT RIGHT ARROW
    'longmapsfrom': u('\u27fb'), # âŸ» LONG LEFTWARDS ARROW FROM BAR
    'longmapsto': u('\u27fc'), # âŸ¼ LONG RIGHTWARDS ARROW FROM BAR
    'longrightarrow': u('\u27f6'), # âŸ¶ LONG RIGHTWARDS ARROW
    'looparrowleft': u('\u21ab'), # â†« LEFTWARDS ARROW WITH LOOP
    'looparrowright': u('\u21ac'), # â†¬ RIGHTWARDS ARROW WITH LOOP
    'mapsfrom': u('\u21a4'), # â†¤ LEFTWARDS ARROW FROM BAR
    'mapsto': u('\u21a6'), # â†¦ RIGHTWARDS ARROW FROM BAR
    'mid': u('\u2223'), # âˆ£ DIVIDES
    'models': u('\u22a7'), # âŠ§ MODELS
    'multimap': u('\u22b8'), # âŠ¸ MULTIMAP
    'nLeftarrow': u('\u21cd'), # â‡ LEFTWARDS DOUBLE ARROW WITH STROKE
    'nLeftrightarrow': u('\u21ce'), # â‡Ž LEFT RIGHT DOUBLE ARROW WITH STROKE
    'nRightarrow': u('\u21cf'), # â‡ RIGHTWARDS DOUBLE ARROW WITH STROKE
    'nVDash': u('\u22af'), # âŠ¯ NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
    'nVdash': u('\u22ae'), # âŠ® DOES NOT FORCE
    'ncong': u('\u2247'), # â‰‡ NEITHER APPROXIMATELY NOR ACTUALLY EQUAL TO
    'ne': u('\u2260'), # â‰  NOT EQUAL TO
    'nearrow': u('\u2197'), # â†— NORTH EAST ARROW
    'neq': u('\u2260'), # â‰  NOT EQUAL TO
    'ngeq': u('\u2271'), # â‰± NEITHER GREATER-THAN NOR EQUAL TO
    'ngtr': u('\u226f'), # â‰¯ NOT GREATER-THAN
    'ni': u('\u220b'), # âˆ‹ CONTAINS AS MEMBER
    'nleftarrow': u('\u219a'), # â†š LEFTWARDS ARROW WITH STROKE
    'nleftrightarrow': u('\u21ae'), # â†® LEFT RIGHT ARROW WITH STROKE
    'nleq': u('\u2270'), # â‰° NEITHER LESS-THAN NOR EQUAL TO
    'nless': u('\u226e'), # â‰® NOT LESS-THAN
    'nmid': u('\u2224'), # âˆ¤ DOES NOT DIVIDE
    'notasymp': u('\u226d'), # â‰­ NOT EQUIVALENT TO
    'notin': u('\u2209'), # âˆ‰ NOT AN ELEMENT OF
    'notowner': u('\u220c'), # âˆŒ DOES NOT CONTAIN AS MEMBER
    'notslash': u('\u233f'), # âŒ¿ APL FUNCTIONAL SYMBOL SLASH BAR
    'nparallel': u('\u2226'), # âˆ¦ NOT PARALLEL TO
    'nprec': u('\u2280'), # âŠ€ DOES NOT PRECEDE
    'npreceq': u('\u22e0'), # â‹  DOES NOT PRECEDE OR EQUAL
    'nrightarrow': u('\u219b'), # â†› RIGHTWARDS ARROW WITH STROKE
    'nsim': u('\u2241'), # â‰ NOT TILDE
    'nsubseteq': u('\u2288'), # âŠˆ NEITHER A SUBSET OF NOR EQUAL TO
    'nsucc': u('\u2281'), # âŠ DOES NOT SUCCEED
    'nsucceq': u('\u22e1'), # â‹¡ DOES NOT SUCCEED OR EQUAL
    'nsupseteq': u('\u2289'), # âŠ‰ NEITHER A SUPERSET OF NOR EQUAL TO
    'ntriangleleft': u('\u22ea'), # â‹ª NOT NORMAL SUBGROUP OF
    'ntrianglelefteq': u('\u22ec'), # â‹¬ NOT NORMAL SUBGROUP OF OR EQUAL TO
    'ntriangleright': u('\u22eb'), # â‹« DOES NOT CONTAIN AS NORMAL SUBGROUP
    'ntrianglerighteq': u('\u22ed'), # â‹­ DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
    'nvDash': u('\u22ad'), # âŠ­ NOT TRUE
    'nvdash': u('\u22ac'), # âŠ¬ DOES NOT PROVE
    'nwarrow': u('\u2196'), # â†– NORTH WEST ARROW
    'owns': u('\u220b'), # âˆ‹ CONTAINS AS MEMBER
    'parallel': u('\u2225'), # âˆ¥ PARALLEL TO
    'perp': u('\u27c2'), # âŸ‚ PERPENDICULAR
    'pitchfork': u('\u22d4'), # â‹” PITCHFORK
    'prec': u('\u227a'), # â‰º PRECEDES
    'precapprox': u('\u2ab7'), # âª· PRECEDES ABOVE ALMOST EQUAL TO
    'preccurlyeq': u('\u227c'), # â‰¼ PRECEDES OR EQUAL TO
    'preceq': u('\u2aaf'), # âª¯ PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
    'precnapprox': u('\u2ab9'), # âª¹ PRECEDES ABOVE NOT ALMOST EQUAL TO
    'precnsim': u('\u22e8'), # â‹¨ PRECEDES BUT NOT EQUIVALENT TO
    'precsim': u('\u227e'), # â‰¾ PRECEDES OR EQUIVALENT TO
    'propto': u('\u221d'), # âˆ PROPORTIONAL TO
    'restriction': u('\u21be'), # â†¾ UPWARDS HARPOON WITH BARB RIGHTWARDS
    'rightarrow': u('\u2192'), # â†’ RIGHTWARDS ARROW
    'rightarrowtail': u('\u21a3'), # â†£ RIGHTWARDS ARROW WITH TAIL
    'rightarrowtriangle': u('\u21fe'), # â‡¾ RIGHTWARDS OPEN-HEADED ARROW
    'rightbarharpoon': u('\u296c'), # â¥¬ RIGHTWARDS HARPOON WITH BARB UP ABOVE LONG DASH
    'rightharpoondown': u('\u21c1'), # â‡ RIGHTWARDS HARPOON WITH BARB DOWNWARDS
    'rightharpoonup': u('\u21c0'), # â‡€ RIGHTWARDS HARPOON WITH BARB UPWARDS
    'rightleftarrows': u('\u21c4'), # â‡„ RIGHTWARDS ARROW OVER LEFTWARDS ARROW
    'rightleftharpoon': u('\u294b'), # â¥‹ LEFT BARB DOWN RIGHT BARB UP HARPOON
    'rightleftharpoons': u('\u21cc'), # â‡Œ RIGHTWARDS HARPOON OVER LEFTWARDS HARPOON
    'rightrightarrows': u('\u21c9'), # â‡‰ RIGHTWARDS PAIRED ARROWS
    'rightrightharpoons': u('\u2964'), # â¥¤ RIGHTWARDS HARPOON WITH BARB UP ABOVE RIGHTWARDS HARPOON WITH BARB DOWN
    'rightslice': u('\u2aa7'), # âª§ GREATER-THAN CLOSED BY CURVE
    'rightsquigarrow': u('\u21dd'), # â‡ RIGHTWARDS SQUIGGLE ARROW
    'risingdotseq': u('\u2253'), # â‰“ IMAGE OF OR APPROXIMATELY EQUAL TO
    'searrow': u('\u2198'), # â†˜ SOUTH EAST ARROW
    'sim': u('\u223c'), # âˆ¼ TILDE OPERATOR
    'simeq': u('\u2243'), # â‰ƒ ASYMPTOTICALLY EQUAL TO
    'smallfrown': u('\u2322'), # âŒ¢ FROWN
    'smallsmile': u('\u2323'), # âŒ£ SMILE
    'smile': u('\u2323'), # âŒ£ SMILE
    'sqsubset': u('\u228f'), # âŠ SQUARE IMAGE OF
    'sqsubseteq': u('\u2291'), # âŠ‘ SQUARE IMAGE OF OR EQUAL TO
    'sqsupset': u('\u2290'), # âŠ SQUARE ORIGINAL OF
    'sqsupseteq': u('\u2292'), # âŠ’ SQUARE ORIGINAL OF OR EQUAL TO
    'subset': u('\u2282'), # âŠ‚ SUBSET OF
    'subseteq': u('\u2286'), # âŠ† SUBSET OF OR EQUAL TO
    'subseteqq': u('\u2ac5'), # â«… SUBSET OF ABOVE EQUALS SIGN
    'subsetneq': u('\u228a'), # âŠŠ SUBSET OF WITH NOT EQUAL TO
    'subsetneqq': u('\u2acb'), # â«‹ SUBSET OF ABOVE NOT EQUAL TO
    'succ': u('\u227b'), # â‰» SUCCEEDS
    'succapprox': u('\u2ab8'), # âª¸ SUCCEEDS ABOVE ALMOST EQUAL TO
    'succcurlyeq': u('\u227d'), # â‰½ SUCCEEDS OR EQUAL TO
    'succeq': u('\u2ab0'), # âª° SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
    'succnapprox': u('\u2aba'), # âªº SUCCEEDS ABOVE NOT ALMOST EQUAL TO
    'succnsim': u('\u22e9'), # â‹© SUCCEEDS BUT NOT EQUIVALENT TO
    'succsim': u('\u227f'), # â‰¿ SUCCEEDS OR EQUIVALENT TO
    'supset': u('\u2283'), # âŠƒ SUPERSET OF
    'supseteq': u('\u2287'), # âŠ‡ SUPERSET OF OR EQUAL TO
    'supseteqq': u('\u2ac6'), # â«† SUPERSET OF ABOVE EQUALS SIGN
    'supsetneq': u('\u228b'), # âŠ‹ SUPERSET OF WITH NOT EQUAL TO
    'supsetneqq': u('\u2acc'), # â«Œ SUPERSET OF ABOVE NOT EQUAL TO
    'swarrow': u('\u2199'), # â†™ SOUTH WEST ARROW
    'to': u('\u2192'), # â†’ RIGHTWARDS ARROW
    'trianglelefteq': u('\u22b4'), # âŠ´ NORMAL SUBGROUP OF OR EQUAL TO
    'triangleq': u('\u225c'), # â‰œ DELTA EQUAL TO
    'trianglerighteq': u('\u22b5'), # âŠµ CONTAINS AS NORMAL SUBGROUP OR EQUAL TO
    'twoheadleftarrow': u('\u219e'), # â†ž LEFTWARDS TWO HEADED ARROW
    'twoheadrightarrow': u('\u21a0'), # â†  RIGHTWARDS TWO HEADED ARROW
    'uparrow': u('\u2191'), # â†‘ UPWARDS ARROW
    'updownarrow': u('\u2195'), # â†• UP DOWN ARROW
    'updownarrows': u('\u21c5'), # â‡… UPWARDS ARROW LEFTWARDS OF DOWNWARDS ARROW
    'updownharpoons': u('\u296e'), # â¥® UPWARDS HARPOON WITH BARB LEFT BESIDE DOWNWARDS HARPOON WITH BARB RIGHT
    'upharpoonleft': u('\u21bf'), # â†¿ UPWARDS HARPOON WITH BARB LEFTWARDS
    'upharpoonright': u('\u21be'), # â†¾ UPWARDS HARPOON WITH BARB RIGHTWARDS
    'upuparrows': u('\u21c8'), # â‡ˆ UPWARDS PAIRED ARROWS
    'upupharpoons': u('\u2963'), # â¥£ UPWARDS HARPOON WITH BARB LEFT BESIDE UPWARDS HARPOON WITH BARB RIGHT
    'vDash': u('\u22a8'), # âŠ¨ TRUE
    'varpropto': u('\u221d'), # âˆ PROPORTIONAL TO
    'vartriangleleft': u('\u22b2'), # âŠ² NORMAL SUBGROUP OF
    'vartriangleright': u('\u22b3'), # âŠ³ CONTAINS AS NORMAL SUBGROUP
    'vdash': u('\u22a2'), # âŠ¢ RIGHT TACK
    'vdots': u('\u22ee'), # â‹® VERTICAL ELLIPSIS
    }
mathunder = {
    'underbrace': u('\u23df'), # âŸ BOTTOM CURLY BRACKET
    }
space = {
    ':': u('\u205f'), # âŸ MEDIUM MATHEMATICAL SPACE
    'medspace': u('\u205f'), # âŸ MEDIUM MATHEMATICAL SPACE
    'quad': u('\u2001'), # â€ EM QUAD
    }
</t>
<t tx="ekr.20130807203905.16763">@first # -*- coding: utf8 -*-

import sys

g.cls()

def u(s):
    try:
        val = None
        if sys.version_info &lt; (3,):
            val = s if isinstance(s,unicode) else unicode(s,"unicode_escape")
        else:
            val = s if isinstance(s,str) else str(s,"unicode_escape")
    except UnicodeDecodeError:
        ### There seems to be a bug: '\\uxxx' is not handled properly.
        if 1:
            g.trace('UnicodeDecodeError',repr(s),'isunicode',isinstance(s,unicode))
        else:
            try:
                val = unicode(s,'ascii')
            except UnicodeDecodeError:
                g.trace('UnicodeDecodeError',repr(s))
    return val
        
@others

for ch in aList:
    # print(ch)
    assert not isinstance(ch,unicode),repr(ch)
    ch2 = u(ch)
    # print(repr(ch))
    # assert unicode(ch,"unicode_escape") == ch2,repr(ch)
print('pass')
</t>
<t tx="ekr.20130807203905.16764">if 0:
    aList_with_u = (
    u('"'),
    u(r'\dq{}'),
    u(r'{\char`\"}'),
    u(r'\#'),
    u(r'\$'),
    u(r'\%'),
    u(r'\&amp;'),
    u(r'\textasciitilde{}'),
    u(r'\_'),
    u(r'\textasciicircum{}'),
    u(r'\textbackslash{}'),
    u(r'\{'),
    u(r'\}'),
    u(r'{[}'),
    u(r'{]}'),
    u(r'\-'),                           # SOFT HYPHEN
    u(r'~'),                            # NO-BREAK SPACE
    u(r'\leavevmode\nobreak\vadjust{}~'),
    u(r'\,'),                           # PUNCTUATION SPACEâ€ˆâ€ˆâ€ˆ
    u(r'\hbox{-}'),                     # NON-BREAKING HYPHEN
    u(r'\,'),                           # NARROW NO-BREAK SPACE
    u(r'$\Leftrightarrow$'),
    u(r'$\spadesuit$'),
    u(r'$\clubsuit$'),
    u(r'\guillemotleft'),   # LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    u(r'\guillemotright'),  # RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    u(r'\textcompwordmark'), # ZERO WIDTH NON-JOINER
    u(r'\textendash{}'),
    u(r'\textemdash{}'),
    u(r'\textquoteleft{}'),
    u(r'\textquoteright{}'),
    u(r'\quotesinglbase{}'),    # SINGLE LOW-9 QUOTATION MARK
    u(r'\textquotedblleft{}'),
    u(r'\textquotedblright{}'),
    u(r'\quotedblbase{}'),      # DOUBLE LOW-9 QUOTATION MARK
    u(r'\textperthousand{}'),   # PER MILLE SIGN
    u(r'\textpertenthousand{}'), # PER TEN THOUSAND SIGN
    u(r'\guilsinglleft{}'),
    u(r'\guilsinglright{}'),
    u(r'\textvisiblespace{}'),  # OPEN BOX
    u(r'\dag{}'),
    u(r'\ddag{}'),
    u(r'\dots{}'),
    u(r'\texttrademark{}'),
    u(r'\textcent{}'),          # Â¢ CENT SIGN
    u(r'\textcurrency{}'),      # Â¤ CURRENCY SYMBOL
    u(r'\textyen{}'),           # Â¥ YEN SIGN
    u(r'\textbrokenbar{}'),     # Â¦ BROKEN BAR
    u(r'\textsection{}'),       # Â§ SECTION SIGN
    u(r'\textasciidieresis{}'), # Â¨ DIAERESIS
    u(r'\textcopyright{}'),     # Â© COPYRIGHT SIGN
    u(r'\textordfeminine{}'),   # Âª FEMININE ORDINAL INDICATOR
    u(r'\textlnot{}'),          # Â¬ NOT SIGN
    u(r'\textregistered{}'),    # Â® REGISTERED SIGN
    u(r'\textasciimacron{}'),   # Â¯ MACRON
    u(r'\textdegree{}'),        # Â° DEGREE SIGN
    u(r'\textpm{}'),            # Â± PLUS-MINUS SIGN
    u(r'\texttwosuperior{}'),   # Â² SUPERSCRIPT TWO
    u(r'\textthreesuperior{}'), # Â³ SUPERSCRIPT THREE
    u(r'\textasciiacute{}'),    # Â´ ACUTE ACCENT
    u(r'\textmu{}'),            # Âµ MICRO SIGN
    u(r'\textparagraph{}'),     # Â¶ PILCROW SIGN # not equal to \textpilcrow
    u(r'\textonesuperior{}'),   # Â¹ SUPERSCRIPT ONE
    u(r'\textordmasculine{}'),  # Âº MASCULINE ORDINAL INDICATOR
    u(r'\textonequarter{}'),    # 1/4 FRACTION
    u(r'\textonehalf{}'),       # 1/2 FRACTION
    u(r'\textthreequarters{}'), # 3/4 FRACTION
    u(r'\texttimes{}'),         # Ã— MULTIPLICATION SIGN
    u(r'\textdiv{}'),           # Ã· DIVISION SIGN
    u(r'\textflorin{}'),        # LATIN SMALL LETTER F WITH HOOK
    u(r'\textasciiacute{}'),    # MODIFIER LETTER PRIME
    u(r'\textacutedbl{}'),      # MODIFIER LETTER DOUBLE PRIME
    u(r'\textbardbl{}'),        # DOUBLE VERTICAL LINE
    u(r'\textbullet{}'),        # BULLET
    u(r'\textasciiacute{}'),    # PRIME
    u(r'\textacutedbl{}'),      # DOUBLE PRIME
    u(r'\textasciigrave{}'),    # REVERSED PRIME
    u(r'\textgravedbl{}'),      # REVERSED DOUBLE PRIME
    u(r'\textreferencemark{}'), # REFERENCE MARK
    u(r'\textinterrobang{}'),   # INTERROBANG
    u(r'\textfractionsolidus{}'), # FRACTION SLASH
    u(r'\textlquill{}'),        # LEFT SQUARE BRACKET WITH QUILL
    u(r'\textrquill{}'),        # RIGHT SQUARE BRACKET WITH QUILL
    u(r'\textdiscount{}'),      # COMMERCIAL MINUS SIGN
    u(r'\textcolonmonetary{}'), # COLON SIGN
    u(r'\textfrenchfranc{}'),   # FRENCH FRANC SIGN
    u(r'\textlira{}'),          # LIRA SIGN
    u(r'\textnaira{}'),         # NAIRA SIGN
    u(r'\textwon{}'),           # WON SIGN
    u(r'\textdong{}'),          # DONG SIGN
    u(r'\texteuro{}'),          # EURO SIGN
    u(r'\textpeso{}'),          # PESO SIGN
    u(r'\textguarani{}'),       # GUARANI SIGN
    u(r'\textcelsius{}'),       # DEGREE CELSIUS
    u(r'\textnumero{}'),        # NUMERO SIGN
    u(r'\textcircledP{}'),      # SOUND RECORDING COYRIGHT
    u(r'\textrecipe{}'),        # PRESCRIPTION TAKE
    u(r'\textservicemark{}'),   # SERVICE MARK
    u(r'\texttrademark{}'),     # TRADE MARK SIGN
    u(r'\textohm{}'),           # OHM SIGN
    u(r'\textmho{}'),           # INVERTED OHM SIGN
    u(r'\textestimated{}'),     # ESTIMATED SYMBOL
    u(r'\textleftarrow{}'),     # LEFTWARDS ARROW
    u(r'\textuparrow{}'),       # UPWARDS ARROW
    u(r'\textrightarrow{}'),    # RIGHTWARDS ARROW
    u(r'\textdownarrow{}'),     # DOWNWARDS ARROW
    u(r'\textminus{}'),         # MINUS SIGN
    u(r'\textasteriskcentered{}'), # ASTERISK OPERATOR
    u(r'\textsurd{}'),          # SQUARE ROOT
    u(r'\textblank{}'),         # BLANK SYMBOL
    u(r'\textopenbullet{}'),    # WHITE BULLET
    u(r'\textbigcircle{}'),     # LARGE CIRCLE
    u(r'\textmusicalnote{}'),   # EIGHTH NOTE
    u(r'\textmarried{}'),       # MARRIAGE SYMBOL
    u(r'\textdivorced{}'),      # DIVORCE SYMBOL
    u(r'\textlangle{}'),        # MATHEMATICAL LEFT ANGLE BRACKET
    u(r'\textrangle{}'),        # MATHEMATICAL RIGHT ANGLE BRACKET
    u(r'\ding{170}'),     # black heartsuit
    u(r'\ding{169}'),     # black diamondsuit
    u(r'\ding{51}'),      # check mark
    u(r'\ding{55}'),      # check mark
    u("Cannot embed stylesheet '%s':\n  %s."),
    # Causes problems.     
    u('\\underline{~}'), 
    u(r'\reflectbox{/}'),
    u(r'\textbar{}'),
    u(r'\textless{}'),
    u(r'\textgreater{}'),
    u(r'~'),
    u('$%s$'),                        
    u(r'\#'),
    u(r'\%'),
    u(r'\\'),       
    u('â€”'),
)

# wrapper = u('\n').join(['%%',
     # r'\begin{%s}' % math_env,
     # '%s',
     # r'\end{%s}' % math_env])

unicode_aList = (
    u'"',
    ur'\dq{}',
    ur'{\char`\"}',
    ur'\#',
    ur'\$',
    ur'\%',
    ur'\&amp;',
    ur'\textasciitilde{}',
    ur'\_',
    ur'\textasciicircum{}',
    ur'\textbackslash{}',
    ur'\{',
    ur'\}',
    ur'{[}',
    ur'{]}',
    ur'\-',
    ur'~',
    ur'\leavevmode\nobreak\vadjust{}~',
    ur'\,',
    ur'\hbox{-}',
    ur'\,',
    ur'$\Leftrightarrow$',
    ur'$\spadesuit$',
    ur'$\clubsuit$',
    ur'\guillemotleft',
    ur'\guillemotright',
    ur'\textcompwordmark',
    ur'\textendash{}',
    ur'\textemdash{}',
    ur'\textquoteleft{}',
    ur'\textquoteright{}',
    ur'\quotesinglbase{}',
    ur'\textquotedblleft{}',
    ur'\textquotedblright{}',
    ur'\quotedblbase{}',
    ur'\textperthousand{}',
    ur'\textpertenthousand{}',
    ur'\guilsinglleft{}',
    ur'\guilsinglright{}',
    ur'\textvisiblespace{}',
    ur'\dag{}',
    ur'\ddag{}',
    ur'\dots{}',
    ur'\texttrademark{}',
    ur'\textcent{}',
    ur'\textcurrency{}',
    ur'\textyen{}',
    ur'\textbrokenbar{}',
    ur'\textsection{}',
    ur'\textasciidieresis{}',
    ur'\textcopyright{}',
    ur'\textordfeminine{}',
    ur'\textlnot{}',
    ur'\textregistered{}',
    ur'\textasciimacron{}',
    ur'\textdegree{}',
    ur'\textpm{}',
    ur'\texttwosuperior{}',
    ur'\textthreesuperior{}',
    ur'\textasciiacute{}',
    ur'\textmu{}',
    ur'\textparagraph{}',
    ur'\textonesuperior{}',
    ur'\textordmasculine{}',
    ur'\textonequarter{}',
    ur'\textonehalf{}',
    ur'\textthreequarters{}',
    ur'\texttimes{}',
    ur'\textdiv{}',
    ur'\textflorin{}',
    ur'\textasciiacute{}',
    ur'\textacutedbl{}',
    ur'\textbardbl{}',
    ur'\textbullet{}',
    ur'\textasciiacute{}',
    ur'\textacutedbl{}',
    ur'\textasciigrave{}',
    ur'\textgravedbl{}',
    ur'\textreferencemark{}',
    ur'\textinterrobang{}',
    ur'\textfractionsolidus{}',
    ur'\textlquill{}',
    ur'\textrquill{}',
    ur'\textdiscount{}',
    ur'\textcolonmonetary{}',
    ur'\textfrenchfranc{}',
    ur'\textlira{}',
    ur'\textnaira{}',
    ur'\textwon{}',
    ur'\textdong{}',
    ur'\texteuro{}',
    ur'\textpeso{}',
    ur'\textguarani{}',
    ur'\textcelsius{}',
    ur'\textnumero{}',
    ur'\textcircledP{}',
    ur'\textrecipe{}',
    ur'\textservicemark{}',
    ur'\texttrademark{}',
    ur'\textohm{}',
    ur'\textmho{}',
    ur'\textestimated{}',
    ur'\textleftarrow{}',
    ur'\textuparrow{}',
    ur'\textrightarrow{}',
    ur'\textdownarrow{}',
    ur'\textminus{}',
    ur'\textasteriskcentered{}',
    ur'\textsurd{}',
    ur'\textblank{}',
    ur'\textopenbullet{}',
    ur'\textbigcircle{}',
    ur'\textmusicalnote{}',
    ur'\textmarried{}',
    ur'\textdivorced{}',
    ur'\textlangle{}',
    ur'\textrangle{}',
    ur'\ding{170}',
    ur'\ding{169}',
    ur'\ding{51}',
    ur'\ding{55}',
    u"Cannot embed stylesheet '%s':\n  %s.",
    u'\\underline{~}', # Can not use ur('\uxxxx) because that is a unicode escapse!!
    ur'\reflectbox{/}',
    ur'\textbar{}',
    ur'\textless{}',
    ur'\textgreater{}',
    ur'~',
    u'$%s$',
    # ur'\'
    ur'\%',
    ur'\\',
    u'â€”',
)

aList = (
    '"',
    r'\dq{}',
    r'{\char`\"}',
    r'\#',
    r'\$',
    r'\%',
    r'\&amp;',
    r'\textasciitilde{}',
    r'\_',
    r'\textasciicircum{}',
    r'\textbackslash{}',
    r'\{',
    r'\}',
    r'{[}',
    r'{]}',
    r'\-',
    r'~',
    r'\leavevmode\nobreak\vadjust{}~',
    r'\,',
    r'\hbox{-}',
    r'\,',
    r'$\Leftrightarrow$',
    r'$\spadesuit$',
    r'$\clubsuit$',
    r'\guillemotleft',
    r'\guillemotright',
    r'\textcompwordmark',
    r'\textendash{}',
    r'\textemdash{}',
    r'\textquoteleft{}',
    r'\textquoteright{}',
    r'\quotesinglbase{}',
    r'\textquotedblleft{}',
    r'\textquotedblright{}',
    r'\quotedblbase{}',
    r'\textperthousand{}',
    r'\textpertenthousand{}',
    r'\guilsinglleft{}',
    r'\guilsinglright{}',
    r'\textvisiblespace{}',
    r'\dag{}',
    r'\ddag{}',
    r'\dots{}',
    r'\texttrademark{}',
    r'\textcent{}',
    r'\textcurrency{}',
    r'\textyen{}',
    r'\textbrokenbar{}',
    r'\textsection{}',
    r'\textasciidieresis{}',
    r'\textcopyright{}',
    r'\textordfeminine{}',
    r'\textlnot{}',
    r'\textregistered{}',
    r'\textasciimacron{}',
    r'\textdegree{}',
    r'\textpm{}',
    r'\texttwosuperior{}',
    r'\textthreesuperior{}',
    r'\textasciiacute{}',
    r'\textmu{}',
    r'\textparagraph{}',
    r'\textonesuperior{}',
    r'\textordmasculine{}',
    r'\textonequarter{}',
    r'\textonehalf{}',
    r'\textthreequarters{}',
    r'\texttimes{}',
    r'\textdiv{}',
    r'\textflorin{}',
    r'\textasciiacute{}',
    r'\textacutedbl{}',
    r'\textbardbl{}',
    r'\textbullet{}',
    r'\textasciiacute{}',
    r'\textacutedbl{}',
    r'\textasciigrave{}',
    r'\textgravedbl{}',
    r'\textreferencemark{}',
    r'\textinterrobang{}',
    r'\textfractionsolidus{}',
    r'\textlquill{}',
    r'\textrquill{}',
    r'\textdiscount{}',
    r'\textcolonmonetary{}',
    r'\textfrenchfranc{}',
    r'\textlira{}',
    r'\textnaira{}',
    r'\textwon{}',
    r'\textdong{}',
    r'\texteuro{}',
    r'\textpeso{}',
    r'\textguarani{}',
    r'\textcelsius{}',
    r'\textnumero{}',
    r'\textcircledP{}',
    r'\textrecipe{}',
    r'\textservicemark{}',
    r'\texttrademark{}',
    r'\textohm{}',
    r'\textmho{}',
    r'\textestimated{}',
    r'\textleftarrow{}',
    r'\textuparrow{}',
    r'\textrightarrow{}',
    r'\textdownarrow{}',
    r'\textminus{}',
    r'\textasteriskcentered{}',
    r'\textsurd{}',
    r'\textblank{}',
    r'\textopenbullet{}',
    r'\textbigcircle{}',
    r'\textmusicalnote{}',
    r'\textmarried{}',
    r'\textdivorced{}',
    r'\textlangle{}',
    r'\textrangle{}',
    r'\ding{170}',
    r'\ding{169}',
    r'\ding{51}',
    r'\ding{55}',
    "Cannot embed stylesheet '%s':\n  %s.",
    '\\' + 'underline{~}', # Can not use ur('\uxxxx) because that is a unicode escapse!!
    r'\reflectbox{/}',
    r'\textbar{}',
    r'\textless{}',
    r'\textgreater{}',
    r'~',
    '$%s$',
    # r'\'
    r'\%',
    r'\\',
    # u'â€”',
)

# wrapper = u('\n').join(['%%',
     # r'\begin{%s}' % math_env,
     # '%s',
     # r'\end{%s}' % math_env])

</t>
<t tx="ekr.20130807203905.16765">ur constants:
    
writers\manpage.py
writers\latex2e\__init__.py
utils\math\latex2matchml.py

u constants:

core.py
frontend.py
io.py
nodes.py
statemachine.py
__init__.py
languages\ca.py
languages\cs.py
languages\eo.py
languages\es.py
languages\fi.py
languages\fr.py
languages\gl.py
languages\he.py
languages\ja.py
languages\lt.py
languages\pl.py
languages\pt_br.py
languages\ru.py
languages\sk.py
languages\sv.py
languages\zh_cn.py
languages\zh_tw.py
parsers\rst\states.py
parsers\rst\directives\body.py
parsers\rst\directives\misc.py
parsers\rst\directives\tables.py
parsers\rst\directives\__init__.py
parsers\rst\languages\af.py
parsers\rst\languages\ca.py
parsers\rst\languages\cs.py
parsers\rst\languages\de.py
parsers\rst\languages\eo.py
parsers\rst\languages\es.py
parsers\rst\languages\fi.py
parsers\rst\languages\fr.py
parsers\rst\languages\gl.py
parsers\rst\languages\he.py
parsers\rst\languages\it.py
parsers\rst\languages\ja.py
parsers\rst\languages\lt.py
parsers\rst\languages\nl.py
parsers\rst\languages\pl.py
parsers\rst\languages\pt_br.py
parsers\rst\languages\ru.py
parsers\rst\languages\sk.py
parsers\rst\languages\sv.py
parsers\rst\languages\zh_cn.py
parsers\rst\languages\zh_tw.py
transforms\parts.py
transforms\references.py
utils\error_reporting.py
utils\punctuation_chars.py
utils\smartquotes.py
utils\__init__.py
utils\math\latex2mathml.py
utils\math\math2html.py
utils\math\tex2unichar.py
utils\math\unichar2tex.py
writers\manpage.py
writers\html4css1\__init__.py
writers\latex2e\__init__.py
writers\odf_odt\__init__.py
writers\xetex\__init__.py
</t>
<t tx="ekr.20130807203905.16773"></t>
<t tx="ekr.20130812034101.12581"></t>
<t tx="ekr.20130814140750.17191"></t>
<t tx="ekr.20130814140750.17192">From: Alia K &lt;alia_khouri@yahoo.com&gt;

Fernando Perez of IPython fame just announced recently that IPython
trunk has the cell magic functionality that was discussed earlier
[http://groups.google.com/group/leo-editor/browse_thread/thread/
7d910a68072dda1/b14e84fc3cfddbf6?lnk=gst&amp;q=ipython#b14e84fc3cfddbf6].
As this could work very nicely with leo as an ipython editor, I will
include his text verbatim here:

===== Fernando

I'm excited to report that we now have cell magics in IPython... PR
1732 [1] has just been merged [2], which implements the design
discussed in IPEP 1 [3]. This is probably one of the largest PRs we've
had so far, with over 100 commits, over 100 comments and a diff that's
almost 11000 lines long (a lot of it moving code around, obviously
it's not all new code).  But it brings two very important thigns:

1) a refactor of the magic system to finally remove the old mixin
class we'd had since the very first days of IPython in 2001.  This is
a cleanup I've been wanting to do for over 10 years!  The new setup
makes the magic system have  a very clean api, that is easy to use
both for the implementation of core features and for users to create
their own magics.

2) the new concept of cell magics: these are magics that get not only
the line they're on, but the entire cell body as well.  And while
these are most naturally used in the notebook, as you would expect
we've built them at the core of IPython, so you can use them with all
the clients (terminal, qt console, notebook).  For example, this is a
Cython magic that Brian just prototyped out (we'll have a production
version of it soon included).  Note that this was copied *from a
regular text terminal*, not from the notebook:

In [3]: from IPython.core.magic import register_line_cell_magic

In [4]: @register_line_cell_magic
   ...: def cython(line, cell):
   ...:     """Compile and import a cell as a .pyx file."""
   ...:     import sys
   ...:     from importlib import import_module
   ...:     module = line.strip()
   ...:     fname = module + '.pyx'
   ...:     with open(fname,'w') as f:
   ...:         f.write(cell)
   ...:     if 'pyximport' not in sys.modules:
   ...:         import pyximport
   ...:         pyximport.install(reload_support=True)
   ...:     globals()[module] = import_module(module)
   ...:

In [5]: %%cython bam
   ...: def f(x):
   ...:     return 2.0*x
   ...:

In [6]: bam.f(10)
Out[6]: 20.0

In a similar spirit, Jonathan Taylor recently created one to call R
transparently in the notebook:

https://github.com/jonathan-taylor/Rmagic

This one hasn't been fully updated to the final API, but the core code
is there and now it should be a trivial matter to update it.


I want to thank everyone who pitched in with ideas during the
discussion and review period, and I hope you'll all enjoy this and
come up with great ways to use the system.  For now, you can see how
the system works by playing with %%timeit and %%prun, the only two
builtins that I extended to work also as cell magics.

For more details, see the documentation where we've added also a long
new section with details and examples of how to create your own [4].

Cheers,

f

[1] https://github.com/ipython/ipython/pull/1732
[2] https://github.com/ipython/ipython/commit/61eb2ffeebb91a94fe9befe2c30e7839781ddc52
[2] https://github.com/ipython/ipython/issues/1611
[3] http://ipython.org/ipython-doc/dev/interactive/reference.html#magic-command-system

</t>
<t tx="ekr.20130814140750.17193">Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9

pyos_inputhook is relevant

IPython lib.inputhook
http://ipython.org/ipython-doc/stable/api/generated/IPython.lib.inputhook.html

* IPython seems to require Python 2.x.
* I can run IPython from either C:\prog\ipython-0.12 or from python\lib\site-packages

From C:\prog\ipython-0.12\IPython\scripts

#!/usr/bin/env python
"""Terminal-based IPython entry point.
"""

from IPython.frontend.terminal.ipapp import launch_new_instance

launch_new_instance()

Here is ipapi.get::

@language python

    def get():
        """Get the global InteractiveShell instance."""
        from IPython.core.interactiveshell import InteractiveShell
        return InteractiveShell.instance()
        
See also:
    
http://ipython.org/ipython-doc/rel-0.12/api/index.html
http://ipython.org/ipython-doc/rel-0.12/api/generated/IPython.core.interactiveshell.html


</t>
<t tx="ekr.20130815102041.15618">This plugin supports printing using the Qt GUI.
Written by Jacob M. Peck.
</t>
<t tx="ekr.20130815102041.15628">By Ville M. Vainio
See: http://en.wikipedia.org/wiki/Mylyn

I went on to start a "leo mylyn" plugin to exercise using the
childrenModified and contentModified signals.

If you want to play with it, enable leomylyn.py, modify stuff around the
tree and do alt-x mylyn-scores.

Of course as it is useless in this state, but becomes useful when it has a
proper gui (maybe in Nav pane), where you would then have a list of "most
interesting" nodes.

In the future, this could be able to remember the scores through the
sessions, degrade the old scores by time, etc. Also, a scoreset would be
associated with a "project" (e.g."own research", "work project foo"), each
of them having their own typical node working set.

Mylyn was a nice boost back in the eclipse days, it could work for Leo too.
My main motivation right now was to demonstrate the signals with something
that is much simpler than using them in qmlnotebook.
</t>
<t tx="ekr.20130815102041.15630">By Terry Brown.

See http://leo-editor.github.io/screen_capture.html

screen_capture now captures an image immediately, screen_capture_5sec waits
five seconds, so you can position the pointer, open menus etc. The only
feedback is in the console, as messages in the log would be distracting in
the captured image.
</t>
<t tx="ekr.20130815102041.15631">By Edward K. Ream

Screencasts promise to be easy to be *much* easier to create than 
slideshows, while also being more interesting, informative and flashy.  It 
is *so* much easier to write a screencast script than it is to lay out a 
slide, take a screenshot, and then manage resulting slide.

In particular, there are few continuity problems with screencasts.  
Continuity is a *huge* problem with slideshows!  If I change one slide, I 
am likely to want to change all following slides.  Which means I have to 
retake all the slides, and file the new versions in the proper places.  In 
contrast, any changes to screencasts naturally propagate forward.  There 
might be an effect on following screencasts scenes, but this will happen 
rarely with a reasonable scene design, and any problems should be easy to 
fix.

With screencasts, the *movie* script is also the *python* script!  There is 
no "translation" from one to the other.  Furthermore, all the work to 
produce a screencast is done (naturally!) within Leo.  No need to create 
and manage external data.  This is another huge advantage and it make 
producing screencasts much faster than producing slideshows.

Screencasts may be the long-awaited tools that will allow me to show Leo in
action so that other will finally be able to understand it easily.
</t>
<t tx="ekr.20130815102041.15632">By Kent Tenney

The timestamp plugin manages the following node attributes:

- str_ctime: creation time
- str_mtime: time node was last modified
- str_atime: time node contents were last viewed
</t>
<t tx="ekr.20130816100419.17299">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20130908104426.11242">https://bugs.launchpad.net/leo-editor/+bug/914221

Summary of a *long* discussion: this may be a docutils issue, and does not
seem easy to fix.
</t>
<t tx="ekr.20130908104426.11269">There are 42 wishlist items.  Some appear to be duplicates, or closely related.
</t>
<t tx="ekr.20130909111702.13058"></t>
<t tx="ekr.20130916105324.19894">@language rest

https://bugs.launchpad.net/leo-editor/+bug/1226353

===== EKR

The most important problem is compatibility.  As I have just verified,
@shadow will work even if the private file does not exist,
but all outline structure will be lost.  Therefore, it may be best
not to try to read old (ver-4thin) files at all.

@shadow does not reload the following simple file correctly!

+ @shadow
   @others
  + child 1
    child 1.1

shadow files (the private files containing the sentinels) use the *old*
(#@+leo-ver=4-thin) sentinels, rather than the new (#@+leo-ver=5-thin)
sentinels.

The old sentinels don't have an explicit notion of nesting level; the new
sentinels do, so it would seem that the way to fix this problem is to use
new sentinels. However, this would be a major change to the inner workings
of the @shadow logic.
</t>
<t tx="ekr.20130919120947.12506">here are two reasons why Leo is unlikely ever to be a web app.

1. There are somewhere around a million lines of Python code in Leo's core
   and plugins. Thus, a *solid* python in javascript system is required.
   This isn't likely to happen.

2. Creating a Leo outline widget is extremely complex. Even starting with a
   working javascript outliner, one has to deal with events (commands)
   coming from Leo scripts rather than from the user.

These seem like the most important obstacles. There may be others, but these
suffice
</t>
<t tx="ekr.20130926053913.11562"></t>
<t tx="ekr.20130926053913.15855"></t>
<t tx="ekr.20131001045038.17448">This idea got started when I (Ville M. Vainio) saw this post by Edward Ream
on IPython developer mailing list:
http://lists.ipython.scipy.org/pipermail/ipython-dev/2008-January/003551.html

I was using FreeMind as mind mapping software, and so I had an immediate
use case for Leo (which, incidentally, is superior to FreeMind as mind
mapper). The wheels started rolling, I got obsessed with the power of this
concept (everything clicked together), and Edwards excitement paralleled
mine. Everything was mind-bogglingly easy/trivial, something that is
typical of all promising technologies.

The goal of close cooperation between Leo and IPython went from vague dream
to completed reality over the span of about 10 days. The IPython bridge has
continued to evolve since then.
</t>
<t tx="ekr.20131001045038.18979">The IPython bridge turns Leo into another kind of `IPython Notebook`_.
IPython users typically use %edit to produce non-trivial functions/classes
instead of entering them directly on the interactive prompt. But this is a
bit clumsy. With Leo, *every Leo node works like an IPython %edit file*:

- You can execute any Leo node in IPython with &lt;Alt-I&gt; (ipython-exec)
- Saving your Leo outline saves all your IPython scripts.
- You can use Leo as always to organize all your IPython scripts.
</t>
<t tx="ekr.20131001045038.18980">*You can run any IPython script from Leo*. Leo's ipython-exec (Alt-I)
command executes the body text of the presently selected Leo node in the
address space of the IPython shell. Such scripts *immediately* affect the
IPython interpreter.

The IPython bridge sets several global variables *within Leo*, allowing Leo
scripts *complete* access to all of IPython's code and data:

- g.app.ipk.namespace is IPython's namespace.
- g.app.ipk.ipkernel is an IPython IPKernelApp object.
- g.app.ipk.ipkernel.shell is an IPython InteractiveShell object.
</t>
<t tx="ekr.20131001045038.18981">*You can run any Leo script from IPython*. The IPython bridge injects an
object called _leo into IPython's namespace. IPython scripts may access
Leo's c and g objects as follows::

    c,g = _leo.c, _leo.g

This allows IPython scripts to do *anything* that a Leo script can do.
Scripts run from IPython *immediately* change Leo, *exactly* as if the
script were run from Leo.

**Important**: the _leo object is an instance of LeoNameSpace class,
defined in leo.core.leoIPython.py. This class allows IPython scripts to
access multiple Leo outlines at once. See the actual code for details.
</t>
<t tx="ekr.20131001045038.19027">@language rest
</t>
<t tx="ekr.20131001045038.19028">When I say Learn Leo, I don't mean Learn or understand the code, I mean
learn what you can do with it.

My true feeling is that Leo is like an infinite ground, where amazing
things can be built. Some of Leo users are already doing incredible things
with it. But when you are new to Leo, you first have to learn the physics
of this new world (Leo Code), and then develop your own engineering (Useful
outlines structures) for building your "information cities"...

Possibly, experienced leo users dont share this view since they learned Leo
physics and engineering long time ago, but those look like a big wall when
starting with Leo.

So Leo files with samples would be like delivering this infinite ground
with some pre-built "information cities" so people can begin using them
right away. Ideally, those leo files should guide the user on how to build
new structures, and in the end, be able to lead him to generate new
structures.

My (again, personal) feeling is that the current policy right now is: Let
him read the code to understand how it works. So only the users willing to
go through the (1) Learn the physics then (2) develop your own way to
develop "information cities" can actually use leo and use its potential.

Since most of the internet users are the ones who need the cities already
built for them to use software, thats the chunk we are loosing.

On the other hand, coming to why programmers (who have the skills to go
through Leo learning process) dont come and use it, its the same story:

Before coming into Leo, what I was doing was actually search for an IDE
that I liked. I went through several, and in the ones I "liked" the most,
it would take you around two hours learning for having a folder with your
scripts and being able to edit them. With Leo, you first have to study and
understand what are directives, how do they work, how everything interacts
in the tree, etc. It takes more than two hours. I would say that it can be
measured in weeks or months until you really know what you are doing.

And here is where the "information cities" come again. If Leo were provided
with an interactive Leo file, which would guide you into: - Importing your
scripts to Leo - Clearly create folders and move/manage your files there -
Suggest directives for those files. - Etc.

That Leo file would save the new user many many hours and he would
instantly start using leo, so we would help him skip the first wall and
begin to get interested.

So then again, this is why I still see that Leo default workbook should be
dispatched with a Leo cheatsheet open by default, so new users begin to
play with it as soon as they open Leo.
</t>
<t tx="ekr.20131001045038.19029">Leo represents a completely new paradigm for editing, programming, and
interacting with data. Well, not completely new, but for many the surface
level seems extremely foreign.

Leo is primarily a tool aimed at python...the paradigm it exposes to the
user is far more like Lisp (homoiconicity via the Node and Tree structure)
and Smalltalk (.leo files save *most* of your programming environment's
state, including data). This is a huge cognitive leap for people only
accustomed to more imperative languages like Python...Leo asks a lot of

-----

​The PIM aspect was what initially led me to Leo. Wikipedia pointed me in
Leo's direction while searching for some good open-source PIM tools. I
tried Chandler but it didn't do what I wanted. Leo did.

</t>
<t tx="ekr.20131001045038.19030">Re: the original question "Why isn't Leo more popular" I can ask myself
"Why don't I adopt tools which promise a better way to work?" I do a lot of
grazing, and encounter very many such tools.

A tool which does everything doesn't grab me, I don't need to do
everything. A tool which, in it's few moments of my attention, describes a
better way to do something I need, gets additional moments. If the tool
salesperson mentions a task I encounter and a better way to do it, with a
learning curve which justifies the benefit ... I will settle in for a
while.

Easier, more powerful boilerplates / templates / completion is the kind of
bait I'll bite on, there's potential for decent return on investment.
</t>
<t tx="ekr.20131001045038.19031">With "bread crumbs" I refer to...the interactive tutorial creator I have
talked so much about. My aim with this tool is that anything you do,
instantly becomes a tutorial, that can be done again and played forward and
backwards. Basically, your actions become an outline, and other users can
"play them" again. This should mean that making a tutorial will take as
much time as it takes for you to perform the action originally.
</t>
<t tx="ekr.20131001045038.19032">As a newbie, I agree. At least, that is the perception, which is
discouraging. I believe it also has to do with the lack of learning
material. The only manual is not very newbie-friendly. It contains a lot of
cross-references to advanced internal commands (@xyz stuff) which put off
newcomers, especially where they are thrown in altogether and may look
scary.

Currently the learning curve does nor _appear_ to be gentle at all. But it
does not necessarily have to be like this. Even if Leo is indeed very
complex and very advanced, I am sure that at least a subset of Leo
functionality can be selected and presented in a nicer way, to attract more
users and help newbies.

Why can't we have some more accessible tutorial, with gentle, self
contained lessons (maybe webcasts, or slides, or simple HTML pages) which
_focus on the basic functionality_? Or perhaps, a two-tiered series of such
lessons, i.e. basic and advanced levels. I think this would be very
helpful.

-----

Another point: Leo is commonly advertised as a programming editor, but it
should be made more clear that it is more than that.

I believe you would attract more users if you also mentioned its usefulness
for general-purpose editing and PIM functionality. Of course, that may be
implicit, but I think you should be putting some more emphasis on this
aspect.

----- 

For me, the trajectory was KeyNote --&gt; MyBase --&gt; NotecasePro/RightNote --&gt;
Leo (!!)

Leo is the best, because it is fully customizable, and gives you seemingly
infinite power. Only, it takes a lot to learn how to use that power.
</t>
<t tx="ekr.20131001045038.19034">Consider that Leo is actively developed, and has a responsive community.
When I requested the support for Rich Text, a couple of months ago, it was
promptly implemented in a matter of days.

As for the power, of course Leo can do whatever other PIMs can do, because
it is extensible by Python. The question is whether enough people are
interested in Leo as a PIM, so as to have enough user contributions. I am
still at the beginning, so I have no idea how difficult it may be,
technically, to impement all the PIM features that we need. But if we
succeed in getting enough people interested, I am sure that nothing is
beyond our reach.

As far as PIM features go the next step, I believe, is implementing a good
tagging system.
</t>
<t tx="ekr.20131001045038.19035">I think a lot of the problem is defining what Leo is. In some ways I think
it's Python's Squeak (Squeak http://www.squeak.org/Screenshots/ being a
SmallTalk environment where everything's an object).

If all you want is an off the shelf turn key text editor with perhaps
completion and syntax highlighting as its most advanced features, then
there are several out there that are probably going to appeal more than
Leo.

If you're looking for an off the shelf turn key outliner, without the
intent to use scripts etc., then again there are lots of alternatives, some
of which probably seem more intuitive / simpler / even more feature rich
than Leo. (The feature rich part is probably misleading, but they may seem
that way initially).

If your looking for an *environment* which includes a good editor and
outliner and is completely scriptable / interactive / "live-code" in
Python, then Leo wins hands down. Of course, it's basically alone in this
field, as far as I know, but I'm sure it would do well even if it
wasn't...I guess Emacs is sort of an environment like this, only in Lisp
with a prehistoric GUI system.

Sometimes I've wondered why Leo seems to appeal to people who aren't
comfortable in Python, I think now it's because they still recognize the
value of an *environment*, and there's just not much in this niche. So to
me it's more why don't more people want an environment like this...

My feeling, talking generally and not about Leo in particular, is that
while not everyone needs to be a "programmer", everyone who uses computers
would benefit from being able to interact with them with more of the
flexibility and efficiency that comes with even relatively simple
"scripting", and less of the limitations that come with the "buy our latest
product and you'll be able to do anything you want with a click" view
pushed by other suppliers of computing environments.
</t>
<t tx="ekr.20131001045038.19036">In that regard, Leo is barely mentioned on WikiPedia - it has a simple
descriptive page, but on the list of text editors it's listed, but there's
no information about o/s support or features.

For marketing, packaging, features, documentation, tutorials,
extensions,... - do a side by side comparison of Vim and Leo - and the
answer(s) to "why leo isn't more popular" leap out at you.
</t>
<t tx="ekr.20131001045038.19038">I came to Leo because it is the only outliner for Linux that supports
cloning that doesn't require an internet connection.

I am struggling to implement it into my workflow though, simply because I
do not have time to figure out the simplest things. (full time university
student) Right now I simply do not have the 200 minutes available to figure
this out. Yet I can see that if I took the time to do my own setup it would
save me far more time in the future. Leo would be a wonderful platform for
writing anything, but especially for fiction. If there was a tutorial on
setting up Leo to do the following, I know there would be immediate
interest from people who write on Linux as there simply is not an outliner
that meets the needs of the average writer.

I need basic text formatting at the standard hot key level. ie. Ctrl-B for
bold, Ctrl-I for italic etc. while in the edit window. I know this can be
done, I almost had it working once but then got busy and by the time I came
back it had escaped me how I had done it. I don't need buttons, I don't
need WSIWYG, RST markup works fine as it gives me lots of output options. I
just need the ability to put my head down and write, using the shortcuts
that are baked into my fingertips at this point, and not having to relearn
those keys. Support for standard word-processing keys are important for
writers. :-)

I think that by creating tutorials that address the basics for different
groups of users who are not programmers, Leo could be an extremely popular
program. I would be willing to contribute to such an effort for writers if
I can get a workflow setup that makes sense for me. My current editor of
choice is Scrivener for Windows run using Crossover. No cloning. :-(

Leo is far too complex for the average person who simply wants to
accomplish a task. Simplifying things for specific classes of users would
open Leo up to many more people who share those requirements and may be
interested in learning the rest of the power of Leo as their use of it
increases. Give people a foot in the door and they will figure out how to
open it the rest of the way as needed.
</t>
<t tx="ekr.20131001045038.19039">i.e. RST markup for "bold".  Is that the goal?

Cheers -Terry

Almost. That plus the ability to be writing along and hit
Ctrl-b s u d d e n l y Ctrl-b and continue on.

I had Leo working to the extent that I could type suddenly Ctrl-Alt-b and
have it retroactively add the markup but it was simply too much of a leap
to change my work habits. Body memory takes years to develop and is not
trivial to attempt to change.

A set of keybindings that mimic the standard word processing key bindings
that then markup the text using RST or Markdown would be a huge step
forward for me in using Leo. Right now I try to find time to fiddle and
play with it, but that has been going on for almost two years now and I
have yet to commit to any serious work in Leo.

===== Terry

Which boils down to Ctrl-b inserting '*' if there's no selection?

I guess it does.

It may seem silly, as I could just type the *, but Shift-8 isn't baked into
muscle memory, Ctrl-b is.

It boils down to being able to replicate those standard word processing
shortcuts in the edit pane and having them not conflict with other key
combos in Leo. Abstracting it to other markup languages would be cool as
well, some people like RST, some people like Markdown. Everyone can use
Ctrl-b.

Ckeditor looks interesting, but it isn't the buttons that matter. I rarely
use the mouse for marking up text.

==== Terry

Quick stab at
https://github.com/leo-editor/snippets/blob/master/ctrl_b_i_u.py
not very tested.

</t>
<t tx="ekr.20131001045038.19040">In you myLeoSettings.leo file, under @settings--&gt;@keys--&gt;@shortcuts,
add the shrotcuts (in the body text of the '@shortcuts' node:

markup_inline_bold ! body = Ctrl-B
markup_inline_italic ! body = Ctrl-I
markup_inline_underline ! body = Ctrl-U

restart Leo

Put the downloaded code in a node, and run it... normally you'd do that
by hitting Ctrl-B, but we just redefined that :-)  So use alt-x
execute-script instead.

Now in the body you should be able to get

**bold** *italic* :ul:`underline`

with the expected keys.  It should be fairly predictable when there's a
selection active.  When there isn't, it just opens or closes the markup
type depending on whether the last action was an open or close, so I
guess nesting would be problem, but rst doesn't understand nesting
inline markup anyway.

The difference between open and close only applies to underline, where
the beginning and end delimiters are different - more a demo than
anything.

To make the code active without the execute-script step it could be
placed in a node which starts with @script, although you need
@bool scripting-at-script-nodes = True
under your @settings node then.

Ideally it would be in a plugin (although it seems heavy to put
essentially one function in a plugin) or core, so it didn't need its
own node in the target outline or @settings.
</t>
<t tx="ekr.20131001045038.19041">I would like to start putting together everything that it would take to
make Leo the default choice for writers on Linux. If it works for me, it'll
work for many others.
</t>
<t tx="ekr.20131001045038.19042">&gt; How difficult would a plugin be?

Easy enough I guess, included in revision 6083, just pushed.

In myLeoSettings.leo, under @settings--&gt;@keys--&gt;@shortcuts::

    markup-inline-bold ! body = Ctrl-B
    markup-inline-italic ! body = Ctrl-I
    markup-inline-underline ! body = Ctrl-U

  - Use Help -&gt; leoSettings.leo to open leoSettings.leo, and copy
    the @enabled-plugins node
    
  - paste this node into your myLeoSettings.leo as a child of the
    @settings node
    
  - just before the line in @enabled-plugins where it says
    "# Alphabetical list of all Leo plugins" add a line:

    markup_inline.py
</t>
<t tx="ekr.20131001045038.19043">Miles's comments inspired me to do something about the Homebrew version of
Leo. Instead of following a long-winded and increasingly out-of-date set of
installation instructions you will soon be able to go (if all goes well!):

brew install leo

I've created a rough formula for Leo and uploaded it to my Homebrew tap. To
try it out, do the following:

- Get Homebrew from http://brew.sh/, following their instructions on how to
install it

- Pay special attention to Python - if you have already installed a bunch
of Python stuff, it's best to keep using the existing Python. Otherwise, if
this is your first Python experience it is safe to install the Homebrew
Python (which will make your life easier) via

  brew install python

  (If all your existing Python tools suddenly disappear, go 'brew remove
  python' to restore order :-))

- Get my formulas:

  brew tap ska-sa/tap

- Et voila:

  brew install leo

- If you kept your old Python, follow the instruction in the caveat printed
at the end of:

  brew info leo

  (I.e. add the suggested line to your ~/.bash_profile file if you are not
  using Homebrew Python)

The formula has three versions:

  brew install leo =&gt; installs the latest stable release (4.10)
  brew install --devel leo =&gt; installs latest alpha (4.11-a2)
  brew install --HEAD leo =&gt; installs the bleeding-edge bzr version from Launchpad

It also installs PyEnchant by default (which can be disabled).

I would love some testing of the installation before I submit it to the
main Homebrew repository (if you guys think the formula is a good idea). I
don't use Leo myself and have only done some cursory poking around.

Miles's point about using a Ruby-based installer to install a Python
package also rings true (although this is becoming more popular these days
on the Mac given how awesome Homebrew is for dependencies and Python
extensions, and this is not any stranger than the C-based "apt-get install
leo").

I would expect to install a Python package such as Leo using "pip install
leo" or "easy_install leo". The main problem has always been that Leo has a
non-standard package layout.

I (only now!) see that Ville, Matt and others have created a setup.py and
leo even exists on PyPI so that these installation commands actually do
something. Unfortunately, for me "pip install leo" results in a Leo that
throws an AssertionError upon running. What is the status of this
installation route? (It is not even mentioned on the installation page!)
Also, "leo 4.10-final" on PyPI actually installs "4.11-devel"...
</t>
<t tx="ekr.20131001045038.19044">&gt; My (again, personal) feeling is that the current policy right now is: Let
him read the code to understand how it works. So only the users willing to
go through the (1) Learn the physics then (2) develop your own way to
develop "information cities" can actually use leo and use its potential.

​I've spent a lot of time on tutorials, slideshows, etc. However, in light
of your first sentence quoted above, it does seem like I have neglected to
show what people can really do with Leo, at least in the tutorial docs. ​
 
&gt; With Leo, you first have to study and understand what are directives, how
do they work, how everything interacts in the tree, etc. It takes more than
two hours. I would say that it can be measured in weeks or months until you
really know what you are doing.

Maybe, but there is a tantalizing possibility. ​I prototyped Leo in about
two hours, using the MORE outliner as a prototype, and inventing @others in
the process. (I was already deeply involved with sections and section
references.)

So for *me*, the Leo aha was almost instantaneous, once I had an outliner
to prototype my thoughts. Since then, things have become more "voluminous",
yet Leo's DOM is so much simpler and more powerful than it was in the early
days. Do these improvement make Leo *more* difficult to learn? It's hard to
believe so, but then nobody is closer to Leo than I.

&gt; And here is where the "information cities" come again. If Leo were
provided with an interactive Leo file, which would guide you ​...

​The idea of putting a cheat sheet into the default workbook.leo is a great
one. There will be a default_workbook.leo in leo/docs, and the code that
creates ~/workbook.leo will make a copy of the default file. This will
allow continuous improvement on default_workbook.leo.
</t>
<t tx="ekr.20131001045038.19045">&gt; For marketing, packaging, features, documentation, tutorials,
extensions,... - do a side by side comparison of Vim and Leo - and the
answer(s) to "why leo isn't more popular" leap out at you.


​The answer is not so clear cut.​ Consider the first item returned by
Google for the search "emacs tutorial":
http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html

This is hardly a breathtaking introduction to emacs. It would not *by
itself* convert people to emacs. It doesn't even highlight what I consider
the most important Aha about emacs, namely that you don't have to remember
(or type) commands with long names!

No, the reason emacs is popular is that it continues to be taught as *the*
programming editor to generations of computer-programming students. The
students learn *from each other*, using a tedious "tutorial" as a
reference. They learn from looking over each other's shoulders.

Leo would be just as popular, imo, if thousands of college students learned
Leo from each other. This does not excuse lack of further work on Leo
tutorials, but this *is* the essence of the situation.
</t>
<t tx="ekr.20131001100236.15927">Leo's valuespace.py plugin uses the ipython namespace when the
--ipython command line switch is in effect.

This plugin provides a "workbook" like way to get data from Leo document to
the namespace, and do calculations based on that data. Having this data be
accessible to the ipython instance makes it convenient to interact and poke
around with the same data.
</t>
<t tx="ekr.20131001100335.15926">To me, it's to directed acyclic graphs what MS Excel is to tables. 
</t>
<t tx="ekr.20131001100335.15927">This e-book has a whole sub-heading on using Leo for Joomla:
http://www.gandsnut.net/downloads/Beginning_Joomla!_From_Novice_to_Professional.pdf

amazon link:
http://www.amazon.com/Beginning-Joomla-From-Novice-Professional/dp/1590598482/ref=sr_1_1?ie=UTF8&amp;qid=1380681874&amp;sr=8-1&amp;keywords=beginning+joomla+from+novice+to+professional
</t>
<t tx="ekr.20131001100335.15938">This section explains how to use Leo's standard search/replace commands. |br|
**Note**: you can also use the Nav Tab (in the Log pane) to search for text. 

Ctrl-F (start-search) shows the Find Tab and puts the focus
in the minibuffer. |br|
**Important**: the Find tab just shows you the status of search and replace
operations. |br|
You control those operations from the minibuffer.

**Note**: You can select radio buttons and toggle check boxes in the
Find Tab with Ctrl-Alt keys. The capitalized words of the radio
buttons or check boxes indicate which Ctrl-Alt key to use. For
example, Ctrl-Alt-X (toggle-find-regex-option) toggles the Regexp
checkbox.

After typing Ctrl-F, type the search string, say "def", in the minibuffer.

Start the find by typing &lt;Return&gt;.

But suppose you want to replace "def" with "foo", instead of just finding
"foo".

Before typing &lt;Return&gt; type &lt;Tab&gt;. The minibuffer prompts for the
replacement string. Notice that the status area now shows “def” as the Find
string.

Type "foo" and type &lt;Return&gt; to start the find-next command.

When Leo finds the next instance of "def", it will select it. |br|
You may type any command.  The following are most useful:

- Ctrl-minus (replace-then-find) replaces the selected text.
- F3 (find-next) continues searching without making a replacement.
- F2 (find-previous) continues the search in reverse.
- Ctrl-G (keyboard-quit) ends the search.
</t>
<t tx="ekr.20131001100335.15940">.. index::
    pair: leoSettings.leo; Tutorial
    pair: Global Settings; Tutorial
    pair: myLeoSettings.leo; Tutorial
    pair: Personal Settings; Tutorial
    pair: Local Settings; Tutorial
    pair: Configuration file; Tutorial

Leo has a flexible (perhaps *too* flexible) configuration system. It's best
to use this flexibility in a restricted way as follows:

1. The file leo/config/leoSettings.leo contains Leo's default **global settings**.
   Don't change this file unless you are one of Leo's developers.
   
2. The file ~/myLeoSettings.leo contains your **personal settings**. Leo will
   not create this file automatically: you should create it yourself.
   Settings in myLeoSettings.leo override (or add to) the default settings
   in leoSettings.leo.
   
3. Any other .leo file may also contain **local settings**. Local
   settings apply only to that file and override all other settings.
   It's best to use local settings sparingly.
   
As a result, settings may vary from one Leo file to another. This can be
confusing. These two commands can help:

- print-settings shows each setting and where it came from.
  
- print-bindings shows each key binding and where it came from.

.. index::
    pair: @settings tree; Tutorial

**Important**: within any file, settings take effect **only** if they are
contained in an **@settings tree**, that is, are descendants of a node
whose headline is @settings. Nodes outside @settings trees do not affect
settings in any way.

Within @settings trees, you specify boolean settings with @bool nodes,
string settings with @string nodes, menus with @menus and @menu nodes, etc.
For exact details, please do study leoSettings.leo. You can open either
leoSettings.leo or myLeoSettings.leo from the Help menu. Within
leoSettings.leo:

- The node "About this file" explains about settings.
- The node "Candidates for settings in myLeoSettings.leo" highlights the
  settings you are most likely to want to customize.
</t>
<t tx="ekr.20131001100335.15942">Give differences between Leo and Emacs, Vim &amp; IPython.</t>
<t tx="ekr.20131001100335.15943">- Leo has shamelessly stolen all of Emacs's most important features: long
  command names, the minibuffer, typing completion and flexible key
  bindings.
  
- One set of Leo's default key bindings are similar to Emacs's defaults. If
  you like, editing text in Leo can feel exactly like editing text in
  Emacs.

- You script Leo in Python, not elisp.

- Emacs has no notion of nodes, cloned or otherwise. Emcas will never have
  anything like @file, @test, @button, @command or @url nodes (etc.!), not
  even in Emacs org-mode.
  
- Leo scripts have *easy* access all nodes via Leo's Document Object Model
  (DOM). Emacs has no DOM at all. In Emacs, everything is just text.
  
- Leo has no dired mode because it isn't needed. Once you have created an
  @file node (or @auto or @edit node), there is no need to drill down to
  that file.
</t>
<t tx="ekr.20131001100335.15944">- One set of Leo's default key bindings are similar to Vim's defaults. If
  you like, editing text in Leo can feel somewhat (not exactly) like
  editing text in Emacs.  Leo has a vim-like command mode, but it's
  still a work in progress.

- You script Leo in Python, not Vim's scripting language.

- Vim has no notion of nodes, cloned or otherwise. Vim will never have
  anything like @file, @test, @button, @command or @url nodes (etc.!), not
  even in Vim's outline-mode.
  
- Leo scripts have *easy* access all nodes via Leo's Document Object Model
  (DOM). Vim has no DOM at all; everything is just text.
</t>
<t tx="ekr.20131001100335.15945"></t>
<t tx="ekr.20131001100335.15946">.. index::
    pair: Minibuffer; Tutorial
    pair: Tab completion; Tutorial

Leo’s minibuffer appears at the bottom of Leo’s main window. You use the
minibuffer to execute commands by name, and also to accumulate arguments to
commands.

Alt-X (full-command) puts the cursor in the minibuffer.

You could type the full command name in the minibuffer, followed by the
&lt;Return&gt; key to invoke the command, but that would be *way* too much work.
Instead, you can avoid most typing using **tab completion**. With tab
completion, there is no need to remember the exact names of Leo’s commands.

For example, suppose you want to print out the list of Leo’s commands. You
might remember only that there are several related commands and that they
all start with "print". Just type::

    &lt;Alt-X&gt;pri&lt;Tab&gt;

You will see "print-" in the minibuffer. This is the longest common prefix
of all the command names that start with "pri". The Completion tab in the log pane
shows all the commands that start with "print-".

Now just type "c&lt;Tab&gt;" and you will see the print-commands command in the
minibuffer.

Finally, &lt;Return&gt; executes the command.

The output of the print-commands command appears in the commands tab, and
focus returns to the body pane.

Summary:

- &lt;Return&gt; executes the command
- &lt;Tab&gt; shows all valid completions.
- &lt;BackSpace&gt; shows more alternatives.
- Ctrl-G exits the minibuffer and puts focus in the body pane.
</t>
<t tx="ekr.20131001100335.15947">F1 (help) shows a help message appears in the viewrendered pane.
Alt-0 (vr-toggle) hides or shows this pane.

F11 (help-for-command) shows the documentation for any Leo command. F11
prompts for the name of a Leo command in the minibuffer. Use tab completion
to see the list of all commands that start with a given prefix.

F12 (help-for-python) shows the documentation from Python's help system.
Typing completion is not available: type the full name of any Python
module, class, function or statement.

These commands clarify which settings are in effect, and where they came
from::

    print-bindings
    print-settings

These commands discuss special topics::

    help-for-abbreviations
    help-for-autocompletion
    help-for-bindings
    help-for-debugging-commands
    help-for-dynamic-abbreviations
    help-for-find-commands
    help-for-minibuffer
    help-for-regular-expressions

Using Leo, especially for programming, requires some learning initially.
Please feel free to `ask for help`_ at any time.
</t>
<t tx="ekr.20131002055813.15973">Here is a slightly reduced screenshot of Leo's main window:

.. image:: images/screen-shots/render-svg-sources.png
   :alt: Screenshot
   :scale: 80 %
   
.. index::
    pair: Body pane; Tutorial
    pair: Expansion box; Tutorial
    pair: Icon area; Tutorial
    pair: Log pane; Tutorial
    pair: Main Window; Tutorial
    pair: Outline pane; Tutorial
    pair: Status line; Tutorial

Leo's main window consists of
an **icon area** just below the menus,
an **outline pane** at the top left,
a **log pane** at the top right,
a **body pane** at the bottom left,
and an optional **viewrendered pane** at the bottom right.
The **minibuffer** and **status line** lie at the bottom of the main window.

The log pane contains several tabs. The **Log tab** shows messages from
Leo, the **Find Tab** shows the status of Leo's Find/Replace commands.
Other tabs may also appear in the log pane: The **Spell Tab** controls
Leo's spell-checking. The **Completion Tab** shows available typing
completions.

.. index::
    pair: Icon box; Tutorial
    pair: Node; Tutorial
    pair: Headline; Tutorial
    pair: Body text; Tutorial

Leo stores all data in **nodes**. Nodes have **headlines**, shown in
the outline pane, and **body text**. The body pane shows the body text of
the **presently selected node**, the node whose headline is selected in the
outline pane.  Headlines have an **icon box** indicating a nodes status.
For example, the icon box has a black border when the node has been changed.
</t>
<t tx="ekr.20131002055813.19036">You may select, expand and contract outline nodes with the mouse as usual,
but using arrow keys is *highly recommended*.

When focus is in the outline pane, *plain* arrows keys change the selected node:

- Right-arrow (expand-and-go-right) expands a node or selects its first child.
- Left-arrow (contract-or-go-left) contracts a node if its children are visible,
  and selects the node's parent otherwise. 
- Up-arrow (goto-prev-visible) selects the previous *visible* outline node.
- Down-arrow (goto-next-visible) selects the next *visible* outline node.
  
When focus is in the outline pane, Shift-arrow keys move the selected node
in the direction of the arrow, if possible.

Regardless of focus, Alt-arrow and Alt-Shift-arrow keys work on outline nodes:

- Alt-Home (goto-first-visible-node) selects the first outline node.
- Alt-End (goto-last-visible-node) selects the last *visible* outline node.
- Alt-arrow keys select the outline pane, and then act just like the plain
  arrow keys when the outline pane has focus.
- Alt-Shift-arrow keys select the outline pane and move the selected node.

The following commands work anywhere, regardless of focus:

- Ctrl-D (move-outline-down) moves the selected node down.
- Ctrl-L (move-outline-left) moves the selected node left.
- Ctrl-R (move-outline-right) moves the selected node right.
- Ctrl-U (move-outline-up) moves the selected node up.
</t>
<t tx="ekr.20131002055813.19037">When focus is in any of Leo's text panes (body pane, log pane, headlines),
Leo works like most text editors:

- Plain arrow keys move the cursor up, down, left or right.
- Ctrl-LeftArrow and Ctrl-RightArrow move the cursor by words.
- Home and End move the cursor to the beginning or end of a line.
- Ctrl-Home moves the cursor to the beginning of the body text.
- Ctrl-End moves the cursor to the end of the body text.
- PageDown and PageUp move the cursor up or down one page.

**Note**: As usual, adding the Shift key modifier to any of the keys above
moves the cursor and extends the selected text.
</t>
<t tx="ekr.20131002055813.19835">Ctrl-I or Insert (insert-node) inserts a new node into the outline.

Regardless of focus, Ctrl-H (edit-headline) begins editing the headline of
the selected node.  |br|
When editing a headline, &lt;Return&gt; (end-edit-headline) ends the editing,
leaving the focus in the body pane.

Ctrl-Shift-C (copy-node) copies the outline and all it's descendants,
placing the node on the clipboard. |br|
Ctrl-Shift-X (cut-node) cuts the outline and all its descendants, placing
the node on the clipboard. |br|
Ctrl-Shift-V (paste-node) pastes a node (and its descendants) from the
clipboard after the presently selected node.

Ctrl-{ (promote) makes all the children of a headline siblings of the
headline. |br|
Ctrl-} (demote) makes all following siblings of a headline children of the
headline. |br|
The demote and promote commands are useful for gathering nodes together before
moving or cutting them.

Ctrl-M (mark) toggles the mark on a node. |br|
Marked nodes have a vertical red bar in their icon area.
</t>
<t tx="ekr.20131002055813.19837">Leo has unlimited undo--Leo remembers *all* changes you make to outline
structure or the contents of any node since you restarted Leo.

Ctrl-Z (undo) undoes the last change. Another Ctrl-Z undoes the
previous change, etc. 

Ctrl-Shift-Z (redo) undoes the effect of the last undo, etc.

The first two entries of the Edit menu show what the next undo or redo
operation will be.
</t>
<t tx="ekr.20131002211347.6456">.. index::
    pair: Command name; Tutorial

Every Leo command has a **command name**. In this document, keystrokes that
invoke a command will be followed by the command name in parentheses.

For example, Ctrl-S (save-file) saves a Leo file.

The full-command (Alt-X) command executes any other command by typing its
full name. For full details see `The minibuffer &amp; completions`_.
</t>
<t tx="ekr.20131003040744.18221">.. index::
    pair: @file node; Tutorial
    
Leo stores outline data on your file system in **.leo files**.

Rather than storing all your data in the .leo file, you may store parts of
your outline data in **external files**, files on your file system.

**@file nodes** create external files. @file nodes have headlines starting
with @file followed by a file name::

    @file leoNodes.py
    @file ../../notes.text
    
.. index::
    pair: Dirty node; Tutorial

Leo reads external files automatically when you open Leo outline, and
writes all **dirty** (changed) external files when you save any Leo
outline.

.. index::
    pair: @all; Tutorial
    pair: Outline Order; Tutorial

The **@all** directive tells Leo to write the **@file tree** (the @file
node and all its descendants) to the external file in **outline order**,
the order in which the nodes appear in the outline pane when all nodes are
expanded. Non-programmers will typically use the @all directive;
programmers typically use the @others directive, as discussed in the
`programming tutorial`_.

.. index::
    pair: Sentinel Comments; Tutorial
    pair: Sentinel Lines; Tutorial

When writing @file nodes, Leo adds **sentinel comments** to external files.
Sentinels embed Leo's outline structure into external files.

If you don't want sentinels in your sources, skip head to
the `Using @auto nodes`_ part of Leo's `programming tutorial`_.
</t>
<t tx="ekr.20131003040744.18222">.. index::
    pair: Section Name; Tutorial
    pair: Section Definition Node; Tutorial
    pair: Section Reference; Tutorial
    pair: Expansion; Tutorial
    pair: Markup; Tutorial
    pair: @others; Tutorial
    
Simple markup,the @others directive, and section references, tell Leo how
to create external files.

Before going into terminology and explanations, let's look at a
step-by-step example:

1. Create a new outline node whose headline is::

    @file myfile.py

2. Type this in @file node's body::
    
    @language python
    @tabwidth -4
    &lt;&lt; docstring &gt;&gt;
    @others
    if __name__ == '__main__':
        main()

3. Create a child of the @file node whose headline is::
   
   &lt;&lt;docstring &gt;&gt;

4. Type this in the child's body text::

    '''
    This is the docstring for this python module.
    '''
    
5. Create another child of the @file node, with the headline::

    main
    
6. Type this in the body::

    def main():
        print('hello from main')
        
7. Saving the outline will create myfile.py automatically.

8. Open myfile.py in an external editor. |br|
   Comments in this file represent Leo directives and Leo's outline structure.

9. (Optional) Run myfile.py with a python interpreter.
   
.. You will see something like::
..
    #@+leo-ver=5-thin
    #@+node:ekr.20131023081456.2537: * @file myfile.py
    #@@language python
    #@@tabwidth -4
    #@+&lt;&lt; docstring &gt;&gt;
    #@+node:ekr.20131023081456.2538: ** &lt;&lt; docstring &gt;&gt;
    '''
    This is the docstring for this python module.
    '''
    #@-&lt;&lt; docstring &gt;&gt;
    #@+others
    #@+node:ekr.20131023081456.2539: ** main
    def main():
        print('hello from main')
    #@-others
    if __name__ == '__main__':
        main()
    #@-leo

Now let's find out how all this works.

**Essential Terms**:

- A **section name** is any text of the form: &lt;&lt; any text &gt;&gt;.
  (&gt;&gt; must not appear in "any text".)
- A **section definition node** is any node whose headline starts with a
  section name.
- A **section reference** is a section name that appears in body text.

Leo creates external files containing @others directives by writing the
*expansion* of the @file node. |br|
The **expansion** of *any* node is
the node's body text after making these text **substitutions**:

1. Leo replaces @others with the *expansion* of all descendant nodes
   **except** section definition nodes. That's how @others got its name.

2. Leo replaces section references by the *expansion* of the body text of
   the corresponding section definition node.
   
Whitespace is significant before @others and section references. Leo adds
the leading whitespace appearing before each @others directive or section
reference to every line of their expansion. As a result, Leo can generate
external files even for Python.  The following cute trick works::

    if 1:
        &lt;&lt; a section &gt;&gt;
    if 0:
        @others

**Notes**:

- Any node may contain a single @others directive. No node may contain more
  than one @others directive.

- Nodes that *aren't* section definition nodes are included in the expansion
  of the *nearest* ancestor node containing an @others directive.
  
.. index::
    pair: Orphan Node; Tutorial

- An **orphan node** is a descendant of an @file node not included in any
  substitution. Leo refuses to write external files containing orphan
  nodes. Instead, Leo writes the @file tree to the .leo file itself,
  thereby preserving all data.

**Example 1**: The body of the @file node for a typical Python module will
look something like::

    '''A docstring.'''
    &lt;&lt; imports &gt;&gt;
    @others
    if __name__ == '__main__':
        main()
        
**Example 2**:  Here is a typical Python class definition in Leo::

    class MyClass:
        '''A docstring.'''
        @others
</t>
<t tx="ekr.20131003040744.18223">As a newbie who still has zero knowledge of Leo's technical details, I can
say: I have absolutely no problem in conceptualizing what Leo is and what
it can do, and probably I also get the Leo's aha -- the difficulty is in
getting into the actual technical aspects of the program. Again, in the end
this all boils down to newbie-friendly tutorials and learning materials...
Something like Leo for dummies would be greatly appreciated.

</t>
<t tx="ekr.20131004064408.16020">.. index::
   pair: Directive; Tutorial

**Directives** control Leo's operations.
Directives start with '@' in the leftmost column.

Directives may appear either in headlines or body text.

When people speak of an @x node, they are implying that the headline starts
with @x. If a node contains an @x directive (in the body pane), they will
usually say something like, "a node containing an @x directive".

Directives apply until overridden by the same (or related) directive in a
descendant node.

Some commonly used general-purpose directives:

.. index::
    pair: @color; Tutorial
    pair: @nocolor; Tutorial
    pair: @killcolor; Tutorial

::

    @color
    @killcolor
    @nocolor

These control whether to syntax color text. 

Nodes may contain multiple color directives.

Nodes containing multiple color directives do not affect coloring of
descendant nodes.
    
.. index::
    pair: @language; Tutorial

::

    @language python
    @language c
    @language rest # restructured text
    @language plain # plain text: no syntax coloring.
    
These control which language to use when syntax coloring text.

.. index::
    pair: @pagewidth; Tutorial
    
::

    @pagewidth 100
    
Sets the page width used when formatting paragraphs.

.. index::
    pair: @tabwidth; Tutorial
    pair: Negative tab width; Tutorial

::

    @tabwidth -4
    @tabwidth 8
    
Sets the width of tabs.

Negative tab widths cause Leo to convert tabs to
spaces and are highly recommended for Python programming.

.. index::
    pair: @wrap; Tutorial
    pair: @nowrap; Tutorial
    
::

    @nowrap
    @wrap

These enable or disable line wrapping in the body pane.
</t>
<t tx="ekr.20131004073415.16044">.. index::
    pair: Clone; Tutorial
    
A **clone** is a node that appears in more than one place in a Leo outline. |br|
Clones are marked with a small red arrow in its icon box.

.. .. image:: images/box13.GIF
..    :scale 200 %
..    :alt: Leo Icon Box With Clone Mark

All clones of a node are actually *the same node*. |br|
Any change to one clone affects all clones. |br|
Inserting, moving or deleting any child of a clone will change all other clones on the screen.

Clones allow data to be stored in *arbitrarily many* places within an outline.

Please take a few moments to experiment with clones:

- Create a node whose headline is A.
- Ctrl-` (clone-node) clones node A.
- Type some text into the body of A.
- All clones of A now have the same body.
- Insert a node, say B, as a child of any of the A nodes.
- All the A nodes now have a B child.
- See what happens if you clone B.
- See what happens if you insert, delete or move nodes that are children of A.
- When you delete a node's penultimate clone,
  the last clone becomes a regular node again.

</t>
<t tx="ekr.20131004191204.16079">Alt-0 (vr-toggle) hides or shows the viewrendered pane.

&lt;Return&gt; puts focus in the body when it is in the outline pane. |br|
Alt-T (focus-to-tree) puts focus in the outline pane.  |br|
Ctrl-T (toggle-active-pane) toggles focus between the outline and body panes.

You may open multiple Leo outlines in different tabs within the same main
window. |br|
Ctrl-Tab (tab-cycle-next) switches between outline tabs.

Ctrl-N (new) creates a new outline in a new tab. |br|
Ctrl-O (open-outline) opens an existing .leo file. |br|
Ctrl-S (save-file) saves the outline. |br|
Ctrl-Q (exit-leo) exits Leo.  Leo will prompt you to save any unsaved outlines.
</t>
<t tx="ekr.20131005214621.16081"></t>
<t tx="ekr.20131005214621.16089">Leo uses a TOC that *looks* like a Sphinx toc but is built by hand.</t>
<t tx="ekr.20131005214621.16090">- Every command has a name.
- You may execute any command by name from the minibuffer.
- Many commands are bound to keystrokes.
- You may bind multiple keystrokes to a single command and change bindings to your taste.
- Leo has commands to create, change and reorganize outlines.
- Within the body pane, Leo uses standard key bindings to move the cursor.
- Ctrl-F starts the find command. Use the minibuffer to complete the command.
- Leo's configuration files specify all settings, including key bindings.
- Leo directives control how Leo works.
- @all creates an external file from all the nodes of an outline.
- Enable plugins using @enabled-plugins nodes in an @settings tree.
</t>
<t tx="ekr.20131005214621.16128">.. _`the rst3 chapter`: rstplugin3.html

- The rst3 command converts an @rst tree to an output file and
  an intermediate file.

- docutils uses the output file; sphinx uses the intermediate file.

- Settings starting with "rst3" control how the rst3 command works.

- Within @rst trees, headlines become rST sections.

- Sections levels in the generated rST correspond to outline levels in Leo.

- You reorganize your rST documents just by reorganizing the corresponding @rst tree.
  
- The rst3 command works acts on the nearest ancestor @rst node, if any, or
  on all descendant @rst nodes.
  
- @rst-no-head nodes insert text (or markup) without an rST headline.

- The rst3 command ignores @rst-ignore nodes and @rst-ignore-tree trees.

- The @button make-sphinx node in LeoDocs.leo calls sphinx automatically.

- CheatSheet.leo contains an expanded version of the example used in this
  tutorial. You can open CheatSheet.leo from Leo's help menu.
  
- The rst3 command provides *many* other capabilities. For details, see
  `the rst3 chapter`_.
  
</t>
<t tx="ekr.20131005214621.16130">This is a reference for all of Leo's directives.

This sections assumes you are *thoroughly* familiar with `Leo's tutorial`_.

</t>
<t tx="ekr.20131007143750.16070">#################
Leo's Cheat Sheet
#################

.. |br| raw:: html

   &lt;br /&gt;
   
.. _`Directives reference`: directives.html
.. _`Commands Reference`: commands.html
.. _`userAttributes`: customizing.html#adding-extensible-attributes-to-nodes-and-leo-files
.. _`Customizing Leo`: customizing.html

.. contents::
    :depth: 4
</t>
<t tx="ekr.20131007143750.16074">This section lists the ivars, properties, functions and methods most
commonly used in Leo scripts.

**Very important**: use Alt-1 (toggle-autocompleter) and Alt-2
(toggle-calltips) to recreate these lists as you type.
</t>
<t tx="ekr.20131007143750.16111"></t>
<t tx="ekr.20131008041326.16053">A plugin is a Python file in Leo's plugins folder.

Every plugin should have a top-level init function that returns True if the
plugin has been initialized properly. The init function typically:

1. Registers an onCreate event handler, called when Leo creates a new window.
2. Calls g.plugin_signon(__name__)

For example::

    def init():
        if &lt;&lt; all imports successful &gt;&gt;:
            g.registerHandler('after-create-leo-frame',onCreate)
            g.plugin_signon(__name__)
            return True
        else:
            return False
   
Plugins do *not* have automatic access to c, g and p.

Plugins define g by importing it::

    import leo.core.leoGlobals as g
    
Plugins gain access to c using event handlers::

    controllers = {}
    
    def init():
        g.registerHandler('after-create-leo-frame',onCreate)
        return True
        
    def onCreate (tag, keys):
        global controllers
        c = keys.get('c')
        if c:
            hash = c.hash()
            if hash not in controllers.keys():
                controllers(hash) = PluginController(c)
            
    def eventHander(tag,keys):
        global controllers
        c = keys.get('c')
        if c:
            controller = controllers.get(c.hash())
            controller.handleEvent()
            
Some plugins inject ivars into the Commands class rather than using
a global controllers dict::

    def onCreate (tag, keys):
        c = keys.get('c')
        if c:
            c.my_plugin_controller = ControllerClass(c)
            
    def eventHander(tag,keys):
        c = keys.get('c')
        if c:
            c.my_plugin_controller.handleEvent()

Once c is determined, the presently selected position is simply c.p.
</t>
<t tx="ekr.20131008041326.16054">.. index::
    pair: @first; Tutorial
    pair: @last; Tutorial

The @first directive forces lines to appear before the first sentinel of a
external file. For example::

    @first #! /usr/bin/env python
    @first # -*- coding: utf-8 -*-

Similarly, @last forces lines to appear after the last sentinel.
</t>
<t tx="ekr.20131008041326.16055">.. index::
    pair: @path; Tutorial

Rather than specifying long paths in @file nodes, you can specify a path in
an ancestor @path node.

For example, suppose three nodes have the following headlines::

    @path a
        @path b
            @file c/d.py

The @file node creates the file a/b/c/d.py

Within @path and @&lt;file&gt; paths, {{exp}} gets evaluated with the following
predefined symbols: c, g, p, os and sys.  For example::

    @file {{os.path.abspath(os.curdir)}}/abc.py
</t>
<t tx="ekr.20131008041326.16056">Use @auto instead of @file when you don't want to add sentinels in the file.

.. index::
    pair: @auto; Tutorial
    pair: Importer; Tutorial

When reading @auto files, Leo **importers** create an outline from the
external file. Importers create nodes for each class, method and function
in the external file.

Notes:

- Leo determines the language using the file's extension.

- Importers exist for C, C#, elisp, html, .ini files, Java, Javascript,
  Pascal, PHP, Python, TypeScript, vimoutliner files and xml.

- If no importer exists for a file, Leo reads the entire file into an @edit
  node.
</t>
<t tx="ekr.20131008041326.16058">.. index::
    pair: @test Node; Tutorial

Leo's unit test commands (&lt;Alt-X&gt;run&lt;tab&gt; gives the full list)
create unit tests from the body text of @test nodes.

- The headline gives the name of the test::

    @test test that g is predefined
    
- The body contains the unit test::

    assert g
    
- The unit test commands convert the body to a subclass of
  unittest.TestCase.  This saves a lot of typing.
  
- The unit test commands predefine c, g, and p as usual.

- 'self' is predefined as the test itself, that is, the instance of
  unittest.TestCase created by the @test node. For example::
  
    self.assertTrue(g)

.. _`Leo's unit-testing reference`: unitTesting.html
    
For more details, see `Leo's unit-testing reference`_.
</t>
<t tx="ekr.20131008041326.16066">Clones are nodes appearing multiple places in the outline.

    - Changes to one clone affect all other clones.
    - All clones of a node are *exactly the same node*.

Views allow multiple views of data to exist in a single outline.

    - A view is simply a collection of nodes.
    - Because of clones, a node may appear in many views at once.
    - View focus attention on tasks and reduce searching for nodes.

Leo expands abbreviations as you type.

    - Abbreviations range from simple shortcuts to multi-line templates
      containing fields.
    - Type ",," to move to the next field.
    - Abbreviations can also insert the result of executing code.
    
Ctrl-left-clicking any URL opens the URL.
</t>
<t tx="ekr.20131008041326.16079">#############
Preliminaries
#############

.. toctree::
   :maxdepth: 2
   
   preface
   testimonials
   acknowledgements
   license

.. ..  :titlesonly: </t>
<t tx="ekr.20131008041326.16080">Do *not* nest any @rst nodes.</t>
<t tx="ekr.20131008041326.16082">.. |---| unicode:: U+02015
   :trim:

#################
Leo's Users Guide
#################

.. _`Leo Tutorial`: tutorial.html

.. epigraph::

   I have been absolutely seduced by Leo over the past few days. I tell you, I can not put it down. I feel like a kid with a shiny new bike...I'm already bursting with new ways I'd like to use the tool in the future.
   
   --Lyn Adams Headley

    
This is Leo's Users Guide. It covers additional material not covered in the
`Leo Tutorial`_.

.. toctree::
   :maxdepth: 2

   customizing
   rstplugin3
   plugins
   commands
   directives

</t>
<t tx="ekr.20131008041326.16091"></t>
<t tx="ekr.20131008041326.16092"></t>
<t tx="ekr.20131008041326.16094">##############
Installing Leo
##############

.. Links used in this document...

.. _`Leo's download page`:  http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106
.. _`Leo's help forum`:     http://groups.google.com/group/leo-editor
.. _`PyEnchant`:            https://sourceforge.net/projects/pyenchant/
.. _`PyQt`:                 http://www.riverbankcomputing.com/software/pyqt/intro
.. _`Python`:               http://www.python.org
.. _`Running Leo`:          running.html
.. _`ask for help`:         https://groups.google.com/forum/#!forum/leo-editor
.. _`git`:                  http://git-scm.com/
.. _`GitHub`: https://github.com/leo-editor

.. index:: Installing Leo

This chapter tells how to install and run Leo on Windows or Linux.
Leo can be installed on MacOS, but the process is difficult and not recommended.

**Important**: If you have *any* problems installing Leo,
please ask for help on `Leo's help forum`_.

.. contents::
    :depth: 4
    
</t>
<t tx="ekr.20131008041326.16099">###################
Advanced Topics
###################

.. toctree::
   :maxdepth: 2

   coloring
   writingPlugins
   unitTesting
   debuggers
   
.. toctree::
   :maxdepth: 1

   atShadow
   scripting-miscellany
   theory
   vim-theory
   leonine-world
</t>
<t tx="ekr.20131008041326.16100">######################
Leo and Other Programs
######################

.. toctree::
   :maxdepth: 2

   emacs
   vimBindings
   leoBridge
   IPythonBridge
   zodb

</t>
<t tx="ekr.20131008041326.16140">##############
Running Leo
##############

.. index:: Running Leo

This chapter tells how to run Leo and discusses Leo's command-line
options.

.. contents::
    :depth: 2
    
</t>
<t tx="ekr.20131008041326.16151">You can run Leo from a Python interpreter as follows::

    import leo
    leo.run() # runs Leo, opening a new outline or,
    leo.run(fileName=aFileName) # runs Leo, opening the given file name.

Another way to run Leo is as follows::

    cd &lt;path-to-launchLeo.py&gt;
    python launchLeo.py %*

Here are some tips that may make running Leo easier:

**Linux**
    
The following shell script will allow you to open foo.leo files by typing leo foo::

    #!/bin/sh 
    python &lt;leopath&gt;launchLeo.py $1

where &lt;leopath&gt; is the path to the directory containing the leo directory. 

**Windows**

You can associate Leo with .leo files using a batch file. Put the
following .bat file in c:\\Windows::

    &lt;path-to-python&gt;/python &lt;path-to-leo&gt;/launchLeo.py %*

Here &lt;path-to-leo&gt; is the path to the directory *containing* the leo directory,
that is, the directory containing launchLeo.py.
</t>
<t tx="ekr.20131008041326.16152">The first time you start Leo, a dialog will ask you for a unique identifier. If
you are using a source code control system such as git, use your git login name.
Otherwise your initials will do.

Leo stores this identifier in the file .leoID.txt. Leo attempts to create
leoID.txt in the .leo sub-directory of your home directory, then in Leo's config
directory, and finally in Leo's core directory. You can change this identifier
at any time by editing .leoID.txt.
</t>
<t tx="ekr.20131008041326.16153" rst_http_attribute="5d71002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710158040000003c2f613e71025d71032858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710458060000003c2f6469763e71055d710628584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710758060000003c2f6469763e71085d710928583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a58060000003c2f6469763e710b5d710c2858060000003c626f64793e710d58070000003c2f626f64793e710e5d710f2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711058070000003c2f68746d6c3e71114e656565656558070000003c2f6469763e0a711258070000003c2f6469763e0a711358350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e">On startup, Leo looks for two arguments of the form::

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's Execute Script command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling app.log.disable or app.log.enable

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body
and Edit Headline commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file::

    path = r"&lt;path-to-folder-containing-the-leo-folder&gt;\\leo\\test\\test.leo"

    g.app.log.disable() # disable reading messages while opening the file
    flag,newFrame = g.openWithFileName(path,None)
    g.app.log.enable() # re-enable the log.

    for p in newFrame.c.all_positions():
        g.es(g.toEncodedString(p.h,"utf-8"))
</t>
<t tx="ekr.20131008041326.16154">Leo sends more detailed error messages to stderr,
the output stream that goes to the console window. In Linux and MacOS
environments, python programs normally execute with the console window visible.
On Windows, can run Leo with the console window visible by associating .leo
files with python.exe *not* pythonw.exe. 

.. For full instructions about how
.. to do this, see `Associating Leo with .leo Files`_.
</t>
<t tx="ekr.20131008041326.16155">Python's HOME environment variable specifies Leo's HOME directory.
See http://docs.python.org/lib/os-procinfo.html for details.

Leo uses os.expanduser('~') to determine the HOME directory if no HOME environment variable exists.

Leo puts several files in your HOME/.leo directory:
.leoID.txt, .leoRecentFiles.txt, and myLeoSettings.leo.
</t>
<t tx="ekr.20131008041326.16156">Leo supports the following command-line options. As usual, you can see the
list by typing the following in a console window::

    leo -h

or::

    leo --help

You will get something like the following::

    Usage: launchLeo.py [options]
    
    Options:
      -h, --help            show this help message and exit
      --fullscreen          start fullscreen (Qt only)
      --ipython             enable ipython support
      --gui=GUI             gui to use (qt/qttabs)
      --maximized           start maximized (Qt only)
      --minimized           start minimized
      --no-cache            disable reading of cached files
      --no-plugins          disable all plugins
      --no-splash           disable the splash screen
      --screen-shot=SCREENSHOT_FN
                            take a screen shot and then exit
      --script=SCRIPT       execute a script and then exit
      --script-window=SCRIPT_WINDOW
                            open a window for scripts
      --select=SELECT       headline or gnx of node to select
      --session-restore     restore previously saved session tabs at startup
      --session-save        save session tabs on exit
      --silent              disable all log messages
      -v, --version         print version number and exit
      --window-size=WINDOW_SIZE
                            initial window size in height x width format
</t>
<t tx="ekr.20131008041326.16176">##################
Designing with Leo
##################

This chapter discusses how outlines can improve the design of programs, web sites and any other complex data. The more complex your program or data, the more useful Leo becomes.

Furthermore, the same features that help with design also help with implementation, maintenance and testing. In all cases, being able to organize, understand and manipulate (script) complex data is what Leo does best.

.. contents::
    :depth: 2

</t>
<t tx="ekr.20131008041326.16177">This section discusses the most important milestones in history of Leo.

..  .. contents::
    ..  :depth: 2
</t>
<t tx="ekr.20131008041326.16178"></t>
<t tx="ekr.20131008041326.16203">.. |---| unicode:: U+02015
   :trim:

##################
The Basics of Leo
##################

..epitaph::

   Edward... you've come up with perhaps the most powerful new concept in code manipulation since VI and Emacs.
    
    --David McNab

This chapter introduces Leo's basic operations for creating and changing outlines. Commands can be executed using keystrokes, or by
name.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20131008041326.16204">.. |br| raw:: html

   &lt;br /&gt;

.. _Leo:                    http://leoeditor.com/
.. _`ask for help`:         https://groups.google.com/forum/#!forum/leo-editor
.. _`programming tutorial`: tutorial-programming.html
.. _`Using @auto nodes`:    tutorial-programming.html#using-auto-nodes
.. _`plugins section`:      tutorial-basics.html#plugins

.. _`Leo plugins`:      plugins.html
.. _`bookmarks.py`:     plugins.html#bookmarks-py
.. _`contextmenu.py`:   plugins.html#contextmenu-py
.. _`mod_scripting.py`: plugins.html#mod-scripting-py
.. _`quicksearch.py`:   plugins.html#quicksearch-py
.. _`todo.py`:          plugins.html#todo-py
.. _`valuespace.py`:    plugins.html#valuespace-py
.. _`viewrendered.py`:  plugins.html#viewrendered-py

</t>
<t tx="ekr.20131008041326.16222">.. |---| unicode:: U+02015 .. for quotes
   :trim:
   
###########################################
Using Leo as a Personal Information Manager
###########################################

    "Cloning is pure genius!"---Michael Manti

    "If you are like me, you have a kind of knowledge base with infos
    gathered over time. And you have projects, where you use some of those
    infos. Now, with conventional outliners you begin to double these
    infos, because you want to have the infos needed for the project with
    your project. With Leo you can do this too, but if you change text in
    one place **it is updated in the other place too!** This is a feature I
    did not see with any other outliner (and I tried a few). Amazing! Leo
    directly supports the way I work!"---F. Geiger

This chapter tells how you can use Leo as a Personal Information Manager.
It introduces `clones`_: one of Leo's most unusual and powerful features
for organizing data.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20131008041326.16241">.. |---| unicode:: U+02015 .. for quotes
   :trim:
   
.. |br| raw:: html

   &lt;br /&gt;

########################################
Creating Documents with the rst3 Command
########################################

.. _`LaTeX`:    http://www.latex-project.org/
.. _`Python's`: http://www.python.org/
.. _`Sphinx`:   http://sphinx-doc.org/
.. _`Sphinx documentation`: http://sphinx-doc.org/contents.html
.. _`docutils`: http://docutils.sourceforge.net
.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html
.. _`rST primer`: http://sphinx-doc.org/rest.html
.. _`first tutorial`: tutorial-basics.html

    "I am a huge fan of Leo. I think it's quite possibly the most
    revolutionary programming tool I have ever used and it (along with the
    Python language) has utterly changed my view of programming (indeed of
    writing) forever."---Shakeeb Alireza
    
Leo's rst3 command converts Leo trees containing `reStructuredText`_ (rST)
or `Sphinx`_ markup to HTML, PDF, `LaTeX`_ and other kinds of output files.
This tutorial gives step-by-step instructions for using the rst3 command.

**Prerequisites**: Please make sure you have read the `first tutorial`_ before reading this
one. If you are new to rST, please read the `rST primer`_. For full
information about Sphinx, please read the `Sphinx documentation`_.

The rst3 command makes using rST or Sphinx *much* easier by automatically
creating underlining for rST sections. To reorganize a document, just
reorganize the corresponding Leo outline: you don't have to change
underlining characters by hand.

The tutorial covers only the basic features of the rst3 command. This is
enough to generate all of Leo's documentation! 

CheatSheet.leo contains an expanded version of the example used in this
tutorial. You can open CheatSheet.leo from Leo's help menu.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20131008041326.16245">.. |---| unicode:: U+02015 .. for quotes
   :trim:
   
####################
Programming with Leo
####################

.. _`ask for help`: https://groups.google.com/forum/#!forum/leo-editor

    "We who use Leo know that it is a breakthrough tool and a whole new way
    of writing code."---Joe Orr

Now we come to the programming features that distinguish Leo from all other
programming environments. This part tells how to create external files from
Leo outlines.

Please study this section carefully if you intend to use Leo for programming.

If you get stuck, please `ask for help`_ immediately.

.. contents::
    :depth: 2
</t>
<t tx="ekr.20131008041326.16246">- Leo creates external files by replacing @others and section references
  with their expansions. 
  
- A **section name** is any text of the form: &lt;&lt; any text &gt;&gt;.

- A **section definition node** is a node whose headline starts with a section name.

- A **section reference** is a section name in body text.

- @first places lines before the first sentinel lines of a file.

- @path specifies a common prefix for the file names of @file and @auto nodes.

- @edit reads an entire external file into a single outline node.

- @auto imports an external file into an outline, creating nodes for
  functions, methods and classes.
  
- Use @edit or @auto to avoid adding Leo sentinels to external files.

- leo/core/LeoPyRef.leo contains all of Leo's core source code.</t>
<t tx="ekr.20131008041326.16248">.. |br| raw:: html

   &lt;br /&gt;

</t>
<t tx="ekr.20131008041326.16252">.. |br| raw:: html

   &lt;br /&gt;

.. _`event handlers`:
.. _`Leo's scripting chapter`:</t>
<t tx="ekr.20131008041326.16253">.. _`PyQt`: http://www.riverbankcomputing.com/software/pyqt/intro

Leo 4.9 featured the completed transition to the `PyQt`_ application
framework, the introduction of the viewrendered pane, and
autocompletion.
</t>
<t tx="ekr.20131008041326.16341">##########
Appendices
##########
   
.. contents::
    :depth: 3
</t>
<t tx="ekr.20131009050634.17610"></t>
<t tx="ekr.20131009050634.17616"></t>
<t tx="ekr.20131009050634.17622"></t>
<t tx="ekr.20131009050634.17623"># Used only if generate_rst is True.</t>
<t tx="ekr.20131009050634.17625"># True: generate rst markup from @code and @doc parts.</t>
<t tx="ekr.20131009050634.17627"># True: generate rst markup. False: generate plain text.</t>
<t tx="ekr.20131009050634.17630"># Can be set by @rst-no-head headlines.</t>
<t tx="ekr.20131009050634.17631"></t>
<t tx="ekr.20131009050634.17658"></t>
<t tx="ekr.20131009052848.6456"></t>
<t tx="ekr.20131009065148.31758">####################
Directives Reference
####################

.. contents::
    :depth: 2
</t>
<t tx="ekr.20131009065148.31760">#########################
Exploring Leo's Code Base
#########################

.. |br| raw:: html

   &lt;br /&gt;
   
This chapter is for anyone who wants to understand Leo's code base,
including those who want to be one of Leo's implementors.

You already know that leoFind.py and leoUndo.py implement Leo's find and
undo command, and so on.

This chapter focuses on the *process* of finding your way around Leo's
code, not the myriad details you will find within Leo's code.

It's actually very easy! Try it. You'll see.

Reading this chapter should take about 20 minutes.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20131009100732.16737">.. index::
    pair: URL; Tutorial
    pair: @url; Tutorial

Leo highlights URLs whenever syntax is coloring is enabled.

Ctrl-Left-Click (open-url-under-cursor) opens the URL under the cursor.

The open-url command opens a URL appearing either in the 
headline or the first line of body text.

If a headline starts with @url, the rest of the headline is take to be a url.

Leo opens URLs that look like file names using os.startfile. |br|
Leo opens all other URLs with your default web browser. |br|
Any scheme (http, mailto, ftp, file, etc.) supported by your browser is valid.

.. _`See the Appendix`: appendices.html#valid-url-s

URL's should contain no spaces: use %20 instead of spaces. |br|
`See the Appendix`_ for a complete description of valid URLs.
</t>
<t tx="ekr.20131009100732.16748">.. index::
    pair: @rst Node; Tutorial
    
1. Create a node someplace in your outline.

2. Type this in the headline::

        @rst myDocument.html
        
The @rst node, and all its descendants, represents your document.</t>
<t tx="ekr.20131009100732.16750">Put something like this in the body of the @rst node::

    #############
    War and Peace
    #############
    
rST markup uses over/underlining to indicate chapter titles. Put a
**overline** consisting of pounds signs above the title (War and Peace),
and an identical **underline** of pound signs below as shown. rST markup
for chapter titles is a bit picky:

- under/overlines must be at least 4 characters long
- under/overlines must be at least as long as the title.
- The overline and underline must be identical.

In addition, the rst3 command requires that the "#" character be used in
the over/underlines for chapter titles.</t>
<t tx="ekr.20131009100732.16751">Now you write your novel, short story, documentation or whatever. Organize
your work as always:

    **nodes create sections, subsections, sub-sub-sections, etc.**, |br|
    **depending on their position in the outline**.
</t>
<t tx="ekr.20131009100732.16752">.. index::
    pair: rst3 Command; Tutorial

&lt;Alt-X&gt;rst3&lt;Return&gt; runs the rst3 command.

- If the present node is an @rst node, or a descendant node of an @rst
  node, the rst3 command applies to the nearest ancestor @rst node.

- Otherwise, the rst3 command applies to all descendant @rst trees.

.. _`this section`: tutorial-basics.html#configuring-leo

If @bool rst3_call_docutils is True, the rst3 command will call docutils
automatically to create the output files. For more information about
Leo settings, see `this section`_.

When using sphinx, run sphinx's "make" utility after running the rst3
command to create the final output files.

**Errors and warnings**:

1. Install docutils and then restart Leo if you see this error::

    writeToDocutils: docutils not present
    
2. ​Leo has a default stylesheet ​​that centers titles and makes them big and bold,
   so you can disregard messages such as::

    stylesheet not found &lt;path-to&gt;default.css
</t>
<t tx="ekr.20131009100732.16753">.. _`ask for help`: https://groups.google.com/forum/#!forum/leo-editor

You now know enough to get started with the rst3 command. Some possible
next steps are:

- Look at Leo's own documentation in LeoDocs.leo. Discover how the nodes in
  this tree correspond to the documentation you see before you.
   
- LeoDocs.leo has an @button make-sphinx script that calls sphinx
  automatically.

- Create your own @rst nodes. Run the rst3 command on them and see what
  happens. If you get stuck, please `ask for help`_.
</t>
<t tx="ekr.20131009100732.16754">Put the rst3_call_docutils setting in the @settings tree in the .leo file
containing the @rst node. This setting determines whether to use plain rST
markup or full sphinx markup. To use plain reStructuredText markup::

    @bool rst3_call_docutils = True
    
To use sphinx markup::

    @bool rst3_call_docutils = False
</t>
<t tx="ekr.20131009100732.16755">Sometimes you want to organize text without creating sections:

1. Create an outline node to organize your text.

2. Type the following in the headline::

    @rst-no-head &lt;any text: it is ignored&gt;
    
The rst3 command adds the body text of this node to the previous section:

- The headline is ignored.
- The @rst-no-head node does not change the rST section structure in any way.
</t>
<t tx="ekr.20131009100732.16760">.. index::
    pair: Abbreviation; Tutorial

Leo optionally expands abbreviations as you type.

Abbreviations typically end with something like ";;" so they won't trigger
by accident.

You define abbreviations in @data abbreviations nodes or @data
global-abbreviations nodes. |br| None come predefined, but leoSettings.leo
contains example abbreviations in the node::

    @@data abbreviations examples

Abbreviations can simply be shortcuts::

    ncn;;=@nocolor
    
Abbreviations can span multiple lines. Continued lines start with \\:, like
this::

    form;;=&lt;form action="main_submit" method="get" accept-charset="utf-8"&gt;
    \:&lt;p&gt;&lt;input type="submit" value="Continue &amp;rarr;"&gt;&lt;/p&gt;
    \:&lt;/form&gt;\n

Abbreviations can define templates in which &lt;\|a-field-name\|&gt; denotes a field
to be filled in::

    input;;=&lt;input type="text/submit/hidden/button"
    \:name="&lt;|name|&gt;"
    \:value="" id="&lt;|id|&gt;"&gt;\n

Typing ",," after inserting a template selects the next field.

Abbreviations can execute **abbreviation scripts**, delimited by {\|{ and
}\|}::

    date;;={|{import time ; x=time.asctime()}|}
    ts;;={|{import time ; x=time.strftime("%Y%m%d%H%M%S")}|}
    
For example, typing ts;; gives::

    20131009171117
    
It's even possible to define a context in which abbreviation scripts execute.

See leoSettings.leo for full details.
</t>
<t tx="ekr.20131009100732.19038">.. index::
    pair: Plugins; Tutorial

`Leo plugins`_ are Python programs that extend what Leo can do.

Plugins reside in the leo/plugins folder.

Enable plugins by adding their file names in @enabled-plugins nodes an @settings tree. |br|
The @enabled-plugins bundled in leoSettings.leo contains a list of default (recommended) plugins.

Programmers have contributed dozens of plugins, including:

- `bookmarks.py`_: manages and shows bookmarks.

- `contextmenu.py`_: shows a context menu when you right-click a headline.

- `mod_scripting.py`_: supports @button and @command nodes.

- `quicksearch.py`_: Adds Nav tab for searching.

- `todo.py`_: provides to-do list and simple project-management capabilities.

- `valuespace.py`_: adds outline-oriented spreadsheet capabilities.

- `viewrendered.py`_: creates the rendering pane and renders content in it.
</t>
<t tx="ekr.20131009100732.19039">Open bookmarks in a list, and show bookmarks in a pane.
</t>
<t tx="ekr.20131009100732.19040">Supports outline-based calculations similar to spreadsheets.
</t>
<t tx="ekr.20131011050613.16815">The LoadManager (LM) class (in leoApp.py) is responsible for initing all
objects and settings. This is a complex process. Here is the big picture:

- The LM reads each local (non-settings) file twice.
  The first load discovers the settings to be used in the second load.
  This ensures that proper settings are *available* during the second load.

- Ctors init settings "early", before calling the ctors for subsidiary objects.
  This ensures that proper settings are *in effect* for subsidiary ctors.
</t>
<t tx="ekr.20131011050613.16839"></t>
<t tx="ekr.20131011050613.16840">Both the legacy and new completer now work *exactly* the same way, because
they both use the AutoCompleterClass to compute the list of completions.

The strict "stateless" requirement means that the "intermediate"
completions must be entered into the body pane while completion is active.
It works well as a visual cue when using the tabbed completer: indeed, the
tabbed completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter. Adding code before
the user accepts the completion might be considered an "advanced" feature.
However, it does have two important advantages, especially when "chaining"
across periods: it indicates the status of the chaining and it limits what
must appear in the qcompleter window.
</t>
<t tx="ekr.20131011050613.16841">There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the
user types a backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert characters that do
not match the start of any possible completion. This is an experimental
feature, but it might play well with using codewise completions as a
fallback to Leo-related completions.

</t>
<t tx="ekr.20131011050613.16842">Performance of Leo-related completions is *much* better than before. The
old code used Python's inspect module and was horribly complex. The new
code uses eval and is perfectly straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up backspacing. Global
caching is possible because completions depend *only* on the present
prefix, *not* on the presently selected node. If ContextSniffer were used,
completions would depend on the selected node and caching would likely be
impractical. Despite these improvements, the performance of
codewise-oriented completions is noticeably slower than Leo-related
completions.

The ac.get_cached_options cuts back the prefix until it finds a cached
prefix. ac.compute_completion_list then uses this
(perhaps-way-too-long-list) as a starting point, and computes the final
completion list by calling g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do "prefix AI" based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to get_completions
replace calls to g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have thousands of
items. Scanning large lists can't be helped in any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the completionDict
does *not* define state (it is valid everywhere) and no state variables had
to be added. In short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.
</t>
<t tx="ekr.20131011050613.16843">@language rest

The following sections deal with different aspects of how Leo handle's
keystrokes that the user types. This is the most complex code in Leo.
</t>
<t tx="ekr.20131011050613.16849">There are two kinds of bindings, gui bindings and pane bindings.

**Gui bindings** are the actual binding as seen by  whatever gui is in effect.
Leo binds every key that has a binding to k.masterKeyHander.

At present Leo makes gui bindings in several places, all equivalent.
Bindings are made to callbacks, all of which have this form::

     def callback(event=None,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke)

As a result, changing gui bindings actually has no effect whatever.
It would be clearer to have a single place to make these bindings...

In any case, the purpose of these callbacks is to capture the value of 'stroke' so
that it can be passed to k.masterKeyHandler.
This relieves k.masterKeyHandler of the impossible task of computing the stroke from the event.

**Important**:  No function argument is ever passed to k.masterKeyHandler from these callbacks,
because k.masterKeyHandler binds keys to command handlers as described next.

**Pane bindings** are bindings represented by various Python dictionaries in the
keyHandlerClass (see below). k.masterKeyHandler and its helpers use these
dictionaries to call the proper command or mode handler. This logic is hairy,
but it is completely separate from the gui binding logic.

Here are the dictionaries that k.masterKeyHandler uses:

- c.commandsDict:
  Keys are minibuffer command names; values are functions f.

- k.inverseCommandsDict:
  Keys are f.__name__l values are emacs command names.

- k.bindingsDict:
  Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven).

- k.masterBindingsDict:
  Keys are pane names: 'all','text',etc. or mode names.
  Values are dicts:  keys are strokes; values are g.Bunch(commandName,func,pane,stroke).

- k.modeWidgetsDict:
  Keys are mode names; values are lists of widgets to which bindings have been made.

- k.settingsNameDict:
  Keys are lowercase settings; values are 'real' Tk key specifiers.
  Important: this table has no inverse.

- inverseBindingDict:
  This is *not* an ivar; it is computed by k.computeInverseBindingDict().
  Keys are emacs command names; values are *lists* of shortcuts.
</t>
<t tx="ekr.20131011050613.16850"></t>
<t tx="ekr.20131011050613.16851">All event objects passed around Leo are *key* event objects. Taking a look
at the eventFilter method, we see clearly see that *only* key events ever
get passed to Leo's core. All other events are handled by Qt-specific event
handlers.

As can be seen, these non-key events *can* be passed to Leo, but only as
the event arg in g.doHook (!) At present, no plugin ever calls
k.masterKeyHandler. The only call to k.masterKeyHandler in qtGui.py is the
expected call in eventFilter.

There are other calls to k.masterKeyHandler in Leo's core, but we can prove
(by induction, if you will), that all events passed to k.masterKeyHandler
are proper leoKeyEvent objects.
</t>
<t tx="ekr.20131011050613.16852">The essential invariant is that the events passed to Leo's core methods
really are leoKeyEvent objects created by qtGui.py. Rather than asserting
this invariant, the code will contains calls to c.check_event in essential
places. c.check_event is a "relaxed" place to do as much error checking is
needed. In particular, running the unit tests calls c.check_event many
times.

c.check_event is a happy "accident". It turns out to be the essential
consistency check that continually verifies that the Qt event methods are
delivering the expected keys to k.masterKeyHandler.
</t>
<t tx="ekr.20131011050613.16853">The KeyStroke class distinguish between "raw" user settings
and the "canonicalized" form used throughout Leo. Indeed,
the ability to explicitly distinguish between the two, using
type checking, substantially clarifies and simplifies the
code.

The KeyStroke class makes possible vital type-related
assertions. Knowing *for sure* exactly what crucial data is
and what it means is a huge step forward.

Objects of the KeyStroke class can be used *exactly* as a
strings may be used:

A. KeyStroke objects may be used as dictionary keys, because
they have __hash__ methods and all the so-called rich
comparison methods: __eq__, __ne__, __ge__, __gt__, __le__
and __lt__. Note that KeyStroke objects may be compared with
other KeyStroke objects, strings and None.

B. At present, KeyStroke objects supports the find, lower
and startswith methods. This simplifies the code
substantially: we can apply these methods to either strings
or KeyStroke objects, so there is no need to create
different versions of the code depending on the value of
g.new_strokes.

However, having the KeyStroke class support string methods
is bad design. Indeed, it is a symptom that the client code
that uses KeyStroke objects knows too much about the
internals of KeyStroke objects. Instead, the KeyStroke class
should have higher-level methods that use s.find, s.lower
and s.startswith internally.

You could say that the fact that code in leoKeys.py calls
s.find, s.lower and s.startswith is a symptom of non OO
programming. The internal details of settings and strokes
"pollutes" the code. This must be fixed. This will likely
create opportunities for further simplifications.

&gt; Why not just have .s attribute in KeyStroke, that contains
the string version?

It is truly impossible to understand the key code without
knowing whether an object is a string representing a user
setting or the canonicalized version used in Leo's core,
that is, a KeyStroke object. Using ks.s instead of ks
destroys precisely the information needed to understand the
code.

Again, this is not a theoretical concern. The key code now
contains assertions of the form::

    assert g.isStroke(stroke)

or::

    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations
required several important revisions of the code. The code
that makes the assertions pass is "innocuous", that is,
almost invisible in the mass of code, but obviously, these
small pieces of code are vital.

This is in no way a violation of OO principles. The code is
not dispatching on the type of objects, it is merely
enforcing vital consistency checks. This code is complex:
confusion about the types of objects is intolerable.
Happily, the resulting clarity allows the code to be
substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...
</t>
<t tx="ekr.20131011050613.16854">The Qt key input code can be greatly simplified by calling a
new k.makeKeyStrokeFromData factory method. At present, the
Qt key input code knows *all* the details of the format of
*canonicalized* settings. This is absolutely wretched
design.

Instead, the Qt input key code should simply pass the key
modifiers and other key information to
k.makeKeyStrokeFromData, in a some kind of "easy" format.
For example, the Qt input key code would represent the
internal Qt modifiers as lists of strings like "alt",
"ctrl", "meta", "shift". k.makeKeyStrokeFromData would then
create a *user* setting from the components, and then call
k.strokeFromSetting to complete the transformation.
</t>
<t tx="ekr.20131011050613.16855">Leo's key dictionaries will always be complex, but basing
them on the TypedDict class was a major improvement.

The g.TypedDict and g.TypedDictOfLists classes are useful
for more than type checking: they have unique names and a
dump method that dumps the dict in an easy-to-read format
that includes the name, and valid types for keys and values.

Plain dicts do have their uses, but for "long-lived" dicts,
and dicts passed around between methods, plain dicts are as
ill-advised as g.Bunches.

</t>
<t tx="ekr.20131011050613.16860">In Leo, each class hides (encapsulates) the details of its internal
workings from user (client) classes. This design principle has been
spectacularly successful. Leo's overall design has remained remarkably
stable for 20 years, even as the internal details of many classes have
radically changed.

The distinction between gui-dependent and gui-independent is important.
Almost all gui-dependent code resides in the plugins folder. Leo's core
code is almost completely gui independent.

Leo's core typically assumes that w (an abstract widget) is a subclass of
the baseTextWidget class. This class implements the DummyHighLevelInterface
interface. Actually, w is usually a LeoQTextBrowser or leoQtBaseTextWidget
object, defined in qtGui.py. These classes provide thin wrappers for
corresponding Qt widgets.

Wrapper classes are useful, regardless of gui independence:

- Wrapper classes often simplify the corresponding code in Leo's code.
- Wrapper classes provide convenient methods for debugging and tracing.
</t>
<t tx="ekr.20131011050613.16862">Once you know approximately where to look, it is easy to use traces to
discover what is going on. To trace the last n (default 4) callers of any
function::

    g.trace(g.callers(n))
    
Many complex methods define a trace variable::

    trace = False and not g.unitTesting
    
A good rule of thumb: the more complex a method is, the more useful its
traces are likely to be.

You can also to use g.pdb() to single-step through the code.
I typically use g.pdb() only for deep mysteries!

**Note**: you must run Leo from a console window to use either g.trace or
g.pdb. I recommend always running Leo from a console.</t>
<t tx="ekr.20131011050613.16866">Several modules contain long comments::

    &lt;&lt; about new sentinels &gt;&gt; (leoAtFile.py)
    &lt;&lt; about the leoBridge module &gt;&gt; (leoBridge.py)
    &lt;&lt; how to write a new importer &gt;&gt; (leoImport.py)
    &lt;&lt; How Leo implements unlimited undo &gt;&gt; (leoUndo.py)
    &lt;&lt; about gui classes and gui plugins &gt;&gt;
    &lt;&lt; About handling events &gt;&gt; (leoFrame.py)
    &lt;&lt; Theory of operation of find/change &gt;&gt; (leoFind.py)
    &lt;&lt; Key bindings, an overview &gt;&gt; (leoKeys.py)
    &lt;&lt; about 'internal' bindings &gt;&gt; (leoKeys.py)
    &lt;&lt; about key dicts &gt;&gt; (leoKeys.py)
    
These comments may be helpful, but do *not* assume that they are accurate.

When in doubt, trust the code, not the comments.
</t>
<t tx="ekr.20131011050613.16868">You can learn *anything* about Leo, provided that you can cause Leo to
execute the relevant code. That's usually very easy!

- It should be straightforward to isolate the module or modules involved.
- The next several sections give hints about finding interesting code.
- Once you find a bit of interesting code, use g.pdb or g.trace to study it.

The following sections provide more details...
</t>
<t tx="ekr.20131011050613.16870">The following methods and their helpers all have useful traces:

- leoQtEventFilter.eventFilter (qtGui.py) and helpers create keystrokes 
  (LeoKeyEvents) from QKeyEvent events.

- k.masterKeyHandler (leoKeys.py) receives LeoKeyEvents from eventFilter
  and invokes one of Leo's commands based on the users bindings.

- k.getArg handles commands like Ctrl-F (search-with-present-options)
  that prompt the user for input.
</t>
<t tx="ekr.20131011050613.16871">c.outerUpdate and helpers eliminate flicker by redrawing the screen only at
the end of each command.

c.outerUpdate contains several sophisticated and useful traces.

qtGui.set_focus (qtGui.py) is the only place that actually explicitly sets
focus in Leo. Enabling a trace there can be useful.
</t>
<t tx="ekr.20131011050613.16876">The following methods are surprisingly fragile. Change them only after
careful thought. Make *sure* to run all unit tests after changing them in
any way:

- leoTree.select and c.selectPosition switch nodes.

- c.endEditing ends editing in a headline and updates undo data.

- leoBody.onBodyChanged updates undo data when body text changes.

- baseNativeTree.onHeadChanged (baseNativeTree.py) updates undo data.

  **Note**: This method overrides leoTree.onHeadChanged (leoFrame.py),
  which is not used.

In addition, *all* event handling in baseNativeTree.py is extremely
fragile. Don't even think about changing this code unless you know exactly
what you are doing.
</t>
<t tx="ekr.20131012060912.16765">What an enormously long and interesting thread!

Thanks for the sub-thread on using Leo for plain ol' writing. It rings true
for me. Leo doesn't leverage much of my prior muscle memory, and that leads
me away from it, and once away it takes awhile to return. This is still
true even though I've been using Leo for half a decade now, and have even
contributed a small thing or two to the bzr repository.

I generally use notepad2, notepad++ for quick and dirty scripts (usually
Windows batch files), editing .ini,.conf, xml etc., etc. files. Way fast
startup time and their syntax highlighting know more file types and is more
reliable (complete). They also grok (some) regular expressions.

I use vim (+cream) when I want to do search and replace, which happens a
lot. I just never figured out how to use this properly in Leo;
`[esc]:%s/old-thing/new-thing/g` is just so much faster (modulo the
significant time it takes to construct regular expressions that actually
work!). Saved mini-buffer commands across sessions is also very handy. If
vim+cream was faster to start I'd never use the notepad replacements.

Weirdly, even for python I often use PyScripter instead of Leo. Sometimes
it's because I need to write for a different version of python than I'm
running Leo from. Others it's because the output I get from running a Leo
node as a script differs from the same thing from a cmd
shell/IDLE/PyScripter console. I also find PyScripter's code completion a
bit more intuitive for the way I type (though, I didn't discover that until
I'd already wandered away from Leo for a time).

None of this is meant as a slam against or complaint about Leo! It's just
sharing observations of my personal use/not-use patterns.

Part of my difficulty in becoming comfortable with Leo is that I'm also not
that comfortable with python, or even general programming. I'm not a
software developer; this is changing, but very slowly. Consequently I spend
a lot of in-Leo time in a state of confusion, often unsure whether I'm
trying to learn programming or python or Leo or more about the actual
problem I'm started out trying to solve this morning. :)

Anyway, the point touched on earlier about leveraging the skills and
experience people already have before they encounter Leo is pretty key to
the overall adoption rate, I think.

cheers,

-matt
</t>
<t tx="ekr.20131012060912.16768">Leo creates commands in two ways:

1. Using the @g.command(command-name) decorator.

2. Using tables, usually getPublicCommands methods in various classes.

For example, to find the code for the sort-lines command, search for
sort-lines. You will find::

    'sort-lines':    self.sortLines,
    
Now search for "def sortLines" and you have arrived.</t>
<t tx="ekr.20131012060912.16769">The following sections discuss topics that may not be apparent from reading
the sources.
</t>
<t tx="ekr.20131012060912.16770">Leo's key handling is complex because it does inherently complex things:

- Code in various places translate user key bindings to dictionaries.

- eventFilter and its helpers translates incoming QKeyEvents to LeoKeyEvents.

- k.masterKeyHandler associates incoming LeoKeyEvents with
  mode-and-pane-dependent bindings.
  
Much of this complexity is a direct result in the flexibility given to
users in specifying key bindings.
</t>
<t tx="ekr.20131012060912.16775">.. index::
    pair: Generator; Tutorial

Leo generators are `Python generators`_. Leo generators traverse (step
through) Leo outlines node by node:
**Leo generators yield a sequence of positions.**

The Commands (commander) and position classes define several generators,
discussed later in this chapter. c.all_positions() traverses
the outline in outline order.  The following prints a properly-indented
list of all headlines::

    for p in c.all_positions():
        print(' '*p.level()+p.h)
        
Leo generators **yield** (return a sequence of) positions. They do *not*
return actual lists; this saves lots of space for large outlines.
In fact, this "sequence of positions" is actually a sequence of a
**single, constantly changing** position.
This is a very important space optimization.
  
When a generator is finished, this single position becomes an **empty
position**. p.v is None for empty positions. There are the right and wrong
ways to test for empty positions::

    if not p:       # Right
    if not p.v:     # Right
    if p is None:   # Wrong!
    
The `scripting portion`_ of `Leo's cheat sheet`_ lists all of Leo's
generators.
  </t>
<t tx="ekr.20131012060912.16788">g.es can send it's output to tabs other than the log tab::

    c.frame.log.selectTab('Test')
        # Create Test or make it visible.

    g.es('Test',color='blue',tabName='Test')
        # Write to the test tab.

Plugins and scripts may call the c.frame.canvas.createCanvas method to create a
log tab containing a graphics widget. Here is an example script::

    log = c.frame.log ; tag = 'my-canvas'
    w = log.canvasDict.get(tag)
    if not w:
        w = log.createCanvas(tag)
        w.configure(bg='yellow')
    log.selectTab(tag)
</t>
<t tx="ekr.20131012191145.16789">For any commander c:

+------------------------------+--------------------------------------------+
| **Property**                 | **Value**                                  |
+------------------------------+--------------------------------------------+
| c.p                          | the presently selected position            |
+------------------------------+--------------------------------------------+
| **Ivar**                     | **Value**                                  |
+------------------------------+--------------------------------------------+
| c.frame                      | the leoFrame representing the main window. |
+------------------------------+--------------------------------------------+
| c.frame.body                 | the leoBody representing the body pane.    |
+------------------------------+--------------------------------------------+
| c.frame.body.wrapper         | a leoQTextEditWidget.                      |
+------------------------------+--------------------------------------------+
| c.frame.body.wrapper.widget  | a LeoQTextBrowser (a QTextBrowser)         |
+------------------------------+--------------------------------------------+
| c.frame.tree                 | a leoQtTree, representing the tree pane    |
+------------------------------+--------------------------------------------+
| c.frame.tree.treeWidget      | a LeoQTreeWidget (a QTreeWidget)           |
+------------------------------+--------------------------------------------+
| c.user_dict                  | a Python dictionary for use by scripts and |
|                              | plugins. Does not persist when Leo exists. |
+------------------------------+--------------------------------------------+</t>
<t tx="ekr.20131013060803.16852">.. index::
    pair: Hello World Example; Tutorial

Here is the obligatory "Hello World!" script::

    g.es('Hello World!')
    
In more detail:

1. Create a node anywhere in the outline.
2. Put g.es('hello, world!') in the node's body text.
3. Select the node and type Ctrl-B.

Notes:

- Output should appear in the log pane.

- Ctrl-B (execute-script) executes the body text of the selected node as a
  Python script. |br|
  If text is selected, execute-script executes only the selected text.

- g.es prints its arguments to Leo's log pane.

..  You can use Ctrl-B even if you are reading this in leoDocs.leo!

g seems to be undefined, yet this script *does* work without error, because...
</t>
<t tx="ekr.20131014050027.16801">.. index::
    pair: Position; Tutorial
    pair: position class; Tutorial

A **position** represents a specific outline node at an exact location
in the outline. Positions are instances of the position class, defined
in leoNodes.py. Methods of the position class provide safe ways to
insert, delete and move outline nodes. The `scripting portion`_ of
`Leo's cheat sheet`_ lists the most important methods of the position
class.

- The vnode at position p is p.v.

- Because all clones share the same vnode, |br|
  many positions may have the same p.v field.

- p.b, p.h and p.u are synonyms for p.v.b, p.v.h and p.v.u.

- For any commander c, c.p is the presently selected node.

**positions usually become invalid when outline structure changes**.
Scripts should store positions for later use only if the script does not
cause the outline to change in any way.

- c.positionExists(p) returns True if p is (still) valid in c's outline.

The next section describes generators. Generators are a great way of
gaining access to outline nodes.
</t>
<t tx="ekr.20131014053720.16809">.. index::
    pair: Capturing Positions; Tutorial
    pair: p.copy(); Tutorial
    
As mentioned previously,
**positions become invalid whenever nodes are inserted, deleted or moved**.

It is valid to capture positions *temporarily*, *provided* that the outline
does not changed while the captured positions are being used. Here is the
proper way::

    aList = [p.copy() for p in c.all_positions()]
        # aList is valid until the outline changes.
        
The p.copy() method returns a *separate* position that does not change when
p changes. Beginners erroneously try to capture positions like this::

    aList = [p for p in c.all_positions()] # Wrong!
    
This is wrong. Leo's generators use a single position, and yield that
*same* position for every node in the outline. Furthermore, that position
will be empty when the generator ends, so every member of aList will be the
(same) empty position!
</t>
<t tx="ekr.20131014053720.16810">.. index::
    pair: Vnode; Tutorial
    pair: vnode class; Tutorial

This section discusses vnodes; the next discusses positions. To script Leo
properly, you *must* understand how vnodes and positions are related.

**vnodes** are instances of the vnode class, defined in leoNodes.py. Each
vnode represents *all* the data associated with an outline node, including
*private* data carrying its outline structure. For each vnode v:

- v.b is the (outline) node's body text.

- v.h is the node's headline.

- v.u is the nodes **user data**, discussed later in this chapter.

..  - v.children is a list of all child vnodes of v.
..  - v.parents is a list of all parent vnodes of v. |br|
..    (v is a clone if and only if len(v.parents) &gt; 1
..  - Scripts **absolutely must not change** v.parents and v.children!

**All cloned outline nodes share a common vnode**. Conversely, |br| each
vnode represents *all* the clones of the corresponding outline node.

Because a *single* vnode can represent *many* outline nodes, it is awkward
to use vnodes directly. This is where positions come in: **positions
simplify access to vnodes**...</t>
<t tx="ekr.20131014053720.16816">The .leo files in Leo's distribution contain many @button nodes (many
disabled), that do repetitive chores. Here is one, @button
promote-child-bodies, from LeoDocs.leo::

    '''Copy the body text of all children to the parent's body text.'''

    # Great for creating what's new nodes.
    result = [p.b]
    b = c.undoer.beforeChangeNodeContents(p)
    for child in p.children():
        if child.b:
            result.append('\n- %s\n\n%s\n' % (child.h,child.b))
        else:
            result.append('\n- %s\n\n' % (child.h))
    p.b = ''.join(result)
    c.undoer.afterChangeNodeContents(p,'promote-child-bodies',b)

This creates a fully undoable promote-child-bodies command.</t>
<t tx="ekr.20131015035606.16778">When focus is in the outline pane::

    Right-arrow (expand-and-go-right)
    Left-arrow (contract-or-go-left)
    Up-arrow (goto-prev-visible) 
    Down-arrow (goto-next-visible)
    
Regardless of focus::

    Alt-Home (goto-first-visible-node) 
    Alt-End (goto-last-visible-node)
    Alt-Right-arrow (expand-and-go-right)
    Alt-Left-arrow (contract-or-go-left)
    Alt-Up-arrow (goto-prev-visible) 
    Alt-Down-arrow (goto-next-visible)
</t>
<t tx="ekr.20131015035606.16780">When focus is in any of Leo's text panes (body pane, log pane, headlines):

    +-------------------+-----------------------+
    | **Key**           | **Move Cursor**       |
    +-------------------+-----------------------+
    | Arrow keys        | one character         |
    +-------------------+-----------------------+
    | Ctrl-LeftArrow    | back one word         |
    +-------------------+-----------------------+
    | Ctrl-RightArrow   | forward one word      |
    +-------------------+-----------------------+
    | Home              | beginning of line     |
    +-------------------+-----------------------+
    | End               | end of line           |
    +-------------------+-----------------------+
    | Ctrl-Home         | beginning of the body |
    +-------------------+-----------------------+
    | Ctrl-End          | end of body           |
    +-------------------+-----------------------+
    | PageDown          | down one page         |
    +-------------------+-----------------------+
    | PageUp            | up one page           |
    +-------------------+-----------------------+
    
Adding the Shift key modifier to any of the keys above
moves the cursor and extends the selected text.
</t>
<t tx="ekr.20131015035606.16786">Directives starting with '@ in the leftmost column
    
See the `Directives reference`_ for full details::

    @                       # starts doc part
    @c                      # ends doc part
    @color
    @doc                    # starts doc part
    @killcolor
    @nocolor
    @language python
    @language c
    @language rest          # restructured text
    @language plain         # plain text: no syntax coloring.
    @lineending lineending
    @pagewidth 100
    @raw, @end_raw          # @file only.
    @tabwidth -4            # use spaces
    @tabwidth 8             # use tabs
    @nowrap
    @wrap
    
Leading whitespace is allowed (and significant) for::

    @all
    @others
    </t>
<t tx="ekr.20131015035606.16788">For documentation see node: "About this file" in leoSettings.leo.

- Key bindings:     @shortcuts
- Visual settings:  @data qt-gui-plugin-style-sheet
- Enabling plugins: @enabled-plugins

To disable a binding for a key, bind it to do-nothing::

    do-nothing = Insert
    
This overrides the following default binding in leoSettings.leo::

    insert-node = Insert
</t>
<t tx="ekr.20131015035606.16799">\@&lt;file&gt; nodes create external files::

    @asis &lt;filename&gt;    
    @auto &lt;filename&gt;        creates outline using importer
    @auto-rst &lt;filename&gt;    (reStructuredText importer)
    @edit &lt;filename&gt;
    @file &lt;filename&gt;        recommended
    @nosent &lt;filename&gt;  
    @shadow &lt;filename&gt;      creates outline structure
                            without sentinels in file
    
See the `Directives reference`_ for full details.
    
**Section names** have the form::

    &lt;&lt; any text, except double closing angle brackets &gt;&gt;
    
**Section-definition nodes** have headlines starting with a section name.

Leo performs **expansions** for all @&lt;file&gt; nodes except @asis.

Expansion of @all:

- Leo replaces @all by the *unexpanded* body text of *all* nodes.

Expansion of section names and @others:

- Leo replaces section names in body text by the *expanded*
  text of the corresponding section definition node.
  
- Leo replaces @others with the *expanded* text of all nodes
  that *aren't* section-definition nodes.
</t>
<t tx="ekr.20131015035606.16800">When focus is in the outline::

    Shift-Down-arrow (move-outline-down) 
    Shift-Left-arrow (move-outline-left) 
    Shift-Right-arrow (move-outline-right) 
    Shift-Up-arrow (move-outline-up)

Regardless of focus::

    Alt-Shift-Down-arrow (move-outline-down) 
    Alt-Shift-Left-arrow (move-outline-left) 
    Alt-Shift-Right-arrow (move-outline-right) 
    Alt-Shift-Up-arrow (move-outline-up)
    Ctrl-D (move-outline-down)
    Ctrl-L (move-outline-left) 
    Ctrl-R (move-outline-right)
    Ctrl-U (move-outline-up)
</t>
<t tx="ekr.20131015035606.16801">For much more information, see the `Commands Reference`_.

Copy/Paste (text)::

    Ctrl-C (copy-text)
    Ctrl-K (kill)
    Ctrl-V (paste-text)
    Ctrl-X (cut-text)
    Ctrl-Y (yank)
    Alt-Y  (yank-pop)
    kill-...

Files::

    Ctrl-N (new) 
    Ctrl-O (open-outline)
    Ctrl-S (save-file) 
    Ctrl-Q (exit-leo)

Focus::

    Alt-T (focus-to-tree) 
    Ctrl-T (toggle-active-pane)
    Ctrl-Tab (tab-cycle-next)
    
Help::

    Alt-0 (vr-toggle)
    F1 (help) 
    F11 (help-for-command) 
    F12 (help-for-python)
    print-bindings
    print-settings
    help-for-...

Find/Replace::

    Ctrl-F (search-with-present-options) 
    Shift-Ctrl-R (replace-string)
    Ctrl-minus (replace-then-find) 
    F3 (find-next) 
    F2 (find-previous)
    
Minibuffer::

    Alt-X (full-command)
    Ctrl-G (keyboard-quit)
    Tab (not a command, completes typing)

Nodes::

    Ctrl-I or Insert (insert-node)
    Ctrl-H (edit-headline)
    &lt;Return&gt; (when editing a headline) (end-edit-headline)
    Ctrl-Shift-C (copy-node)
    Ctrl-Shift-X (cut-node) 
    Ctrl-Shift-V (paste-node) 
    Ctrl-{ (promote)
    Ctrl-} (demote)
    Ctrl-M (mark) 

Undo::

    Ctrl-Z (undo)
    Ctrl-Shift-Z (redo)
</t>
<t tx="ekr.20131015091948.16784">#############################
A Miscellany of Leo Scripting
#############################

This chapter covers miscellaneous topics related to Leo scripts.

You might call this a FAQ for scripts...

.. contents::
    :depth: 3
</t>
<t tx="ekr.20131015104133.16763"></t>
<t tx="ekr.20131015104133.16766">#####################################
Downloading, Installing &amp; Running Leo
#####################################

.. This page exists simply to organize the main TOC.

.. toctree::
   :maxdepth: 4

   download
   installing
   running
</t>
<t tx="ekr.20131016021541.16893">- execute-script predefines c, g and p.
- c is a commander, g is the leoGlobals module, and p is the current position.
- Vnodes contain all outline data.
- Positions provide easy access to vnodes.
- Positions become invalid when outline nodes are inserted, deleted or moved.
- Generators visit all or parts of the outline, in a specified order.
- Generators yield a *single* position whose value constantly changes.
- p.copy() yields a new position that does not change when p changes.
- Alt-1 enables autocompletion.
- Leo's autocompleter understands symbols such as c, g, g.app, etc.
- @button nodes create scripts that can be applied to any outline node.
- @test nodes create unit tests (subclasses of unittest.TestCase) from body text.</t>
<t tx="ekr.20131016021541.16894">.. index::
    pair: @edit; Tutorial

Use @edit instead of @file to place the entire contents of an external file
into a single outline node. Leo writes no sentinel when writing @edit
files.</t>
<t tx="ekr.20131016084446.16726">The `scripting portion`_ of `Leo's cheat sheet`_ contains much more
information about scripting, including lists of Leo's generators and useful
methods of the commander and position classes. 

`Leo's Directive Reference`_ discusses all directives in great detail.
It would be a good idea to skim this chapter to see what it contains.
</t>
<t tx="ekr.20131016103844.16730">See the docstring of these plugins for more details:

- bookmarks.py: Manages URL's used as bookmarks.
- contextmenu.py: Brings up context menu when user right-clicks a headline.
- mod_scripting.py: Supports @button and @command nodes.
- quicksearch.py: Adds Nav tab for searching.
- todo.py: Manages to-do lists and simple project management.
- valuespace.py: Creates an outline-oriented spreadsheet.
- viewrendered.py: Creates a rendering pane.
  Automatically loaded by Leo's help commands.
  Supports @graphics-script, @image, @html, @movie and @svg nodes.
</t>
<t tx="ekr.20131017051340.16732">These are not included on the web, but may be of interest to those
reading LeoDocs.leo.</t>
<t tx="ekr.20131017051340.16733">This chapter uses the following outline (with all nodes expanded) as an
ongoing example::

    + A (clone)
      + B
        - C
      - D
    - E
    + A (clone)
      + B
        - C
      - D
    - F
    
Only the A nodes are clones of each other.
    
c.all_positions, when applied to the example tree above, yields::

    A, B, C, D, E, A, B, C, D, F.
</t>
<t tx="ekr.20131017051340.16735">This script::

    def print_p_stack(p):
        c,result = p.v.context,[]
        v,n = p.v,p.childIndex()
        for data in p.stack:
            v,n = data
            result.append('(%s %s)' % (n,v.h))
        return ','.join(result)
    
    for p in c.all_positions():
        print('(%s %s) p.stack: %s' % (
            p.childIndex(),p.h,print_p_stack(p)))
            
yields the following when applied to the example
outline::
    
    (0 A) p.stack:
    (0 B) p.stack: (0 A)
    (0 C) p.stack: (0 A),(0 B)
    (1 D) p.stack: (0 A)
    (1 E) p.stack:
    (2 A) p.stack:
    (0 B) p.stack: (2 A)
    (0 C) p.stack: (2 A),(0 B)
    (1 D) p.stack: (2 A)
    (3 F) p.stack:

Top-level nodes::

    (0 A) p.stack:
    (1 E) p.stack:
    (2 A) p.stack:
    (3 F) p.stack:

B::

    (0 B) p.stack: (0 A)
    (0 B) p.stack: (2 A)

C::

    (0 C) p.stack: (0 A),(0 B)
    (0 C) p.stack: (2 A),(0 B)

All Leo generators use a single, ever-changing, position object::

    for p in c.all_positions():
        print('id(p): %s id(p.v): %s (%s %s) p.stack: %s' % (
            id(p),id(p.v),p.childIndex(),p.h,print_p_stack(p)))

The output is something like::

    id(p): 214733232 id(p.v): 192725360 (0 A) p.stack:
    id(p): 214733232 id(p.v): 192725488 (0 B) p.stack: (0 A)
    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B)
    id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (0 A)
    id(p): 214733232 id(p.v): 192725392 (1 E) p.stack:
    id(p): 214733232 id(p.v): 192725360 (2 A) p.stack:
    id(p): 214733232 id(p.v): 192725488 (0 B) p.stack: (2 A)
    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B)
    id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (2 A)
    id(p): 214733232 id(p.v): 192725584 (3 F) p.stack:
    
A::

    id(p): 214733232 id(p.v): 192725360 (0 A) p.stack:
    id(p): 214733232 id(p.v): 192725360 (2 A) p.stack:
    
B::

    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B)
    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B)

C::

    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B)
    id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B)

D::

    id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (0 A)
    id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (2 A)
    
Each Leo outline contains a hidden vnode, c.hiddenRootNode::

    c.hiddenRootNode.children: [A, E, A, F]
    A.children: [B]
    B.children: [C]
    C.children: []
    D.children: []
    E.children: []
    F.children: []
    
    c.hiddenRootNode.parents: []
    A.parents: [c.hiddenRootNode,c.hiddenRootNode]
    B.parents: [A]
    C.parents: [B]
    D.parents: [A]
    E.parents: [c.hiddenRootNode]
    F.parents: [c.hiddenRootNode]
</t>
<t tx="ekr.20131017051340.16815">.. index::
    pair: Calltips; Tutorial

Calltips show the expected arguments to functions and methods:

- Alt-2 (toggle-calltips) enables and disables calltips.
- '(' shows calltips, when @language python is in effect.
- &lt;Return&gt; or Ctrl-G (keyboard-quit) exits calltips.

Calltips work for any Python function or method, including Python's
global functions. Examples::

    g.toUnicode(            g.toUnicode(s, encoding, reportErrors=False
    c.widgetWantsFocusNow(  c.widgetWantsFocusNow(w
    reduce(                 reduce(function, sequence[, initial]) -&gt; value
</t>
<t tx="ekr.20131017100502.16702">To gather statistics, do the following in a console window, not idle::

    &gt; python
    &gt;&gt;&gt; import leo
    &gt;&gt;&gt; import leo.core.runLeo as r
    &gt;&gt;&gt; r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

This writes intermediate data to cwd.leoProfile.txt.
The statistics are written to stdout.
</t>
<t tx="ekr.20131017174814.17479">.. |---| unicode:: U+02015 .. for quotes
   :trim:
   
#######
Preface
#######

.. _`Leo's tutorial`: tutorial.html
.. _`ask for help`:   https://groups.google.com/forum/#!forum/leo-editor
.. _`Directed Acyclic Graphs`: https://en.wikipedia.org/wiki/Directed_acyclic_graph
.. _`group of developers and users`: https://groups.google.com/forum/#!forum/leo-editor
.. _`The Leonine World`: leonine-world.html

.. epigraph::

   Word outlines are very useful. But Leo makes Word look like a clunky toy.
   
   --Joe Orr

Leo is a fundamentally different way of using and organizing data, programs
and scripts. Leo has been under active development for 15 years and has an
active `group of developers and users`_.

You won't learn all about Leo in a day or two. `Leo's tutorial`_
explains the basic features. You can learn more advanced features
later. Please `ask for help`_ immediately if you get stuck.

Leo has shamelessly stolen the best features of Emacs, including the
minibuffer and many Emacs-like commands. But Leo goes *far* beyond
other editors:

- Leo *completely integrates* Python scripting and outlines, not just the
  outline's data, but the outline structure as well.

- Features such as @test nodes and @button nodes can not even be
  *thought* in traditional editors. Leo implements such features
  easily; other editors could only simulate them--laboriously and
  unnaturally.
   
- Leo's outlines are based `Directed Acyclic Graphs`_. As a result, Leo can
  organize data in completely new ways.
  
These features combine to accelerate your work flow in a unique
**Leonine** way, described more fully in `The Leonine World`_.
  
In the next sections, Leo's users tell, in their own words, why they think
Leo is something truly special...
  </t>
<t tx="ekr.20131018100353.16706">Clones can greatly accelerate your work flow. To start a project, clone
nodes related to the project and drag them at or near the top level, where
you can get at them easily. When the project is complete, just delete the
clones. This work flow is surprisingly effective:

- The original nodes never move, but they change whenever their clones do.

- There is nothing to "put back in place" when you are done. Just delete the
  clones.
  
Used this way, **clones create views**: when you gather cloned nodes
together for a project, you are, in effect, creating a project-oriented
view of the outline. This view **focuses your attention** on only those
nodes that are relevant to the task at hand.
</t>
<t tx="ekr.20131019035402.17557"></t>
<t tx="ekr.20131019035402.17573">#################
The Leonine World
#################

**Leonine** refers to Leo's unique way of organizing data and
programs. This has many implications:

**Browsing**: Leo remembers your outline organization. Class browsers
don't. Doh!

**The big picture**: Outline nodes hide messy details, revealing the big
picture *at all times*.

**Programming**: Leo outlines naturally organize programs into modules,
classes and functions. Leonine sources are their own design document. How
you organize outlines is a choice in a new design space.

**User-defined types**: Headlines naturally describe a node's contents:
**headlines naturally define types**. Leo's core supports types such as
@button, @rst, @suite, @url, etc. Plugins define @bookmark, @graph, @html
and @task types. Scripts can easily define other types.

**Testing**: Leo's @test nodes creates a unique unit-testing framework:

- @test nodes focus on the real test code.
- It is easy to run only the @test nodes in a particular suboutline.
- @test scripts can easily use data in their children.

**Work flow**: Clones accelerate your work flow by focusing your attention
on the task at hand. Once you have gathered the relevant nodes, there is no
need to keep searching for them. You can change the clones, and the
original nodes change as well. This is a great way to fix bugs or to write
books.

**Databases**: Leo's clones create new opportunities for scriptable
databases. In my brother Speed's outlines, suboutlines *are* SQL queries!
</t>
<t tx="ekr.20131019061259.16686">execute-script predefines::

    c: The commander of the present outline.
    g: The leo.core.leoGlobals module.
    p: The presently selected position, c.p.
    
@test scripts predefine all the above, plus::

    self: The instance of unittest.TestCase
</t>
<t tx="ekr.20131019061259.16687">::

    c.all_positions()
    c.all_unique_positions()
    p.children()
    p.parents()
    p.self_and_parents()
    p.self_and_siblings()
    p.following_siblings()
    p.subtree()
    p.self_and_subtree()
</t>
<t tx="ekr.20131019061259.16688">::

    c.frame         c's outer frame, a leoFrame instance.
    c.user_dict     a temporary dict for use of scripts and plugins.
    c.redraw()
    c.positionExists(p)

Here is a partial list of the **official ivars** of any leoFrame f::

    f.c                     is the frame’s commander.
    f.body                  is a leoBody instance.
    f.body.wrapper          is a leoQTextEditWidget instance.
    f.body.wrapper.widget   is a LeoQTextBrowser(QTextBrowser) instance.
    f.log                   is a leoLog instance.
    f.tree                  is a leoQtTree instance.
    f.tree.treeWidget       is a LeoQTreeWidget (a QTreeWidget) instance.
    
Use autocompletion to explore these objects!
</t>
<t tx="ekr.20131019061259.16690">::

    v.b: v's body text.
    v.h: v's headline text.
    v.u: v.unknownAttributes, a persistent Python dictionary.
    
v.u (uA's or unknownAttributes or userAttributes) allow plugins or scripts
to associate persistent data with vnodes. For details see the section about
`userAttributes`_ in the `Customizing Leo`_ chapter.
</t>
<t tx="ekr.20131019061259.16691">**Properties**::

    p.b: same as p.v.b.
    p.h: same as p.v.h.
    p.u: same as p.v.u.

**Getters**::

    p.back()
    p.children()
    p.firstChild()
    p.hasBack()
    p.hasChildren()
    p.hasNext()
    p.hasParent()
    p.hasThreadBack()
    p.hasThreadNext()
    p.isAncestorOf(p2)
    p.isAnyAtFileNode()
    p.isAt...Node()
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isRoot()
    p.isVisible()
    p.lastChild()
    p.level()
    p.next()
    p.nodeAfterTree()
    p.nthChild()
    p.numberOfChildren()
    p.parent()
    p.parents()
    p.threadBack()
    p.threadNext()
    p.visBack()
    p.visNext()
    
**Setters**::

    p.setDirty()
    p.setMarked()

**Operations on nodes**::

    p.clone()
    p.contract()
    p.doDelete(new_position)
    p.expand()
    p.insertAfter()
    p.insertAsNthChild(n)
    p.insertBefore()
    p.moveAfter(p2)
    p.moveToFirstChildOf(parent,n)
    p.moveToLastChildOf(parent,n)
    p.moveToNthChildOf(parent,n)
    p.moveToRoot(oldRoot=None)
        # oldRoot **must** be the old root position if it exists.
        
**Moving positions**

The following move positions *themselves*: they change the node to which a
position refers. They do *not* change outline structure in any way! Use
these when generators are not flexible enough::

    p.moveToBack()
    p.moveToFirstChild()
    p.moveToLastChild()
    p.moveToLastNode()
    p.moveToNext()
    p.moveToNodeAfterTree(p2)
    p.moveToNthChild(n)) 
    p.moveToParent()
    p.moveToThreadBack()
    p.moveToThreadNext()
    p.moveToVisBack(c)
    p.moveToVisNext(c)
</t>
<t tx="ekr.20131019061259.16692">For full details, see @file leoGlobals.py in LeoPyRef.leo.

**g vars**::

    g.app
    g.app.gui
    g.app.windowlist
    g.unitTesting
    g.user_dict  # a temporary dict for use of scripts and plugins.
    
**g decorator**::

    @g.command(command-name)
    
**g functions** (the most interesting: there are many more in leoGlobals.py)::
    
    g.angleBrackets()
    g.app.commanders()
    g.app.gui.guiName()
    g.es(*args,**keys)
    g.es_print(*args,**keys)
    g.es_exception()
    g.getScript(c,p,
        useSelectedText=True,
        forcePythonSentinels=True,
        useSentinels=True)
    g.openWithFileName(fileName,old_c=None,gui=None)
    g.os_path_... # Wrappers for os.path methods.
    g.pdb(message='')
    g.toEncodedString(s,encoding='utf-8',reportErrors=False)
    g.toUnicode(s, encoding='utf-8',reportErrors=False)
    g.trace(*args,**keys)
    g.warning(*args,**keys)
</t>
<t tx="ekr.20131019061259.16693"></t>
<t tx="ekr.20131019061259.16697">found 27 broken links.

http://leoeditor.com/images/edit_note.html
http://leoeditor.com/images/toolbar.html
http://leoeditor.com/images/delete.html
http://leoeditor.com/images/editcopy.html
http://leoeditor.com/images/duedate.html
http://leoeditor.com/slides/external-files/index.html
http://leoeditor.com/slides/leo-basics-step-by-step/_sources/slide-010.html
http://leoeditor.com/images/newlist.html
http://leoeditor.com/images/new_item.html
http://leoeditor.com/images/owners.html
http://leoeditor.com/images/complete.html
http://leoeditor.com/images/openlist.html
http://leoeditor.com/images/editcut.html
http://leoeditor.com/images/print.html
http://leoeditor.com/slides/installation/index.html
http://leoeditor.com/images/refresh.html
http://leoeditor.com/slides/using-leos-minibuffer/index.html
http://leoeditor.com/images/editpaste.html
http://leoeditor.com/slides/installation/_static/underscore.html
http://leoeditor.com/images/find.html
http://leoeditor.com/front.html
http://leoeditor.com/slides/scripting-leo/index.html
http://leoeditor.com/images/printprev.html
http://leoeditor.com/slides/leo-basics-step-by-step/index.html
http://leoeditor.com/slides/clones-and-views/index.html
http://leoeditor.com/images/mail_item.html
http://leoeditor.com/images/page_setup.html
</t>
<t tx="ekr.20131023151757.17122"></t>
<t tx="ekr.20131023151757.17124">.. epigraph::

   I would never again willingly program without Leo
   
   --Edward K. Ream

.. epigraph::

   If you're looking for an *environment* which includes a good editor and outliner and is completely scriptable / interactive / "live-code" in Python, then Leo wins hands down. Of course, it's basically alone in this field, as far as I know, but I'm sure it would do well even if it wasn't :-). Take out the Python part, and maybe there're some others out there, but who'd want to take out the Python part :) I guess Emacs is sort of an environment like this, only in Lisp with a prehistoric GUI system.
   Sometimes I've wondered why Leo seems to appeal to people who aren't comfortable in Python, I think now it's because they still recognize the value of an *environment*, and there's just not much in this niche.
   My feeling, talking generally and not about Leo in particular, is that while not everyone needs to be a "programmer", everyone who uses computers would benefit from being able to interact with them with more of the flexibility and efficiency that comes with even relatively simple "scripting", and less of the limitations that come with the "buy our latest product and you'll be able to do   anything you want with a click" view pushed by other suppliers of computing environments.

   --Terry Brown
   
.. epigraph::

   Leo's impact on my life since I found it in January has been substantial.
   Leo allows me to automate my life to a great extent. It is my to-do list, my personal assistant, my address book, my password log, my recipe archive, my rss feed reader (due to rss.py), and my favored editor. It partially powers my blog (along with git, ruby, and heroku), allowing me to create a new blog entry with one click and a bit of editing. Viewrendered (with markdown support!) has changed the way I write READMEs and blog posts. On top of all of that, it has allowed to me to organize several disparate tabletop game design projects I have going, as well as my numerous writing projects. Not to mention the impact it has on my ability to understand and decode large python projects!
   But what really cinches all of this for me is how crazy extensible Leo is. Script buttons in particular are an integral part of my daily workflow, allowing me to transform my productivity over the last month...I'm now a thing-getter-doner, and I find much of it is due to the powerful core of Leo, plus scripting.py and todo.py.

   --Jacob Peck
          
.. epigraph::

   The outliner format helps me organize/reorganize my thoughts gradually, instead of putting everything in the right place from the beginning. I write a lot of body text with few headlines, and Leo's approach leaves lots of space for the body text and therefore suits my workflow. I find that I end up revisiting notes composed on Leo more often than notes slapped into tools like Evernote or random files in the file system.
   With Leo, I can interleave "notes" (most of the content), generated files and even random data and python scripts to manipulate that data. I process this data in various tools, but Leo helps me group it together in "project specific" Leo files.
   I know how to script the outline, so I can easily whip up different tools for my needs that deal with the headline structure directly.
    
   --Ville M. Vainio
    
.. epigraph::

   Why Leo? Because I have two nodes which were originally identical but are now different and I want to see the differences.
   
    My outline loads a @file called ~/.leo/t/gen which contains a @button with several @rclick children for commonly used tasks. 
    - I add a new one, @rclick diff
    
    - selected = c.getSelectedPositions()
    
    - open('/tmp/a_diff', 'w').write(selected[0].b)
    
    - open('/tmp/b_diff', 'w').write(selected[1].b)
    
    - import os
    
    - os.system("xxdiff /tmp/a_diff /tmp/b_diff &amp;")    
    
    which is horrible for a number of reasons but also took only moments to write. And now, not only does this Leo session have a visual node diff capability, but also every future session which loads ~/.leo/t/gen.
    
   When you can go from wanting to having a feature in less time than it takes to write an email about it - well, that's "why Leo".
    
   --Terry Brown
</t>
<t tx="ekr.20131023180133.17111">- Cut &amp; copy a clone to create an unlinked (archived, non-cloned) copy of it.

- if 0:
    @others
    
- Reorganize (clone) @test nodes to specify only those tests that you want to run.

- Clone nodes and move them close together to focus your attention on them.

- class myClass:
    @others
    
- &lt;&lt; imports &gt;&gt;

- Creating to-do nodes to get to-do items *out* of sight.

- Put the project I am working on at the *bottom* of the outline.</t>
<t tx="ekr.20131023180133.17112">From Writers Workshop: https://groups.google.com/forum/#!topic/leo-editor/6zR9WK66Nz4s

I still think the best way to do is to put examples. I was not able to
realize how to -clearly- say this until I read a recent post talking about
how tutos are right now regarding the hello world, and how they should be.

That made me realize that that is exactly what I have being missing so far:
A step by step guide of the cool things Leo can do.

I wish I could get a step by step guide on how to transform an outline or a
subtree into a website html and open it. That is cool but I dont know how
to do that. How to post a node into a blog How to call and run an R file
from Leo Use RST properly

By step by step, I mean, literally, "write this in a new node" "write this
other thing in a sub-node" "Select the first node, then execute command..."

Heck, for pretty much any export file Leo can transform an outline into, I
would actually do something like that, in a "Leo quick examples" so within
a few examples and step-by-step guides as the ones mentioned, the users
will see how easy is to just write information once and have it as a
website, as a document, posted into a blog, etc.

Thanks to the new changes in the tutorial, now I clearly know how to find
strings, but it got me some months to be able to easily do something as
simple as that. But since the new tuto explains that step by step (copy
this, insert text etc) as soon as I read that I could do that. There are
more Leo skills that dont come to mind but often find myself wandering
about when will I be able to do those, that is why I often ask for examples
on how do you guys use things, because without those, the new user has to
figure out how are the steps by himself without guides, and even though
they are very simple, you only know how simple those are after you see them
done, before, its just something you cant even imagine that is there.
</t>
<t tx="ekr.20131024051649.17136">Put introductory words in the body of the @rst node itself:

    "Well, Prince, so Genoa and Lucca are now just family estates of the
    Buonapartes. But I warn you, if you don't tell me that this means war,
    if you still try to defend the infamies and horrors perpetrated by that
    Antichrist--I really believe he is Antichrist--I will have nothing more
    to do with you and you are no longer my friend, no longer my 'faithful
    slave,' as you call yourself! But how do you do? I see I have
    frightened you--sit down and tell me all the news."
    
    It was in July, 1805, and the speaker was the well-known Anna Pavlovna
    Scherer, maid of honor and favorite of the Empress Marya Fedorovna.
    With these words she greeted Prince Vasili Kuragin, a man of high rank
    and importance, who was the first to arrive at her reception. Anna
    Pavlovna had had a cough for some days. She was, as she said, suffering
    from la grippe; grippe being then a new word in St. Petersburg, used
    only by the elite.
</t>
<t tx="ekr.20131024051649.17137">To create a new section, subsection, etc., in the output file:

1. Create a new outline node, as some descendant of the @rst node.

2. **The new node's headline becomes the section's title**.

3. Type the contents of the section in the body text of the node.

That's all there is to it:

- **The rst3 command generates rST underlining automatically**.

- **You reorganize your document by reorganizing nodes**.

There is *no* need to change markup when reorganizing your document, a huge
improvement over writing "raw" rST.
</t>
<t tx="ekr.20131025044901.17143">Org mode is kinda like Leo for Emacs: http://orgmode.org/manual/index.html

As a result of "convergent evolution" it has many of Leo's features:

- Outline commands:
http://orgmode.org/manual/Structure-editing.html#Structure-editing

- To-do lists: http://orgmode.org/manual/TODO-Items.html#TODO-Items

- Hyperlinks: http://orgmode.org/manual/Hyperlinks.html#Hyperlinks

This is natural.

But org mode lacks *all* of Leo's crucial scripting features:

1. Org mode gives scripts *no* access to org mode outlines! There is no API, for elisp or any other language. No predefined c,g,p. In org mode, **everything is just text**.

2. Org mode has no extensibility features: no plugin architecture, no event handlers, no @button.

3. Org mode has no clones, generators, or positions because everything is a simple tree.

It is possible to create source files using org mode:
http://orgmode.org/manual/Working-With-Source-Code.html#Working-With-Source-Code

But org mode is feeble in comparison:

- No @others(!!)  noweb is used as the markup--there is *no* integration of markup with outline structure.
- Source code must be delimited with markup(!!)
  http://orgmode.org/manual/Structure-of-code-blocks.html#Structure-of-code-blocks
- No automatic tangling.
- No untangling at all.
- No automatic imports (@auto).

Emacs makes up for it's lack true outline structure with a huge user base,
so most (not all!) Leo's features have gotten *simulated* in an ugly,
hard-to-extend, way. But simulation has its limits: features like @button
and @test do not exist in org mode.</t>
<t tx="ekr.20131025044901.17144">"Not sure why you said 'you can specify a computer program as an
outline like thing in an outliner like setting.' Why not just say,
'write a computer program in an outline?' Is there some nuance I am
missing?"---EKR

There are probably a million reasons I said it like that, but I think
the main one is my everpresent, brightly burning belief that a program
should be designed before its coded. Remember those guys, back in the
day, who after receiving their programming assignment, would go to the
keyboard and start pounding out C code? Remember their finished
product? Remember how long it took them to finally complete the
project?

Meanwhile, when receiving an assignment, I'd spend hours to days with
a bunch of paper, drawing diagrams. By the time I sat down at the
terminal, I knew my data structures and algorithms. The hours to days
head start of the "start coding immediately" guys evaporated because
for me, coding was just a secretarial task, and I was required to do
less refactoring, or even worse, kludging. Later, sometimes I'd
substitute an outliner for the diagrams on paper; in the days of
functional decomposition, an outliner was the perfect fit.

Back to your question: If all I needed to do was **write** a program,
I'd just sit down at a computer and start pounding out C or Python or
Lua or whatever. But that's not my style. I need to **design** a
program, and after all, a design is just a specification of how the
program is going to be written.

So it seems to me that I *design* the program on Leo, and then, when
the time comes, I flip a switch and Leo *writes* the program for me.
That's how I'd view what I've heard about Leo.
</t>
<t tx="ekr.20131025044901.17147">It is often useful to put reference material in your @rst tree
that will *not* be included in the actual output.

To have the rst3 command ignore a single node, type this in the node's headline::

    @rst-ignore &lt;ignored-text&gt;
    
Neither the headline nor body text will be part of the output file.
    
To have the rst3 command ignore a node and all its descendants,
type this in the node's headline::

    @rst-ignore-tree &lt;ignored-text&gt;
</t>
<t tx="ekr.20131025044901.17148">.. _`rST manual`: http://docutils.sourceforge.net/docs/user/rst/quickref.html#directives

The `rST manual`_ tells how to insert "raw" markup into the output. For
example, Leo's documentation uses the following two kinds of special
markup::

    .. |br| raw:: html
    
       &lt;br /&gt;
    
    .. |---| unicode:: U+02015 .. for quotes
       :trim:

With this markup in place, \|br\| has the effect of inserting &lt;br /&gt; (a
line break), while - - - inserts the unicode "quotation dash" used to
indicate the author of quotations.

Note that rST automatically turns - - into a dash: --.
</t>
<t tx="ekr.20131027064821.17131">Leo's read code parses text into true Python objects: Leo's positions and vnodes.

As a result, Leo scripts will be **orders of magnitude faster** than similar code in vim or emacs.

Leo scripts will also be **orders of magnitude simpler** than similar code in vim or emacs.

As a result, Leo has major subsystems, such as the rst3 command, that are virtually unthinkable
in text-oriented worlds such as vim or Emacs.  It would require emulating all of Leo's
fundamental, behind-the-scenes, data structures: generators, positions, and vnodes, including
the code that creates those data structures from both .leo files (xml readers and writers) 
and external files (code that creates vnodes from sentinel comments).

..  It would be easier in emacs, because elisp is more capable than the vim scripting language,
..  but neither elisp nor vimscript is anywhere near as easy to use as Python.

Emulating Leo in emacs or vim would have one advantage, it would not have to duplicate
the 15+ year process of improvement in Leo's read code (sentinals), data structures (vnodes)
and support code (generators).  But this would be a gigantic effort: to get the benefits of Leo
in either vim or Emacs the leoFileCommands, leoAtFileCommands and leoNodes modules would have to
be emulated.
</t>
<t tx="ekr.20131027064821.17144">The rst3 command applied to::

    @rst myDocument.html
    
will generate an **output file**, myDocument.html, from this node and its
children, grand-children, etc. The rst3 command creates the output
file in the same directory as the .leo file containing the @rst node. You
can specify other directories using absolute or relative paths. Examples::

    @rst myDocument.html        # in same folder as the .leo file
    @rst html/myDocument.html   # in a subfolder
    @rst ~/docs/myDocument.html # an absolute path to the folder
    
The rst3 command writes an **intermediate file** in the same directory as
the output file. This intermediate file contains the reStructuredText
markup generated by the rst3 command. It has the suffix .txt::

    myDocument.html.txt


</t>
<t tx="ekr.20131027064821.18685"></t>
<t tx="ekr.20131027064821.18689">When using sphinx you must ensure that sphinx's conf.py file is configured
so that it will find the intermediate files created by the rst3 command.

For example, the conf.py file for Leo's docs contains the following::

    source_suffix = '.html.txt'
    
This "matches" the form of the intermediate files.  For example,
given::

    @rst myDocument.html
    
and the default value for the rst3_write_intermediate_extension setting::

    @string rst3_write_intermediate_extension = .txt
    
the name of intermediate file will be::

    myDocument.html.txt

myDocument.html.txt is the **input** file for sphinx.
</t>
<t tx="ekr.20131027064821.18709">.. _`docutils`:         http://docutils.sourceforge.net
.. _LaTeX:              http://www.latex-project.org/
.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html
.. _`Sphinx`:           http://sphinx.pocoo.org/</t>
<t tx="ekr.20131028213522.17137">Samples of use (Maybe):

    Sample on how to import bookmarks from Internet browser (I have that
    script ready myself, I could add that)

    Sample of website generated with an outline, easy to open and edit for
    the user to view its power. Ideally, just after transforming the
    outline to website, the user should be able to open it and see it in
    html.

    Sample of RST outline and one click opening with render pane.

    The RPG helper we recently discussed about.

    And as many other practical and ready-to-go samples that could impress
    the new user. All of them, ready to go, no edit required to view. There
    are ways of using Leo that beginers cant think of and those would make
    a great addon for such a beginer leo file.

Other (JKN)
    how to invoke Leo (short list of command-line parameters    
    brief note on creating your own settings (myLeoSettings etc)    
    How to 'install' plugins, adding buttons    
    @node summary usage    

More: Rest of the directives:
    @button    
    @rclick    
    and all of them, with sample of ussage    

More: Associate leo files    
    Include the bat + instructions on how to associate Leo files for
    double-click oppening in windows.
</t>
<t tx="ekr.20131028213522.17138">::

  -h, --help            show this help message and exit
  --fullscreen          start fullscreen
  --ipython             enable ipython support
  --gui=GUI             gui to use (qt/qttabs)
  --maximized           start maximized
  --minimized           start minimized
  --no-cache            disable reading of cached files
  --no-plugins          disable all plugins
  --no-splash           disable the splash screen
  --screen-shot=SCREENSHOT_FN
                        take a screen shot and then exit
  --script=SCRIPT       execute a script and then exit
  --script-window=SCRIPT_WINDOW
                        open a window for scripts
  --select=SELECT       headline or gnx of node to select
  --session-restore     restore previously saved session tabs at startup
  --session-save        save session tabs on exit
  --silent              disable all log messages
  -v, --version         print version number and exit
  --window-size=WINDOW_SIZE
                        initial window size (height x width)
</t>
<t tx="ekr.20131028213522.17150"></t>
<t tx="ekr.20131029095615.17089"></t>
<t tx="ekr.20131030071311.17087">This tutorial would benefit from an example toolchain for a writer. How to
actually get an html file that can be loaded into a word processor to
output an .odt or .docx file for example.

For most of the purposes that a programmer would use rst, i.e., documentation
or a web page, the tutorial goes far enough. But for those who have
different output goals, highlighting the flexibility that Leo with rst
should be a primary goal. There are literally hundreds of writers in the
world for every programmer. If you want Leo to become popular, this is a
critical understanding. IMHO.</t>
<t tx="ekr.20131030184445.16582">##################
More Leo Resources
##################

.. _`Introduction to Leo`:  http://www.youtube.com/watch?v=Zu6J-J0qFi0
.. _`bookmarks plugin video`: https://vimeo.com/77720098 
.. _`2012 PyOhio talk`:     http://www.youtube.com/watch?v=JgJ89ekGj-s

.. _`slashdot article`:     http://leoeditor.com/testimonials.html#speed-ream-s-slashdot-article
.. _`scripting tutorial`:   http://blog.suspended-chord.info/2014/01/28/intro-to-leo-scripting/
.. _`wikipedia page`:       http://en.wikipedia.org/wiki/Leo_(editor)
.. _`literate programming`: http://www.literateprogramming.com/
.. _`Leo's resource page`:  http://www.jserv.com/jk_orr/xml/leo.htm
.. _`Mind Mapping`:         http://www.mind-mapping.org/
.. _`Icons`:                http://leoeditor.com/icons.html
.. _`blog post`: http://reflectionsonprogramming.com/2013/02/related-things-are-not-kept-together/

Videos:

- Ville Vainio's `Introduction to Leo`_.

- Terry Brown's `bookmarks plugin video`_.

- Tom Fetherston's `2012 PyOhio talk`_

More resources:

- Speed Ream's `slashdot article`_ about Leo.

- Jacob Peck's `scripting tutorial`_.

- Leo's `wikipedia page`_.

- A page about `literate programming`_.

- Joe Orr's `Leo's resource page`_ containing XSLT stylesheets for Leo.

- The `Mind Mapping`_ page.

- `Icons`_ telling the world that you used Leo.

Rickard Lindberg's `blog post`_ about how Leo can improve the
organization of code.
</t>
<t tx="ekr.20131030184445.17285">Add these files to `/etc/apt/sources.list`::

    deb http://ppa.launchpad.net/villemvainio/ppa/ubuntu jaunty main
    deb-src http://ppa.launchpad.net/villemvainio/ppa/ubuntu jaunty main

Then run::

    sudo apt-get update
    sudo apt-get install leo
</t>
<t tx="ekr.20131030184445.17286">You may download Leo's sources in one of three ways, as described at:
http://leoeditor.com/download.html If the sources are zipped, unzip them
into the **unpacked folder** in your home directory. The unpacked folder
will be called something like leo-5.0a1.

You now have two choices:

1. You can run Leo from your home directory.
   Just add  ~/leo-4-5 to your path.

2. You can install leo into /usr/local/lib and /usr/local/bin by running Leo's install script as follows::

    cd ~/leo-4-11-final # Change version as appropriate.
    chmod u+x install
    sudo ./install

The install script will instruct you to add /usr/local/bin to your path.
You can, instead, add the following link::

    sudo ln -s /usr/local/lib/leo/ /usr/local/lib/python2.6/site-packages/

That's it!  See `Running Leo`_ for how to run Leo after installing it.
</t>
<t tx="ekr.20131031101712.16486">Supported by Leo's core:

- @chapters, @chapter
- @rst, @rst-no-head, @rst-ignore, @rst-ignore-tree
- @settings
- @test, @testsetup, @testclass
- @url

Within @settings trees:

- @bool, @color, @directory, @encoding, @int
- @float, @font, @ratio, @path, @string
- @buttons, @commands
- @enabled-plugins
- @menus, @menu, @menuat, @item
- @openwith, @shortcuts

Supported by plugins:

- bookmarks.py: @bookmarks, @bookmark
- at_folder.py: @folder
- at_produce.py: @produce
- at_view.py: @clip, @strip, @view
- expfolder.py: @expfolder
- mod_scripting.py: @button, @command, @script
- viewrendered.py: @graphics-script, @image, @html, @movie and @svg
</t>
<t tx="ekr.20131031101712.16685">- Tab completion now shows all @command &amp; @button nodes.
- Leo tabs may be detached from the main window.
- The Open With menu now works.
- Leo can highlight the pane containing the focus.
- The bigdash plugin searches across multiple files.
- Improved abbreviation capabilities.
- Improved handling of URL's.
- Improved editing of non-Leo files.
- Improvements create "weightless" unit testing.

</t>
<t tx="ekr.20131031101712.17211">- Rewrote Leo's tutorials.
- Greatly improved abbreviations, including templates.
- Clones are now valid anywhere in @file nodes.
- Leo now warns if a .leo file is open elsewhere.
- Leo's IPython bridge now works with IPython 1.x.
- Added support for @testsetup and @testclass.
- Added support for sessions.
- Added colorizing themes.
- A colored border highlights the pane with focus.
- Added support for the clojure, markdown and TypeScript languages.
- Added importers for .ipynb, .otl and vimoutliner files.
- Many new and improved commands, plugins and scripts.
- Dozens of bug fixes and code-level improvements.
</t>
<t tx="ekr.20131101080215.16488">===== Steve Litt

I think the first step in getting this kind of review is to get more
fans who can write and who are listened to. To do that, you'd need to
give them enough of a burning desire to spend a few days learning the
ins and outs of Leo. I'll give you an idea how to do this later in this
email.

But first, I think Leo has an image problem. Mention Leo, and most
people say "it's an outliner." If that's all Leo was, VimOutliner would
have eaten Leo's lunch years ago --- VimOutliner's faster and has the
90% of outlining features that people use 90% of the time. Not only
that, face the facts, 95% of the population will never believe they
need an outliner or that an outliner would do them any good, or that
outlining is a skill they need to bother to acquire.

My understanding, and please correct me if I'm wrong, is that Leo is a
mechanism by which you can specify a computer program as an outline
like thing in an outliner like setting, flip a switch, and bang, there's
your program. THAT'S what's going to hook people.

So here's what to do. Make a 3 minute video showing how to compose an
application outline and turn it into a program. The program can be
trivially simple, but make the program as 2014 relevant as possible: A
web app would be nice. At the end of the video explain that although
this video's program was simple, Leo can be used to make arbitrarily
complex apps, and make them well.

Maybe have a second video showing how to make a GUI app. Maybe a 3rd
showing how to write a book in Leo, flip a switch, and have it be a
book, flip it back, and see your book as an outline again, ready for
changes, either minor, or structurally major.

Publicize these videos, and you're going to get some journalists
excited, and those are your reviews.

One more thing: Start publicizing different ways people use Leo.
Encourage them to write in with their unique uses, and publicize them.
I bet people are doing things with Leo you never dreamed of, and some
of those things might be the itch some journalist wants to scratch.
</t>
<t tx="ekr.20131102044158.16488">The rst3 command requires the `docutils`_ Python package. You must also
install the `Sphinx`_ package if you use sphinx markup. Sphinx gives Leo's
and `Python's`_ web sites their distinctive appearance and features.

After installing docutils or sphinx, you must restart Leo so that the new
installation will take effect.
</t>
<t tx="ekr.20131105110107.16836">Leo 4.11 final                                     November 6, 2013

Leo 4.11 final is now available at: http://sourceforge.net/projects/leo/files/Leo/
Leo 4.11 contains over a year's work on Leo.

Leo is a PIM, an IDE and an outliner for programmers, authors and web
designers. Leo's unique features organize data in a revolutionary way.
Python scripts can easily access all parts of Leo outlines.
See http://leoeditor.com/tutorial.html

The highlights of Leo 4.11:
---------------------------

- Leo's tutorials have been rewritten and simplified.
- Greatly improved abbreviations, including templates.
- Clones are now valid anywhere in @file nodes.
- Leo now warns if a .leo file is open elsewhere.
- Leo's IPython bridge now works with IPython 1.x.
- Added support for @testsetup and @testclass.
- Added support for sessions.
- Added colorizing themes.
- A colored border highlights the pane with focus.
- Added support for the clojure, markdown and TypeScript languages.
- Added importers for .ipynb, .otl and vimoutliner files.
- Many new and improved commands, plugins and scripts.
- Dozens of bug fixes and code-level improvements.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Bzr:       http://code.launchpad.net/leo-editor/
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20131105110107.16837"></t>
<t tx="ekr.20131105110107.16838"></t>
<t tx="ekr.20131105110107.16839"></t>
<t tx="ekr.20131105110107.16840">This was a recent problem.  Normally setInputState should *not* set the border.

Added code to eventFilter to call remove_border on focus out.

set-xxx-state commands call setInputState with set_border = True.
</t>
<t tx="ekr.20131105110107.16841">The fix was in qtBody.setWrap.
</t>
<t tx="ekr.20131105110107.16842"># The change was to g.getScript.
</t>
<t tx="ekr.20131105110107.16843">The trick is to find the wrapper first: it is *also* a QMenu.
We can then call menuBar.setActiveAction on its action!!
</t>
<t tx="ekr.20131105110107.16844">https://bugs.launchpad.net/leo-editor/+bug/1021849

Rev 5789 fixes this bug, using some hints from the NSIS support forum.

The fix was to CreateShortCut in the Desktop Shortcut section:
  - remove single quotes.
  - remove the "0" trailing arg.

The installer passes all my tests on my Windows 7 machine, which is all the testing I have ever done.


Here is the checkin log::

QQQ
Fixed the icon problem and improved and simplified the install/uninstall 
process in several ways.

1. Fixed https://bugs.launchpad.net/leo-editor/+bug/1021849

The fix was to CreateShortCut in the Desktop Shortcut section:
  - remove single quotes.
  - remove the "0" trailing arg.

2. Changed the make-leo button to simplify the uninstall manifest.

Rather than computing the files to be deleted, the uninstall script now 
just does RMDir /r "$INSTDIR\\leo".
This *is* safe, and ensures that all files &amp; directories get deleted, 
including $INSTDIR itself.
QQQ

The only possible drawback to using the /r option is that it will delete 
any files that the user has created in the leo directory.  Imo, there is no 
perfect solution to this.  Warning prompts never do any good, and if we 
retain files, for whatever reason, there will be bug reports saying that 
Leo didn't properly uninstall itself.  This has already happened :-)

I am happy to live with the present situation, unless somebody a) objects 
loudly and b) shows how the problem can be solved cleanly.
</t>
<t tx="ekr.20131105110107.16845">https://bugs.launchpad.net/leo-editor/+bug/1194209

save-as doesn't update the window title.  Changing tabs does.

The main fixes were to qtFrame.get/setTitle. When using tabs, the
LeoTabbedTopLevel widget is the top-level window, *not* the DynamicWindow
(a QMainWindow).

Another fix was setting c.frame.title in saveAs to::
    
    c.computeWindowTitle(c.mFileName)
    
This ensures that all all window titles have the same format.

I chose to do the bare minimum fix, confined to g.computeWindowTitle::

    if os.sep in '/\\':
        title = title.replace('/',os.sep).replace('\\',os.sep)

I didn't have the nerve to put similar code in, say, g.os_path_join. The
Python docs for os.path.join state, "In all cases, join(head, tail) returns
a path to the same location as path (but the strings may differ)."

</t>
<t tx="ekr.20131105110107.16846">https://bugs.launchpad.net/leo-editor/+bug/879338

Having the colorizer colorize a language properly gives the false illusion
that Leo "understands" the language.

Supporting the language in the global tables in leoApp.py makes the
illusion a reality.

Rev 5334 is a first draft of a fix of bug 879338:
Global tables in leoApp.py should describe all languages known to the colorizer
https://bugs.launchpad.net/leo-editor/+bug/879338

The essence of the bug fix is that Leo's language-description tables should
contain entries for all .py files in the leo/modes folder. These files
control the colorizer. If Leo's colorizer knows about a language, then Leo
should know as much as possible about the language.

In concept, this is a fairly straightforward process, but there were *many*
details to handle. If you aren't a Leo developer, you might want to stop
reading now...

===== Tables

Fixing this bug required non-trivial changes to the following tables::

    g.app.language_delims_dict
    # Keys are languages, values are 1,2 or 3-tuples of delims.

    g.app.language_extension_dict
    # Keys are language names, values are extensions.

    g.app.self.extension_dict
    # Keys are extensions, values are language names

I used scripts to generate new entries for these tables, but these scripts
can not possibly deal with the all the complications...

Leo uses these tables as follows:

1.  To generate the comment delimiters in sentinels for each language.

Happily, getting the comment delimiters correct was probably the easiest
part, so Leo should continue to write sentinels properly for
previously-know languages. However, I had to take care to preserve the REM,
CWEB, forth and perlpod hacks, so that comment delims would include the
necessary spaces.

2. To associate file extensions with importers.

Knowing about new file extensions doesn't actually allow Leo to import any
new languages. For all languages without an official importer Leo will
simply copy the entire text of the file into a single node, as it always
has.

3. To colorize code.

Leo's colorizer mostly doesn't use these tables: to colorize language x,
the colorizer looks for the file leo/modes/x.py. Thus, these changes
probably do not affect the colorizer at all.

===== Special cases

I did a lot of googling in order to determine the proper file extensions to
use for various language. In the process, I learned that *almost* all
languages described in the leo/modes folder are real, interesting and
useful languages.

However, there at least 5 categories of special cases that affect the
tables:

1. Languages that are really just colorizer modes:

These include embperl, pseudoplain and phpsection. We need entries in
leo/modes for these, but they aren't real languages and thus they should
not appear in the language-description tables.

2. Things that might be colorized but aren't real languages.

Afaik, the following are not real languages, and Leo would never have to
generate files in these languages: cvs_commit,dsssl,relax_ng_compatc and svn_commit.

Notes:

- relax_ng_compact is an xml schema.

- The rtf colorizer is *not* a colorizer for binary .rtf file format, is a
  colorizer for .rtf sources. It probably won't do too much harm to retain
  the colorizer data for these languages, but I wouldn't mind eliminating
  them either.

3.  Unknown languages.

A few languages seem not really to exist: freemarker, hex, jcl, progress, props.

4. Languages without real comment delimiters.

Patch annotations are *not* real comment delimiters, so Leo could not
generate patch (.fix or .patch) files from an outline. Happily, there is no
need to do so.

5. Conflicting file extensions.

There are two separate kinds of problems:

A. Leo contains colorizers for several assembly languages. Typically,
assembly languages have .asm or .a file extensions. However, a particular
extension can only be associated with a single language name. Thus, Leo has
no way of knowing what language to associate with .asm or .a files. So I
just punted and didn't make any association at all.

B. Both the rebol and r languages use the .r file extension. One of Leo's
users previously created an entry for rebol, so that's the language that
takes precedence.
</t>
<t tx="ekr.20131105110107.16847">https://bugs.launchpad.net/leo-editor/+bug/971171

If If $(HOME)/.leo/.leoRecentFiles.txt does not exist,
the only recent file ever is the current file

The fix: rf.writeRecentFilesFile creates $(HOME)/.leo/.leoRecentFiles.txt if it does not exist.
</t>
<t tx="ekr.20131105110107.16848">https://bugs.launchpad.net/leo-editor/+bug/981849

The original fix was misguided. It attempted to use more careful code in
setSelectionRangeHelper &amp; lengthHelper.
    
The new fix avoids messing with the viewport in both setEditorColors methods:

leo-editor thread: opening new top level windows
http://groups.google.com/group/leo-editor/browse_thread/thread/8f5f6c72d8716b33

The key is to use a descriptor in LeoQTextBrowser stylesheets.  Example::

'LeoQTextBrowser { &lt;&lt; the actual stylesheet &gt;&gt; }

See http://stackoverflow.com/questions/9554435/qtextedit-background-color-change-also-the-color-of-scrollbar
</t>
<t tx="ekr.20131105110107.16849">https://bugs.launchpad.net/leo-editor/+bug/998090
save file as doesn't remove entry from open file list

Save file as leaves the file's previous path in g.app.db.openFiles, so
that next time the original file's opened you get a "already open"
message.
</t>
<t tx="ekr.20131105110107.16850">The bug was in chapter.findPositionInChapter.
</t>
<t tx="ekr.20131105110107.16851">These bugs are really the same bug

Node body contents displayed is unpredictably incorrect
https://bugs.launchpad.net/leo-editor/+bug/979142

Prints to tabs in the Log Pane are UTF-8 encoded
https://bugs.launchpad.net/leo-editor/+bug/971166

The fix was:

1. Use the "slow" code in leoQTextEditWidget.get.
2. Use w.get/setAllText in leoFrame.pasteText.
</t>
<t tx="ekr.20131105110107.16852"></t>
<t tx="ekr.20131105110107.16853"></t>
<t tx="ekr.20131105110107.16854">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 553, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 2120, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "c:\leo.repo\trunk\leo\core\leoImport.py", line 479, in flattenOutline
    theFile.write(s)
TypeError: must be str, not bytes
</t>
<t tx="ekr.20131105110107.16855">The crash happens only when the new readSettings argument to leoBridge.bridgeController is False.
In that case, the global dicts were not inited properly.

What I did:
    
- Created lm.createDefaultSettingsDicts, called by lm.readGlobalSettingsFiles.
- leoBridge.initLeo calls lm.createDefaultSettingsDicts to set the global dicts.

Bug description:

--- Begin Python script to run from a console ------
import leo.core.leoBridge as b
bridge = b.controller(gui='nullGui',verbose=False,loadPlugins=False,readSettings=False)
c = bridge.openLeoFile(r'c:\users\edreamleo\test\minimal.leo')
--- End Python Script -----

The above script and minimal.leo are attached to this bug report.  Put
them in the same directory, open a console, set the current working
directory to the directory containing the script, and run the script.
You will see the this exception on the console:

2012-11-16 11:28:51 /home/ldi/tmp
$ python readSettingsFile.py
Traceback (most recent call last):
File "readSettingsFalse.py", line 5, in &lt;module&gt;
  cmdrUnl = bridge.openLeoFile('minimal.leo')
File "/home/ldi/bzr/LeoLatest/leo/core/leoBridge.py", line 330, in openLeoFile
  c = self.createFrame(fileName)
File "/home/ldi/bzr/LeoLatest/leo/core/leoBridge.py", line 367, in createFrame
  c = g.openWithFileName(fileName)
File "/home/ldi/bzr/LeoLatest/leo/core/leoGlobals.py", line 1875, in openWithFileName
  return g.app.loadManager.loadLocalFile(fileName,gui,old_c)
File "/home/ldi/bzr/LeoLatest/leo/core/leoApp.py", line 2539, in loadLocalFile
  previousSettings = lm.getPreviousSettings(fn)
File "/home/ldi/bzr/LeoLatest/leo/core/leoApp.py", line 1668, in getPreviousSettings
  lm.globalSettingsDict,lm.globalShortcutsDict,localFlag=True)
File "/home/ldi/bzr/LeoLatest/leo/core/leoApp.py", line 1626, in computeLocalSettings
  settings_d = settings_d.copy()
AttributeError: 'NoneType' object has no attribute 'copy'
2012-11-16 11:28:55 /home/ldi/tmp
$
</t>
<t tx="ekr.20131105110107.16856">Note: happens only with Python 3.3.0.

Here is a minor traceback when opening quickstart.leo

Leo 4.11 devel, build 5468, 2012-09-30 13:02:59
Python 3.3.0, qt version 4.8.3
Windows 6, 1, 7601, 2, Service Pack 1
reading: C:\Python33\Lib\site-packages\leo-editor\leo\doc\quickstart.leo
unexpected exception in g.importFromPath(rest)
Traceback (most recent call last):
  File "C:\Python33\Lib\site-packages\leo-editor\leo\core\leoGlobals.py", line 5689, in importFromPath
    data = imp.find_module(moduleName,[path]) # This can open the file.
  File "C:\Python33\lib\imp.py", line 203, in find_module
    package_directory = os.path.join(entry, name)
  File "C:\Python33\lib\ntpath.py", line 171, in join
    if b[:1] in seps:
TypeError: Type str doesn't support the buffer API
Can not import rest
</t>
<t tx="ekr.20131105110107.16857">The @test at.readOneAtShadowNode retains @shadow links node
give fail1: test not set up properly.
The outline is then corrupted, causing other unit tests to fail.
The partial solution is not to call the undo command in the finally clause.
</t>
<t tx="ekr.20131105110107.16858">https://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3/6162e6108b09428e

The new code is much like g.computeFileUrl.
</t>
<t tx="ekr.20131105110107.16859">** Not all import problems can be fixed automatically! **

- Added perfectImportFlag. (There was already an importing flag).

- Fixed bug in Fixed underindent convention:

    undentBy adds a period; parseUnderindentTag removes the period.
    
- @file read code must *regenerate* the \\- convention.

    This is done by readNormalLine.
    
    - Fixed an unrelated bug in g.computeWidth.  All unit tests pass.

    - Created g.computeLeadingWhitespaceWidth.
    
- some docstrings are not imported properly in py2_test_grammar.py

    The must be fixed by hand, using @raw and @end_raw.

- escapeFalseSectionReferences now is a do-nothing:
    
    It never generates @verbatim sentinels during import.
    
===== Notes

Rev 5378: cleanup-imported-nodes script in scripts.leo &amp; an Aha
http://groups.google.com/group/leo-editor/browse_thread/thread/77b9df4f4ed6dba0

&gt; The third (and I think last) import fail involves not generating
&gt; @verbatim sentinels when importing files.

Fixed in the trunk at rev 5386.

This is (to me) a really interesting dark corner of Leo's import code.

By searching for @verbatim, I discovered a method called
escapeFalseSectionReferences.  This method inserts an @verbatim
"directive" before lines that look like section references.

This is wrong for multiple reasons.  It confuses the importer, there
is no such thing as an @verbatim directive, and worst, it fails to
solve the essential problem, which is that before the imported file is
saved, the **user** must fix the problem!

For example, when importing a line like::

  a = x &lt;&lt; y &gt;&gt; z

The user, and *only* the user, should change this to something like::

   a = x &lt;&lt; y \
   &gt;&gt; z # EKR

I suppose each importer could figure out a language-specific
workaround, but imo this isn't particularly important, for reasons
which will become clearer below.

So now escapeFalseSectionReferences is a do-nothing.

With this explanation, perhaps the checkin log will make sense::

QQQQQ
Fixed another import fail in an "interesting" way: the import code no
longer inserts @verbatim. This means a later write of the imported
will fail. This is correct!

Indeed, the failed write is the only way to alert the user that the
code must be revised by hand.

Note that another import fail, involving a leading '@' on a line in a
docstring, must also be fixed by hand. In lib2to3/pgen/grammar.py the
*only* possible fix is to enclose the entire docstring at the end of
the file by @raw and @end_raw.

All unit tests pass, but no new tests have been added so far.
QQQQQ

The other import fail mentioned in the checkin log is a truly
fascinating case, one that no amount of AI could possibly discover the
correct fix.

At the very end of lib2to3/pgen/grammar.py the following code
(shortened a bit) appears at the top level::

   opmap_raw = """
   ( LPAR
   ) RPAR
   [snip]
   @ AT
   [snip]
   == EQEQUAL
   != NOTEQUAL
   """
   opmap = {}
   for line in opmap_raw.splitlines():
       if line:
           op, name = line.split()
           opmap[op] = getattr(token, name)

There are several things to notice about this code:

1. It contains a line starting with '@'.  Sooner or later, this is
going to cause problems for either Leo's import code or Leo's write
code.

2. It's overly clever, but it's overly clever for a reason: it's
testing tokenizing logic.

3. The code at the end of the file assumes that all lines of the
docstring are 2-tuples.

For these reasons, the one and *only* possible way to make Leo write
this code correctly is to enclose the *entire* docstring in @raw and
@end_raw directives.  Like this::

   @raw
   opmap_raw = """
   ( LPAR
   ) RPAR
   [snip]
   @ AT
   [snip]
   == EQEQUAL
   != NOTEQUAL
   """
  @end_raw

In particular, surrounding the line "@ AT" with @raw/@end_raw
directives will cause 2to3 to fail on startup:  the Leo sentinel lines
will not be 2-tuples!

===== Important Conclusions

All this picky detail illustrates a crucial fact.  No matter how good
Leo's importers are, (and they are now quite good), there will
*always* be cases where thoughtful human intervention will be
required.

Furthermore, the simplest thing that could possibly work is for the
importers to allow some constructions that are guaranteed to cause
problems later, when the user attempts to write the file.  We hope
that Leo will complain about certain constructions, but Leo may not be
able to complain about all constructions.

Thus, some import mistakes can *only* be found by running tests.  For
complex programs like 2to3, the only truly safe way to check imports
is by running the 2to3 test suite.
</t>
<t tx="ekr.20131105110107.16860">The fix was to always call c.selectPosition in leoFind.showSuccess.
This ensures that leoTree.setBodyTextAfterSelect always does w.setAllText,
which is essential to init the syntax colorer properly.

The happy side effect of this change is that a lot of duplicate selection
code in showSuccess disappears.

Also converted two section references in leoTree.selectHelper to selectNewNode.
</t>
<t tx="ekr.20131105110107.16861">http://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3#

In my installation, now on the latest revision ( r5195) I'm still
experiencing an issue with the '@url command' using 'File-URL' in a Windows
environment.

I'm able to create the Leo User documentation locally. - However, when I
try to read the documentation using the 'File-URL'

file:///D:/Branches/leo-editor/leo/doc/html/_build/html/leo_toc.html

I get the following message in the Leo-Log.

&lt;log&gt;

File 'D:\D:\Branches\leo-editor\leo\doc\html\_build\html\leo_toc.html' does not exist

&lt;/log&gt;

However if I enter this URL directly into FF it is found and displayed properly.

EKR: Obviously, the 'D:\D:\' is the problem.

The fix is simply to special-case file:/// on Windows in g.computeFileUrl.
</t>
<t tx="ekr.20131105110107.16862">LeoQTextBrowser.onSliderChanged must set v.scrollBarSpot only if "self" is actually the body pane.

Otherwise scrolling the log pane will scroll the body pane!
</t>
<t tx="ekr.20131105110107.16863">The maintain_scroll option is *evil*.
</t>
<t tx="ekr.20131105110107.16864">An assert failed during scanning in mungeAllFunctions.

Added defensive code to mungeAllFunctions, dedentBlocks and
replaceComments. The new code simply increments a pointer if a "progress"
assert would fail. (The progress assert still exists, as a double-check.)

Fixed bug: the call to u.afterChangeGroup in the go() method is called only once.

Suppress warning messages given by CPrettyPrinter.indent.
</t>
<t tx="ekr.20131105110107.16865">If the user has not typed anything in the minibuffer, &lt;alt-x&gt;&lt;tab&gt; returns *all* completions.

Otherwise, if there are no completions, the "Completions" tab is empty, *not* all completions.

This behavior is much more intuitive than the old behavior.

The fix was a new special case in k.computeCompletionList.
</t>
<t tx="ekr.20131105110107.16866"># The fix was simply to call c.endEdiing in undo and redo *before* getting the undo params.
# This allows c.endEditing to properly set the undo stack.
</t>
<t tx="ekr.20131105110107.16867">dw.createFindTab now creates a third column with a minimum width.
The find/change text widgets span the second and third columns.
</t>
<t tx="ekr.20131105110107.16868">Don't show full completion list when the minibuffer becomes empty.
</t>
<t tx="ekr.20131105110107.16869">http://groups.google.com/group/leo-editor/browse_thread/thread/dd16ac6dc1832eb2

bookmarks.py was the culprit. The code in onCreate must test to see if c.free_layout already exists.
</t>
<t tx="ekr.20131105110107.16870"></t>
<t tx="ekr.20131105110107.16871"># Changed: onActivateEvent (qtGui), onDeactivateEvent (qtGui)
</t>
<t tx="ekr.20131105110107.16872">Added code to findAllUnitTestNodes to look up the tree for @test &amp; @suite nodes
if none have been found so far.  Only for the run-unit-tests-externally/locally.
</t>
<t tx="ekr.20131105110107.16873"></t>
<t tx="ekr.20131105110107.16874">A shock: p.deletePositionsInList must be rethought and rewritten
https://groups.google.com/forum/#!topic/leo-editor/IWMWhUlkos0
</t>
<t tx="ekr.20131105110107.16875">The fix was to set new_c=self.c in the call to c.close in createFileFromOutline.
</t>
<t tx="ekr.20131105110107.16876">If an assert fails, the entire file is read into a single node.
</t>
<t tx="ekr.20131105110107.16877">https://bugs.launchpad.net/leo-editor/+bug/903640
Import of Python files containing the strings "&lt;&lt;" and "&gt;&gt;" does not work

At present @auto can import .py files containing self.cprint("&lt;&lt;" + ret +
"&gt;&gt;\n")

Furthermore, it's possible to write such files properly after changing
them.

Thus, this bug seems to have been completely fixed, as far as @auto goes.

However, *importing* the file with Leo's import-file command does fail (an
@ignore is inserted). This is expected: unlike @auto, the import command
creates an @file node, so the "perfect import" check will complain that the
section called &lt;&lt; ret &gt;&gt; is undefined.

I am going to close this item. I see no real need to support other section
delimiters in external files. If there ever becomes a real need to do so, a
separate wishlist item will be appropriate.
</t>
<t tx="ekr.20131105110107.16878"></t>
<t tx="ekr.20131105110107.16879">Rev 5840 adds support for hack that is active only on Ubuntu systems.

When Leo starts up, it creates a commander (tab) called "loading..." before
loading all tabs. This ensures that the first "real" .leo file loaded (into
a tab) will have a menu area. This tab exists only until the first real
.leo file is loaded.

Yes, this is a pretty horrible hack, but it seems necessary on Ubuntu
Unity. Presumably this is a Qt or Unity problem, but there has been
response to previous bug reports, so it seems that best that can be done.

</t>
<t tx="ekr.20131105110107.16880">This was a horrible kludge in LM.doPostPluginsInit
</t>
<t tx="ekr.20131105110107.16881">Changes in rev 4163 caused the bug.

The problem is the call to w.setStyleSheet in g.app.gui.update_style_sheet.
Apparently, this causes a layout-request event that spoils the scroll position.

The fixes:
    
1. update_style_sheet does nothing if the new stylesheet is the same as the old.

2. Added lockout to mouseReleaseEvent. update_style_sheet does nothing if
   the lockout is set.
   
3. mouseReleaseEvent sets c.p.v.insertPoint if appropriate.

Hitting Ctrl-H can still cause a small unwanted scroll, but the insert point remains visible.
</t>
<t tx="ekr.20131105110107.16882">https://bugs.launchpad.net/leo-editor/+bug/1184855

The fix was to set the name of the .leo file to foobar.pyxxx.leo in LM.initWrapperLeoFile.
</t>
<t tx="ekr.20131105110107.16883">Selecting body editor with clicks doesn't save/restore visual ivars.
The solution would be to create a new onClick event handler...

- Removed insert=None,new_p=None args from all versions of setAllText.
  These are entirely misguided, and may have contributed to scrolling problems.
  
  setAllText now *only* sets text, nothing else!

- All calls to leoMoveCursorHelper are followed by code that updates
  v.insertSpot, v.selectionStart and v.selectionLength.
  
- v.restoreCursorAndScroll now *carefully* restores selection
  based on v.insertSpot, v.selectionStart and v.selectionLength.
  It also restores the scrollbar using v.scrollBarSpot.
  
- &lt; &lt; unselect the old node &gt; &gt; (selectHelper) now *only*
  sets v.scrollBarSpot.
</t>
<t tx="ekr.20131105110107.16884"></t>
<t tx="ekr.20131105110107.16885">https://groups.google.com/forum/#!topic/leo-editor/IWMWhUlkos0

There has been much discussion recently about deleting lists of positions.
I now see that all previous strategies are fatally flawed. This is quite
shocking.

Here is the Aha: the positions passed to p.deletePositionsInList only
*specify* the desired changes; the only way to *make* those changes is to
operate on vnodes!

The new view of the problem is relatively straightforward. Consider this
very simple outline, containing no clones::

    + ROOT
      - A
      - B

The fundamental problem is simple. If we delete node A, the index of node B
in ROOT.children will change. This problem has (almost) nothing to do with
clones or positions.

To make this concrete, let's look at the *vnodes* that represent this tree.
It is the vnodes, and *not* the positions, that represent all of Leo's
data. Let ROOT, A and B be the vnodes corresponding to the nodes ROOT, A
and B. ROOT.children will look like this at first::

    ROOT.children = [A,B]

That is, the children array contains references (links) to both A and B.
After deleting A, we will have::

    ROOT.children = [B]

As you can see, the reference to B is at index 1 of ROOT.children before
deleting A, and at index 0 of ROOT.children after deleting A. Thus, *any*
position referring to B will become invalid after deleting A.

Several people, including myself, have proposed an unsound solution--just
delete positions in reverse order, so that B will be deleted before A. This
idea has appeal, but it truly *is* unsound. Here is an outline that at last
explodes the notion that there is *any* correct order for deleting
positions. All A' nodes are clones of each other::

    + ROOT
      + A'
        - B # at position p1
      + A'
        - B # at position p2

**Important**: B is *not* a clone. Also note that there is only *one* node
called A and *one* node called B. The children arrays will look like::

    ROOT.children = [A,A]
    A.children = [B]
    B.children = []

It surely must be reasonable to pass either *or both* positions p1 and p2
to p.deletePositionsInList. But after deleting the B corresponding to p1,
the children arrays will look like:

    ROOT.children = [A,A]
    A.children = []
    B.children = [] # B is no longer referenced anywhere!

So if p.deletePositionsInList attempts to delete position p2 (from A), B
will no longer appear in A.children!

There are many other cases that we could discuss, but the conclusion in all
cases is that we must use the positions passed to p.deletePositionsInList
only as *hints* about what to do.

Happily, there is a simple strategy that sidesteps all the difficulties:

Step 1. Verify, *before* making any changes to the outline, that all the
positions passed to p.deletePositionsInList *initially* make sense.

Step 2. Treat each position as a "request" to delete *some* vnode from the
children array in the *position's* parent vnode.

This is just a bit subtle. Let me explain it in detail.

First, recall that vnodes do not have unique parent vnodes. Because of
clones, a vnode may may have *many* parents. Happily, every position *does*
specify a unique parent (vnode) at that position.

Second, as shown above, there is no way to order positions such that all
later positions remain valid. As the example above shows, deleting (the
vnode corresponding to) a position P may cause *all* later positions
referring to P.v to refer to *already deleted* vnodes.

In other words, we simply *must* ignore the child indices in positions.
Given a position P, P.parent is well defined. So Step 2 above will simply
delete the *first* element in P.parent.children containing P.v.

As we have seen, there may not even *be* any such element of
P.parent.children: a previous delete may have already deleted the last item
of P.parent.children equal to P.v. That should *not* be considered an
error--Step 1 has ensured that all positions *originally* did make sense.

Summary

Positions passed to p.deletePositionsInList specify *vnodes* to be deleted
from specific parents, but they do *not* specify at what index in the
parent.children array (if any!) those vnodes are to be found. The algorithm
will delete the *first* item in the children array that references the
vnode to be deleted.

This will almost always be good enough. In the unlikely event that more
control is desired, p.deletePositionsInList can not possibly be used.

The new emphasis on vnodes at last puts the problem an a completely solid
foundation. Moreover, the new algorithm should be considerably faster than
the old: there is no need to sort positions.
</t>
<t tx="ekr.20131105110107.16886"></t>
<t tx="ekr.20131105110107.16887"></t>
<t tx="ekr.20131105110107.16888">http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893
</t>
<t tx="ekr.20131105110107.16889"></t>
<t tx="ekr.20131105110107.16890">If off, only the insert point is restored.

It's kinda pointless to make this a user option.
</t>
<t tx="ekr.20131105110107.16891">Extensions is a convenient place: code can use g.importExtension to import it.

Alas, sh.py can not be used in Leo's core.
</t>
<t tx="ekr.20131105110107.16892">The format of such local suppressions is::

    # pylint: disable=&lt;message-number&gt;
</t>
<t tx="ekr.20131105110107.16893">The new code works like leoTree.onHeadChanged.

The code can be called twice, so it is a bit tricky
to only issue warnings once.
</t>
<t tx="ekr.20131105110107.16894"></t>
<t tx="ekr.20131105110107.16895"></t>
<t tx="ekr.20131105110107.16896">A few changes that should have been done long ago:

- Added support for 'before' keyword.  Prints something before the function name.
- Use g.shortFileName(__file__) instead of "&lt;module&gt;"
</t>
<t tx="ekr.20131105110107.16897"></t>
<t tx="ekr.20131105110107.16898">Remove all .xml files in the leo/modes directory.

Imo, this should have been done long ago, for at least the following
reasons:

- These files are part of the jEdit project.
- They are used only by the jedit2py script in scripts.leo.
- The colorizer doesn't use them.
- Bug fixes to the colorizer are made to the .py files, not to the .xml files.
- We can always get updated versions of the .xml files from the jEdit
  project in the unlikely event that we ever need them again.

2. Remove the following .py files from the leo/modes directory:
cvs_commit.py, dsssl.py, freemarker.py, hex.py, jcl.py, progress.py,
props.py and svn_commit.py.

Notes:

- embperl.py, phpsection.py and pseudoplain.py will *not* be removed;
they are internal colorizer states.

- relax_ng_compact.py will be removed if it is not used by any other
colorizer.

- patch.py and rtf.py colorizers will be retained, even though Leo can
never generate such files. 
</t>
<t tx="ekr.20131105110107.16899"></t>
<t tx="ekr.20131105110107.16900">You can get this branch here: https://code.launchpad.net/~leo-editor-team/leo-editor/contrib
</t>
<t tx="ekr.20131105110107.16901">By Ville M. Vainio.

I created a proof of concept for dumping leo trees to excel.

Demo outline is in collab branch,

/Projects/excel_integration

Screenshot attached.

My usage is that I collect and organize findings (of technology studies) in
leo, and then dump the report to excel, to be read and actioned upon by
other people.

I haven't yet polished this workflow in that there is a bunch of manual
work in formatting the report...
 
</t>
<t tx="ekr.20131105110107.16902">Apart from the full text search indexing script I just added, I've made
a bunch of basically cosmetic changes to Ville's multi outline full text
search tool.  There's a new @setting, @int fts_max_hits, which controls
the max hits returned, instead of the hardwired default of 30.

With any sensible value for fts_max_hits, searches for terms which
generate many hits in many outlines won't return the full list of
outlines containing hits, because the search stops when fts_max_hits is
reached.  I set fts_max_hits to a non-sensible 1200 to get around this,
it seems to work fine.  Obviously terms which generate that many hits
are bad search terms anyway, but it's helpful to get as close to the
full list of outlines containing hits as possible.

Also most of my changes apply only to the "f target" find command, not
the simpler "s target" search command.
</t>
<t tx="ekr.20131105110107.16903">From Ville:

aaaaand we are live :).

Test it out at:

http://koti.kapsi.fi/vivainio/t/LeoReader/main.html

Sources here:

https://github.com/vivainio/LeoReader

Pretty much all the relevant stuff is in these files:

https://github.com/vivainio/LeoReader/blob/master/leoaccess.coffee

https://github.com/vivainio/LeoReader/blob/master/main.html

Works ok in Firefox and Chrome.
</t>
<t tx="ekr.20131105110107.16904">By Ville M. Vainio

Ok, I now created a toy UI demo for how "cell" based leo (like ipython
notebook) could operate.

qmlnotebook.leo (ctrl+b script + test outline) is now at contrib branch. If
you want to try it, open the .leo file, ensure you are running latest Leo
from trunk, and press ctrl+b on the first node.

It's probably the first stab at using QML to solve a problem in Leo. It
doesn't run from leo yet (it's not a plugin, more protoing needed before
it's worthwhile to make it a plugin.

When you add and delete text, the cells resize naturally.

What it currently does is putting every node wrapper in a list of QObjects,
and use that as the model in QML side (model is just a container that has
the list of stuff to show in Repeater).

So you can edit every node in a leo document in this "notebook". Future
version will probably only allow editing a subtree.

Note how headlines are "toned down" with small, grey font. Intention is
that e.g. with ipython notebook, the headline will just be a running,
uneditable sequence number basically.

BTW, forgot to mention that I put the NodeWrapper stuff under leo.core. We
can move it out eventually, but right now it seemed like a natural place
for this kind of cross-plugin utility.

And on related note: remember that with QML, sky is the limit as far as the
styling goes :). So if you have wild ideas about adding customizable
images, animated checkboxes, or other weird stuff next to the nodes, fire
away.

===== Kent Tenney

Interesting ...

Am I correct: this is POC, edits in your serialized pane don't reflect in
the Leo file?

===== Ville

Yes, modifications are not saved yet. Also, modifications in normal body
editors are not copied over to the notebook yet.  This is probably going to
end up like tabula and stickynotes in this regard.

===== Kent

This is a hint of something I've long wanted, what I have called 'slurped'
vs 'chunked' Something I miss with Leo is the capability get an overview of
a file, I find myself needing to 'open file with gvim' to grok at file
level.

The pane you are generating offers both at once, I can see the linear view
of the file, retaining the 'chunk' metadata (node headlines).

===== Ville

Getting an overview of a file could be an interesting extra use case, my
main interest is still in using it for interactive programming/computation
(like ipython notebook) .

===== Terry Brown

Played with it. I guess the next step would be demo of python handling
events from the QML UI elements, and of python finding and manipulating the
QML UI elements.

I'm wondering about the advantages of this approach over the "regular"
QWidget approach. QML is perhaps a more terse and elegant language for
defining a UI, and it has scripting of UI behavior in javascript. And
perhaps it has a more tablet friendly widget set?

But I wonder what it lets you do that you can't do with the QWidget stack,
given that mixing the two seems to mean that Leo is using two GUI systems -
they may be very tightly integrated, but mind-space wise it's two complex
systems instead of one.

Which isn't a reason not to use QML, just wondering if it has advantages
I'm missing.

===== Terry

Here's a demo to run Ville's QML thing in a free_layout pane. Requires rev.
5284 so the .qml file in leo/plugins/qmlnb/ is available.

Paste this into a node, run-script on the node, right click a splitter
handle, Insert, click the Action button, select "Add QML shower".

Note that you can flick the text boxes it shows up and down with the mouse,
in a tablet / phone ui kind of way.

---cut here---
from PyQt4.QtCore import QUrl
from PyQt4.QtDeclarative import QDeclarativeView
class QMLShower:
    def __init__(self, c):
        self.c = c
        c._qml_shower = self
        self.w = None
        c.free_layout.get_top_splitter().register_provider(self)
    def ns_provider_id(self):  # allow for re-registering, mainly for dev.
        return '__qml_shower'
    def ns_provides(self):  # what we can provide
        return [("Add QML shower", '__add_qml_shower')]
    def ns_provide(self, id_):  # provide it
        if id_ == '__add_qml_shower':
            g.unregisterHandler('select2', self.update)
            g.registerHandler('select2', self.update)
            if not self.w:
                self.w = self.make_widget()
            return self.w
    def make_widget(self):
        view = QDeclarativeView()
        path = g.os_path_join(g.computeLeoDir(), 'plugins', 'qmlnb', 'qml', 'leonbmain.qml')
        view.setSource(QUrl(path))
        view.setResizeMode(QDeclarativeView.SizeRootObjectToView)
        # Display the user interface and allow the user to interact with it.
        view.setGeometry(100, 100, 400, 240)
        view.show()
        # rootObject = view.rootObject()
        return view   
    def update(self, tag, kwords):
        pass
    def closed(self, event):
        g.unregisterHandler('select2', self.update)

QMLShower(c)
---cut here---
</t>
<t tx="ekr.20131105110107.16905">From: Jacob Peck

One of the ways I use Leo is as an information management/database for when
I'm running tabletop RPGs. Such games involve a fair amount of similarly
structure data. I set out to make a way of defining a template, and
providing macro expansions within the template, so that the user could
click a script button, be prompted for data, and be rewarded with a
fully-populated copy of the template. I've managed to accomplish this with
the code below:

https://gist.github.com/gatesphere/2be5030506a364ee6ec1

How it works is like this:

- Create a `@template` node.  This is the parent node for your template.

- Create a `@destination` node as a child of the @template node. This 
node's headline is the name of a top level node where your completed 
template will be placed.  `@destination Sessions` will place the 
finished product under the top-level "Sessions" node.

- Populate the @template node with various `@item` nodes - these keep 
their structure in the filled template.  Anything that needs to be a 
part of the final product has to be an @item node.

All of that is fine and dandy if you just want to copy and paste... but 
that's already baked into Leo.  So I added macro expansion.  The script 
gathers up all instances of anything that fits the regex "&lt;\\$\\w+&gt;" is a 
macro variable name.  Something like `&lt;$name&gt;` or `&lt;$date&gt;`.  The script 
gathers up all of these variable names, and prompts the user (ala 
todo.py's "Redistribute Priorities" function) for values for each of 
them. They are global with respect to the template, so using the same 
macro variable in multiple places in the same template will result in 
all of them being filled in with the same value.

In addition, there is one more type of node that can go under @template 
nodes - @default.  @default nodes provide a default value for a macro 
variable.  The node with a headline of `@default &lt;$name&gt;` and a body of 
"This is my body" gives the `&lt;$name&gt;` macro a value of "This is my body" 
everywhere within the template, and that macro will not be prompted for 
a value.  This is handy if you're copying templates between Leo 
worksheets, and want them flexible, but don't want them to fill in the 
same value for every single invocation of copy-template.

Here's an example template:

@template &lt;$campaign&gt; Session #&lt;$num&gt; ($date)
       @destination Sessions
       @default &lt;$campaign&gt;
       @item Who's Coming?
       @item In-World Start Date
       @item Log
       @item Threads
             @item High Priority
             @item Low Priority
       @item News
             @item Out of Character
             @item In Character

The body of `@default &lt;$campaign&gt;` is "World of Ka'rim".  The body of 
`@item Who's Coming?` is "John, Jane, Jack, Jenny, Jeremy".

Running copy-template on this template, and filling the values prompted 
for (&lt;$num&gt; and &lt;$date&gt;) gives the following under the top-level node 
Sessions:

World of Ka'rim Session #1 (01 May 2013)
       Who's Coming?
       In-World Start Date
       Log
       Threads
             High Priority
             Low Priority
       News
             Out of Character
             In Character

The headlines bodies are correctly filled in with macro expansions, and 
other text is verbatim copied from the respective headlines and bodies.

So... two questions:

1.) Did I re-implement something Leo already does?
2.) Anyone have any suggestions on reducing the amount of code/any fixes?

Also, hope someone else finds this useful.  Once it's cleaned up, I 
might do a leo-editor blog post about it.
</t>
<t tx="ekr.20131105110107.16906"></t>
<t tx="ekr.20131105110107.16907">Help-for command translate !&lt;command-name&gt;! in the docstring to the binding for command-name.
</t>
<t tx="ekr.20131105110107.16908"></t>
<t tx="ekr.20131105110107.16909">Skip '.' before section names in v.matchHeadline.

2013/08/01: bug fix: allow leading periods in at.isSectionName.
</t>
<t tx="ekr.20131105110107.16910"></t>
<t tx="ekr.20131105110107.16911">In earlier version of Leo if one runs test externally with the selected
position under @test node, that @test was executed with
(run-marked-unit-tests-externally)

The fix was to the "important special case" in TM.findAllUnitTestNodes.
</t>
<t tx="ekr.20131105110107.16912">The commands now work, and Alt-slash and Alt-Ctrl-slash are bound as in Emacs.
</t>
<t tx="ekr.20131105110107.16913">The quicksearch plugin now supports the go-anywhere command. It works "sort
of" like Nav bar. Also Nav bar now does live search on headline (you have
to press enter to force search of bodies as well)

Once the hits are shows, you can navigate them by pressing up/down while
focus is still in line editor &amp; you can keep on typing (sort of like
sublime text).

This has a very clever hack (even if I say so myself)--spaces in search
string are replaced with * wild card. So if you search for, say "file txt",
it will search for "file*txt", matching e.g. @file readme.txt
</t>
<t tx="ekr.20131105110107.16914"></t>
<t tx="ekr.20131105110107.16915">Instead of just printing their docstrings.
</t>
<t tx="ekr.20131105110107.16916"></t>
<t tx="ekr.20131105110107.16917"></t>
<t tx="ekr.20131105110107.16918">- Documented that return ends the search.
- Documented that deleting the entire search pattern aborts the search.
- Removed annoying status messages printed to log.

- (Can't do) If text is already highlighted, Alt-S or Alt-R should use that text.

</t>
<t tx="ekr.20131105110107.16919">By Terry Brown

I assume all *nix shell users use the screen shell multiplexer, and
hopefully *nix shell users who use Leo know about the leoscreen plugin
which passes text back and forth between Leo and the shell (provided you're
running screen), which is very handy for build scripts and SQL hacking etc.
etc.

Anyway, if you're in that sliver on the Venn diagram :-) there's a new
command leoscreen-jump-to-error which scans the output in the shell for the
offending line in the last python traceback, handy if you're coding python
in Leo and running/debugging in the shell.

leoscreen-jump-to-error
    Jump to the python error reported in the shell window, if the
    file's loaded in the current Leo session. Just looks for a line:

        File "somefile.py", line NNN, in xxx

    and looks for a node starting with "@" and ending with "somefile.py",
    then jumps to line NNN in that file.
</t>
<t tx="ekr.20131105110107.16920">https://bugs.launchpad.net/bugs/994985
Wishlist: normalize-whitespace

When using @auto, the logic often complains about "abnormal" whitespace and
refuses to write/read node normally.

What I did:
    
1. The clean-lines command (and thus the clean-all-lines command)
   now remove trailing whitespace while preserving newlines.
   
2. reportMismatch suggests using the clean-all-lines command.
   Note: a good unit test for reportMismatch already exists.
   
3. Added a unit test for clean-lines.
</t>
<t tx="ekr.20131105110107.16921">Useful for re-parsing text that was not originally parsed properly.
</t>
<t tx="ekr.20131105110107.16922">Created print-buttons command, showing source of all @command and @button nodes.

Changed ParserBaseClass.doButtons/doCommands so they return
lists of (p.copy(),script) rather than (p.h,script)

Added g.app.config.atLocalButtonsList &amp; g.app.config.atLocalCommandsList
for use by print-buttons command.
</t>
<t tx="ekr.20131105110107.16923">"refresh from disk" is now done for all selected nodes. You can either

ctrl-click each @&lt;file&gt; node you want refreshed, then "refresh from
disk" to refresh all of them, or

shift-click the first and last @&lt;file&gt; node you want refreshed, to
select the entries in between, then "refresh from
disk" to refresh all of them.

(i.e. standard UI list multi item selection)

But be aware of this bug:
https://bugs.launchpad.net/leo-editor/+bug/1090950

using refresh from disk immediately after cutting nodes from the
outline has odd effects.
</t>
<t tx="ekr.20131105110107.16924">A simple change to k.computeCompletionList was all that was needed.

</t>
<t tx="ekr.20131105110107.16925"></t>
<t tx="ekr.20131105110107.16926">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I just pushed two new commands, zoom-in and zoom-out, which increase
or decrease the body text font size by one point size.  They probably
deserve default bindings, but to what?  I have them on Ctrl-; and Ctrl-'

They leverage the new theme "engine" by manipulating a constant
"@font-size-body".  I've set it up in the default theme, anyone using
the new dark theme will need to add

   @font-size-body = 18px

in the config node for that theme, 

@settings--&gt;solarized_dark theme settings--&gt;stylesheet &amp; source--&gt;config

and replace the literal "18px" with "@font-size-body" in the node

@settings--&gt;solarized_dark theme settings--&gt;stylesheet &amp; source--&gt;Non-color styles (fonts etc.)--&gt;body editor

commit log:

  zoom-in / zoom-out commands
  ctrl-mouse wheel scrolling for same
  
  replace old focused pane border highlight with pure stylesheet
  version
  
  rename solarized_dark theme leo_dark_0
</t>
<t tx="ekr.20131105110107.16927"></t>
<t tx="ekr.20131105110107.16928">This is a significant improvement, and makes Leo suitable for authoring
text. It should have been done ages ago. Please let me know immediately if
this new behavior causes problems for you.

There is one glitch.  If you add @wrap, the directive won't be in effect 
until you leave the node and revisit it.

===== redla

There is one problem which is caused by this change: I have @wrap active
and see my "plain" text wrapped properly. But if there is any "long enough"
URL on the page (i.e. longer than the screen width), this is not wrapped
(as there is no space in the string) nor I can see the end of it (as there
is no horizontal scrollbar either)

</t>
<t tx="ekr.20131105110107.16929">These are generated from the @button node's docstring, if it exists.
</t>
<t tx="ekr.20131105110107.16930">Leo now supports having border colors that show which pane has focus.

To enable such borders, modify (in your myLeoSettings.leo)::

    @data qt-gui-plugin-style-sheet

Change::

  @focused-border-style = none

to::

  @focused-border-style = solid

**Important**: The following settings are no longer used::

    @int focus_border_width = 1
    @bool use_focus_border = False 
</t>
<t tx="ekr.20131105110107.16931">by Terry Brown

I just pushed the solarized dark theme to trunk. There were some changes to
core code, but nothing too major, and I've been using it for some time.

In leoSettings.leo there's a new top-level node called 'Themes', which
contains a single theme node at the moment, you can copy that to you
myLeoSettings.leo file under @settings. Read the README node of the theme
node for more instructions.

The theme is far from perfect - it's relatively easy to get it looking ok
if you're already running a dark desktop theme, which is what I'm doing,
but much harder if you want Leo dark in a light desktop theme, as you need
to theme everything.

 - See the README. If you're already running a dark theme there's a `base`
   node which can be switched to `@ignore base` to take more advantage of
   your desktop theme.

 - The new theme system includes a stylesheet authoring tool with macro
   substitutions :-) you no longer edit @data qt-gui-plugin-style-sheet
   directly but edit a more comfortable Leo tree version and then
   run-script on the appropriate node to "compile" to @data
   qt-gui-plugin-style-sheet
   
**Note**: The docs in the theme node do mention moving other @data
qt-gui-plugin-style-sheet and @color nodes out of the way, but I've added a
couple of notes about putting it at the bottom of the @setting list to
ensure it overrides other settings. The problem is when the default theme's
@data qt-gui-plugin-style-sheet node comes after the dark theme's.

===== Ville.

If you prefer the bigger contrast that e.g. Sublime Text 2 has, try this
"config": https://gist.github.com/vivainio/5261207

===== Terry

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Along these lines someone wanted a dark body only, you can get that by just
adding @ignore to all the color related nodes other than body, or moving
all of them under an @ignore node.

===== Ville 

I'm slightly bothered by the fact that color variable names have
"solarized" in them. You are supposed to create new themes by changing
their values in the "config" node, after which the theme is not "solarized"
any more. How about "@leotheme-c-0" (for color 0) etc.

===== Terry

The variable replacement runs up to ten levels deep, after which it bails
assuming you've created a loop :-)

So there's nothing wrong with::

  @solarized-yellow = #abcdef

The issue is that `@solarized-yellow` is used in the guts of the stylesheet
definition. Instead, ideally, but I didn't get to it, in the config node
you'd have::

  @solarized-yellow = #abcdef
  ...
  @highlight-hot = @solarized-yellow

and then use `@highlight-hot` in the guts of the stylesheet definition.

**Note**: you can't create new themes simply by editing the config node,
it's not possible to create enough constants for every style element that
can be addressed by a stylesheet.

But it would be nice to move all the color and numeric constants out of the
stylesheet and into the config node as I've described above, just a find
and replace operation.
</t>
<t tx="ekr.20131105110107.16932">By Ville M. Vainio

https://plus.google.com/103097156557482112329/posts/6D9GPRCdXVh
</t>
<t tx="ekr.20131105110107.16933">- Added the following commands:
    
    - ctrl-click-icon
    - ctrl-click-at-cursor
    - open-url
    - open-url-under-cursor
    
- Double-click *only* edits headline.
- Only look at first line of the body in @url nodes.
- Ctrl-click in body allows spaces in url's.
</t>
<t tx="ekr.20131105110107.16934"></t>
<t tx="ekr.20131105110107.16935">Leo now contains support for \@testsetup nodes. At present, they work only
when running unit tests locally.

In effect, \@testsetup nodes provide common setup code for all following
\@test and \@suite nodes. Such common setup code is the real reason for
having custom subclasses of unittest.TestCase. This Leonine solution is
much than either:

a) @testclass nodes (which I never use) or

b) "injecting" common test code using::

    exec(g.findTestScript(c,\'@common name-of-common-test-code\'))

Leo's test-execution code prepends the body text of an \@testsetup node to
all following @test and @suite nodes. Multiple \@testsetup nodes may appear
in an outline. The range of an @testsetup node extends over all following
\@test and \@suite nodes until the next \@testsetup node is seen (in
outline order).

</t>
<t tx="ekr.20131105110107.16936">\@testclass nodes should set either the suite or testclass vars.

\@suite nodes should set the suite var.
</t>
<t tx="ekr.20131105110107.16937">- Changed es so it always queues messages when g.app.log is None.
- Completed the command-line args: --session-save and --session-restore.
- Wrote session info in leoTabbedTopLevel.closeEvent and g.app.onQuit.

Rev 5324 finishes some session-related work. The existing
session commands are unchanged, but Leo now fully supports
two new command-line arguments::

    --session-restore     restore previously saved session tabs at startup
    --session-save        save session tabs on exit

If you use both arguments, everything is automatic: Leo
saves the tabs when you quit Leo, and restores tabs when you
start Leo. Note that you can still specify file names on the
command line in addition to whatever files --session-restore
will open for you.

If you use only --session-restore, it is up to you to save
sessions "by hand" with one of the session commands, for
instance, session-snapshot-save.
</t>
<t tx="ekr.20131105110107.16938">A major change in Leo's read/write code.  The first "live" rev was 5584.
At present, controlled by the allow_cloned_sibs switch in leoAtFile.py.

Fixes the following bugs:

clones sometimes not saved
https://bugs.launchpad.net/leo-editor/+bug/882243

When all clones of a node are in an @file subtree, they disappear on exit
https://bugs.launchpad.net/leo-editor/+bug/1084661
</t>
<t tx="ekr.20131105110107.16939">http://groups.google.com/group/leo-editor/browse_thread/thread/67a28984616d09c9
About bug 882243: clones sometimes not saved

What I did:

- Added allow_cloned_sibs switch at the start of leoAtFile.py.
  All new code enabled by this switch.

- Refactored at.createNewThinNode:
    - Renamed createThinChild4 to old_createThinChild4.
    - Added new_createThinChild4.
    - Added createV5ThinNode.
    
The key invariant in createV5ThinNode:
    On exit from at.changeLevel, top of at.thinNodeStack is the parent.
</t>
<t tx="ekr.20131105110107.16940">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Abbreviations can now include computed values and place holders which you
can step through, filling in a template.

Here's a quick screencast of the template expansions:
http://www.greygreen.org/tmp/leoabbrev.ogv

Here are the draft docs. for abbreviations:

Abbreviations are very versatile. You can type ``def;;``, and Leo will
prompt you for a function name, detect whether the function needs a
``self`` parameter, ask for a list of parameters, and expand your input
(just ``"some_function"`` and ``"one, two, three=4"`` to something
like:: 
    def some_function(one, two, three=4):
        """some_function - Return &lt;|return|&gt;
    
        :Parameters:
        - `one`: &lt;|describe one|&gt;
        - `two`: &lt;|describe two|&gt;
        - `three`: &lt;|describe three|&gt;

        Created: Wed Aug 22 10:32:54 CDT 2012
        """
    
        &lt;|code|&gt;

The first placeholder, ``&lt;|return|&gt;`` will be selected, so you can
begin typing in the right place. Hitting ``,,`` will select the next
place holder, and so on.

They can also close XML tags, enter balanced indented markup for
various languages, etc.

Here's a list of `@settings` which relate to abbreviations.

@bool enable-abbreviations = False
    True: enable abbreviations
    False disable abbreviations
    
    Typically you would enable abbreviations in myLeoSettings.leo or in
individual .leo files.
@data global-abbreviations &amp; @data abbreviations
    # Comments lines (lines starting with '#') are ignored.
    # Non-comment lines should have the form::
    #
    #    name=definition
    
    # Definitions in @data abbreviation nodes override definitions in
@data # global-abbreviation nodes. Typically you would define @data
abbreviation nodes # in myLeoSettings.leo
@string abbreviations-subst-start = None
    If this @string is set to something other than None, *and*
    @bool scripting-at-script-nodes = True, then substitutions
    will be made when abbreviations are inserted.  For example
    set abbreviations-subst-start to ``{|{`` and
    abbreviations-subst-end to ``}|}`` and an abbreviation
    like::
    
        date;;={|{import time;x=time.asctime()}|}
    
    will expand to something like "Mon Aug 20 22:00:40 2012"
    
    See also abbreviations-subst-env.
@string abbreviations-subst-end = }|}
    See abbreviations-subst-start.  This setting,
    abbreviations-subst-end, has no effect if
    abbreviations-subst-start is not set.
@data abbreviations-subst-env
    If abbreviations-subst-start is set (see that 
    @setting), the code in this node will be executed, once
    only, when the outline is loaded, in an environment which
    will be used for execution of substitutions in
    abbreviations.  For example, if this node contains
    ``import time``, then an abbreviation like::
    
        date;;={|{import time;x=time.asctime()}|}
    
    can be written more simply as::
    
        date;;={|{x=time.asctime()}|}
    
    The environment will contain `c` and `g`, a dict called `_values`
    (see ask() and get() in @data abbreviations-subst-env), and
    `_abr`, the abbreviation being expanded.
    
    Start lines with `\\:` to preserve indentation.
@@data abbreviations examples
    See the node for examples of advanced abbreviations with
    substitutions.
@string abbreviations-place-start = &lt;|
    Start of a placeholder for template expansions.  E.g.
    the `&lt;|` in::
    
        w;;=while &lt;|condition|&gt;:
        \\:    &lt;|code|&gt;
    
    This would expand with the `&lt;|condition|&gt;` selected, and `,,`,
    if that's an abbreviation linked to next_place(), see 
    @@data abbreviations examples, would select `&lt;|code|&gt;`.
@string abbreviations-place-end = \\|&gt;
    The end of a placeholder for template expansions, e.g.
    `|&gt;`. See @string abbreviations-place-start.


===== EKR

The same exec statement appears to allow the execution of arbitrary
Python code.

===== Terry

That's why enabling requires @bool scripting-at-script-nodes = True as
well as the abbreviation specific stuff.  The risk seems equivalent to
the scripting-at-script-nodes = True risk.
</t>
<t tx="ekr.20131105110107.16941">Leo's abbreviations have been significantly improved by adding scripted
abbreviations and templates. This is the work of Terry Brown,
&lt;terry_n_brown@yahoo.com&gt;

Terry describes the new features in a screencast: http://www.greygreen.org/tmp/leoabbrev.ogv

The highlights::

1. The @data abbreviations-subst-env node contains a script defining the
   environment in which all abbreviations execute. This allows helper
   functions to be defined. Very handy.
   
2. Scripts may span multiple lines. Line starting with "\:" (2 characters)
   continue a script. This allows abbreviations to define multi-line
   templates.  Helpers defined in @data abbreviations-subst-env can
   fill in templates with *calculated* (not predefined) data.
   
3. Templates may contain placeholders that the user can fill in.  By default,
   the double comma binding selects the next placeholder.

4. Added a new setting: @bool scripting-abbreviations, default False.
   Scripting abbreviations will be enabled if *either* of the following is
   True::

        @bool scripting-abbreviations
        @bool scripting-at-script-nodes
    
    This is a safety feature: it allows scripting abbreviations to be
    enabled *without* enabling the (very dangerous in general)
    scripting-at-script-nodes setting.

5. Added a new example node: @@data abbreviations examples.  This contains
   several extremely useful scripts.
</t>
<t tx="ekr.20131105110107.16942">https://bugs.launchpad.net/leo-editor/+bug/711158

- The PickleShareDB object is created even if caching (of files) is disabled.
  This allows us to used g.app.db even when --no-cache is in effect.
  
- Added the three methods in app.Detecting already-open files.
</t>
<t tx="ekr.20131105110107.16943"></t>
<t tx="ekr.20131105110107.16944">Leo now supports @auto-otl, along with imports of .otl files.

There are two ways to create @auto-otl nodes:

1.  Use Leo's import-file command to create and populate an @auto-otl
node. Save the .leo file.

2. Create an @auto-otl &lt;path to the .otl file&gt;.  Use the refresh-from-disk command
to populate the node *before* saving the .leo file.

Either way, you should now have an @auto-otl node whose **children**
represent the contents of the external .otl file.  (The actual @auto-
otl node is *not* written to the external file.  This allows you to
put Leo directives in the node.) Changing the children in Leo will
change the external file.  Changing the external file outside of Leo
will update the outline the next time you restart the .leo file
containing the @auto-otl node.
</t>
<t tx="ekr.20131105110107.16945">Rev 5488 contains a prototype for importing IPython notebook (.ipynb) files 
into Leo.  In theory, this would allow two-way interchanges between Leo 
outlines and the outlines in IPython notebooks.

At present, the prototype simply converts a string containing the contents 
of a .ipynb file to a Leo outline.  A few details remain, but it shows that 
such conversion is straightforward.  Otoh, this is just a first step: we 
would like the Leo outline to support most of the features of IPython 
notebooks, including embedded images, etc.

===== From: Alia K

May a suggest a radical thought exercise that only occurred to me after 
seeing what can be achieved in terms of in-browser editing with 
http://codemirror.net/: 

Why not create an ipython notebook "plugin" version of leo which would only 
provide core leo functionality: outlines, literate programming, and clones, 
but would not be burdened by having to support legacy leo plugins. 

You could leverage all the mad goodness and momentum that is happening with 
ipython right now (interactivity, parallelism, networking and 
collaboration, interactive access to javascript libs like d3.js, etc.., 
inline images, and movies, and cell magic, etc..). Since ipython is pretty 
much pervasively used ... it could be a good thing for leo (-:
</t>
<t tx="ekr.20131105110107.16946">Added TypeScriptScanner class and related code.
</t>
<t tx="ekr.20131105110107.16947">Created vimoutlinerScanner.

Created at.writeAtAutoOtlFile.
</t>
<t tx="ekr.20131105110107.16948"></t>
<t tx="ekr.20131105110107.16949"></t>
<t tx="ekr.20131105110107.16950">Added printing.py.
</t>
<t tx="ekr.20131105110107.16951">From: Ville M. Vainio
See: http://en.wikipedia.org/wiki/Mylyn

I went on to start a "leo mylyn" plugin to exercise using the
childrenModified and contentModified signals.

If you want to play with it, pull, enable leomylyn.py, modify stuff
around the tree and do alt-x mylyn-scores.

Of course as it is useless in this state, but becomes useful when it
has a proper gui (maybe in Nav pane), where you would then have a list
of "most interesting" nodes.

In the future, this could be able to remember the scores through the
sessions, degrade the old scores by time, etc. Also, a scoreset would
be associated with a "project" (e.g."own research", "work project
foo"), each of them having their own typical node working set.

Mylyn was a nice boost back in the eclipse days, it could work for Leo
too. My main motivation right now was to demonstrate the signals with
something that is much simpler than using them in qmlnotebook.
</t>
<t tx="ekr.20131105110107.16952">The printing.py plugin fixes this bug:
https://bugs.launchpad.net/leo-editor/+bug/1132804

Here's the docstring:

'''Supports printing from the Qt GUI.

Jacob M. Peck, 2013

Commands
========
This plugin supports the following twelve commands:

print-selected-node
-------------------

Opens up the print dialog to print the selected headline and node.

print-preview-selected-node
---------------------------

Opens up the print preview dialog to preview the selected headline
and node.

print-selected-node-body
------------------------

Opens up the print dialog to print the selected node body.

print-preview-selected-node-body
--------------------------------

Opens up the print preview dialog to preview the selected node body.

print-expanded-node
-------------------

Opens up the print dialog to print the expanded contents of the
selected node, with top-level headline.

print-preview-expanded-node
---------------------------

Opens up the print preview dialog to preview the expanded contents
of the selected node, with top-level headline.

print-expanded-node-body
------------------------

Opens up the print dialog to print the expanded node body.

print-preview-expanded-node-body
--------------------------------

Opens up the print preview dialog to preview the expanded node
body.

print-marked-nodes
------------------

Opens up the print dialog to print all marked nodes in the current
outline, with headlines.

print-preview-marked-nodes
--------------------------

Opens up the print preview dialog to preview all marked nodes in \\
the current outline, with headlines.

print-marked-node-bodies
------------------------

Opens up the print dialog to print the bodies of all marked nodes
in the current outline.

print-preview-marked-node-bodies
--------------------------------

Opens up the print preview dialog to preview the bodies of all
marked nodes in the current outline.

Settings
========
- ``@string printing-font-family = DejaVu Sans Mono``
   The font family for printing.  A monospaced font is recommended.

- ``@string printing-font-size = 12``
   The font size for printing bodies, in px.  Due to limitations
   of PyQt, the size of headlines cannot be changed.
   
'''
</t>
<t tx="ekr.20131105110107.16953">By Terry Brown.

See http://leo-editor.github.io/screen_capture.html

screen_capture_now captures an image immediately, screen_capture_5sec waits
five seconds, so you can position the pointer, open menus etc. The only
feedback is in the console, as messages in the log would be distracting in
the captured image.
</t>
<t tx="ekr.20131105110107.16954">By Edward K. Ream

Screencasts promise to be easy to be *much* easier to create than 
slideshows, while also being more interesting, informative and flashy.  It 
is *so* much easier to write a screencast script than it is to lay out a 
slide, take a screenshot, and then manage resulting slide.

In particular, there are few continuity problems with screencasts.  
Continuity is a *huge* problem with slideshows!  If I change one slide, I 
am likely to want to change all following slides.  Which means I have to 
retake all the slides, and file the new versions in the proper places.  In 
contrast, any changes to screencasts naturally propagate forward.  There 
might be an effect on following screencasts scenes, but this will happen 
rarely with a reasonable scene design, and any problems should be easy to 
fix.

With screencasts, the *movie* script is also the *python* script!  There is 
no "translation" from one to the other.  Furthermore, all the work to 
produce a screencast is done (naturally!) within Leo.  No need to create 
and manage external data.  This is another huge advantage and it make 
producing screencasts much faster than producing slideshows.

Screencasts may be the long-awaited tools that will allow me to show Leo in
action so that other will finally be able to understand it easily.
</t>
<t tx="ekr.20131105110107.16955">By Kent Tenney

The timestamp plugin manages the following node attributes:

- str_ctime: creation time
- str_mtime: time node was last modified
- str_atime: time node contents were last viewed
</t>
<t tx="ekr.20131105110107.16956"></t>
<t tx="ekr.20131105110107.16957">By Terry Brown

The bookmarks.py plugin provides a pane with colored links to nodes.
Bookmarks can now be added and removed with mouse clicks, making navigation
back and forward between related nodes quick and easy.

The free_layout Action button context menu will also allow you to add one
of these bookmark panes, and they will be saved and loaded again if the
layout is saved and loaded.

=====

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&amp;name=' + escape(d.title) + '&amp;selection=' + escape(window.getSelection()) + '&amp;url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks--&gt;Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox.
</t>
<t tx="ekr.20131105110107.16958">IPython plugin now works with all versions of IPython.

- Import logic looks for legacy IPython first (0.11 and prev),
  then looks for new-style IPython (0.12 and above).

- Created GlobalIPythonManager class, assigned to leoIPython.gipm and g.app.gipm.

- Added self.c ivar to LeoNode class.  This is the same as p.v.context.

- Changed:
    - init (qtGui.py top level) (qtPdb)
    - runMainLoop (qtGui)
    - start_new_api
</t>
<t tx="ekr.20131105110107.16959">**Important** Ville M. Vainio has made many nifty additions to this plugin.

Here is a summary: http://leo-editor.github.io/valuespace-intro.html

Some details:

1. valuespace now support yaml in named anchors (i.e. "@a foo.yaml" now parses
parent as yaml and assigns the result to variable "foo"). It also has a
dependency on pyyaml now.

2. I'm doing some research now, that requires storing inputs in json, I use
   those inputs to calculate some outputs and store them in .json files. I
   added a few directives to valuespace.py plugin to bring native json data
   support.

**@vsi foo.json**

reads in file foo.json, and stores the parsed data structure to vs /
ipython variable "foo"

**@vso bar.json**

serializes content of variable "bar" to json file. \@vsi gets executed
during pass 1 of vs-update, \@vso gets executed in phase 2.

Body text gets assigned with json content in both cases.

Some further notes:

- Yes, the .json extension is explicitly special cased in the code. The
  idea is that e.g. @vso foo.csv would serialize the contents of variable
  "foo" as csv, .yml would use yaml etc.

- vsi and vso stand for value space input and value space output,
  respectively

For now, the best way to study it is valuespage_example.py in contrib
branch.

I'm being very successful in using it + new ipython support as "ipython
notebook" workalike.

Ipython notebook is better for quick experiments, but I'm doing long term
(multi-week) research, where Leo + IPython + valuespace is doing a great
job so far.

===== Terry Brown

I've added ``vs-eval``, ``vs-last``, and ``vs-last-pretty`` commands to
the ``valuespace.py`` plug-in.  Update docs below.

===== Ville

If you don't want them in there, let me know and I'll move them. I put them
in there to avoid creating yet another plug-in, they're sort of a light
weight local calculation tool, vs. ``valuespace.py``'s outline wide calcs.

valuespace.py
=============

vs-eval
-------

Execute the selected text, if any.  Select next line of text.
    
Tries hard to capture the result of from the last expression in the
selected text::
    
    import datetime
    today = datetime.date.today()
    
will capture the value of ``today`` even though the last line is a
statement, not an expression.
    
Stores results in ``c.vs['_last']`` for insertion
into body by ``vs-last`` or ``vs-last-pretty``.

Removes common indentation (``textwrap.dedent()``) before executing,
allowing execution of indented code.

``g``, ``c``, and ``p`` are available to executing code, assignments
are made in the ``c.vs`` namespace and persist for the life of ``c``.
    
vs-last
-------

Insert the last result from ``vs-eval``.  Inserted as a string,
so ``"1\\n2\\n3\\n4"`` will cover four lines and insert no quotes,
for ``repr()`` style insertion use ``vs-last-pretty``.
    
vs-last-pretty
--------------

Insert the last result from ``vs-eval``.  Formatted by
``pprint.pformat()``,  so ``"1\\n2\\n3\\n4"`` will appear as
'``"1\\n2\\n3\\n4"``', see all ``vs-last``.
</t>
<t tx="ekr.20131105110107.16960">Supported ctrl-clicks in viewrendered panes.

Jacob Peck added support for markdown
http://packages.python.org/Markdown/
markup in viewrendered panes.
</t>
<t tx="ekr.20131105110107.16961">The highlights of the changes:

1. leo.core.leoIPython.py now contains *all* of Leo's IPython-related code.
   The setup code comes mainly from leo.plugins.internal_ipkernel.py.

2. internal_ipkernel.py still exists (it will go away soon), but it has has
   been completely disabled as follows::

    if 0:
        @others

3. When the --ipython command-line argument is in effect, g.app.ipk is a
   *singleton* IPython shell, shared by any and all IPython consoles.

4. The startup code injects only a single object, _leo, into the IPython
   namespace. This is an instance of the bulked-up LeoNameSpace class. This
   interface class now contains features that make it easier to deal with
   multiple open Leo commanders.

- _leo.g is set to leoGlobals only once. Not exactly correct, perhaps, but
  nobody will notice.

- _leo.commanders is a (read-only) property returning the list of open
  commanders. This list is always kept up-to-date: it scans
  g.app.windowList before returning its result.

- _leo.c is a (read/write) property returning g.app.windowList[0].c if the
  windowList has only one element, or the "designated commander" if it
  exists. Otherwise, it returns None. In that case, the expectation is that
  the user will "designate" a commander with: _leo.c = aCommander.

- _leo.find_c(path) returns the commander c such that c.fileName() or
  g.shortFileName(c) matches path.

5. Perhaps most importantly, that's *all* there is. In particular, Ville's
   magic functions and LeoWorkbook class are gone.

Imo, the deleted code might better exist as IPython startup code, but I
could be wrong. Furthermore, Leo's p.h and p.b properties are new since
Ville first created the code, and so this kind of support code is less
urgently needed.

If there is a great demand to restore these features, it can always be done
later. For now, though, I wanted to do the simplest thing that could
possibly work.
</t>
<t tx="ekr.20131105110107.16962">The following scripts have been added to scripts.leo:

By Terry Brown::

    Add @script node
    Cross-outline node editing
    Export full contents
    Full tree view (See the discussion in the child)
    Indexing files for full text search
    Persistent state with json as a leo abbreviation
    Tool for diffing Leo files
    
By Edward K. Ream::

    Cleanup imported nodes
    Create global data structures from in modes/*.py files
    Get all comments from modes (slow)
    Import org mode
    jinja2 templating
    Recursive import script (with cleanups)
    
By Brian Theado::

    Display function call hierarchy in Leo
</t>
<t tx="ekr.20131105110107.16963">From: wgw &lt;wgwinder@gmail.com&gt;

I would like to see a fuller outline view of Leo trees. So instead of 
seeing one body only and the tree of headlines, I want to display all the 
parts of the tree (all bodies and subheadings) as continuous text, much 
like a word processor outline. 

===== From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Ville did something possibly similar:
https://groups.google.com/forum/?fromgroups=#!topic/leo-editor/Zs-5jKjPAB0

===== From: wgw &lt;wgwinder@gmail.com&gt;

Thanks! That plugin does both more and less than I want: more, because I
get a full and nicely formatted window with editable text boxes; less,
since it doesn't write any edited text back to the tree.

My fumbling tinkering would go towards not editing in the preview
window/pane at all, and just having a keystroke or click scroll the editing=

pane to the right node in Leo. But that would mean that the preview panel=

would have have to be properly indexed so that from the cursor position in=

the panel the plugin could find the proper node back in the Leo panel.
 (Kludgey way: put the node id in the text!)

Thanks for the suggestion.

===== wgw

Is there a  way to delete an inserted pane?

===== Terry

Yes, although a bit putzy.  Right click on the panel divider adjacent
to the pane, it may be above or below or left or right of it.  The panes
either side of the divider will be highlighted blue and orange.  There
will be an option to "Delete 1 left" or "Delete 1 below" or similar, if
that seems to refer to the panel you want to delete, that's your option.

If the target panel seems to be joined with another (i.e. 2 not 1
above) try right clicking a different divider to start with.

===== Matt Wilkie

I use *"r-click &gt; Edit in ..."* for this purpose. It's a poor man's
workaround. Something integrated would be much nicer. Just thought I'd
mention it for anyone looking for something they might be able to use right
away.

===== Terry

When I try that it only edits the one node, none of its children.
Which is what I thought it did.

===== Matt Wilkie

Are the links in the overview supposed to open up a browser window? The
alt-tip text gives an in-Leo hierarchy, e.g. "B:\code\dropbox-code.leo#leo
stuff--&gt;Overview of selected nodes" but clicking goes to
http://www.google.ca/, and in Internet Explorer even though Firefox is my
default browser.

===== Terry

No, that's not right, they're supposed to just select the node they
belong to.

===== Matt

And, more generally, can these hover-over-pane-divider-then-right-click
actions be made available any other way? Like a drop down menu from a
button or alt-x command or something.

===== Terry

What, you mean instead of being completely hidden where no one will
ever find them?  :-)  Most of them (not the Open Window variants of
course) rely on the context provided by your selection of a particular
divider, insert-where, delete-which etc.

Probably the most friendly would be a button which pops up an overlay
over the UI where you can select which pane to delete, or where to
insert, etc.  But that would be hard.

But it occurs to me that it might be the open window variants you want,
specifically the code to make a button / command to open a window with
a particular panel in it.  That would be this:

if hasattr(c, 'free_layout'):
    splitter = c.free_layout.get_top_splitter()
    if splitter:
        splitter.open_window(action='_add_overview_pane')

===== wgw

Excellent! This is really a great help for me. I'm still experimenting, but 
one thing I will find useful is that I can open several of these panes and 
navigate through each of the "views". Plus (and this has been a longtime 
wishlist item for those with fading sight), I can increase the text size 
for reading big chunks of text. 

(Another plus, and this is a big one, I can actually read your code well 
enough that I start to have some inkling about how to do this kind of 
addition to Leo. I could never begin to write it myself, but Leo makes it 
accessible even for shambling hackers.)

One question: is there a  way to delete an inserted pane?  It  looks useful 
to have an inserted pane, but refreshing will require killing the pane and 
reinserting.... 


</t>
<t tx="ekr.20131105110107.16964">- Added @color minibuffer-foreground-color setting.
- Added @color log_warning_color setting.
- Fully supported :: convention in @mode nodes.
- Added --no-plugins command-line option.
</t>
<t tx="ekr.20131105110107.16965">The new home page is http://leoeditor.com/

- Added link to home page from the TOC.
- Removed online-tutorial link.
- Added search box.
- Added link to glossary from Leo's home page.
- Added scaled screen shot to Leo's home page.
- Brought screen shots up to date.
</t>
<t tx="ekr.20131105110107.16966"></t>
<t tx="ekr.20131105110107.16967">See http://leoeditor.com/tutorial.html
</t>
<t tx="ekr.20131105110107.16968"></t>
<t tx="ekr.20131105110107.16969">This will reduce duplicate scripts.
</t>
<t tx="ekr.20131105110107.16970">There are non-persistent Python dicts, for free use by plugins and scripts.
</t>
<t tx="ekr.20131105110107.16971"></t>
<t tx="ekr.20131105110107.16972">Made the following changes:

- Refactored the code in abbrevClass.finishCreate into three parts, mostly
  so each may have its own docstring.

- Added try/finally protection in the exec statement, so that errors in
  \@data abbreviations-subst-env do not cause problems during startup.

- Added a new setting: @bool scripting-abbreviations, default False.
  Scripting abbreviations will be enabled if *either* of the following is
  True::

        @bool scripting-abbreviations
        @bool scripting-at-script-nodes
    
    This is a safety feature: it allows scripting abbreviations to be
    enabled *without* enabling the (very dangerous in general)
    scripting-at-script-nodes setting.

- finishCreate always reports either::

        Abbreviations on
        Abbreviations off

    in the normal operating environment (not unit testing, not null gui,
    not batch mode, etc.) As a result, there is less need to issue the
    following message::

        Note: @abbreviations-subst-start found, but no substitutions without @scripting-at-script-nodes = True"

- Changed @data abbreviations-subst-env node to handle missing os.environ['LOGNAME'].

- To make this work, the doData parser in leoConfig.py no longer strips
  lines.
</t>
<t tx="ekr.20131105110107.16973">Found empty methods using: ^[ ]*def.*$(\n[ ]*)*pass
    
Removed all calls to unused methods in qtGui.
    
Rev 6016:
- Removed all definitions and calls to createBindings.
  All definitions were empty.
  
Rev 6017:
- Removed all definitions and calls of createFindPanel.
  All definitions were empty.
- Removed call to createFrame in findTab ctor in leoFind.py.
  The gui code creates the frame.
- Removed all calls to createRootWindow and recreateRootWindow
- Removed do-nothing leoQtFindTab.createFindTab and leoQtFindTab.createFrame.
- Removed all definitions and calls of setBindings.
  All definitions were empty.
  
Rev 6017:
- Removed all definitions of killGui, createRootWindow and recreateRootWindow.
  All definitions were empty and they were never called.
- Removed all definitions of interrupt.  All were do-nothings.
  Removed a single call to .interrupt in 
- Removed do-nothing def of colorizer.kill.  Never called.

Rev 6018:
- Removed do-nothing def of setCanvasBindings.  Never called.
- Removed LeoQTreeWidget.dragEvent.  Never called.
- Removed all definitions of isSameColorState.  It always returned True.
  Removed the single usage of isSameColorState.
- Removed all definitions of killPopupMenu.
  Removed the only call to killPopupMenu in backlink.py.
- Removed all definitions of gui.color.  Never called.
- Removed qtFrame.enable, qtFrame.disable and qtFrame.isEnabled. Never called.
- Removed all calls to getFrame.  They were never called and they always returned None.
- Removed all calls to onActivate.  They were never called and did nothing.

Rev 6019:
* Removed leoQtLog do:nothings, and any calls in Leo's core.
    No calls: configureBorder,configureFont,getFontConfig.
    Commented out calls to setColorFromConfig and setFontFromConfig.
- Removed leoQtLog: saveAllState, restoreAllState, SetWidgetFontFromConfig, forceLogUpdate.
- Removed HighLevelInterface: onActivateLog, disable, enable.
- Removed *all* defs of setFocus.  They are never called!
- Removed all defs of setTabBindings and one call.  All defs were do-nothings.
- Ditto for setMinibufferBindings and createBindings.  All defs were do-nothings.
* Removed tree methods: headWidth,widthInPixels,
    setEditLabelState,setUnselectedLabelState,
    setDisabledHeadlineColors,setEditHeadlineColors,setUnselectedHeadlineColors,
    setFont,getFont.
</t>
<t tx="ekr.20131105110107.16974">Added qtGui.setFilter and used it to simplify the code.

The new code is only enabled if the newFilter is set at the start of qtGui.py.
</t>
<t tx="ekr.20131105110107.16975"></t>
<t tx="ekr.20131105110107.16977">The cursor was positioned one character from the end when there was no
newline at the end of the paragraph.  

The fix was to adjust ins in rp_reformat as follows::

    if not tail and ins &lt; len(s): ins += 1

Example::

A file that is both source controlled and customized by the user is
inconvenient for both novices and experts.
</t>
<t tx="ekr.20131105110107.16978">Typed tab while autocompleting: The fix was adding a better guard in
tab_callback.

</t>
<t tx="ekr.20131105110107.16979">https://bugs.launchpad.net/leo-editor/+bug/869385

The Nav pane and the "prev" and "next" buttons can't position
from one chapter to another.

What I did:
    
- c.goToNext/PrevHistory now just call nodeHistory.goNext/Prev.
  This encapsulates complications properly.
- Added "chapter" keyword arg to cc.selectChapterForPosition.
  When present, this forces a match in the given chapter if possible.
- Rewrote the select and update methods in class nodeHistory.
  Most importantly, update removes duplicates.
  A kludge: update ignores @chapter nodes, which are "selected" behind the scenes.
</t>
<t tx="ekr.20131105110107.16980">@language rest

# https://bugs.launchpad.net/leo-editor/+bug/879338

Only the clojure language needed entries in the tables.

The following script finds all language keys lacking a mode file::

@language python

    import glob
    files = glob.glob(g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py'))
    files = [g.shortFileName(z)[:-3] for z in files]
    print('\n'.join(sorted(files)))
    keys = sorted(g.app.language_delims_dict.keys())
    for fn in files:
        if fn not in keys:
            print(fn)
            
@language rest
            
The result is::
        
    clojure
    embperl     # A helper mode
    patch       # No comment lines
    phpsection  # A helper mode.
    pseudoplain # No comment lines.
    rtf         # Annotations not exactly a comment.
</t>
<t tx="ekr.20131105110107.16981">https://bugs.launchpad.net/leo-editor/+bug/1019794

Added the following to copyTreeFromSelfTo:

    p2.v.u = copy.deepcopy(p.v.u)
</t>
<t tx="ekr.20131105110107.16982">https://bugs.launchpad.net/leo-editor/+bug/1028986

The fix was to createUrlForBinaryFile.
</t>
<t tx="ekr.20131105110107.16983">https://bugs.launchpad.net/leo-editor/+bug/1046195

If I drag part of an outline from one leo file to another and the source
outline contain special characters (ä, ö, ü, ß, ...), then they are
misrepresented in the target file.

The fix was to use g.toUnicode rather than g.u in parseText.
</t>
<t tx="ekr.20131105110107.16984">https://bugs.launchpad.net/leo-editor/+bug/1046728

The @auto example now works.
</t>
<t tx="ekr.20131105110107.16985">https://bugs.launchpad.net/leo-editor/+bug/1074812

The problem are the marks created by a svn conflict. Leo can not recover
from this kind of error in such a way as to recover data. The workaround is
to report a corrupted file in at.scanText4.
</t>
<t tx="ekr.20131105110107.16986">https://bugs.launchpad.net/leo-editor/+bug/1099035

The new kill-to-end-of-line command is supposed to work just
like the emacs kill-line command. That is, it kill from the
insert point to the end of the line. If there are no
non-blank characters to the right of the insert point, it
kills everything up to and including the newline.
</t>
<t tx="ekr.20131105110107.16987">https://bugs.launchpad.net/leo-editor/+bug/1132821

When opening a file with @auto via a soft link (on Linux) Leo reads in the
file correctly, but after modifying the content leo replaces the link with
an actual file, which means the original file, is not modified and you end
up with two different versions on disk.

os.path.realpath follows symbolic links.

The only safe place for the fix is in at.replaceTargetFileIfDifferent.
</t>
<t tx="ekr.20131105110107.16988">https://bugs.launchpad.net/leo-editor/+bug/1160660

The primary fix was to createCompareClones.

The created nodes are also a bit clearer about what the changes are.
</t>
<t tx="ekr.20131105110107.16989">Undoing a headline change does not change focus to the headline
https://bugs.launchpad.net/leo-editor/+bug/1162307
</t>
<t tx="ekr.20131105110107.16990">https://bugs.launchpad.net/leo-editor/+bug/1175013

A file that is both source controlled and customized by the user is
inconvenient for both novices and experts.

What I did:
    
- leo\plugins\spellpyx.txt is no longer part of the distribution.
- EnchantClass.__init__ creates an empty leo/plugins/spellpyx.txt if necessary.

Rev 5992: eliminate redraw flash when selecting the Chapters: combo box.
</t>
<t tx="ekr.20131105110107.16991">the tricky string that leo can not handle 
https://bugs.launchpad.net/leo-editor/+bug/1182695
</t>
<t tx="ekr.20131105110107.16992">https://bugs.launchpad.net/leo-editor/+bug/1182864

The fix was to countLinesHelper.
</t>
<t tx="ekr.20131105110107.16993">https://bugs.launchpad.net/leo-editor/+bug/1185409

Added g.is_binary_external_file and is_binary_string.
Modified ic.createOutline to create @url file:// node.
</t>
<t tx="ekr.20131105110107.16994">https://bugs.launchpad.net/leo-editor/+bug/1193819

Changed mod_scripting.py and setCommandForButton in qtGui.py.
</t>
<t tx="ekr.20131105110107.16995">https://bugs.launchpad.net/leo-editor/+bug/1193870

The fix was to leoQtMenu.destroy.  Previously, it did nothing.
</t>
<t tx="ekr.20131105110107.16996">https://bugs.launchpad.net/leo-editor/+bug/1208659

The compare failure was the result of using baseScannerClass.startsString.
This is wrong: single quotes do *not* start strings in xml or html.

Added better traces when the comparison fails.

Another change: if the @auto import fails, the file is imported as usual
(with an @ignore node). That is, no @edit node is created. This disables a
dubious feature.

Alas, reportMismatch can't possibly detect tokenizing errors: reportMismatch
only has the imported lists of *lines* for the error report, not the
tokens.
</t>
<t tx="ekr.20131105110107.16997">https://bugs.launchpad.net/leo-editor/+bug/1208942
Leo holding directory/file handles after file close?

Open Leo
2. Create a new directory "test"
3. Create a new Leo file, save as "test/test.leo"
4. Create @file node in test.leo, save file.
5. Close test.leo, but keep Leo open (with another .leo open in a different tab)
6. Attempt to delete "test" directory &lt;&lt;-- FAILS, "open in another application"
7. Close Leo completely
8. Delete "test" directory &lt;&lt;-- Succeeds, now that Leo's closed

Actually, only just opening a .leo file without any @file nodes was enough to keep a file open.

The fix was to close theFile in fc.getLeoFile.
</t>
<t tx="ekr.20131105110107.16998">This bug was fixed by the new_read (and new_write) logic
first committed at Rev. 5960.

</t>
<t tx="ekr.20131105110107.16999">https://bugs.launchpad.net/leo-editor/+bug/1223383

https://groups.google.com/forum/#!searchin/leo-editor/garbled$20text/leo-editor/tq1HdMFuyVg/fbpK2M6K1tIJ

**Note**: Python does not support utf-16 encoding:
http://www.python.org/dev/peps/pep-0263/

converting utf-16 -&gt; utf-8 AND remove BOM
http://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom

    # str.decode will get rid of the BOM for you (and deduce the endianness).
    with open(ff_name, 'rb') as source_file:
        with open(target_file_name, 'w+b') as dest_file:
            contents = source_file.read()
            dest_file.write(contents.decode('utf-16').encode('utf-8'))
        
Note:  my favorite way to see BOM bytes is to open the file in xemacs and use &lt;alt-x&gt;hexl-mode.
For example, the following body text::
    
    @first # -*- coding: utf-16 -*-
    @encoding utf-16

    This is a test
    
Will be rendered as::
    
    00000000: fffe 2300 2000 2d00 2a00 2d00 2000 6300  ..#. .-.*.-. .c.
    00000010: 6f00 6400 6900 6e00 6700 3a00 2000 7500  o.d.i.n.g.:. .u.
    00000020: 7400 6600 2d00 3100 3600 2000 2d00 2a00  t.f.-.1.6. .-.*.
    00000030: 2d00 0a23 fffe 4000 2b00 6c00 6500 6f00  -..#..@.+.l.e.o.
    00000040: 2d00 7600 6500 7200 3d00 3500 2d00 7400  -.v.e.r.=.5.-.t.
    00000050: 6800 6900 6e00 2d00 6500 6e00 6300 6f00  h.i.n.-.e.n.c.o.
    00000060: 6400 6900 6e00 6700 3d00 7500 7400 6600  d.i.n.g.=.u.t.f.
    00000070: 2d00 3100 3600 2c00 2e00 0a23 fffe 4000  -.1.6.,....#..@.
    00000080: 2b00 6e00 6f00 6400 6500 3a00 6500 6b00  +.n.o.d.e.:.e.k.
    00000090: 7200 2e00 3200 3000 3100 3300 3000 3900  r...2.0.1.3.0.9.
    000000a0: 3000 3900 3100 3900 3300 3700 3000 3200  0.9.1.9.3.7.0.2.
    000000b0: 2e00 3900 3100 3700 3000 3a00 2000 2a00  ..9.1.7.0.:. .*.
    000000c0: 2000 4000 6600 6900 6c00 6500 2000 6300   .@.f.i.l.e. .c.
    000000d0: 3a00 2f00 7400 6500 7300 7400 2f00 7500  :./.t.e.s.t./.u.
    000000e0: 7400 6600 2d00 3100 3600 2d00 7400 6500  t.f.-.1.6.-.t.e.
    000000f0: 7300 7400 2e00 7400 7800 7400 0a23 4040  s.t...t.x.t..#@@
    00000100: 6669 7273 740a 23ff fe40 0040 0065 006e  first.#..@.@.e.n
    00000110: 0063 006f 0064 0069 006e 0067 0020 0075  .c.o.d.i.n.g. .u
    00000120: 0074 0066 002d 0031 0036 000a 0aff fe54  .t.f.-.1.6.....T
    00000130: 0068 0069 0073 0020 0069 0073 0020 0061  .h.i.s. .i.s. .a
    00000140: 0020 0074 0065 0073 0074 000a 2340 2d6c  . .t.e.s.t..#@-l
    00000150: 656f 0a                                  eo.

From: Chema Cortes &lt;pych3m4@gmail.com&gt;

I have some external files encoded with utf8 and utf16-le with BOM marks.
Leo ignores these marks, and these files become garbled. I cannot fix this
problem with @encoding directives.

Reading the code, I can see the problem when leo opens files as
binary, followed by a unicode encoding. Why not use, instead, the
'codecs.open' for this job, more friendly with BOM-marks?

Testing with system:
Leo 4.11 devel, build 5418, 2012-07-09 09:10:17
Python 2.7.3, qt version 4.8.0
Windows 5, 1, 2600, 2, Service Pack 3
</t>
<t tx="ekr.20131105110107.17000">Added new_write master switch in leoAtFile.py.
When new_write is True:
- Leo no longer writes a temporary output file.
- at.replaceTargetFileIfDifferent calls the new at.create method to write the target file.
- onl simply writes '\n'.  Conversion to the desired newline happens only in at.create.

Important: writing utf-16 files appears to work, but reading utf-16 files
does not. There are problems decoding utf-16 string in at.readline.
Possibly reading the entire file and converting to unicode might work.

Added new_read master switch in leoAtFile.py.
When new_read is True:
- at.readFileToUnicode converts the entire input file to unicode
  with a single call to g.toUnicode.
- at.getLine uses ivars to retrieve the next line.
  (the theFile and fileName arguments to at.getLine are not used).
  
I am quite happy with the new code. It is considerably
simpler than the old, and handles unicode in a much more
reasonable fashion. In particular:

1. at.readFileToUnicode at last handles the problem of
   discovering encodings properly, without reading files
   twice. It uses a trial encoding (ascii) in order order to
   scan @+leo headers. This is an unexpected simple
   fundamental method. at.readFileToUnicode converts the
   entire file unicode.

2. When new_read is True, at.readLines now is very simple
   because the conversion to unicode has already happened.

3. When new_write is True, the conversion of newlines and
   the conversion to an encoded string each happens exactly
   once, in at.create. This is an important simplification.
</t>
<t tx="ekr.20131105110107.17001">https://bugs.launchpad.net/leo-editor/+bug/1224586

Reorganizing @chapter nodes under an outline's @chapters node breaks the
Chapter dropdown navigation box until the outline is reloaded.

Summary:

- Recompute drop-down list every time it is activated.
- Eliminated chapter.hoist ivar.
- Recompute chapter data every time a chapter is selected.

Details:
    
- Eliminate chapter.root ivar.
- recompute root of @chapter node every time it is needed
  using chapter.findChapterNode(chapter.name).
- Eliminated chapter.hoistStack.
  Append one entry to c.hoistStack when selection a non-main chapter.
  Pop one entry when unselecting a non-main chapter.
- Created LeoQComboBox in tt.createControl in order to be able to subclass focusInEvent.
- Created cc.setAllChapterNames, called from LeoQComboBox.focusInEvent.
- Added "create" keyword argument to selectChapterByName.
  This avoid a compile-time choice: it is True except when the user
  types the name from the minibuffer. 
</t>
<t tx="ekr.20131105110107.17002">@language rest

https://bugs.launchpad.net/leo-editor/+bug/1226358

First reported at URLs seem to be broken on Mac OS 10.7 Lion
https://groups.google.com/forum/#!searchin/leo-editor/URLs$20seem$20to$20be$20broken/leo-editor/vM8qn66aNi0/4oTIu_UIDUwJ

I think I know the cause of the problem with file URLs on Mac OS 10.7
Lion. In leoGlobals.py, in g.os_startfile(fname), we have::

@language python

    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', quoted_fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system('open %s' % (quoted_fname))
            
@language rest

The problem is that the quoted file path is being passed to
subprocess.call, instead of the raw file path. I verified this by
experimenting with subprocess.call() in a Python interactive mode
window -- it doesn't want the path to be quoted. I also modified the
os_startfile method to use the unquoted pathname, and verified that
this fixed the problem.
</t>
<t tx="ekr.20131105110107.17003">https://bugs.launchpad.net/leo-editor/+bug/1226816

The fix was to LM.initWrapperLeoFile.
</t>
<t tx="ekr.20131105110107.17004">https://bugs.launchpad.net/leo-editor/+bug/1229896

The fix was to nodeHistory.select at rev 6042
</t>
<t tx="ekr.20131105110107.17005">https://plus.google.com/_/notifications/emlink?emr=02870587547267324596&amp;emid=CJCDv9Ppo7QCFcQbTAodl2MAAA&amp;path=%2F103097156557482112329%2Fposts%2FTL3HQegbK3T&amp;dt=1355829277202&amp;ub=63

\@auto did not write the following .json file properly(!)::

    {
        'name' : "Test app 1"
    }

The last } was missing from the generated file.

The fix was to at.putCodeLine(!!).  It is amazing that this bug could exist.
</t>
<t tx="ekr.20131105110107.17006">1183855 (un)select hooks not fired when node selection changed by find command
https://bugs.launchpad.net/leo-editor/+bug/1183855

1212332 Insert doesn't fire unselect / select events
https://bugs.launchpad.net/leo-editor/+bug/1212332


Select and unselect hooks were not being called when a command (including
the find command) left focus in the headline.

The fix was to c.redraw(!) It now calls c.frame.tree.select before calling
c.frame.tree.redraw.
</t>
<t tx="ekr.20131105110107.17007">https://bugs.launchpad.net/leo-editor/+bug/1159302
</t>
<t tx="ekr.20131105110107.17008">If $(HOME)/.leo/.leoRecentFiles.txt does not exist, the only recent file ever is the current file

https://bugs.launchpad.net/leo-editor/+bug/971171

It works for me.  I did make minor changes to rf.writeRecentFileFileHelper.
</t>
<t tx="ekr.20131105110107.17009">https://bugs.launchpad.net/leo-editor/+bug/1178249

I am going to mark this report as invalid. Please reopen if necessary.

There were recent changes to the @url handling::
- rev 5171 Refactored URL handling, and revised bookmarks plugin to use the new code.
- rev 5208 Fixed g.computeFileUrl so that it converts (Windows only) file:/// to file://

However, file url's seem to be working as expected.

Note that @url file:filename.leo is *not* a valid url, it should be @url file://filename.leo.

Any of the following work in a headline::

    &lt; a relative path &gt;
    file://&lt; a relative path &gt;
    @url &lt; a relative path &gt;
    @url file://&lt; a relative path&gt;

In particular, note this code in g.computeFileUrl::

    path = g.os_path_finalize_join(c.openDirectory,base,path)

</t>
<t tx="ekr.20131105110107.17010">https://bugs.launchpad.net/leo-editor/+bug/1182694

A string-formatting bug.

https://groups.google.com/forum/?fromgroups#!topic/leo-editor/uy_7dP1uY8w

https://leo-editor.googlegroups.com/attach/4b330006a649027d/SC-2013_5_21_14_12_31.png?view=1&amp;part=5

https://leo-editor.googlegroups.com/attach/4b330006a649027d/SC-2013_5_21_14_12_19.png?view=1&amp;part=4

This is a consequence of an underindented comment.  Like this::

        def test(self):
            string = "abc,\n\
    xyz"

http://leoeditor.com/directives.html#index-7

An underindented line is a line of body text that is indented less then the
starting line of the class, method or function in which it appears. Leo
outlines can not represent such lines exactly: every line in an external
file will have at least the indentation of any unindented line of the
corresponding node in the outline. Leo will issue a warning (not an error)
for underindented Python comment lines. Such lines can not change the
meaning of Python programs.
</t>
<t tx="ekr.20131105110107.17011">Already fixed.
</t>
<t tx="ekr.20131105110107.17012">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;
Leo 4.10 deb for Ubuntu Precise available

The open_dict now protects again crashes with try/except.
It's not clear when this new code happened.

When launched from command line, it causes this error that should
probably be hidden with try-except:

/home/ville/.leo/workbook.leo
Traceback (most recent call last):

  File "/usr/lib/pymodules/python2.7/leo/core/leoEditCommands.py",
line 10372, in __init__
    self.d = enchant.DictWithPWL(language,fn)

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
735, in __init__
    self.pwl = self._broker.request_pwl_dict(pwl)

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
280, in request_pwl_dict
    self._raise_error(eStr % (pwl,))

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
219, in _raise_error
    raise eclass(err)

Error: Couldn't open personal wordlist
'/usr/share/pyshared/leo/plugins/spellpyx.txt'

not a valid dictionary file /usr/share/pyshared/leo/plugins/spellpyx.txt
wrote recent file: /home/ville/.leo/.leoRecentFiles.txt
ville@ville-tp:~$ leo

** isPython3: False
Leo 4.10 final, build 5020, 2012-02-26 13:18:08 -0600
Python 2.7.3, qt version 4.8.1
linux2
reading settings in /usr/share/pyshared/leo/config/leoSettings.leo
Using default leo file name:
/home/ville/.leo/workbook.leo
Traceback (most recent call last):

  File "/usr/lib/pymodules/python2.7/leo/core/leoEditCommands.py",
line 10372, in __init__
    self.d = enchant.DictWithPWL(language,fn)

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
735, in __init__
    self.pwl = self._broker.request_pwl_dict(pwl)

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
280, in request_pwl_dict
    self._raise_error(eStr % (pwl,))

  File "/usr/lib/python2.7/dist-packages/enchant/__init__.py", line
219, in _raise_error
    raise eclass(err)

Error: Couldn't open personal wordlist
'/usr/share/pyshared/leo/plugins/spellpyx.txt'

not a valid dictionary file /usr/share/pyshared/leo/plugins/spellpyx.txt
wrote recent file: /home/ville/.leo/.leoRecentFiles.txt

</t>
<t tx="ekr.20131105110107.17013">https://groups.google.com/forum/#!topic/leo-editor/Mbn3VzY-jr0
</t>
<t tx="ekr.20131105110107.17014">Rev 6119 fixes a major bug involving the rst3 command.
Previously, rst3-related settings, which start with "rst3_"
where not, in fact, initializing the internal rst3 settings!

I never noticed this because all the documentation in
LeoDocs.leo used to use @ @rst-options parts to specify
settings.

But using @ @rst-options this way is *very* bad style: it
hides any variations in settings in the blah-blah-blah of
specifying defaults.

Now, the defaults are given in settings in the "Startup"
node. This is correct: defaults are given *one*, in an
out-of-the way place.

BTW, now that almost all @ @rst-options parts are gone,
there is even less reason for the @file nodes in
LeoDocs.leo. I'm going to remove them, thereby removing all
the not-really-needed .txt files they generate. Naturally,
this makes LeoDocs.leo bigger, but I think the clarity of
expression is worthwhile. LeoDocs.leo really should be a
model of good practice.
</t>
<t tx="ekr.20131105110107.17015">At rev 6107.
    
- Restored @bool ignore_unbound_non_ascii_keys setting to leoSettings.leo.
- Made self-insert-char an official command, but it will do nothing if
  executed from the minibuffer.
- ec.selfInsertCommand now calls g.app.gui.insertKeyEvent for non-plain keys.
- qtGui.insertKeyEvent uses QKeyEvent.text() to insert Alt-Ctrl keys as follows:
  qw.insertPlainText(qevent.text()).
  Viktor verifies that this strategy works.
- Added event ivar (a QKeyEvent) to leoKeyEvent class.
- Added event positional arg to leoGui.create_key_event.
</t>
<t tx="ekr.20131105110107.17016"></t>
<t tx="ekr.20131105110107.17017">Happened when user typed tab.
</t>
<t tx="ekr.20131105110107.17018">@language rest

To emphasize what is said below in the checkin log, there is a systemic
problem with the leoBridge module: it uses a nullGui in which all dialogs
are do-nothings. This will affect all commands, such as c.save, etc., that
may (or may not) ask the user for input.

The workaround I used for c.save, c.saveAs and c.saveTo was to add a
"fileName" keyword arg, so that code using a commander returned by
leoBridge can just demand that a certain fileName be used. This is as far
as I am willing to go for the 4.11 release.

The following test, call it leo-bridge-test.py, passes::

@language python

# Do *not* execute this from inside Leo!
if __name__ == '__main__':
    import os
    import sys
    sys.path.insert(0,'c:/leo.repo/trunk/leo')
    import leo.core.leoBridge as leoBridge
    print(leoBridge)
    cc = leoBridge.controller(gui='nullGui',verbose=False)
    g = cc.globals()
    print(g)
    path = 'c:/Users/edreamleo/does-not-exist.leo'
    assert not os.path.exists(path),path
    assert not g.os_path_exists(path),path
    c = cc.openLeoFile(path)
    root = c.rootPosition()
    assert root
    root.h = 'root'
    p = root.insertAsLastChild()
    p.h = 'A'
    assert p and p.h
    if 0:
        for p in c.all_positions():
            print(p.h)
    path = 'c:/Test/leo-bridge-test.leo'
    c.save(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
    os.remove(path)
    assert not os.path.exists(path),path
    assert not g.os_path_exists(path),path
    c.saveAs(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
    c.saveTo(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
</t>
<t tx="ekr.20131105110107.17019">1168689 outdated documentation about ipython
https://bugs.launchpad.net/leo-editor/+bug/1168689

Changed runWithIpythonKernel, LM.initApp, app.finishQuit.
Added commanders property.

Injects only _leo into the IPython namespace
_leo.c is a property
The getter returns the single element of _leo.commanders_list
or a commander set previously by the setter.
    
_leo.commanders is a read-only property returning _leo.commanders_list
after first doing an update.

The highlights of the changes:

1. leo.core.leoIPython.py now contains *all* of Leo's IPython-related code.
   The setup code comes mainly from leo.plugins.internal_ipkernel.py.

2. internal_ipkernel.py still exists (it will go away soon), but it has has
   been completely disabled as follows::

    if 0:
        @others

3. When the --ipython command-line argument is in effect, g.app.ipk is a
   *singleton* IPython shell, shared by any and all IPython consoles.

4. The startup code injects only a single object, _leo, into the IPython
   namespace. This is an instance of the bulked-up LeoNameSpace class. This
   interface class now contains features that make it easier to deal with
   multiple open Leo commanders.

- _leo.g is set to leoGlobals only once. Not exactly correct, perhaps, but
  nobody will notice.

- _leo.commanders is a (read-only) property returning the list of open
  commanders. This list is always kept up-to-date: it scans
  g.app.windowList before returning its result.

- _leo.c is a (read/write) property returning g.app.windowList[0].c if the
  windowList has only one element, or the "designated commander" if it
  exists. Otherwise, it returns None. In that case, the expectation is that
  the user will "designate" a commander with: _leo.c = aCommander.

- _leo.find_c(path) returns the commander c such that c.fileName() or
  g.shortFileName(c) matches path.

5. Perhaps most importantly, that's *all* there is. In particular, Ville's
   magic functions and LeoWorkbook class are gone.

Imo, the deleted code might better exist as IPython startup code, but I
could be wrong. Furthermore, Leo's p.h and p.b properties are new since
Ville first created the code, and so this kind of support code is less
urgently needed.

If there is a great demand to restore these features, it can always be done
later. For now, though, I wanted to do the simplest thing that could
possibly work.
</t>
<t tx="ekr.20131105110107.17020">Bug: Window size was not set when --minimized is in effect.

LM.scanOptions now sets LM.options['windowSize'] to (h,w), both ints.

getWindowPositionAttributes now checks LM.options.get('windowSize')

startVnodes now properly sets top geometry when --minimized is in effect.
</t>
<t tx="ekr.20131105110107.17021">https://bugs.launchpad.net/leo-editor/+bug/1243847

The fix: at.replaceFileWithString now *always* calls g.toEncodedString.
</t>
<t tx="ekr.20131105110107.17022">https://bugs.launchpad.net/leo-editor/+bug/1243855

The fix was to not make assumptions about type in compareFiles and create.

</t>
<t tx="ekr.20131105110107.17023">
</t>
<t tx="ekr.20131105110107.17024">https://bugs.launchpad.net/leo-editor/+bug/1168689

You must use "python launchLeo.py --ipython" instead of the ipython.py plugin

The old ipython.py plugin is deprecated: it exists in leo/plugins/obsolete.

The docs of ipython and leo should be updated

https://groups.google.com/forum/?fromgroups#!topic/leo-editor/n5IVGe6fh2k
</t>
<t tx="ekr.20131105110107.17025">https://bugs.launchpad.net/leo-editor/+bug/1180186
</t>
<t tx="ekr.20131105110107.17026"></t>
<t tx="ekr.20131105110107.17027"></t>
<t tx="ekr.20131105110107.17028">Changed DynamicWindow.createFindTab.

Added a help line at the bottom.
</t>
<t tx="ekr.20131105110107.17029">importing a medium sized java project ~ 400 files
https://groups.google.com/forum/#!searchin/leo-editor/importing$20a$20medium$20sized$20java$20project/leo-editor/PiuFXtAHG0s/o6vwu19PsMEJ

For example, when warning about existing files.

Fixed at rev 5935. What I did:
    
1. Added yesToAllMessage keyword arg to all runAskYesNoCancelDialog methods.

2. **only** at.writeAll manages at.canCancelFlag, at.cancelFlag and at.yesToAll.

3. Path changed logic in at.writeAllHelper now calls at.promptForDangerousWrite.

4. at.promptForDangerousWrite sets cancelFlag and yesToAll *only* if canCancelFlag is True.
   This ensures that these flags are not changed outside the code managed by at.writeAll.
</t>
<t tx="ekr.20131105110107.17030">Bound Alt-Ctrl-M for macro-call-last (c-x e in emacs).
</t>
<t tx="ekr.20131105110107.17031">Added c.openCheatSheet.
Added LM.openEmptyWorkBook.
Added open-cheat-sheet-leo command.
Added "Open CheatSheet.leo" menu item.
Changed LM.doPostPluginsInit.
</t>
<t tx="ekr.20131105110107.17032">Added c.insertHeadlineBefore and unit tests for same.
</t>
<t tx="ekr.20131105110107.17033">help-for-dynamic-abbreviations
help-for-abbreviations
help-for-find-commands
</t>
<t tx="ekr.20131105110107.17034">markup_inline.py,richtext.py, rss.py.
</t>
<t tx="ekr.20131105110107.17041">@language rest
</t>
<t tx="ekr.20131105110107.17042">1. The following are always single-line paragraphs::
    
    @anything
    '''         # on a line all by itself. 
    """         # on a line all by itself.

2. The following always start a paragraph, terminating the previous
   paragraph::

    - Whatever
    1. Whatever
    22) Whatever
    a. Whatever # single character only.
    Z. Whatever # single character only.

3. The leading indentation in lists will be at least the the number of
   characters preceding "Whatever".

Not yet: support for non-breaking space (unicode code point U+00A0).

What I did:
    
- Rewrote c.findBoundParagraph &amp; added helpers:
    - c.starts/endParagraph
    - c.singleLineParagraph.
- Add space adjustments to rp_wrap_all_lines.
</t>
<t tx="ekr.20131105110107.17043">- g.set_language doesn't handle ambiguous @language directives!!
- Eliminated scanToCursor logic
- Added c.hasAmbiguousLanguage and c.getLanguageAtCursor helpers.
- Changed c.insertComments and c.removeComments.
</t>
<t tx="ekr.20131105110107.17044">https://bugs.launchpad.net/leo-editor/+bug/1247672

In Haskell it is common to end certain functions with the single quote character. i.e.

sum = foldl' (+) 0

foldl' is a variety of the function foldl with modified characteristics. In
this case, it is strict.

The haskell syntax highlighter on Leo treats that single quote as the
beginning of a string.

As a note that may matter -- I don't know Leo so below may be non-important
I see this:

def haskell_rule4(colorer, s, i):
    return colorer.match_seq(s, i, kind="literal1", seq="' '",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

In the leo/modes/haskell.py file.

Haskell does have strings that are surrounded by single quotes. Single
quotes are either (somewhat) regular characters or surround a single (
non-string ) character.

Gatesphere on the #Leo was helpful today and asked that I include the link
to this jedit xml syntax def for haskell:

http://jedit.git.sourceforge.net/git/gitweb.cgi?p=jedit/jEdit.bak;a=blob_plain;f=modes/haskell.xml;hb=HEAD

Feel free to contact me if you need additional info.

====



Oh -- I should add that it is not uncommon to end function names with
multiple single quotes as well.

i.e.

sqrt
sqrt'
sqrt''
sqrt'''

for 4 different methods of determining square root.

The fix was a hack to match_keywords, and an alteration to rule28.
</t>
<t tx="ekr.20131105110107.17045">Changed defaults in leoSettings.leo from 14px to 12px.
</t>
<t tx="ekr.20131105110107.17046">@language rest

https://groups.google.com/forum/#!topic/leo-editor/qglPWiqnyog

Using the LeoSetup-4.11-b1.exe installer with Python27 works fine.

However using Python33 it's not so happy. Selecting Start Menu&gt;Leo does not launch Leo, I just see a flash of the splashscreen and it dies.
Same result using the desktop shortcut icon.

The target properties of the desktop icon are:
C:\Python33\pythonw.exe "C:\Program Files (x86)\Leo-4.11-b1\launchLeo.py"

I can run Leo from a console though. Here is the log:
C:\Program Files (x86)\Leo-4.11-b1&gt;launchleo.py

** isPython3: True
Leo 4.11b1, build 5020, 2012-02-26 13:18:08 -0600
Python 3.3.3, qt version 4.8.5
Windows 6, 1, 7601, 2, Service Pack 1
...

Running from a command shell works fine with no errors.

===== EKR

    Using the LeoSetup-4.11-b1.exe installer with Python27 works fine.

    However using Python33 it's not so happy. Selecting Start Menu&gt;Leo does not launch Leo, I just see a flash of the splashscreen and it dies.
    Same result using the desktop shortcut icon.


Thanks for this report.

&gt; The target properties of the desktop icon are:
&gt; C:\Python33\pythonw.exe "C:\Program Files (x86)\Leo-4.11-b1\launchLeo.py"

These look correct. And they work for me after a clean install. Note: the
initial load of Leo can take quite awhile: all .py files must be compiled.

For trouble shooting, please do the following:

- Change pythonw.exe to python.exe
- Add an -i option to the target properties.

The effect of this will be to run Leo in a console window, holding the
console window open.

This should tell you exactly what is happening.

&gt; Selecting Start Menu&gt;Leo does not launch Leo, I just see a flash of the
  splashscreen and it dies.

I did find an issue related to the start menu. If I chose "All Programs"
then Leo, there was an old copy of the leo shortcut lying around that
didn't work. And even after deleting the Leo install, there was an old,
out-out-date Leo folder accessible from the start menu. And furthermore,
there were differences (from the start menu) between opening Leo and
opening Leo for all users.

This is surely confusing, but it may be the result of old installs.

My suggestion:

1. Uninstall b1.
2. Delete everything related to Leo from your start menu, both accessible
   via "search programs and files" and the "all programs list". Make sure
   to delete everything for all users as well as yourself.
3. Reinstall b1.
4. Test. If problems remain, make the changes above (-i, python.exe), and
   report the results.
</t>
<t tx="ekr.20131105122124.16479">@killcolor

https://groups.google.com/forum/#!topic/leo-editor/OSe0_D5tmJQ

http://stackoverflow.com/questions/7325052/can-someone-explain-to-me-why-the-dot-command-is-so-useful-in-vim
</t>
<t tx="ekr.20131105122124.16482">N   &lt;Del&gt;       delete N characters under and after the cursor
    &lt;Del&gt;       delete the character under the cursor
    &lt;Del&gt;       while entering a count: delete last character
    
    &lt;Left&gt;      (motion) cursor left
    &lt;Right&gt;     (motion) cursor right
    &lt;C-Left&gt;    (motion) cursor one word left
    &lt;C-Right&gt;   (motion) cursor one word right
    
    &lt;Down&gt;      recall newer command-line that starts with current command
    &lt;S-Down&gt;    recall newer command-line from history
    &lt;S-Up&gt;      recall older command-line from history
    &lt;Up&gt;        recall older command-line that starts with current command
    &lt;Esc&gt;       abandon command-line (if 'wildchar' is &lt;Esc&gt;, type it twice)

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R &lt;0-9a-z"%:-&gt;     insert contents of register &lt;0-9a-z"%:-&gt;
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made
    
    0               (motion) to first character in the line (also: &lt;Home&gt; key)
VIS ~               switch case for highlighted text
N   ~               switch case for N characters and advance cursor
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
N   _               (motion) down N-1 lines, on the first non-blank character
N   -               (motion) up N lines, on the first non-blank character
N   ,               (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   .               (motion?) repeat last change (with count replaced with N)
N   ;               (motion) repeat the last "f", "F", "t", or "T" N times
N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `"              (motion) go to the position when last editing this file
    '&lt;a-zA-Z0-9[]'"&lt;&gt;&gt;  (motion) same as `, but on the first non-blank in the line
    `&lt;              (motion) go to the start of the (previous) Visual area
    `&lt;0-9&gt;          (motion) go to the position where Vim was last exited
    `&lt;A-Z&gt;          (motion) go to mark &lt;A-Z&gt; in any file
    `&lt;a-z&gt;          (motion) go to mark &lt;a-z&gt; within current file
    `&gt;              (motion) go to the end of the (previous) Visual area
    `[              (motion) go to the start of the previously operated or put text
    `]              (motion) go to the end of the previously operated or put text
    ``              (motion) go to the position before the last jump
N   $               (motion) go to the last character in the line (N-1 lines lower) (also: &lt;End&gt; key)
    ^               (motion) go to first non-blank character in the line
N   %               (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %               (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   &lt;{motion}       move the lines that are moved over with {motion} one shiftwidth left
N   &gt;{motion}       move the lines that are moved over with {motion} one shiftwidth right
N   &lt;&lt;              move N lines one shiftwidth left
N   &gt;&gt;              move N lines one shiftwidth right

N   #                           (motion) search backward for the identifier under the cursor
N   *                           (motion) search forward for the identifier under the cursor
N   /&lt;CR&gt;                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]&lt;CR&gt;   (motion) search forward for the Nth occurrence of {pattern}
N   ?&lt;CR&gt;                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]&lt;CR&gt;   (motion) search backward for the Nth occurrence of {pattern}

N   @&lt;a-z&gt;          execute the contents of register &lt;a-z&gt; (N times)
N   @@              (motion?) repeat previous @&lt;a-z&gt; (N times)

    "&lt;char&gt;         use register &lt;char&gt; for the next delete, yank, or put

N   [#              (motion) N times back to unclosed "#if" or "#else"
N   [(              (motion) N times back to unclosed '('
N   [*              (motion) N times back to start of comment "/*"
N   [[              (motion) N sections backward, at start of section
N   []              (motion) N sections backward, at end of section
N   [p              (motion?) like P, but adjust indent to current line
N   [{              (motion) N times back to unclosed '{'
N   ]#              (motion) N times forward to unclosed "#else" or "#endif"
N   ])              (motion) N times forward to unclosed ')'
N   ]*              (motion) N times forward to end of comment "*/"
N   ][              (motion) N sections forward, at end of section
N   ]]              (motion) N sections forward, at start of section
N   ]p              (motion?) like p, but adjust indent to current line
N   ]}              (motion) N times forward to unclosed '}'

N   A               append text at the end of the line (N times)
N   B               (motion) N blank-separated WORDS backward
N   C               change to end-of-line (and N-1 more lines)
N   D               delete to end-of-line (and N-1 more lines)
N   E               (motion) forward to the end of the Nth blank-separated WORD
N   F&lt;char&gt;         (motion) to the Nth occurrence of &lt;char&gt; to the left
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   H               (motion?) go to the Nth line in the window, on the first non-blank
N   I               insert text before the first non-blank in the line (N times)
N   J               (motion?) join N-1 lines (delete newlines)
VIS J               (motion?) join the highlighted lines
    K               lookup keyword under the cursor with 'keywordprg' program (default: "man")
    M               (motion?) go to the middle line in the window, on the first non-blank
N   L               (motion?) go to the Nth line from the bottom, on the first non-blank
N   N               (motion) repeat last search, in opposite direction
N   O               open a new line above the current line, append text (N times)
N   P               put a register before the cursor position (N times)
N   R               enter Replace mode (repeat the entered text N times)
N   S               change N lines
N   T&lt;char&gt;         (motion) till before the Nth occurrence of &lt;char&gt; to the left
    U               restore last changed line
VIS U               make highlighted text uppercase
    V               highlight linewise or stop highlighting
    V               start highlighting linewise    }  operator to affect
N   W               (motion) N blank-separated WORDS forward
N   X               delete N characters before the cursor
N   Y               yank N lines
    ZQ              Same as ":q!".
    ZZ              Same as ":x".
N   a               append text after the cursor (N times)
N   b               (motion) N words backward
N   cc              change N lines
N   c{motion}       change the text that is moved over with {motion}
VIS c               change the highlighted text
VIS d               delete the highlighted text
N   dd              delete N lines
N   d{motion}       delete the text that is moved over with {motion}
N   e               (motion) forward to the end of the Nth word
N   f&lt;char&gt;         (motion) to the Nth occurrence of &lt;char&gt; to the right
    g CTRL-G        show cursor column, line, and character position
N   g^              (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
    g~{motion}      switch case for the text that is moved over with {motion}
N   g#              (motion) like "#", but also find partial matches
N   g$              (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*              (motion) like "*", but also find partial matches
N   g0              (motion) to first character in screen line (differs from "0" when lines wrap)
    gD              (motion) goto global declaration of identifier under the cursor
N   gE              (motion) backward to the end of the Nth blank-separated WORD
N   gI              insert text in column 1 (N times)
    gU{motion}      make the text that is moved over with {motion} uppercase
    ga              show ascii value of character under cursor in decimal, hex, and octal
    gd              (motion) goto local declaration of identifier under the cursor
    gf  or ]f       Edit the file whose name is under the cursor
N   ge              (motion) backward to the end of the Nth word
N   gg              (motion) goto line N (default: first line), on the first non-blank character
N   gj              (motion) down N screen lines (differs from "j" when line wraps)
N   gk              (motion) up N screen lines (differs from "k" when line wraps)
N   gq{motion}      format the lines that are moved over with {motion} to 'textwidth' length
N   gs              Goto Sleep for N seconds
    gu{motion}      make the text that is moved over with {motion} lowercase
    gv              start highlighting on previous visual area
N   h               (motion) left (also: CTRL-H, &lt;BS&gt;, or &lt;Left&gt; key)
N   i               insert text before the cursor (N times) (also: &lt;Insert&gt;)
N   j               (motion) down N lines (also: CTRL-J, CTRL-N, &lt;NL&gt;, and &lt;Down&gt;)
N   k               (motion) up N lines (also: CTRL-P and &lt;Up&gt;)
N   l               (motion) right (also: &lt;Space&gt; or &lt;Right&gt; key)
N   n               (motion?) repeat last search
    m&lt;a-zA-Z&gt;       mark current position with mark &lt;a-zA-Z&gt;
N   o               open a new line below the current line, append text (N times)
    o               (motion?) exchange cursor position with start of highlighting
N   p               put a register after the cursor position (N times)
    q               stop recording
    q&lt;A-Z&gt;          record typed characters, appended to register &lt;a-z&gt;
    q&lt;a-z&gt;          record typed characters into register &lt;a-z&gt;
N   r&lt;char&gt;         replace N characters with &lt;char&gt;
N   s               change N characters
N   t&lt;char&gt;         (motion) till before the Nth occurrence of &lt;char&gt; to the right
N   u               undo last N changes
VIS u               make highlighted text lowercase
    v               highlight characters or stop highlighting
    v               start highlighting characters  }  move cursor and use
N   w               (motion) N words forward
N   x               delete N characters under and after the cursor
N   yy              yank N lines 
N   y{motion}       yank the text moved over with {motion} 
VIS y               yank the highlighted text 
    z- or zb        redraw, current line at bottom of window
    z. or zz        redraw, current line at center of window
    z&lt;CR&gt; or zt     redraw, current line at top of window
N   zh              scroll screen N characters to the right
N   zl              scroll screen N characters to the left
</t>
<t tx="ekr.20131105122124.16483">                                           Value of magic option
                                           ---------------------
                        meaning            magic       nomagic

           matches any single character      .            \.
                  matches start of line      ^            ^
                    matches end of line      $            $
                  matches start of word      \&lt;           \&lt;
                    matches end of word      \&gt;           \&gt;
   matches a single char from the range      [a-z]        \[a-z]
 matches a single char not in the range      [^a-z]       \[^a-z]
             matches an identifier char      \i           \i
              idem but excluding digits      \I           \I
            matches a keyword character      \k           \k
              idem but excluding digits      \K           \K
           matches a filename character      \f           \f
              idem but excluding digits      \F           \F
          matches a printable character      \p           \p
              idem but excluding digits      \P           \P

                          matches &lt;Esc&gt;      \e           \e
                          matches &lt;Tab&gt;      \t           \t
                           matches &lt;CR&gt;      \r           \r
                           matches &lt;BS&gt;      \b           \b

matches 0 or more of the preceding atom      *            \*
matches 1 or more of the preceding atom      \+           \+
   matches 0 or 1 of the preceding atom      \=           \=
                 separates two branches      \|           \|
           group a pattern into an atom      \(\)         \(\)
</t>
<t tx="ekr.20131105122124.16484">    char                action in Insert mode
    ----                --------------------- 
 
    &lt;Esc&gt;               end Insert mode, back to Normal mode
    &lt;BS&gt; or CTRL-H      delete the character before the cursor
    {char1} &lt;BS&gt; {char2}    enter digraph if 'digraph' option set
    &lt;Del&gt;               delete the character under the cursor
    &lt;End&gt;               cursor after last character in the line
    &lt;Home&gt;              cursor to first character in the line
    &lt;NL&gt; or &lt;CR&gt;        begin new line
    
    cursor keys         move cursor left/right/up/down
    shift-left/right    one word left/right
    shift-up/down       one screenful backward/forward

    CTRL-@              insert previously inserted text and stop insert
    CTRL-A              insert previously inserted text
    CTRL-B              toggle 'revins' (reverse insert) option
    CTRL-C              like &lt;Esc&gt;, but do not do an abbreviation
    CTRL-D              delete one shiftwidth of indent in front of the current line
0   CTRL-D              delete all indent in the current line
^   CTRL-D              delete all indent in the current line, restore indent in next line
    CTRL-E              insert the character from below the cursor
    CTRL-K {char1} {char2}  enter digraph
    CTRL-M or CTRL-J    begin new line
    CTRL-N              insert next match of identifier before the cursor
    CTRL-O {command}    execute {command}
    CTRL-P              insert previous match of identifier before the cursor
    CTRL-R &lt;0-9a-z%:.-"&gt; insert contents of register &lt;0-9a-z%:.-"&gt;
    CTRL-T              insert one shiftwidth of indent in front of the current line
    CTRL-U              delete all entered characters in the current line
    CTRL-V &lt;char&gt;..     insert character literally, or enter decimal byte value
    CTRL-W              delete word before the cursor
    CTRL-X ...          complete the word before the cursor in various ways
    CTRL-Y              insert the character from above the cursor
</t>
<t tx="ekr.20131105122124.16485">N  !{motion}{command}&lt;CR&gt;  filter the lines that are moved over through {command}
N  !!{command}&lt;CR&gt;         filter N lines through {command}
   {visual}!{command}&lt;CR&gt;  filter the highlighted lines through {command}
   :[range]! {command}&lt;CR&gt; filter [range] lines through {command}
N  ={motion}               filter the lines that are moved over through "indent"
N  ==                      filter N lines through "indent"
   {visual}=               filter the highlighted lines through "indent"
   
:[range]s[ubstitute]/{pattern}/{string}/[g][c]
:[range]s[ubstitute] [g][c]
   &amp;         Repeat previous ":s" on current line without options
:[range]ret[ab][!] [tabstop]
</t>
<t tx="ekr.20131105122124.16486">Used only in Visual mode or after an operator

a   Select current word
A   Select current WORD
s   Select current sentence
p   Select current paragraph
S   Select current block (from "[(" to "])")
P   Select current block (from "[{" to "]}")
</t>
<t tx="ekr.20131105122124.16487">[num]       [num] lines downwards, in column 1
+[num]      [num] lines downwards, in column 1
-[num]      [num] lines upwards, in column 1
e[+num]     [num] characters to the right of the end of the match
e[-num]     [num] characters to the left of the end of the match
s[+num]     [num] characters to the right of the start of the match
s[-num]     [num] characters to the left of the start of the match
b[+num]     [num] characters to the right of the start (begin) of the match
b[-num]     [num] characters to the left of the start (begin) of the match
;{search command}   execute {search command} next

Examples

/test/+1		one line below "test", in column 1
/test/e		on the last t of "test"
/test/s+2		on the 's' of "test"
/test/b-3		three characters before "test"
</t>
<t tx="ekr.20131105122124.16488">:%g/^a/-1join     join lines starting with character 'a' to previous line
:%g/^ *$/d        delete empty lines
:%v/vim/m 1       move lines not matching the word 'vim' to line 1
:%g/^a/+1d        delete lines after the ones starting with character 'a'

:so[urce] {file}    Read Ex commands from {file}.
:so[urce]! {file}   Read Vim commands from {file}.
:sl[eep] [N]        don't do anything for N seconds
</t>
<t tx="ekr.20131105122124.16489">name       short name   explanation
----       ----------   -----------
aleph          al       ASCII code of the letter Aleph (RIGHTLEFT)
autoindent     ai       take indent for new line from previous line
autowrite      aw       automatically write file if changed
backspace      bs       how backspace works at start of line
backup         bk       keep backup file after overwriting a file
backupdir      bdir     list of directories for the backup file
backupext      bex      extension used for the backup file
binary         bin      edit binary file mode
bioskey        biosk    MS-DOS: use bios calls for input characters
breakat        brk      characters that may cause a line break
cindent        cin      do C program indenting
cinkeys        cink     keys that trigger indent when 'cindent' is set
cinoptions     cino     how to do indenting when 'cindent' is set
cinwords       cinw     words where 'si' and 'cin' add an indent
cmdheight      ch       number of lines to use for the command-line
columns        co       number of columns in the display
comments       com      patterns that can start a comment line
compatible     cp       behave Vi-compatibly as much as possible
cpoptions      cpo      flags for Vi-compatible behaviour
define         def      pattern to be used to find a macro definition
dictionary     dict     list of filenames used for keyword completion
digraph        dg       enable the entering of digraphs in Insert mode
directory      dir      list of directory names for the swapfile
edcompatible   ed       toggle flags of ":substitute" command
endofline      eol      write end-of-line for last line in file
equalalways    ea       windows are automatically made the same size
equalprg       ep       external program to use for "=" command
errorbells     eb       ring the bell for error messages
errorfile      ef       name of the error file for the QuickFix mode
errorformat    efm      description of the lines in the error file
esckeys        ek       recognize function keys in Insert mode
expandtab      et       use spaces when &lt;Tab&gt; is inserted
exrc                    read .vimrc and .exrc in the current directory
formatoptions  fo       how automatic formatting is to be done
formatprg      fp       name of external program used with "gq" command
gdefault       gd       the ":substitute" flag 'g' is default on
guifont        gfn      GUI: Name(s) of font(s) to be used
guioptions     go       GUI: Which components and options are used
guipty                  GUI: try to use a pseudo-tty for ":!" commands
helpfile       hf       name of this help file
helpheight     hh       minimum height of a new help window
hidden         hid      don't unload buffer when it is abandoned
highlight      hl       sets highlighting mode for various occasions
history        hi       number of command-lines that are remembered
hkmap          hk       Hebrew keyboard mapping (RIGHTLEFT)
icon                    set icon of the window to the name of the file
ignorecase     ic       ignore case in search patterns
include        inc      pattern to be used to find an include file
incsearch      is       highlight match while typing search pattern
infercase      inf      adjust case of match for keyword completion
insertmode     im       start the edit of a file in Insert mode
isfname        isf      characters included in filenames and pathnames
isident        isi      characters included in identifiers
isprint        isp      printable characters
iskeyword      isk      characters included in keywords
joinspaces     js       two spaces after a period with a join command
keywordprg     kp       program to use for the "K" command
langmap        lmap     alphabetic characters for other language mode
laststatus     ls       tells when last window has status lines
linebreak      lbr      wrap long lines at a blank
lines                   number of lines in the display
lisp                    automatic indenting for Lisp
list                    show &lt;Tab&gt; and end-of-line
magic                   changes special characters in search patterns
makeprg        mp       program to use for the ":make" command
maxmapdepth    mmd      maximum recursive depth for mapping
maxmem         mm       maximum memory (in Kbyte) used for one buffer
maxmemtot      mmt      maximum memory (in Kbyte) used for all buffers
modeline       ml       recognize modelines at start or end of file
modelines      mls      number of lines checked for modelines
modified       mod      buffer has been modified
more                    pause listings when the whole screen is filled
mouse                   enable the use of mouse clicks
mousetime      mouset   max time between mouse double-click
number         nu       print the line number in front of each line
paragraphs     para     nroff macros that separate paragraphs
paste                   allow pasting text
patchmode      pm       keep the oldest version of a file
path           pa       list of directories searched with "gf" et.al.
readonly       ro       disallow writing the buffer
remap                   allow mappings to work recursively
report                  threshold for reporting nr. of lines changed
restorescreen  rs       Win32: restore screen when exiting
revins         ri       inserting characters will work backwards
rightleft      rl       window is right-to-left oriented (RIGHTLEFT)
ruler          ru       show cursor line and column in the status line
scroll         scr      lines to scroll with CTRL-U and CTRL-D
scrolljump     sj       minimum number of lines to scroll
scrolloff      so       minimum nr. of lines above and below cursor
sections       sect     nroff macros that separate sections
secure                  secure mode for reading .vimrc in current dir
shell          sh       name of shell to use for external commands
shellcmdflag   shcf     flag to shell to execute one command
shellpipe      sp       string to put output of ":make" in error file
shellquote     shq      quote character(s) for around shell command
shellredir     srr      string to put output of filter in a temp file
shelltype      st       Amiga: influences how to use a shell
shiftround     sr       round indent to multiple of shiftwidth
shiftwidth     sw       number of spaces to use for (auto)indent step
shortmess      shm      list of flags, reduce length of messages
shortname      sn       non-MS-DOS: File names assumed to be 8.3 chars
showbreak      sbr      string to use at the start of wrapped lines
showcmd        sc       show (partial) command in status line
showmatch      sm       briefly jump to matching bracket if insert one
showmode       smd      message on status line to show current mode
sidescroll     ss       minimum number of columns to scroll horizontal
smartcase      scs      no ignore case when pattern has uppercase
smartindent    si       smart autoindenting for C programs. For perl
                        script editing set this option and the following
                        key mapping: inoremap # x&lt;BS&gt;# 
smarttab       sta      use 'shiftwidth' when inserting &lt;Tab&gt;
splitbelow     sb       new window from split is below the current one
startofline    sol      commands move cursor to first blank in line
suffixes       su       suffixes that are ignored with multiple match
swapsync       sws      how to sync swapfile
tabstop        ts       number of spaces that &lt;Tab&gt; in file uses
taglength      tl       number of significant characters for a tag
tagrelative    tr       filenames in tag file are relative
tags           tag      list of filenames used by the tag command
term                    name of the terminal
terse                   shorten some messages
textauto       ta       set 'textmode' automatically when reading file
textmode       tx       lines are separated by &lt;CR&gt;&lt;NL&gt;
textwidth      tw       maximum width of text that is being inserted
tildeop        top      tilde command "~" behaves like an operator
timeout        to       time out on mappings and key codes
ttimeout                time out on mappings
timeoutlen     tm       time out time in milliseconds
ttimeoutlen    ttm      time out time for key codes in milliseconds
title                   set title of window to the name of the file
ttybuiltin     tbi      use built-in termcap before external termcap
ttyfast        tf       indicates a fast terminal connection
ttyscroll      tsl      maximum number of lines for a scroll
ttytype        tty      alias for 'term'
undolevels     ul       maximum number of changes that can be undone
updatecount    uc       after this many characters flush swapfile
updatetime     ut       after this many milliseconds flush swapfile
viminfo        vi       use .viminfo file upon startup and exiting
visualbell     vb       use visual bell instead of beeping
warn                    warn for shell command when buffer was changed
weirdinvert    wi       for terminals that have weird inversion method
whichwrap      ww       allow specified keys to cross line boundaries
wildchar       wc       command-line character for wildcard expansion
winheight      wh       minimum number of lines for the current window
wrap                    long lines wrap and continue on the next line
wrapmargin     wm       chars from the right where wrapping starts
wrapscan       ws       searches wrap around the end of the file
writeany       wa       write to file with no need for "!" override
writebackup    wb       make a backup before overwriting a file
writedelay     wd       delay this many msec for each char (for debug)
</t>
<t tx="ekr.20131105122124.16490">'wildchar' (default: &lt;Tab&gt;)
    do completion on the pattern in front of the cursor. If there are
    multiple matches, beep and show the first one; further 'wildchar' will
    show the next ones.
                   
CTRL-A  insert all names that match pattern in front of cursor
CTRL-D  list   all names that match the pattern in front of the cursor
CTRL-L  insert longest common part of names that match pattern
CTRL-N  after 'wildchar' with multiple matches: go to next match
CTRL-P  after 'wildchar' with multiple matches: go to previous match
</t>
<t tx="ekr.20131105122124.16491">|           separates two commands (not for ":global" and ":!")
"           begins comment

%           current filename (only where filename is expected)
#[number]   alternate filename [number] (only where filename is expected)

Note: The next four are typed literally; these are not special keys!

&lt;cword&gt;     word under the cursor (only where filename is expected)
&lt;cWORD&gt;     WORD under the cursor (only where filename is expected)
&lt;cfile&gt;     file name under the cursor (only where filename is expected)
&lt;afile&gt;     file name for autocommand (only where filename is expected)

After "%", "#", "&lt;cfile&gt;", or "&lt;afile&gt;"
:p          full path
:h          head
:t          tail
:r          root
:e          extension
</t>
<t tx="ekr.20131105122124.16492">,               separates two line numbers
;               idem, set cursor to the first line number
                before interpreting the second one
{number}        an absolute line number
.               the current line
$               the last line in the file
%               equal to 1,$ (the entire file)
*               equal to '&lt;,'&gt; (visual area)
't              position of mark t
/{pattern}[/]   the next line where {pattern} matches
?{pattern}[?]   the previous line where {pattern} matches
+[num]          add [num] to the preceding line number (default: 1)
-[num]          subtract [num] from the preceding line number (default: 1)
</t>
<t tx="ekr.20131105122124.16493">38 -- Starting VIM


vim [options]                start editing with an empty buffer
vim [options] {file ..}      start editing one or more files
vim [options] -t {tag}       edit the file associated with {tag}
vim [options] -e [fname]     start editing in QuickFix mode, display the first error


39 -- Vim Command Line Arguments


-g                  start GUI (also allows other options)

+[num]              put the cursor at line [num] (default: last line)
+{command}          execute {command} after loading the file
+/{pat} {file ..}   put the cursor at the first occurrence of {pat}
-v                  read-only mode (View), implies -n
-R                  read-only mode, same as -v
-b                  binary mode
-l                  lisp mode
-H                  Hebrew mode ('hkmap' and 'rightleft' are set)
-r                  give list of swap files
-r {file ..}        recover aborted edit session
-n                  do not create swapfile
-o [N]              open N windows (default: one for each file)
-x                  Amiga: do not restart VIM to open a window (for
                        e.g., mail)
-s {scriptin}       first read commands from the file {scriptin}
-w {scriptout}      write typed chars to file {scriptout} (append)
-W {scriptout}      write typed chars to file {scriptout} (overwrite)
-T {terminal}       set terminal name
-d {device}         Amiga: open {device} to be used as a console
-u {vimrc}          read inits from {vimrc} instead of other inits
-i {viminfo}        read info from {viminfo} instead of other files
--                  end of options, other arguments are file names

Automatic option setting when editing a file

vim:{set-arg}: ..       In the first and last lines of the
                        file (see 'ml' option), {set-arg} is
                        given as an argument to ":set"
                        
Automatic execution of commands on certain events.

:au                     List all autocommands
:au {event}             List all autocommands for {event}
:au {event} {pat}       List all autocommands for {event} with {pat}
:au {event} {pat} {cmd} Enter new autocommands for {event} with {pat}
:au!                    Remove all autocommands
:au! {event}            Remove all autocommands for {event}
:au! * {pat}            Remove all autocommands for {pat}
:au! {event} {pat}      Remove all autocommands for {event} with {pat}
:au! {event} {pat} {cmd}  Remove all autocommands for {event} with {pat} and enter new one
</t>
<t tx="ekr.20131105122124.16494">:marks                  print the active marks
:ju[mps]                print the jump list
:ta[g][!] {tag}         Jump to tag {tag}
:[count]ta[g][!]        Jump to [count]'th newer tag in tag list
:[count]po[p][!]        Jump back from [count]'th older tag in tag list
:tags                   Print tag list
:dig[raphs]                                 show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:r [file]               insert the contents of [file] below the cursor
:r! {command}           insert the standard output of {command} below the cursor
:[range]d [x]           delete [range] lines [into register x]
:reg                    show the contents of all registers
:reg {arg}              show the contents of registers mentioned in {arg}
:[range]ce[nter] [width] center the lines in [range]
:[range]le[ft] [indent]  left-align the lines in [range] [with indent]
:[range]ri[ght] [width]  right-align the lines in [range]
:@&lt;a-z&gt;                 execute the contents of register &lt;a-z&gt; as an Ex command
:@@                     repeat previous :@&lt;a-z&gt;
:[range]g[lobal]/{pattern}/[cmd] 
:[range]g[lobal]!/{pattern}/[cmd]     or    :[range]v/{pattern}/[cmd]
:ma[p] {lhs} {rhs}          Map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! {lhs} {rhs}         Map {lhs} to {rhs} in Insert and Command-line mode.
:no[remap][!] {lhs} {rhs}   Same as ":map", no remapping for this {rhs}
:unm[ap] {lhs}              Remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}             Remove the mapping of {lhs} for Insert and Command-line mode.
:ma[p] [lhs]         List mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p]! [lhs]        List mappings (starting with [lhs]) for Insert and Command-line mode.
:cmap/:cunmap/:cnoremap 
:imap/:iunmap/:inoremap
:nmap/:nunmap/:nnoremap
:vmap/:vunmap/:vnoremap
:mk[exrc][!] [file]  write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file] same as ":mkexrc", but with default ".vimrc"
:mapc[lear]          remove mappings for Normal and Visual mode
:mapc[lear]!         remove mappings for Insert and Cmdline mode
:imapc[lear]         remove mappings for Insert mode
:vmapc[lear]         remove mappings for Visual mode
:nmapc[lear]         remove mappings for Normal mode
:cmapc[lear]         remove mappings for Cmdline mode

:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
:ab[breviate] {lhs}        show abbr's that start with {lhs}
:ab[breviate]              show all abbreviations
:una[bbreviate] {lhs}      remove abbreviation for {lhs}
:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
:iab/:iunab/:inoreab       like ":ab", but only for Insert mode
:cab/:cunab/:cnoreab       like ":ab", but only for Command-line mode
:abc[lear]                 remove all abbreviations
:cabc[lear]                remove all abbr's for Cmdline mode
:iabc[lear]                remove all abbr's for Insert mode
:se[t]                  Show all modified options.
:se[t] all              Show all options.
:se[t] {option}         Set toggle option on, show string or number option.
:se[t] no{option}       Set toggle option off.
:se[t] inv{option}      invert toggle option.
:se[t] {option}={value} Set string or number option to {value}.
:se[t] {option}?        Show value of {option}.
:se[t] {option}&amp;        Reset {option} to its default value.
:fix[del]               Set value of 't_kD' according to value of 't_kb'.
:sh[ell]        start a shell
:!{command}     execute {command} with a shell
:cc [nr]        display error [nr] (default is the same again)
:cn             display the next error
:cp             display the previous error
:cl             list all errors
:cf             read errors from the file 'errorfile'
:cq             quit without writing and return error code (to the compiler)
:make [args]    start make, read errors, and jump to first error
:ve[rsion]      show exact version number of this Vim
:mode N         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:norm[al][!] {commands} Execute Normal mode commands.
:e[dit]              Edit the current file, unless changes have been made.
:e[dit]!             Edit the current file always.  Discard any changes.
:e[dit] {file}       Edit {file}, unless changes have been made.
:e[dit]! {file}      Edit {file} always.  Discard any changes.
:pwd                 Print the current directory name.
:cd [path]           Change the current directory to [path].
:f[ile]              Print the current filename and the cursor position.
:f[ile] {name}       Set the current filename to {name}.
:files               Show alternate filenames.

:argu[ment] N       edit file N
:n[ext]             edit next file
:n[ext] {arglist}   define new arg list and edit first file
:N[ext]             edit previous file
:rew[ind][!]        edit first file
:last               edit last file
:sar[gument] N      edit file N (new window)
:sn[ext]            edit next file (new window)
:sn[ext] {arglist}  define new arg list and edit first file (new window)
:sN[ext]            Edit previous file (new window)
:srew[ind]          Edit first file (new window)
:slast              Edit last file (new window)


:ar[gs]              Print the argument list, with the current file in "[]".
:all  or :sall       Open a window for every file in the arg list.
:wn[ext][!]          Write file and edit next file.
:wn[ext][!] {file}   Write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wN[ext][!] [file]   Write file and edit previous file.
:[range]w[rite][!]            Write to the current file.
:[range]w[rite] {file}        Write to {file}, unless it already exists.
:[range]w[rite]! {file}       Write to {file}.  Overwrite an existing file.
:[range]w[rite][!] &gt;&gt;         Append to the current file.
:[range]w[rite][!] &gt;&gt; {file}  Append to {file}.
:[range]w[rite] !{cmd}        Execute {cmd} with [range] lines as standard input.
:wall[!]                      write all changed buffers

:q[uit]               Quit current buffer.
:q[uit]!              Quit current buffer always.
:qall                 Exit Vim, unless changes have been made.
:qall!                Exit Vim always, discard any changes.
:cq                   Quit without writing and return error code.

:wq[!]                Write the current file and exit.
:wq[!] {file}         Write to {file} and exit.
:x[it][!] [file]      Like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]  Write all changed buffers and exit
:st[op][!]              Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.

:rv[iminfo] [file]      Read info from viminfo file [file]
:rv[iminfo]! [file]     idem, overwrite exisiting info
:wv[iminfo] [file]      Add info to viminfo file [file]
:wv[iminfo]! [file]     Write info to viminfo file [file]

:split                  Split window into two parts
:split {file}           Split window and edit {file} in one of them

:buffers  or  :files    list all known buffer and file names
:ball     or  :sball    edit all args/buffers
:unhide   or  :sunhide  edit all loaded buffers

:bunload[!] [N]         unload buffer [N] from memory
:bdelete[!] [N]         unload buffer [N] and delete it from the buffer list

:[N]buffer [N]      to arg/buf N
:[N]bnext [N]       to Nth next arg/buf
:[N]bNext [N]       to Nth previous arg/buf
:[N]bprevious [N]   to Nth previous arg/buf
:brewind            to first arg/buf
:blast              to last arg/buf
:[N]bmod [N]        to Nth modified buf

:[N]sbuffer [N]     to arg/buf N (in new window)
:[N]sbnext [N]      to Nth next arg/buf (in new window)
:[N]sbNext [N]      to Nth previous arg/buf (in new window)
:[N]sbprevious [N]  to Nth previous arg/buf (in new window)
:sbrewind           to first arg/buf (in new window)
:sblast             to last arg/buf (in new window)
:[N]sbmod [N]       to Nth modified buf (in new window)
</t>
<t tx="ekr.20131105122124.16495">:!{command}                     execute {command} with a shell
:@&lt;a-z&gt;                         execute the contents of register &lt;a-z&gt; as an Ex command
:@@                             repeat previous :@&lt;a-z&gt;
:N[ext]                         edit previous file
:ab[breviate]                   show all abbreviations
:ab[breviate] {lhs}             show abbr's that start with {lhs}
:ab[breviate] {lhs} {rhs}       add abbreviation for {lhs} to {rhs}
:abc[lear]                      remove all abbreviations
:all  or :sall                  open a window for every file in the arg list.
:ar[gs]                         print the argument list, with the current file in "[]".
:argu[ment] N                   edit file N
:[N]bNext [N]                   to Nth previous arg/buf
:ball     or  :sball            edit all args/buffers
:bdelete[!] [N]                 unload buffer [N] and delete it from the buffer list
:blast                          to last arg/buf
:[N]bmod [N]                    to Nth modified buf
:[N]bnext [N]                   to Nth next arg/buf
:[N]bprevious [N]               to Nth previous arg/buf
:[N]buffer [N]                  to arg/buf N
:brewind                        to first arg/buf
:buffers  or  :files            list all known buffer and file names
:bunload[!] [N]                 unload buffer [N] from memory
:cab/:cunab/:cnoreab            like ":ab", but only for Command-line mode
:cabc[lear]                     remove all abbr's for Cmdline mode
:cc [nr]                        display error [nr] (default is the same again)
:cd [path]                      change the current directory to [path].
:[range]ce[nter] [width]        center the lines in [range]
:cf                             read errors from the file 'errorfile'
:cl                             list all errors
:cmap/:cunmap/:cnoremap 
:cmapc[lear]                    remove mappings for Cmdline mode
:cn                             display the next error
:cp                             display the previous error
:cq                             quit without writing and return error code.
:cq                             quit without writing and return error code (to the compiler)
:[range]d [x]                   delete [range] lines [into register x]
:dig[raphs]                     show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:e[dit]                         edit the current file, unless changes have been made.
:e[dit] {file}                  edit {file}, unless changes have been made.
:e[dit]!                        edit the current file always.  Discard any changes.
:e[dit]! {file}                 edit {file} always.  Discard any changes.
:f[ile]                         print the current filename and the cursor position.
:f[ile] {name}                  set the current filename to {name}.
:files                          show alternate filenames.
:fix[del]                       set value of 't_kD' according to value of 't_kb'.
:[range]g[lobal]!/{pattern}/[cmd]
:[range]g[lobal]/{pattern}/[cmd] 
:iab/:iunab/:inoreab            like ":ab", but only for Insert mode
:iabc[lear]                     remove all abbr's for Insert mode
:imap/:iunmap/:inoremap
:imapc[lear]                    remove mappings for Insert mode
:ju[mps]                        print the jump list
:last                           edit last file
:[range]le[ft] [indent]         left-align the lines in [range] [with indent]
:ma[p] [lhs]                    list mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p] {lhs} {rhs}              map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! [lhs]                   list mappings (starting with [lhs]) for Insert and Command-line mode.
:ma[p]! {lhs} {rhs}             map {lhs} to {rhs} in Insert and Command-line mode.
:make [args]                    start make, read errors, and jump to first error
:mapc[lear]                     remove mappings for Normal and Visual mode
:mapc[lear]!                    remove mappings for Insert and Cmdline mode
:marks                          print the active marks
:mk[exrc][!] [file]             write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file]            same as ":mkexrc", but with default ".vimrc"
:mode N                         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:n[ext]                         edit next file
:n[ext] {arglist}               define new arg list and edit first file
:nmap/:nunmap/:nnoremap
:nmapc[lear]                    remove mappings for Normal mode
:no[remap][!] {lhs} {rhs}       same as ":map", no remapping for this {rhs}
:norea[bbrev] [lhs] [rhs]       like ":ab", but don't remap [rhs]
:norm[al][!] {commands}         execute Normal mode commands.
:[count]po[p][!]                jump back from [count]'th older tag in tag list
:pwd                            print the current directory name.
:q[uit]                         quit current buffer.
:q[uit]!                        quit current buffer always.
:qall                           exit Vim, unless changes have been made.
:qall!                          exit Vim always, discard any changes.
:r [file]                       insert the contents of [file] below the cursor
:r! {command}                   insert the standard output of {command} below the cursor
:reg                            show the contents of all registers
:reg {arg}                      show the contents of registers mentioned in {arg}
:rew[ind][!]                    edit first file
:[range]ri[ght] [width]         right-align the lines in [range]
:rv[iminfo] [file]              read info from viminfo file [file]
:rv[iminfo]! [file]             idem, overwrite exisiting info
:sN[ext]                        edit previous file (new window)
:sar[gument] N                  edit file N (new window)
:sblast                         to last arg/buf (in new window)
:[N]sbNext [N]                  to Nth previous arg/buf (in new window)
:[N]sbmod [N]                   to Nth modified buf (in new window)
:[N]sbnext [N]                  to Nth next arg/buf (in new window)
:[N]sbprevious [N]              to Nth previous arg/buf (in new window)
:[N]sbuffer [N]                 to arg/buf N (in new window)
:sbrewind                       to first arg/buf (in new window)
:se[t]                          show all modified options.
:se[t] all                      show all options.
:se[t] inv{option}              invert toggle option.
:se[t] no{option}               set toggle option off.
:se[t] {option}                 set toggle option on, show string or number option.
:se[t] {option}&amp;                reset {option} to its default value.
:se[t] {option}={value}         set string or number option to {value}.
:se[t] {option}?                show value of {option}.
:sh[ell]                        start a shell
:slast                          edit last file (new window)
:sn[ext]                        edit next file (new window)
:sn[ext] {arglist}              define new arg list and edit first file (new window)
:split                          Split window into two parts
:split {file}                   Split window and edit {file} in one of them
:srew[ind]                      Edit first file (new window)
:st[op][!]                      Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.
:[count]ta[g][!]                jump to [count]'th newer tag in tag list
:ta[g][!] {tag}                 jump to tag {tag}
:tags                           print tag list
:una[bbreviate] {lhs}           remove abbreviation for {lhs}
:unhide   or  :sunhide          edit all loaded buffers
:unm[ap] {lhs}                  remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}                 remove the mapping of {lhs} for Insert and Command-line mode.
:[range]v/{pattern}/[cmd]
:ve[rsion]                      show exact version number of this Vim
:vmap/:vunmap/:vnoremap
:vmapc[lear]                    remove mappings for Visual mode
:[range]w[rite] !{cmd}          execute {cmd} with [range] lines as standard input.
:[range]w[rite] {file}          write to {file}, unless it already exists.
:[range]w[rite]! {file}         write to {file}.  Overwrite an existing file.
:[range]w[rite][!]              write to the current file.
:[range]w[rite][!] &gt;&gt;           append to the current file.
:[range]w[rite][!] &gt;&gt; {file}    append to {file}.
:wN[ext][!] [file]              write file and edit previous file.
:wall[!]                        write all changed buffers
:wn[ext][!]                     write file and edit next file.
:wn[ext][!] {file}              write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wq[!]                          write the current file and exit.
:wq[!] {file}                   write to {file} and exit.
:wv[iminfo] [file]              add info to viminfo file [file]
:wv[iminfo]! [file]             write info to viminfo file [file]
:x[it][!] [file]                like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]          Write all changed buffers and exit
</t>
<t tx="ekr.20131108082341.18226">@color

w   to start of next word, excluding it's first character.
e   to end of next word, including it's last character.
$   to end of line, including the last character.
0   to start of line

Motions may include repeat count:

d2w
2dd
d2d

From: http://bullium.com/support/vim.html#motion

Basic motion commands:

N h
N j or Ctrl-N
N k or Ctrl-P
0 or &lt;Home&gt;
^ 
$ or &lt;End&gt;
g0 or
g&lt;Home&gt; 	
g^
g$ or g&lt;End&gt;
f{char}
F{char}
t{char}
T{char}
; 	Repeat latest f, t, F or T [count] times.
, 	Repeat latest f, t, F or T in opposite direction [count] times.
-
N + or CTRL-M or &lt;CR&gt;
N _
&lt;C-End&gt; or G
N &lt;C-Home&gt; or gg
N &lt;S-Right&gt; or w
N &lt;C-Right&gt; or W
N e 	Forward to the end of word [count]
E 	Forward to the end of WORD [count]
&lt;S-Left&gt; or
b 	[count] words backward
&lt;C-Left&gt; or
B 	[count] WORDS backward
ge 	Backward to the end of word [count]
gE 	Backward to the end of WORD [count]

These commands move over words or WORDS.

A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, ). This can be changed with the 'iskeyword' option.

A WORD consists of a sequence of non-blank characters, separated with white
space. An empty line is also considered to be a word and a WORD.

N ( 	    
N ) 	    
N { 	    
N } 	
N ]] 	    
N ][ 	    
N [[ 	    
N [] 	
</t>
<t tx="ekr.20131108082341.18235">    CTRL-B  (motion?) cursor to beginning of command-line
    CTRL-E  (motion?) cursor to end of command-line
    N   .   (motion?) repeat last change (with count replaced with N)
N   [p      (motion?) like P, but adjust indent to current line
N   ]p      (motion?) like p, but adjust indent to current line
    
    &lt;Left&gt;  (motion) cursor left
    &lt;Right&gt; (motion) cursor right
    &lt;S-Left&gt;/&lt;S-Right&gt;  (motion) cursor one word left/right
    
N   CTRL-F  (motion) window N pages Forwards (downwards)
N   CTRL-I  (motion) go to Nth newer position in jump list
N   CTRL-O  (motion) go to Nth older position in jump list
N   CTRL-T  (motion) Jump back from Nth older tag in tag list
    0       (motion) to first character in the line (also: &lt;Home&gt; key)
N   +       (motion) down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
N   _       (motion) down N-1 lines, on the first non-blank character
N   -       (motion) up N lines, on the first non-blank character
N   ,       (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   ;       (motion) repeat the last "f", "F", "t", or "T" N times
N   (       (motion) N sentences backward
N   )       (motion) N sentences forward
N   {       (motion) N paragraphs backward
N   }       (motion) N paragraphs forward
N   |       (motion) to column N (default: 1)

    `"                  (motion) go to the position when last editing this file
    '&lt;a-zA-Z0-9[]'"&lt;&gt;&gt;  (motion) same as `, but on the first non-blank in the line
    `&lt;                  (motion?) go to the start of the (previous) Visual area
    `&lt;0-9&gt;              (motion) go to the position where Vim was last exited
    `&lt;A-Z&gt;              (motion) go to mark &lt;A-Z&gt; in any file
    `&lt;a-z&gt;              (motion) go to mark &lt;a-z&gt; within current file
    `&gt;                  (motion) go to the end of the (previous) Visual area
    `[                  (motion) go to the start of the previously operated or put text
    `]                  (motion) go to the end of the previously operated or put text
    ``                  (motion) go to the position before the last jump

N   $       (motion) go to the last character in the line (N-1 lines lower) (also: &lt;End&gt; key)
    ^       (motion) go to first non-blank character in the line
N   %       (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %       (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   #       (motion) search backward for the identifier under the cursor
N   *       (motion) search forward for the identifier under the cursor
N   /&lt;CR&gt;   (motion) repeat last search, in the forward direction

N   /{pattern}[/[offset]]&lt;CR&gt;   (motion) search forward for the Nth occurrence of {pattern}
N   ?&lt;CR&gt;                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]&lt;CR&gt;   (motion) search backward for the Nth occurrence of {pattern}

N   [#      (motion) N times back to unclosed "#if" or "#else"
N   [(      (motion) N times back to unclosed '('
N   [*      (motion) N times back to start of comment "/*"
N   [[      (motion) N sections backward, at start of section
N   []      (motion) N sections backward, at end of section
N   [{      (motion) N times back to unclosed '{'

N   ]#      (motion) N times forward to unclosed "#else" or "#endif"
N   ])      (motion) N times forward to unclosed ')'
N   ]*      (motion) N times forward to end of comment "*/"
N   ][      (motion) N sections forward, at end of section
N   ]]      (motion) N sections forward, at start of section
N   ]}      (motion) N times forward to unclosed '}'

N   B       (motion) N blank-separated WORDS backward
N   E       (motion) forward to the end of the Nth blank-separated WORD
N   F&lt;char&gt; (motion) to the Nth occurrence of &lt;char&gt; to the left
N   G       (motion) goto line N (default: last line), on the first non-blank character
N   H       (motion?) go to the Nth line in the window, on the first non-blank
N   J       (motion?) join N-1 lines (delete newlines)
VIS J       (motion?) join the highlighted lines
    M       (motion?) go to the middle line in the window, on the first non-blank
N   L       (motion?) go to the Nth line from the bottom, on the first non-blank
N   N       (motion) repeat last search, in opposite direction
N   T&lt;char&gt; (motion) till before the Nth occurrence of &lt;char&gt; to the left
N   W       (motion) N blank-separated WORDS forward

N   b       (motion) N words backward
N   e       (motion) forward to the end of the Nth word
N   f&lt;char&gt; (motion) to the Nth occurrence of &lt;char&gt; to the right
N   g^      (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
N   g#      (motion) like "#", but also find partial matches
N   g$      (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*      (motion) like "*", but also find partial matches
N   g0      (motion) to first character in screen line (differs from "0" when lines wrap)
    gD      (motion) goto global declaration of identifier under the cursor
N   gE      (motion) backward to the end of the Nth blank-separated WORD
    gd      (motion) goto local declaration of identifier under the cursor
N   ge      (motion) backward to the end of the Nth word
N   gg      (motion) goto line N (default: first line), on the first non-blank character
N   gj      (motion) down N screen lines (differs from "j" when line wraps)
N   gk      (motion) up N screen lines (differs from "k" when line wraps)
N   h       (motion) left (also: CTRL-H, &lt;BS&gt;, or &lt;Left&gt; key)
N   j       (motion) down N lines (also: CTRL-J, CTRL-N, &lt;NL&gt;, and &lt;Down&gt;)
N   k       (motion) up N lines (also: CTRL-P and &lt;Up&gt;)
N   l       (motion) right (also: &lt;Space&gt; or &lt;Right&gt; key)
N   n       (motion?) repeat last search
    o       (motion?) exchange cursor position with start of highlighting
N   t&lt;char&gt; (motion) till before the Nth occurrence of &lt;char&gt; to the right
N   w       (motion) N words forward
</t>
<t tx="ekr.20131109090612.29139">@language c
/* Execute a command in Normal mode. */
void normal_cmd(oap, toplevel)
    oparg_T *oap;
    int	  toplevel UNUSED; /* TRUE when called from main() */
{
    &lt;&lt; init vars &gt;&gt;
    &lt;&lt; check for pending operator &gt;&gt;
    &lt;&lt; reset the count &gt;&gt;
    &lt;&lt; restore counts before receiving K_CURSORHOLD &gt;&gt;
    &lt;&lt; get command character from user &gt;&gt;
    &lt;&lt; handle special caces for visual/select mode &gt;&gt;
    &lt;&lt; invert horizontal movements and operations &gt;&gt;
    &lt;&lt; get additional character &gt;&gt;
    &lt;&lt; flush the showcmd characters to the screen &gt;&gt;
    #ifdef FEAT_AUTOCMD
    if (ca.cmdchar != K_IGNORE)
        did_cursorhold = FALSE;
    #endif
    State = NORMAL;
    &lt;&lt; goto normal_end on ESC &gt;&gt;
    &lt;&lt; set msg_ vars &gt;&gt;
    &lt;&lt; remember where the cursor was &gt;&gt;
    /*
     * Execute the command!
     * Call the command function found in the commands table.
     */
    ca.arg = nv_cmds[idx].cmd_arg;
    (nv_cmds[idx].cmd_func)(&amp;ca);
    &lt;&lt; reset oap-regname &gt;&gt;
    &lt;&lt; set old_mapped_len &gt;&gt;
    &lt;&lt; handle pending operator &gt;&gt;
    &lt;&lt; wait to write message &gt;&gt;
normal_end:
    &lt;&lt; finish up &gt;&gt;
}
</t>
<t tx="ekr.20131109090612.29140">/*
 * May restart edit(), if we got here with CTRL-O in Insert mode (but not
 * if still inside a mapping that started in Visual mode).
 * May switch from Visual to Select mode after CTRL-O command.
 */
if ( oap-&gt;op_type == OP_NOP

    #ifdef FEAT_VISUAL
    &amp;&amp; ((restart_edit != 0 &amp;&amp; !VIsual_active &amp;&amp; old_mapped_len == 0)
    || restart_VIsual_select == 1)
    #else
        &amp;&amp; restart_edit != 0
    #endif

    &amp;&amp; !(ca.retval &amp; CA_COMMAND_BUSY)
    &amp;&amp; stuff_empty()
    &amp;&amp; oap-&gt;regname == 0
) {
    #ifdef FEAT_VISUAL
    if (restart_VIsual_select == 1)
    {
        VIsual_select = TRUE;
        showmode();
        restart_VIsual_select = 0;
    }
    #endif

    if (restart_edit != 0
        #ifdef FEAT_VISUAL
        &amp;&amp; !VIsual_active &amp;&amp; old_mapped_len == 0
        #endif
    )
        (void)edit(restart_edit, FALSE, 1L);
}
</t>
<t tx="ekr.20131109090612.29141">/*
 * Finish up after executing a Normal mode command.
 */

msg_nowait = FALSE;

/* Reset finish_op, in case it was set */
#ifdef CURSOR_SHAPE
c = finish_op;
#endif

finish_op = FALSE;

#ifdef CURSOR_SHAPE
/* Redraw the cursor with another shape, if we were in Operator-pending
 * mode or did a replace command. */
if (c || ca.cmdchar == 'r')
{
    ui_cursor_shape();		/* may show different cursor shape */
    # ifdef FEAT_MOUSESHAPE
    update_mouseshape(-1);
    # endif
}
#endif

#ifdef FEAT_CMDL_INFO
if (oap-&gt;op_type == OP_NOP &amp;&amp; oap-&gt;regname == 0
    # ifdef FEAT_AUTOCMD
        &amp;&amp; ca.cmdchar != K_CURSORHOLD
    # endif
)
    clear_showcmd();
#endif

checkpcmark();	/* check if we moved since setting pcmark */
vim_free(ca.searchbuf);

#ifdef FEAT_MBYTE
if (has_mbyte)
    mb_adjust_cursor();
#endif

#ifdef FEAT_SCROLLBIND
if (curwin-&gt;w_p_scb &amp;&amp; toplevel)
{
    validate_cursor();	/* may need to update w_leftcol */
    do_check_scrollbind(TRUE);
}
#endif

&lt;&lt; possibly restart edit &gt;&gt;

#ifdef FEAT_VISUAL
if (restart_VIsual_select == 2)
    restart_VIsual_select = 1;
#endif

/* Save count before an operator for next time. */
opcount = ca.opcount;
</t>
<t tx="ekr.20131109090612.29142">/*
 * Wait for a moment when a message is displayed that will be overwritten
 * by the mode message.
 * In Visual mode and with "^O" in Insert mode, a short message will be
 * overwritten by the mode message.  Wait a bit, until a key is hit.
 * In Visual mode, it's more important to keep the Visual area updated
 * than keeping a message (e.g. from a /pat search).
 * Only do this if the command was typed, not from a mapping.
 * Don't wait when emsg_silent is non-zero.
 * Also wait a bit after an error message, e.g. for "^O:".
 * Don't redraw the screen, it would remove the message.
 */
if (       ((p_smd
	    &amp;&amp; msg_silent == 0
	    &amp;&amp; (restart_edit != 0
#ifdef FEAT_VISUAL
		|| (VIsual_active
		    &amp;&amp; old_pos.lnum == curwin-&gt;w_cursor.lnum
		    &amp;&amp; old_pos.col == curwin-&gt;w_cursor.col)
#endif
	       )
	    &amp;&amp; (clear_cmdline
		|| redraw_cmdline)
	    &amp;&amp; (msg_didout || (msg_didany &amp;&amp; msg_scroll))
	    &amp;&amp; !msg_nowait
	    &amp;&amp; KeyTyped)
	|| (restart_edit != 0
#ifdef FEAT_VISUAL
	    &amp;&amp; !VIsual_active
#endif
	    &amp;&amp; (msg_scroll
		|| emsg_on_display)))
    &amp;&amp; oap-&gt;regname == 0
    &amp;&amp; !(ca.retval &amp; CA_COMMAND_BUSY)
    &amp;&amp; stuff_empty()
    &amp;&amp; typebuf_typed()
    &amp;&amp; emsg_silent == 0
    &amp;&amp; !did_wait_return
    &amp;&amp; oap-&gt;op_type == OP_NOP)
{
    int	save_State = State;
    /* Draw the cursor with the right shape here */
    if (restart_edit != 0)
        State = INSERT;
    /* If need to redraw, and there is a "keep_msg", redraw before the delay */
    if (must_redraw &amp;&amp; keep_msg != NULL &amp;&amp; !emsg_on_display)
    {
        char_u	*kmsg;
        kmsg = keep_msg;
        keep_msg = NULL;
        /* showmode() will clear keep_msg, but we want to use it anyway */
        update_screen(0);
        /* now reset it, otherwise it's put in the history again */
        keep_msg = kmsg;
        msg_attr(kmsg, keep_msg_attr);
        vim_free(kmsg);
    }
    setcursor();
    cursor_on();
    out_flush();
    if (msg_scroll || emsg_on_display)
        ui_delay(1000L, TRUE);	/* wait at least one second */
    ui_delay(3000L, FALSE);	/* wait up to three seconds */
    State = save_State;
    msg_scroll = FALSE;
    emsg_on_display = FALSE;
}
</t>
<t tx="ekr.20131109090612.29143">/*
 * If we didn't start or finish an operator, reset oap-&gt;regname, unless we
 * need it later.
 */
if (!finish_op
    &amp;&amp; !oap-&gt;op_type
    &amp;&amp; (idx &lt; 0 || !(nv_cmds[idx].cmd_flags &amp; NV_KEEPREG))
) {
    clearop(oap);

    #ifdef FEAT_EVAL
    set_reg_var('"');
    #endif
}
</t>
<t tx="ekr.20131109090612.29144">
#ifdef FEAT_VISUAL
/* Get the length of mapped chars again after typing a count, second
 * character or "z333&lt;cr&gt;". */
if (old_mapped_len &gt; 0)
    old_mapped_len = typebuf_maplen();
#endif
</t>
<t tx="ekr.20131109090612.29145">/*
 * If an operation is pending, handle it...
 */
do_pending_operator(&amp;ca, old_col, FALSE);
</t>
<t tx="ekr.20131109090612.29146">#ifdef FEAT_VISUAL
old_pos = curwin-&gt;w_cursor;		/* remember where cursor was */

/* When 'keymodel' contains "startsel" some keys start Select/Visual
 * mode. */
if (!VIsual_active &amp;&amp; km_startsel)
{
    if (nv_cmds[idx].cmd_flags &amp; NV_SS)
    {
        start_selection();
        unshift_special(&amp;ca);
        idx = find_command(ca.cmdchar);
    }
    else if ((nv_cmds[idx].cmd_flags &amp; NV_SSS) &amp;&amp; (mod_mask &amp; MOD_MASK_SHIFT)
    ) {
        start_selection();
        mod_mask &amp;= ~MOD_MASK_SHIFT;
    }
}
#endif
</t>
<t tx="ekr.20131109090612.29147">
#ifdef FEAT_CMDL_INFO
/*
 * Flush the showcmd characters onto the screen so we can see them while
 * the command is being executed.  Only do this when the shown command was
 * actually displayed, otherwise this will slow down a lot when executing
 * mappings.
 */
if (need_flushbuf)
    out_flush();
#endif
</t>
<t tx="ekr.20131109090612.29148">/*
 * Get an additional character if we need one.
 */
if ((nv_cmds[idx].cmd_flags &amp; NV_NCH)
    &amp;&amp; (((nv_cmds[idx].cmd_flags &amp; NV_NCH_NOP) == NV_NCH_NOP
	    &amp;&amp; oap-&gt;op_type == OP_NOP)
	|| (nv_cmds[idx].cmd_flags &amp; NV_NCH_ALW) == NV_NCH_ALW
	|| (ca.cmdchar == 'q'
	    &amp;&amp; oap-&gt;op_type == OP_NOP
	    &amp;&amp; !Recording
	    &amp;&amp; !Exec_reg)
	|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
	    &amp;&amp; (oap-&gt;op_type != OP_NOP
#ifdef FEAT_VISUAL
		|| VIsual_active
#endif
    )))
) {
    int	*cp;
    int	repl = FALSE;	/* get character for replace mode */
    int	lit = FALSE;	/* get extra character literally */
    int	langmap_active = FALSE;    /* using :lmap mappings */
    int	lang;		/* getting a text character */

    #ifdef USE_IM_CONTROL
    int	save_smd;	/* saved value of p_smd */
    #endif
    
    ++no_mapping;
    ++allow_keys;		/* no mapping for nchar, but allow key codes */

    #ifdef FEAT_AUTOCMD
    /* Don't generate a CursorHold event here, most commands can't handle
     * it, e.g., nv_replace(), nv_csearch(). */
    did_cursorhold = TRUE;
    #endif

    if (ca.cmdchar == 'g')
    {
        /*
         * For 'g' get the next character now, so that we can check for
         * "gr", "g'" and "g`".
         */
        ca.nchar = plain_vgetc();
        LANGMAP_ADJUST(ca.nchar, TRUE);
        
        #ifdef FEAT_CMDL_INFO
        need_flushbuf |= add_to_showcmd(ca.nchar);
        #endif
    
        if (ca.nchar == 'r' || ca.nchar == '\'' ||
            ca.nchar == '`' || ca.nchar == Ctrl_BSL
        ) {
            cp = &amp;ca.extra_char;	/* need to get a third character */
            if (ca.nchar != 'r')
                lit = TRUE;	/* get it literally */
            else
                repl = TRUE;	/* get it in replace mode */
        }
        else
            cp = NULL;	/* no third character needed */
    }
    else
    {
        if (ca.cmdchar == 'r')	/* get it in replace mode */
        repl = TRUE;
        cp = &amp;ca.nchar;
    }
    lang = (repl || (nv_cmds[idx].cmd_flags &amp; NV_LANG));

    if (cp != NULL)
    {
        &lt;&lt; get second or third character &gt;&gt;
    }
    --no_mapping;
    --allow_keys;
}
</t>
<t tx="ekr.20131109090612.29149">#ifdef FEAT_RIGHTLEFT
if (curwin-&gt;w_p_rl &amp;&amp; KeyTyped &amp;&amp; !KeyStuffed
				  &amp;&amp; (nv_cmds[idx].cmd_flags &amp; NV_RL))
{
    /* Invert horizontal movements and operations.  Only when typed by the
     * user directly, not when the result of a mapping or "x" translated
     * to "dl". */
    switch (ca.cmdchar)
    {
        case 'l':	    ca.cmdchar = 'h'; break;
        case K_RIGHT:   ca.cmdchar = K_LEFT; break;
        case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;
        case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;
        case 'h':	    ca.cmdchar = 'l'; break;
        case K_LEFT:    ca.cmdchar = K_RIGHT; break;
        case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;
        case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;
        case '&gt;':	    ca.cmdchar = '&lt;'; break;
        case '&lt;':	    ca.cmdchar = '&gt;'; break;
    }
    idx = find_command(ca.cmdchar);
}
#endif
</t>
<t tx="ekr.20131109090612.29150">#ifdef FEAT_VISUAL
/*
 * In Visual/Select mode, a few keys are handled in a special way.
 */
if (VIsual_active)
{
    /* when 'keymodel' contains "stopsel" may stop Select/Visual mode */
    if (km_stopsel
        &amp;&amp; (nv_cmds[idx].cmd_flags &amp; NV_STS)
        &amp;&amp; !(mod_mask &amp; MOD_MASK_SHIFT)
    ) {
        end_visual_mode();
        redraw_curbuf_later(INVERTED);
    }
    
    /* Keys that work different when 'keymodel' contains "startsel" */
    if (km_startsel)
    {
        if (nv_cmds[idx].cmd_flags &amp; NV_SS)
        {
            unshift_special(&amp;ca);
            idx = find_command(ca.cmdchar);
            if (idx &lt; 0)
            {
                /* Just in case */
                clearopbeep(oap);
                goto normal_end;
            }
        }
        else if ((nv_cmds[idx].cmd_flags &amp; NV_SSS)
            &amp;&amp; (mod_mask &amp; MOD_MASK_SHIFT)
        ) {
            mod_mask &amp;= ~MOD_MASK_SHIFT;
        }
    }
}
#endif
</t>
<t tx="ekr.20131109090612.29151">/*
 * Get the command character from the user.
 */
c = safe_vgetc();
LANGMAP_ADJUST(c, TRUE);
#ifdef FEAT_VISUAL
/*
 * If a mapping was started in Visual or Select mode, remember the length
 * of the mapping.  This is used below to not return to Insert mode for as
 * long as the mapping is being executed.
 */
if (restart_edit == 0)
old_mapped_len = 0;
else if (old_mapped_len
    || (VIsual_active &amp;&amp; mapped_len == 0 &amp;&amp; typebuf_maplen() &gt; 0))
old_mapped_len = typebuf_maplen();
#endif
if (c == NUL)
    c = K_ZERO;
#ifdef FEAT_VISUAL
/*
 * In Select mode, typed text replaces the selection.
 */
if (VIsual_active
    &amp;&amp; VIsual_select
    &amp;&amp; (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER)
)
{
    /* Fake a "c"hange command.  When "restart_edit" is set (e.g., because
     * 'insertmode' is set) fake a "d"elete command, Insert mode will
     * restart automatically.
     * Insert the typed character in the typeahead buffer, so that it can
     * be mapped in Insert mode.  Required for ":lmap" to work. */
    ins_char_typebuf(c);
    if (restart_edit != 0)
        c = 'd';
    else
        c = 'c';
    msg_nowait = TRUE;	/* don't delay going to insert mode */
}
#endif

#ifdef FEAT_CMDL_INFO
need_flushbuf = add_to_showcmd(c);
#endif

getcount:

#ifdef FEAT_VISUAL
if (!(VIsual_active &amp;&amp; VIsual_select))
#endif
{
    /*
     * Handle a count before a command and compute ca.count0.
     * Note that '0' is a command and not the start of a count, but it's
     * part of a count after other digits.
     */
    while (    (c &gt;= '1' &amp;&amp; c &lt;= '9')
        || (ca.count0 != 0 &amp;&amp; (c == K_DEL || c == K_KDEL || c == '0'))
    ) {
        if (c == K_DEL || c == K_KDEL)
        {
            ca.count0 /= 10;
            #ifdef FEAT_CMDL_INFO
                    del_from_showcmd(4);	/* delete the digit and ~@% */
            #endif
        }
        else
            ca.count0 = ca.count0 * 10 + (c - '0');
        if (ca.count0 &lt; 0)	    /* got too large! */
            ca.count0 = 999999999L;
        #ifdef FEAT_EVAL
        /* Set v:count here, when called from main() and not a stuffed
         * command, so that v:count can be used in an expression mapping
         * right after the count. */
        if (toplevel &amp;&amp; stuff_empty())
        {
            long count = ca.count0;
        
            /* multiply with ca.opcount the same way as below */
            if (ca.opcount != 0)
                count = ca.opcount * (count == 0 ? 1 : count);
            set_vcount(count, count == 0 ? 1 : count, set_prevcount);
            set_prevcount = FALSE;  /* only set v:prevcount once */
        }
        #endif
        if (ctrl_w)
        {
            ++no_mapping;
            ++allow_keys;		/* no mapping for nchar, but keys */
        }
        ++no_zero_mapping;		/* don't map zero here */
        c = plain_vgetc();
        LANGMAP_ADJUST(c, TRUE);
        --no_zero_mapping;
        if (ctrl_w)
        {
            --no_mapping;
            --allow_keys;
        }
        #ifdef FEAT_CMDL_INFO
        need_flushbuf |= add_to_showcmd(c);
        #endif
    }
    
    /*
     * If we got CTRL-W there may be a/another count
     */
    if (c == Ctrl_W &amp;&amp; !ctrl_w &amp;&amp; oap-&gt;op_type == OP_NOP)
    {
        ctrl_w = TRUE;
        ca.opcount = ca.count0;	/* remember first count */
        ca.count0 = 0;
        ++no_mapping;
        ++allow_keys;		/* no mapping for nchar, but keys */
        c = plain_vgetc();		/* get next character */
        LANGMAP_ADJUST(c, TRUE);
        --no_mapping;
        --allow_keys;
        #ifdef FEAT_CMDL_INFO
            need_flushbuf |= add_to_showcmd(c);
        #endif
        goto getcount;		/* jump back */
    }
}

#ifdef FEAT_AUTOCMD
if (c == K_CURSORHOLD)
{
    /* Save the count values so that ca.opcount and ca.count0 are exactly
     * the same when coming back here after handling K_CURSORHOLD. */
    oap-&gt;prev_opcount = ca.opcount;
    oap-&gt;prev_count0 = ca.count0;
}
else
#endif
if (ca.opcount != 0)
{
    /*
     * If we're in the middle of an operator (including after entering a
     * yank buffer with '"') AND we had a count before the operator, then
     * that count overrides the current value of ca.count0.
     * What this means effectively, is that commands like "3dw" get turned
     * into "d3w" which makes things fall into place pretty neatly.
     * If you give a count before AND after the operator, they are
     * multiplied.
     */
    if (ca.count0)
        ca.count0 *= ca.opcount;
    else
        ca.count0 = ca.opcount;
}
/*
 * Always remember the count.  It will be set to zero (on the next call,
 * above) when there is no pending operator.
 * When called from main(), save the count for use by the "count" built-in
 * variable.
 */
ca.opcount = ca.count0;
ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);

#ifdef FEAT_EVAL
/*
 * Only set v:count when called from main() and not a stuffed command.
 */
if (toplevel &amp;&amp; stuff_empty())
    set_vcount(ca.count0, ca.count1, set_prevcount);
#endif

/*
 * Find the command character in the table of commands.
 * For CTRL-W we already got nchar when looking for a count.
 */
if (ctrl_w)
{
    ca.nchar = c;
    ca.cmdchar = Ctrl_W;
}
else
    ca.cmdchar = c;
idx = find_command(ca.cmdchar);
if (idx &lt; 0)
{
    /* Not a known command: beep. */
    clearopbeep(oap);
    goto normal_end;
}
if (text_locked() &amp;&amp; (nv_cmds[idx].cmd_flags &amp; NV_NCW))
{
    /* This command is not allowed while editing a ccmdline: beep. */
    clearopbeep(oap);
    text_locked_msg();
    goto normal_end;
}

#ifdef FEAT_AUTOCMD
if ((nv_cmds[idx].cmd_flags &amp; NV_NCW) &amp;&amp; curbuf_locked())
    goto normal_end;
#endif
</t>
<t tx="ekr.20131109090612.29152">#ifdef FEAT_AUTOCMD
    /* Restore counts from before receiving K_CURSORHOLD.  This means after
     * typing "3", handling K_CURSORHOLD and then typing "2" we get "32", not
     * "3 * 2". */
    if (oap-&gt;prev_opcount &gt; 0 || oap-&gt;prev_count0 &gt; 0)
    {
        ca.opcount = oap-&gt;prev_opcount;
        ca.count0 = oap-&gt;prev_count0;
        oap-&gt;prev_opcount = 0;
        oap-&gt;prev_count0 = 0;
    }
#endif
#ifdef FEAT_VISUAL
    mapped_len = typebuf_maplen();
#endif
State = NORMAL_BUSY;
#ifdef USE_ON_FLY_SCROLL
    dont_scroll = FALSE;	/* allow scrolling here */
#endif
</t>
<t tx="ekr.20131109090612.29153">/* When not finishing an operator and no register name typed, reset the count. */
if (!finish_op &amp;&amp; !oap-&gt;regname)
{
    ca.opcount = 0;
    #ifdef FEAT_EVAL
        set_prevcount = TRUE;
    #endif
}
</t>
<t tx="ekr.20131109090612.29154">/*
 * If there is an operator pending, then the command we take this time
 * will terminate it. Finish_op tells us to finish the operation before
 * returning this time (unless the operation was cancelled).
 */
#ifdef CURSOR_SHAPE
    c = finish_op;
#endif
finish_op = (oap-&gt;op_type != OP_NOP);
#ifdef CURSOR_SHAPE
    if (finish_op != c)
    {
        ui_cursor_shape(); /* may show different cursor shape */
        # ifdef FEAT_MOUSESHAPE
            update_mouseshape(-1);
        # endif
    }
#endif
</t>
<t tx="ekr.20131109090612.29155">/* Use a count remembered from before entering an operator.  After typing
 * "3d" we return from normal_cmd() and come back here, the "3" is
 * remembered in "opcount". */
ca.opcount = opcount;
</t>
<t tx="ekr.20131109090612.29156">cmdarg_T	ca;			/* command arguments */
int		c;
int		ctrl_w = FALSE;		/* got CTRL-W command */
int		old_col = curwin-&gt;w_curswant;
#ifdef FEAT_CMDL_INFO
    int		need_flushbuf;		/* need to call out_flush() */
#endif
#ifdef FEAT_VISUAL
    pos_T	old_pos;		/* cursor position before command */
    int		mapped_len;
    static int	old_mapped_len = 0;
#endif
int		idx;
#ifdef FEAT_EVAL
    int		set_prevcount = FALSE;
#endif
vim_memset(&amp;ca, 0, sizeof(ca));	/* also resets ca.retval */
ca.oap = oap;
&lt;&lt; use remembered count before entering an operator &gt;&gt;
#ifdef FEAT_SNIFF
    want_sniff_request = sniff_connected;
#endif
</t>
<t tx="ekr.20131109090612.29157">if (ca.nchar == ESC)
{
    clearop(oap);
    if (restart_edit == 0 &amp;&amp; goto_im())
        restart_edit = 'a';
    goto normal_end;
}
</t>
<t tx="ekr.20131109090612.29158">/*
 * Get a second or third character.
 */
#ifdef CURSOR_SHAPE
if (repl)
{
    State = REPLACE;	/* pretend Replace mode */
    ui_cursor_shape();	/* show different cursor shape */
}
#endif

if (lang &amp;&amp; curbuf-&gt;b_p_iminsert == B_IMODE_LMAP)
{
    /* Allow mappings defined with ":lmap". */
    --no_mapping;
    --allow_keys;
    if (repl)
        State = LREPLACE;
    else
        State = LANGMAP;
    langmap_active = TRUE;
}

#ifdef USE_IM_CONTROL
save_smd = p_smd;
p_smd = FALSE;	/* Don't let the IM code show the mode here */
if (lang &amp;&amp; curbuf-&gt;b_p_iminsert == B_IMODE_IM)
    im_set_active(TRUE);
#endif

*cp = plain_vgetc();
if (langmap_active)
{
    /* Undo the decrement done above */
    ++no_mapping;
    ++allow_keys;
    State = NORMAL_BUSY;
}

#ifdef USE_IM_CONTROL
if (lang)
{
    if (curbuf-&gt;b_p_iminsert != B_IMODE_LMAP)
        im_save_status(&amp;curbuf-&gt;b_p_iminsert);
    im_set_active(FALSE);
}
p_smd = save_smd;
#endif

#ifdef CURSOR_SHAPE
State = NORMAL_BUSY;
#endif

#ifdef FEAT_CMDL_INFO
need_flushbuf |= add_to_showcmd(*cp);
#endif

if (!lit)
{
    #ifdef FEAT_DIGRAPHS
    /* Typing CTRL-K gets a digraph. */
    if (*cp == Ctrl_K
        &amp;&amp; ((nv_cmds[idx].cmd_flags &amp; NV_LANG)
            || cp == &amp;ca.extra_char)
        &amp;&amp; vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)
    {
        c = get_digraph(FALSE);
        if (c &gt; 0)
        {
            *cp = c;
            # ifdef FEAT_CMDL_INFO
            /* Guessing how to update showcmd here... */
            del_from_showcmd(3);
            need_flushbuf |= add_to_showcmd(*cp);
            # endif
        }
    }
    #endif

    /* adjust chars &gt; 127, except after "tTfFr" commands */
    LANGMAP_ADJUST(*cp, !lang);

    #ifdef FEAT_RIGHTLEFT
    /* adjust Hebrew mapped char */
    if (p_hkmap &amp;&amp; lang &amp;&amp; KeyTyped)
        *cp = hkmap(*cp);
        # ifdef FEAT_FKMAP
        /* adjust Farsi mapped char */
        if (p_fkmap &amp;&amp; lang &amp;&amp; KeyTyped)
            *cp = fkmap(*cp);
        # endif
    #endif
}
/*
 * When the next character is CTRL-\ a following CTRL-N means the
 * command is aborted and we go to Normal mode.
 */
if (cp == &amp;ca.extra_char
    &amp;&amp; ca.nchar == Ctrl_BSL
    &amp;&amp; (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))
{
    ca.cmdchar = Ctrl_BSL;
    ca.nchar = ca.extra_char;
    idx = find_command(ca.cmdchar);
}
else if (*cp == Ctrl_BSL)
{
    long towait = (p_ttm &gt;= 0 ? p_ttm : p_tm);
    /* There is a busy wait here when typing "f&lt;C-\&gt;" and then
     * something different from CTRL-N.  Can't be avoided. */
    while ((c = vpeekc()) &lt;= 0 &amp;&amp; towait &gt; 0L)
    {
        do_sleep(towait &gt; 50L ? 50L : towait);
        towait -= 50L;
    }
    if (c &gt; 0)
    {
        c = plain_vgetc();
        if (c != Ctrl_N &amp;&amp; c != Ctrl_G)
        vungetc(c);
        else
        {
            ca.cmdchar = Ctrl_BSL;
            ca.nchar = c;
            idx = find_command(ca.cmdchar);
        }
    }
}

#ifdef FEAT_MBYTE
/* When getting a text character and the next character is a
* multi-byte character, it could be a composing character.
* However, don't wait for it to arrive. */
while (enc_utf8 &amp;&amp; lang &amp;&amp; (c = vpeekc()) &gt; 0
     &amp;&amp; (c &gt;= 0x100 || MB_BYTE2LEN(vpeekc()) &gt; 1))
{
    c = plain_vgetc();
    if (!utf_iscomposing(c))
    {
        vungetc(c);		/* it wasn't, put it back */
        break;
    }
    else if (ca.ncharC1 == 0)
        ca.ncharC1 = c;
    else
        ca.ncharC2 = c;
}
#endif
</t>
<t tx="ekr.20131109090612.29159">if (ca.cmdchar != K_IGNORE)
{
    msg_didout = FALSE;    /* don't scroll screen up for normal command */
    msg_col = 0;
}
</t>
<t tx="ekr.20131111105746.16556">class VimTestCase(unittest.TestCase):

    """Data-driven unit tests for vim commands commands."""

    @others
</t>
<t tx="ekr.20131111105746.16557">def __init__ (self,c,parent,before,after,sel,ins,tempNode):

    
    unittest.TestCase.__init__(self)
        # Init the base class.
    self.c = c
    self.failFlag = False
    self.parent = parent.copy()
    self.before = before.copy()
    self.after  = after.copy()
    self.sel    = sel.copy() # Two lines giving the selection range in tk coordinates.
    self.ins    = ins.copy() # One line giving the insert point in tk coordinate.
    self.tempNode = tempNode.copy()
    self.vc = VimCommands(c)
</t>
<t tx="ekr.20131111105746.16558">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g
    g.app.unitTestDict["fail"] = g.callers()
    self.failFlag = True
</t>
<t tx="ekr.20131111105746.16559">def editBody (self):

    c,vc = self.c, self.vc
    # Get the command.
    command = self.parent.h
    i = command.find(' ')
    if i &gt; -1: command = command[:i]
    # Compute the result in tempNode.b
    status,n1,command,n2,motion = vc.scan(command)
    assert status == 'done',repr(status)
    vc.exec_(command,n1,n2,motion)
    return commandName
</t>
<t tx="ekr.20131111105746.16560">def runTest(self):

    commandName = self.editBody()
    self.compare(commandName)
</t>
<t tx="ekr.20131111105746.16561">def setUp(self):

    c = self.c
    tempNode = self.tempNode
    c.undoer.clearUndoState()
    self.deleteChildren(tempNode)
    text = self.before.b
    # tempNode.setBodyString(text)
    tempNode.b = text
    c.selectPosition(self.tempNode)
    w = c.frame.body.bodyCtrl
    if self.sel:
        # self.sel is a **tk** index.
        s = str(self.sel.b) # Can't be unicode.
        lines = s.split('\n')
        w.setSelectionRange(lines[0],lines[1])
    if self.ins:
        s = str(self.ins.b) # Can't be unicode.
        lines = s.split('\n')
        g.trace(lines)
        w.setInsertPoint(lines[0])
    if not self.sel and not self.ins:
        w.setInsertPoint(0)
        w.setSelectionRange(0,0)
</t>
<t tx="ekr.20131111105746.16562">def shortDescription (self):

    try:
        return "VimTestCase: %s" % (self.parent.h)
    except Exception:
        g.es_print_exception()
        return "VimTestCase"
</t>
<t tx="ekr.20131111105746.16563">def tearDown (self):

    c = self.c
    tempNode = self.tempNode
    c.selectPosition(tempNode)
    if not self.failFlag:
        tempNode.setBodyString("")
        self.deleteChildren(tempNode)
    tempNode.clearDirty()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20131111140646.16533">def compare(self,commandName):
    
    
    def comp(before,after,compareHeadlines=False,report=False):
        return tm.compareOutlines(before,after,
            compareHeadlines=compareHeadlines,
            report=report)

    # Don't call the undoer if we expect no change.
    if comp(self.before,self.after):
        return
    try:
        s = commandName
        after,before,temp = self.after,self.before,self.tempNode
        assert comp(temp,after),'%s: before undo1' % s
        if 0: # Not ready yet?
            c.undoer.undo()
            assert comp(temp,before),'%s: after undo1' % s
            c.undoer.redo()
            assert comp(temp,after),'%s: after redo' % s
            c.undoer.undo()
            assert comp(temp,before),'%s: after undo2' % s
    except Exception:
        self.fail()
        raise
</t>
<t tx="ekr.20131111140646.16534">def deleteChildren(self,p):
    
    # Delete all children of p.
    while p.hadChildren():
        p.firstChild().doDelete()
</t>
<t tx="ekr.20131115075142.16636">@language rest

Use .leo files to test settings rather than to contain data. These files
would typically contain just an @settings tree, and one or two nodes
illustrating their effect. Opening such files limits the effects of
experimental/non-standard/risky settings. This is a great tip to know.

For example, the files leo10pt.leo, leo12pt.leo, leo14-12pt.leo and
leo14pt.leo in the leo/config folder make it easy to compare different font
settings.

As another example, when starting the vim-mode project I created a .leo
file containing @bool vim-mode = True. By opening this file I test vim mode
without interfering with my normal work flow.

</t>
<t tx="ekr.20131116123026.16661"># For the Find screencast.  It could be improved so the differences between nodes is more apparent.
</t>
<t tx="ekr.20131116123026.16662">DEF spam():
    pass
</t>
<t tx="ekr.20131116123026.16663">def eggs():
    pass
</t>
<t tx="ekr.20131116212505.16666">@language rest

c, g, p: commanders, generators, p.b, p.h etc.

@button (already covered)
@test (already covered)
    
@language python
</t>
<t tx="ekr.20131116212505.16667"># g is a Python module containing global utility functions and classes.
# g.es prints its arguments to Leo's log pane.
g.es(g.es)
# g is a large module:
g.es(len(list(dir(g))))
</t>
<t tx="ekr.20131116212505.16668"># Ctrl-B executes the Python code in the presently-selected body pane.
g.es('hello world')

</t>
<t tx="ekr.20131116212505.16669">print('hi')
print('there')
</t>
<t tx="ekr.20131117054619.16683">@language rest

New check boxes:
    - Find-All starts at selected node.
    - Ignore duplicates.

* (Done??) Reset wrap &amp; onlyPosition when the find pattern changes:
    The find command must reset several state variables whenever
    a) The find pattern changes or
    b) a limited (node-only, suboutline-only) search completes or
    c) a wrapped search completes.
    d) Whenever any radio button (find scope) changes.

- Create unit tests.
    - Check all bug reports.
    - Test outline-only, node-only, wrap.
    - Test isearch (forward &amp; backward)
* Revise theory of operation.
- Add @bool find_all_from_present_position = True
* Ctrl-F puts selected text into the search box.
- Make sure to capture search string, even if do ctrl-g, etc.
** Smart search: clear ignore case if the search text has at least one uppercase letter.
- find-all and change-all never wrap.=

Maybe:
- Put "not found" message somewhere else.
- Don't put unknown ctrl keys in minibuffer (suppress ctrl-shift-r)

@language python
</t>
<t tx="ekr.20131118113639.17705">@language rest

Important classes &amp; methods:
- spellTabHandler (in leoEditcommands.py) is no longer a subclass of leoFind class.
- dw.createFindTab &amp; helpers
- class FindTabManager
- class EventWrapper

What I did:
- Added support for Alt-Ctrl keys.
- start-find selects all text in findbox.
- Removed eventFilter ivar
- All defaults work in the Find pane, except the Alt-Ctrl bindings.
  The user can just use the standard Alt-bindings to set checkboxes and radio buttons.
- Add shortcuts to button names.
- Honor Ctrl-G, F2, F3, Ctrl-- &amp; Ctrl-+ from any widget in the find pane.
- Create help button in the Find pane.
- dw code now sets ftm ivars, not dw ivars.
- Added tab easter egg to searchWithPresentOptions.
- Removed all clones and dead code from leoSettings.leo.
  (Improved introductory comments.)
- Createf leo/config/exampleSettings.leo.
- fc.minibuffer_mode replaces fc.expert_mode.
- start-find command
- test set-replace-string.
- Protect self.p everywhere.
- Don't hide find pane during searches.
- Init widgets from c.config.
- Clicking widgets should set leoFind ivars.
- Toggle commands should toggle widgets.
- Move search classes from leoEditCommands.py to leoFind.py

Changed methods:
- c.initObjects now creates leoFind object.
- c.finishCreate does: self.findCommands = leoFind.leoFind(c)
- Added the FindTabManager (ftm)
- dw.createFindTab adds find buttons and calls.
- dw.createFindTab creates the FindTabManager and calls ftm.init_widgets.
* Added find_generation ivar to vnode class.
</t>
<t tx="ekr.20131120115900.16329">################
Videos about Leo
################

.. |br| raw:: html

   &lt;br /&gt;

This page links to videos about Leo.  **Important notes**:

- Videos hosted at screencast.com look a bit clearer than YouTube videos, |br|
  but they may not always be available due to bandwidth limits.
- screencast.com viewers: click the "Full Size" button. |br|
- YouTube viewers: select top quality in the video settings. |br|
  YouTube videos typically become clearer after a few seconds.
  
**Potential screencasters**: please read these
`tips for screencast authors &lt;http://leoeditor.com/FAQ.html#how-to-make-a-screencast&gt;`_.

.. list-table::
   :widths: 10 30 10 10
   :header-rows: 1

   * - Level
     - Title
     - Screencast
     - YouTube
   * - Intro
     - A Brief Introduction to Leo
     - `hi-res &lt;http://www.screencast.com/t/xDZAOqfsAhPZ&gt;`__
     - `regular &lt;http://www.youtube.com/watch?v=tuM8MvI9g6k&gt;`__
   * - Intro
     - Leo for Programmers
     - `hi-res &lt;http://www.screencast.com/t/lgR6lMhWK&gt;`__
     - `regular &lt;http://www.youtube.com/watch?v=WkUbJAuFfI4&gt;`__
   * - Intro
     - Ville Vianio introduces Leo
     -
     - `regular &lt;http://www.youtube.com/watch?v=Zu6J-J0qFi0&gt;`__
   * - Basic
     - Using Leo’s Find pane
     - `hi-res &lt;http://www.screencast.com/t/O7915mYD3&gt;`__
     - `regular &lt;https://www.youtube.com/watch?v=K5mmlnSOkLM&gt;`__
   * - Basic
     - Using Leo’s minibuffer
     - `hi-res &lt;http://www.screencast.com/t/tEQ7brI4n6&gt;`__
     - `regular &lt;https://www.youtube.com/watch?v=dEaGOi6hVpo&gt;`__
   * - Intermediate
     - Using abbreviations
     -
     - `regular &lt;http://www.youtube.com/watch?v=WRoiXO53Aac&gt;`__
   * - Intermediate
     - Using clones to speed your work flow
     - `hi-res &lt;http://www.screencast.com/t/l8W9H5G8zB&gt;`__
     - `regular &lt;https://www.youtube.com/watch?v=DsHEHNLKi2o&gt;`__
   * - Plugin
     - Terry Brown demos bookmarks.py
     -
     - `regular &lt;https://vimeo.com/77720098&gt;`__
   * - Plugin
     - Fidel Perez demos mod_http.py
     -
     - `regular &lt;http://www.youtube.com/watch?v=9AvbL_0JEMw&amp;feature=youtu.be&gt;`__
   * - Plugin
     - mod_ftp.py
     -
     - `regular &lt;http://www.youtube.com/watch?v=bnj0NQuljQo&gt;`__
</t>
<t tx="ekr.20131121050226.16327">- Don't reload any files!
- Only reprocess leoSettings.leo or myLeoSettings.leo if they are actually open.
- Change LoadManager to handle a reload flag.
</t>
<t tx="ekr.20131121050226.16328">open leoSettings.leo.
open myLeoSettings.leo.

Concentrate on:
    - visual settings.
    - keyboard shortcuts.

print-settings, print-bindings, print-commands.

Trick: use small, easily/quickly started, file to test settings.
    Demo: put console *behind* window.
</t>
<t tx="ekr.20131121090013.17108">Very important.

ActivePath is an alternative.  Has rclick interface.
</t>
<t tx="ekr.20131121211048.16378">Different font sizes, coloring schemes, plugins, etc.
</t>
<t tx="ekr.20131122055946.16388">The following radio buttons appear in the Find pane:

Entire Outline
    When selected, Find commands search the entire outline.
    Alt+Ctrl+E (set-find-everywhere) sets this radio button.

Node Only
    When selected, Find commands search only the selected node.
    Alt+Ctrl+N (set-find-node-only) sets this radio button
    
Suboutline Only
    When selected, the Find and Change commands search only the currently
    selected headline and its offspring.
    Alt+Ctrl+S (set-find-suboutline-only) sets this radio button.
</t>
<t tx="ekr.20131122055946.16401">Making screencasts is a lot easier than you probably think.

Here are some tips to get you started quickly.







</t>
<t tx="ekr.20131122055946.16402">The primary purpose of this script is to open your app at a fixed,
unchanging size. This is surprisingly important:

- It ensures that the window will always render to pixels in the same way.
- It makes it easier to splice in new video to an existing video.
- It makes it easier to plan your video to ensure everything will appear as you expect.
- It provides continuity when making a series of videos.

Here is a script that I use when making Leo's screencasts::

    python27 launchLeo.py --no-cache --gui=qttabs
    --window-size=682x1264 &lt;list of .leo files&gt; %*​
    
This *particular* --window-size causes Camtasia to create a window whose
actual size is 720x1280, the nominal 720p resolution. It may prevent text
blur. Or not. I do know that Leo's screencasts look great at 720p.</t>
<t tx="ekr.20131122055946.16403">Make sure that you can actually upload *excellent quality* videos before
doing anything else. This step is crucial. If you skip this step, all of
your initial recording an post-production work could be utterly wasted.

Use *short* (10-second) test videos at this step. Their primary purpose
verify that you can can get to the *end* of the production process
successfully. You *are* going to make lots of mistakes here: using short
videos helps you make these mistakes quickly.

Don't even *think* about making longer videos until the answers to all the
following questions are clearly "yes":

- Is your camera working?
- Is your microphone working?
- Do you know how to record your voice and screen?
- Can you log into YouTube or screencast.com?
- Can you upload to YouTube or screencast.com?
- Is the sound in your *uploaded* video great?
- Do the pixels in your *uploaded* look great?

This last item is particularly important. Just because pixels look good in
your video editor is no guarantee that they will look good when uploaded.

You are ready to try your first "real" take *only* when you can upload a
video that looks and sounds great.
</t>
<t tx="ekr.20131122055946.16404">Before rushing right out and making your first video, I recommend
watching the tutorial screencasts at screencast.com:
http://www.techsmith.com/tutorial-camtasia-8.html

Watch the tutorials to see how the presentations themselves are
organized. Watch them until it feels natural to emulate their style.

If you will be using Camtasia, you will also want to watch the tutorials
to learn how Camtasia works.  But this is a secondary consideration.
</t>
<t tx="ekr.20131122055946.16405">Now it's time to go beyond test videos. Even now, though, I recommend
keeping your first efforts short: one minute or so. Again, this saves time.
You'll ending up throwing away two or three anyway ;-)

Bring up your app using you demo script and run through your presentation.

Here's the **most important tip**: As you narrate your video, audio flubs
are inevitable, but they don't matter at all *provided* that you *realize*
that you have just flubbed a word or phrase. 

When you flub a line, don't panic! Just *pause*, regroup, and repeat the
phrase until you get it right. *Pausing is essential*: it simplifies
inserting and deleting sound bites during post production.

You'll relax once you realize that flubs don't matter and that pausing
makes post-production easier. Once you relax, getting a good take will
suddenly become easier.

Correcting flubs *as soon as they happen* is absolutely essential. Don't
even *think* about fixing audio flubs in post-production. It simply can't
be done. Instead of spending 20 minutes trying (and failing) to correct a
flub in post production, it is much faster and better to take 20 seconds
during your take to correct the flub.

Similar remarks apply to video, but in my experience it's much easier to
get the video right. If you do flub the video, it will be much easier if
you just do a complete retake. With Camtasia, you can separate the audio
and video tracks, but usually that won't work, especially if there is audio
of key clicks.

By retaking audio flubs as they happen, I find it easy to work without a
script. It feels more natural to me than reading a script. YMMV. When
I get stuck, I just pause. Or just start over. Otoh, it wouldn't be that
hard to read a script. Just *pause* before and after each phrase. Never
rush your audio!

In short, the key Aha is: insert (audio) pauses *everywhere* as needed.
It's easy to edit them out. It's virtually impossible to edit in the middle
of words, even with the world's best audio editor.
</t>
<t tx="ekr.20131122055946.16406">Post production should be easy provided that you have corrected all audio
flubs as they happen. This keeps the audio and video in synch. Just edit
out flubs and reduce overly-long pauses.

I won't discuss production details here because they depend on the editor
you are using.

Do a new take if you don't have clean audio. Depending on the complexity of
your video, it may be possible to splice a partial take in the middle or
end of your video. Similarly, it may be possible to splice in a new take to
add material you didn't cover in your first take.

One final word of advice. When editing your video, settle for "good
enough". Perfectionism is not your friend.
</t>
<t tx="ekr.20131122055946.16407">Making a screencast is a lot easier than you think :-)

- Create a script that will open your app at a fixed, optimal, size.

- Emulate the style and form of screencast.com tutorials.

- Verify the *entire* production process with short test videos.

  Before making longer videos, make *sure* that the test videos look and
  sound great *when they have been uploaded*.
  
- When doing a take, flubs don't matter, *provided* you correct them
  *during the take*.  Use pauses.  Make haste slowly!

- Splice in new takes during post-production to fix flubs and add new
  material.

</t>
<t tx="ekr.20131122162143.16455">g.cls()
# Determine whether the focus widget supports the high-level interface.
import leo.plugins.qtGui as qtGui
import leo.core.leoFrame as leoFrame
import PyQt4.QtGui as QtGui
if 0:
    c.logWantsFocusNow()
elif 1: # Edit a headline
    c.editHeadline(p)
    # c.redraw()
body_w = c.frame.body.bodyCtrl.widget
w = QtGui.QApplication.focusWidget()
print('Focus','isBodyCtrl',w == body_w,w)
tree = c.frame.tree
while w:
    # isText = g.app.gui.isTextWidget(w)
    if isinstance(w,QtGui.QLineEdit):
        wrapper = tree.getWrapper(w,item=None)
        if isinstance(wrapper,qtGui.leoQtBaseTextWidget):
            print('QLineEdit has wrapper',w,wrapper)
        else:
            print('QLineEdit: NO wrapper',w)
            # wrapper = tree.headlineWrapper(c,item=None,name='find-head-wrapper',widget=w)
            # print('QLineEdit NEW wrapper',w,wrapper)
        break
    elif isinstance(w,QtGui.QTextEdit):
        wrapper = getattr(w,'leo_wrapper',None)
        if wrapper:
            if isinstance(wrapper,qtGui.leoQtBaseTextWidget):
                print('QTextEdit has text wrapper',w,wrapper)
            elif isinstance(wrapper,qtGui.leoQtLog):
                logCtrl = wrapper.widget # same as wrapper.logCtrl
                print('QtTextEdit has log wrapper',w,logCtrl)
            else:
                print('unknown wrapper',wrapper)
        else:
            wrapper = qtGui.leoQTextEditWidget(w,'find-wrapper',c=c)
            print('QTextEdit NEW wrapper',w,wrapper)
        break
    print('Fail',w)
    wrapper = False
    if hasattr(w,'parent'):
        w = w.parent()
    else:
        print('no parent',w)
        break
if wrapper:
    print('is searchable (has wrapper)',w,wrapper)
    # Make sure wrapper supports the high-level interface.
    print('high level?',isinstance(wrapper,leoFrame.HighLevelInterface))
    table = (
        'insert',
        'getAllText',
        'setAllText',
        'setInsertPoint',
        'setSelectionRange',
    )
    for ivar in table:
        print(bool(getattr(wrapper,ivar,None)),ivar)
</t>
<t tx="ekr.20131123071505.16462">redoGroup oops: expecting bunch.items.  bunch.kind = typing
redoGroup Bunch...
dirtyVnodeList: [&lt;pos 192439856 childIndex: 9 lvl: 0 key: 65845296:9 find.generalSearchHelper (Must init!!)&gt;]
kind: typing
leading: 10
newMiddleLines: [u'        self.setup_command() ### ']
newNewlines: 1
newSel: (276, 276)
newText: None
oldMiddleLines: [u'        self.setup_command()']
oldNewlines: 1
oldSel: (271, 271)
oldText: None
p: &lt;pos 192438800 childIndex: 9 lvl: 0 key: 65845296:9 find.generalSearchHelper (Must init!!)&gt;
redoHelper: &lt;bound method undoer.redoTyping of &lt;leo.core.leoUndo.undoer instance at 0x03FF4198&gt;&gt;
trailing: 9
undoHelper: &lt;bound method undoer.undoTyping of &lt;leo.core.leoUndo.undoer instance at 0x03FF4198&gt;&gt;
undoType: Typing
yview: 0
</t>
<t tx="ekr.20131129061821.16884">Here are some more tips I've learned from experience:

1. Redo audio tests and video tests every time you start a new
   session. It's amazing how hum can creep into recordings.

2. The most important step in post production is to get the pacing so
   it feels right. Beware of editing out pauses. Make sure you give
   your viewers time to see what you are doing, and to see what you
   have done.
   
3. Don't waste time on callouts or captions until the audio and video
   work together at a relaxed pace. It's almost as hard to correct
   pacing mistakes as it is to correct audio flubs.</t>
<t tx="ekr.20131207054442.16335">* unit tests?
- Create save/restore_isearch_vars methods using isearch_save_d.
</t>
<t tx="ekr.20131208103040.16342">- focus on visual settings.
@menu
leo-x-pt.leo files.
- Small test .leo files: useful for settings.
</t>
<t tx="ekr.20131208103040.16343"></t>
<t tx="ekr.20131208103040.16344"></t>
<t tx="ekr.20131208103040.16349">recursive import.  Where is it?
active-path plugin, 
</t>
<t tx="ekr.20131208103040.16350">- Ctrl-G hides the Find pane.

- Show how to use the minibuffer to discover the toggle commands:
    &lt;Alt-X&gt;tog&lt;tab&gt;f&lt;tab&gt;   or
    &lt;Alt-X&gt;set&lt;tab&gt;f&lt;tab&gt;
</t>
<t tx="ekr.20131211054925.16380">Using Leo *is* easy.

The rule (of thumb) that helper methods should be children of the method
that calls them instantly reveals that programs are outlines in disguise.
Once you have a way of seeing that fact *at all times*, one can never go
back to the flat, myopic way of seeing. It's really that simple.

And finally, there is @others. I created it within the first hour of
prototyping Leo in the MORE outliner. It has remained unchanged all these
years because it is, fundamentally, a very simple idea.

</t>
<t tx="ekr.20131211054925.16385">@language rest

This screencast is a *brief* introduction to Leo.

Other video tutorials will cover all of Leo's features in more detail.
</t>
<t tx="ekr.20131211054925.16388">1. Enable volume leveling and noise removal in Camtasia. This tip, all
   by itself, makes a big difference.

2. Use a better microphone, preferably one with about a 1-inch diaphram.
   This is the kind of microphone that Andrew Price uses.
   The Audio-technica AT2020 USB is relatively inexpensive.
  
3. Use "pop filter" with the microphone. This is a cloth or (better) a
   metal screen that is placed in front of the microphone. It smooths
   the sound.
  
4. Adjust the sound level for maximum volume without distortion: With
   the microphone about a foot from your mouth, turn the volume as
   loud as possible, then turn down until no red is visible in the
   meter.
</t>
<t tx="ekr.20131211054925.16389">@file nodes create **external files** from outlines.

External files are files on your file system.

Leo outlines work much like project files in an IDE.
</t>
<t tx="ekr.20131211054925.16390">- Every outline node can contain a Python script.

- Leo scripts have *easy* access to all data
  *in the outline in which the script resides*.
  
Example:

    g.es(p.h)
</t>
<t tx="ekr.20131211054925.16391">Leo looks like an ordinary outlining program.

The headline describes the contents of an outline node.

The body pane shows contents (body text) of the selected node.

You can insert, move, delete, copy and paste nodes.
</t>
<t tx="ekr.20131211054925.16392"></t>
<t tx="ekr.20131211054925.16393">Nodes may appear many times within the same outline.

A change to one clone affects all the other clones of that node.
</t>
<t tx="ekr.20131211054925.16394">1. Leo looks like an ordinary outliner program.

2. Leo really is an IDE.

3. Leo scripts have full, easy access to all outline data.

4. Nodes may be cloned.
</t>
<t tx="ekr.20131212054637.16399">This is node A.
</t>
<t tx="ekr.20131212054637.16400">This is node B.
</t>
<t tx="ekr.20131213072223.16396"></t>
<t tx="ekr.20131213072223.16397">@language rest

Are any more needed?

When ready to release:

- Note to Dave Winer.
- Announce to comp.lang.python &amp; SourceForge.
</t>
<t tx="ekr.20131215083347.16902">Any Leo node may contain a Python script.

Ctrl-B (execute-script) executes the body text of the presently selected node.

execute-script creates the script using @others and section references: |br|
**you can create complex scripts from a node and its descendants.**

As discussed below, execute-script predefines three variables: c, g and p. |br|
Using these variables, scripts may easily do any of the following:

- Gain access to all data contained in any Leo outline.
- Traverse the data in any outline.
- Use utility classes and function in the leo.core.leoGlobals module.
- Execute any code in Leo's own code base.
</t>
<t tx="ekr.20131215083347.16903">Leo creates **external files** (files on your file system) from
**@file nodes** and *all the descendants* of the @file node.
Examples::

    @file spam.py
    @file ../foo.c
    @file ~/bar.py
    
A single Leo outline may contain many @file nodes. As a result, Leo
outlines function much like project files in other IDE's (Integrated
Development Environments).

Within an @file tree, simple text markup (discussed next) tells Leo how
to create the external file from the @file node and its descendants.
   
**Note**: Other kinds of nodes (not discussed here) can also create
external files::

    @nosent x.py
    @shadow y.py
    @auto z.py</t>
<t tx="ekr.20131220065609.16614">Leo 4.11.1 final                                December 20, 2013

Leo 4.11.1 is now available at:
http://sourceforge.net/projects/leo/files/Leo/

This version makes Leo easier to learn.

Leo is a PIM, an IDE and an outliner.
Video tutorials: http://leoeditor.com/screencasts.html
Text tutorials: http://leoeditor.com/tutorial.html

The highlights of Leo 4.11.1:
-----------------------------

- New video tutorials: http://leoeditor.com/screencasts.html
- Added join-leo-irc command: a good way to get help.
- The Find Tab is easier to understand and use.
- Simplified and reorganized global settings in leoSetting.leo.
- Reorganized menus, including a new Settings menu.
- Added @data qt-gui-user-style-sheet
- More untuitive bindings for Return, Insert and Delete keys.
- Per-node expansions of cloned nodes.

Links:
------
Leo:       http://leoeditor.com
Docs:      http://leoeditor.com/leo_toc.html
Tutorials: http://leoeditor.com/tutorial.html
Videos:    http://leoeditor.com/screencasts.html
Forum:     http://groups.google.com/group/leo-editor
Download:  http://sourceforge.net/projects/leo/files/
Bzr:       http://code.launchpad.net/leo-editor/
Quotes:    http://leoeditor.com/testimonials.html
</t>
<t tx="ekr.20131220065609.16615">@language rest

Added support for @bool force_execute_entire_body, default False.
When True, the execute_script command forces whole text to be the text.

The c.forceExecuteEntireBody ivar can be toggled by scripts.
</t>
<t tx="ekr.20131220065609.16616">http://mail.google.com/mail/u/0/#inbox/1423c5445471eeb2

The Command reference was wrong.
</t>
<t tx="ekr.20131220065609.16617">- Restored c.config.getData.
- Added gcm.getOutlineData, c.config.getOutlineData.
- Added parser.doOutlineData and getOutlineDataHelper.
</t>
<t tx="ekr.20131220065609.16618">@language rest

https://groups.google.com/forum/#!topic/leo-editor/OSe0_D5tmJQ

What I did:
    
- Added (complex) code to support scanning after tree substitutions.
- Added support for @data tree-abbreviations.
    - The body contains a list of the abbreviation names.
    - The children should contain nodes matching each abbreviation name.
        The children of *those* nodes are pasted as the last children
        of the present node when the tree abbreviation fires.
- Added ParserBaseClass.doTreeAbbreviationData, called from PBC.doData.
- Added abbrevClass.init_tree_abbrev and helpers.
- Refactored and changed expandAbbrev: added ac.expand_text and ac.expand_tree.
- Added some flags to c.pasteOutline and c.promote,
  These flags disable unwanted actions when expanding tree abbreviations.

@language python
</t>
<t tx="ekr.20131220065609.16619"></t>
<t tx="ekr.20131220065609.16620">Changed add_border and remove_border in qtGui.py
</t>
<t tx="ekr.20131220065609.16621"></t>
<t tx="ekr.20131220065609.16622">Changed ParserBaseClass.parseHeadline so it ignores everything after @data
name.
</t>
<t tx="ekr.20131220065609.16623">The first line is significant.  All others are comments.

The fix was to ParserBaseClass.doItems.
</t>
<t tx="ekr.20131220065609.16624">Disambiguated various debug switches.

The master debug switches are now::
    
    g.app.debug_app
    g.app.debug_widgets

Added leoQtEventFilter.traceWidget.

Added toggle-debug button in my copy of leoPy.leo.
</t>
<t tx="ekr.20131220065609.16625">@language rest

What I did:
    
- Created LeoBaseTabWidget, containing most of the code of LeoTabbedTopLevel.
- LeoTabbedTopLevel derives from this new class.
    
- leoQtLog.__init__ now calls tw.setMovable(True).
  This allows Log pane tabs to be rearranged.
  
- Changed dw.createTabWidget. The changes have as yet no effect:

    def createTabWidget (self,parent,name,hPolicy=None,vPolicy=None):
    
        # w = LeoBaseTabWidget(parent)
        w = QtGui.QTabWidget(parent)
        tb = w.tabBar()
        # tb.setTabsClosable(True)
        self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
        self.setName(w,name)
        return w
</t>
<t tx="ekr.20131220065609.16626">@language rest

When the Find pane is active, Alt-x toggles the regex check box, etc.

There is no obvious way to disable the widget when the pane is deactivated.
It must be possible, but perhaps it is not worth it.

The solution was simply to remove the keyboard hints from the Find pane!

</t>
<t tx="ekr.20131220065609.16628">Eliminated clones from this file: all settings are defined in exactly one
place.
</t>
<t tx="ekr.20131220065609.16629">Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&amp;name=' + escape(d.title) + '&amp;selection=' + escape(window.getSelection()) + '&amp;url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks--&gt;Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox.
</t>
<t tx="ekr.20131220065609.16631">It used to select the minibuffer label, which messed up following logic.
</t>
<t tx="ekr.20131220065609.16633">It now always stays in the tree pane when you hit return to
end editing.

This will be more natural to newbies, and allows plain arrow
keys to traverse the tree more easily.

Also, c.treeEditFocusHelper no longer exists, and the @bool
stayInTreeAfterEditHeadline setting no longer exists.
</t>
<t tx="ekr.20131220065609.16634"></t>
<t tx="ekr.20131220065609.16635"></t>
<t tx="ekr.20131220065609.16636"></t>
<t tx="ekr.20131220065609.16637">- The new nodewatch.py plugin creates a scriptable jump-list of nodes with a UI pane.
  It is an alternative to clones/bookmarks/backlinks/UNLs.
  
- Fixed bug in viewrendered.py: '@string view-rendered-default-kind' is now
  functional. Setting it to 'md' makes vr default to trying markdown
  rendering without the need for the ugly '@md' in the headline. vr is
  still smart enough to default to rst for Leo's various help-for commands,
  as well as anything that uses c.putHelpFor.
  
- The booksmarks.py plugin (rev 6420) now supports cross-file bookmarks.
  
- Improved quickfind.py plugin (rev 6390).
  
- Improved quickmove.py plugin (rev 6446).

- Improved todo.py plugin (rev 6433).

- The scripting.py now creates commands from @rclick nodes, but only if
  @bool scripting-at-rclick-nodes is True.
</t>
<t tx="ekr.20131220065609.16638">Help menu:
- Contains only help-related items.
- Contains more items that link to Leo's web site.

Settings menu (a new menu):
- Open Global Settings opens leoSettings.leo.
- Open Personal Settings opens myLeoSettings.leo.
- Open Local settings selects the @settings node in the local .leo file, if it exists.

Plugins menu:
- Changed plugins_menu.py plugin so it honors items in @menu Plugins.

Cmds menu:
- Improved Settings submenu and added &amp; Help submenu.
- Open Python Shell (was in Windows menu) now part of Cmds:Debug menu.

File menu:
- Now contains items that open various .leo files.
</t>
<t tx="ekr.20131220065609.17422">The entries here override the entries in @data qt-gui-plugin-style-sheet

This is a *major* improvement: you don't have to copy/paste @data
qt-gui-plugin-style-sheet. Just put your particular overrides in
@data qt-gui-user-style-sheet. At long last, you can see just what you
changed.
</t>
<t tx="ekr.20131221065129.16519">@language rest
</t>
<t tx="ekr.20131221065129.16520">- Return inserts a newline.
- Arrow keys move the cursor by characters.
- Ctrl-Arrow keys move the cursor by words.
- Home and End move the cursor to the start/end of a line.
- PageUp and Page-Down move the cursor by pages.
- Ctrl-Home and Ctrl-End move the cursor to the start/end of the body text.

- Adding the Shift modifier to any of these keys extends the selection:

- Shift Arrow keys.
- Shift-Ctrl-Arrow keys.
- Shift-PageUp and Shift-PageDown.
- Shift-Home and Shift-End.
- Shift-Ctrl-Home and Shift-Ctrl-End.
</t>
<t tx="ekr.20131221065129.16522">The presently selected pane has a blue border.
We say that the selected pane **has focus**.

Regardless of what pane has focus:

- Alt-T puts selects the outline pane.
- Alt-D puts selects the body pane.
- Alt-Arrow key select another outline node
  and put focus in the outline pane.

A handy shortcut:

- When the outline pane has focus,
  the Return puts focus in the body pane.
</t>
<t tx="ekr.20131221065129.16524">Ctrl-N creates a new file.
Ctrl-S saves the file.

When focus is in the outline pane:

- The Insert key inserts a new node.
  Type the headline text followed by Return.
- The Delete key or the BackSpace key deletes a node.
- Plain Arrow keys select nodes.
- Shift-Arrow keys move nodes.

The following commands work regardless of focus.


- Ctrl-I inserts a new node.
- Ctrl-H edits the headline of the selected node.
- Ctrl-Shift-X deletes (cuts) the node.
  (Ctrl-Shift-C copies the selected node)
- Ctrl-Shift-V copies a previously copied or cut node.
- Alt-Arrow keys select nodes, as in Windows explorer.
- Alt-Shift-Arrow keys move nodes.
- Ctrl-U, Ctrl-D, Ctrl-L and Ctrl-R move nodes up, down, left and right.
- Ctrl-Z undoes the last operation. 
  Ctrl-Shift-Z redoes the last operation.
</t>
<t tx="ekr.20131221065129.16525">- When editing a headline, the Return key leaves focus in the tree.
- When focus is in the outline pane, the Insert key inserts a node.
- When focus is in the outline pane, the Delete and BackSpace keys deletes node.
</t>
<t tx="ekr.20131221065129.16526">All menu shortcuts are shown as bound to the menu-shortcut command.
</t>
<t tx="ekr.20131222112420.16374">This should be more intuitive for newcomers.
</t>
<t tx="ekr.20131225061403.16375">@nocolor-node

- Choosing bookmarks-show with a large tree selected kills performance.
- view-pack will create sorted list of unl's.
- view-unpack will sort list of unl's.
</t>
<t tx="ekr.20131225061403.16377">@g.command('view-pack')
def viewPack(event):
    c = event.get('c')
    if not c: return
    result = [g.unl(p) for p in c.p.self_and_subtree()]
    # What to do about c.p.b and c.p.h?
</t>
<t tx="ekr.20131230090121.16504">@first # -*- coding: utf-8 -*-
'''Support for @views trees and related operations.'''
# Started 2013/12/31.
@language python
@tabwidth -4
from __future__ import print_function
&lt;&lt; imports &gt;&gt;
@others
</t>
<t tx="ekr.20131230090121.16506">import leo.core.leoGlobals as g
import copy
import time
</t>
<t tx="ekr.20131230090121.16507">'''
A class to handle @views trees and related operations.
Such trees have the following structure:

- @views
  - @auto-view &lt;unl of @auto node&gt;
    - @organizers
      - @organizer &lt;headline&gt;
    - @clones
    
The body text of @organizer and @clones consists of unl's, one per line.
'''
</t>
<t tx="ekr.20131230090121.16508">class ViewController:
    &lt;&lt; docstring &gt;&gt;
    @others
</t>
<t tx="ekr.20131230090121.16509">def __init__ (self,c):
    '''Ctor for ViewController class.'''
    self.c = c
    self.headline_ivar = '_imported_headline'
    self.init()
    
def init(self):
    '''
    Init all ivars of this class.
    Unit tests may call this method to ensure that this class is re-inited properly.
    '''
    self.all_ods = []
        # List of all od nodes.
    self.anchors_d = {}
        # Keys are anchoring positions, values are sorted lists of ods.
    self.anchor_offset_d = {}
        # Keys are anchoring positions, values are ints.
    self.existing_ods = []
        # List of od instances corresponding to @existing-organizer: nodes.
    self.global_bare_organizer_node_list = []
        # List of organizers that have no parent organizer node.
        # This list excludes existing organizer nodes.
    self.headlines_dict = {}
        # Keys are vnodes; values are list of child headlines.
    self.imported_organizers_list = []
        # The list of nodes that have children on entry, such as class nodes.
    self.n_nodes_scanned = 0
        # Number of nodes scanned by demote.
    self.organizer_ods = []
        # List of od instances corresponding to @organizer: nodes.
    self.organizer_unls = []
        # The list of od.unl for all od instances in self.organizer_ods.
    self.root = None
        # The position of the @auto node.
    self.pending = []
        # The list of nodes pending to be added to an organizer.
    self.stack = []
        # The stack containing real and virtual parent nodes during the main loop.
    self.temp_node = None
        # The parent position of all holding cells.
    self.trail_write_1 = None
        # The trial write on entry.
    self.views_node = None
        # The position of the @views node.
    self.work_list = []
        # A gloal list of (parent,child) tuples for all nodes that are
        # to be moved to **non-existing** organizer nodes.
        # **Important**: Nodes are moved in the order they appear in this list:
        # the tuples contain no childIndex component!
        # This list is the "backbone" of this class:
        # - The front end (demote and its helpers) adds items to this list.
        # - The back end (move_nodes and its helpers) moves nodes using this list.
</t>
<t tx="ekr.20131230090121.16511">def update_before_write_at_auto_file(self,root):
    '''
    Update the @auto-view node for root, an @auto node. Create @organizer,
    @existing-organizer, @clones and @headlines nodes as needed.
    This *must not* be called for trial writes.
    '''
    trace = False and not g.unitTesting
    vc = self
    c = vc.c
    changed = False
    t1 = time.clock()
    # Create lists of cloned and organizer nodes.
    clones,existing_organizers,organizers = \
        vc.find_special_nodes(root)
    # Delete all children of the @auto-view node for this @auto node.
    at_auto_view = vc.find_at_auto_view_node(root)
    if at_auto_view.hasChildren():
        changed = True
        at_auto_view.deleteAllChildren()
    # Create the single @clones node.
    if clones:
        at_clones = vc.find_at_clones_node(root)
        at_clones.b = ''.join(
            ['gnx: %s\nunl: %s\n' % (z[0],z[1]) for z in clones])
    # Create the single @organizers node.
    if organizers or existing_organizers:
        at_organizers = vc.find_at_organizers_node(root)
    # Create one @organizers: node for each organizer node.
    for p in organizers:
        # g.trace('organizer',p.h)
        at_organizer = at_organizers.insertAsLastChild()
        at_organizer.h = '@organizer: %s' % p.h
        # The organizer node's unl is implicit in each child's unl.
        at_organizer.b = '\n'.join([
            'unl: '+vc.relative_unl(z,root) for z in p.children()])
    # Create one @existing-organizer node for each existing organizer.
    ivar = vc.headline_ivar
    for p in existing_organizers:
        at_organizer = at_organizers.insertAsLastChild()
        h = getattr(p.v,ivar,p.h)
        if trace and h != p.h: g.trace('==&gt;',h) # p.h,'==&gt;',h
        at_organizer.h = '@existing-organizer: %s' % h
        # The organizer node's unl is implicit in each child's unl.
        at_organizer.b = '\n'.join([
            'unl: '+vc.relative_unl(z,root) for z in p.children()])
    # Create the single @headlines node.
    vc.create_at_headlines(root)
    if changed and not g.unitTesting:
        g.es_print('updated @views node in %4.2f sec.' % (
            time.clock()-t1))
    if changed:
        c.redraw()
    return at_auto_view # For at-file-to-at-auto command.
</t>
<t tx="ekr.20131230090121.16513">def update_after_read_at_auto_file(self,root):
    '''
    Recreate all organizer nodes and clones for a single @auto node
    using the corresponding @organizer: and @clones nodes.
    '''
    trace = True and not g.unitTesting
    vc = self
    c = vc.c
    if not vc.is_at_auto_node(root):
        return # Not an error: it might be and @auto-rst node.
    old_changed = c.isChanged()
    try:
        vc.init()
        vc.root = root.copy()
        t1 = time.clock()
        vc.trial_write_1 = vc.trial_write(root)
        t2 = time.clock()
        at_organizers = vc.has_at_organizers_node(root)
        t3 = time.clock()
        if at_organizers:
            vc.create_organizer_nodes(at_organizers,root)
        t4 = time.clock()
        at_clones = vc.has_at_clones_node(root)
        if at_clones:
            vc.create_clone_links(at_clones,root)
        t5 = time.clock()
        n = len(vc.work_list)
        ok = vc.check(root)
        t6 = time.clock()
        if ok:
            vc.update_headlines_after_read(root)
        t7 = time.clock()
        c.setChanged(old_changed if ok else False)
            ### To do: revert if not ok.
    except Exception:
        g.es_exception()
        n = 0
        ok = False
    if trace:
        if t7-t1 &gt; 0.5: g.trace(
            '\n  trial_write:                 %4.2f sec' % (t2-t1),
            # '\n  has_at_organizers_node:    %4.2f sec' % (t3-t2),
            '\n  create_organizer_nodes:      %4.2f sec' % (t4-t3),
            '\n  create_clone_links:          %4.2f sec' % (t5-t4),
            '\n  check:                       %4.2f sec' % (t6-t5),
            '\n  update_headlines_after_read: %4.2f sec' % (t7-t6),
            '\n  total:                       %4.2f sec' % (t7-t1))
            # '\n  file:',root.h)
        # else: g.trace('total: %4.2f sec' % (t7-t1),root.h)
    if ok and n &gt; 0:
        g.es('rearragned: %s' % (root.h),color='blue')
        g.es('moved %s nodes in %4.2f sec.' % (n,t7-t1))
        g.trace('@auto-view moved %s nodes in %4.2f sec. for' % (
            n,t2),root.h,noname=True)
    c.selectPosition(root)
    c.redraw()
    return ok
</t>
<t tx="ekr.20131230090121.16514"></t>
<t tx="ekr.20131230090121.16515"></t>
<t tx="ekr.20131230090121.16516">def find_at_clones_node(self,root):
    '''
    Find the @clones node for root, an @auto node.
    Create the @clones node if it does not exist.
    '''
    vc = self
    c = vc.c
    h = '@clones'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
</t>
<t tx="ekr.20131230090121.16518">def find_at_organizers_node(self,root):
    '''
    Find the @organizers node for root, and @auto node.
    Create the @organizers node if it doesn't exist.
    '''
    vc = self
    c = vc.c
    h = '@organizers'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
</t>
<t tx="ekr.20131230090121.16519">def find_at_views_node(self):
    '''
    Find the first @views node in the outline.
    If it does not exist, create it as the *last* top-level node,
    so that no existing positions become invalid.
    '''
    vc = self
    c = vc.c
    p = g.findNodeAnywhere(c,'@views')
    if not p:
        last = c.rootPosition()
        while last.hasNext():
            last.moveToNext()
        p = last.insertAfter()
        p.h = '@views'
        # c.selectPosition(p)
        # c.redraw()
    return p
</t>
<t tx="ekr.20131230090121.16520">def find_at_auto_view_node (self,root):
    '''
    Return the @auto-view node for root, an @auto node.
    Create the node if it does not exist.
    '''
    vc = self
    views = vc.find_at_views_node()
    p = vc.has_at_auto_view_node(root)
    if not p:
        p = views.insertAsLastChild()
        p.h = '@auto-view:' + root.h[len('@auto'):].strip()
        p.b = vc.at_auto_view_body(root)
    return p
</t>
<t tx="ekr.20131230090121.16522">def clean_nodes(self):
    '''Delete @auto-view nodes with no corresponding @auto nodes.'''
    vc = self
    c = vc.c
    views = vc.has_at_views_node()
    if not views:
        return
    # Remember the gnx of all @auto nodes.
    d = {}
    for p in c.all_unique_positions():
        if vc.is_at_auto_node(p):
            d[p.v.gnx] = True
    # Remember all unused @auto-view nodes.
    delete = []
    for child in views.children():
        s = child.b and g.splitlines(child.b)
        gnx = s[len('gnx'):].strip()
        if gnx not in d:
            g.trace(child.h,gnx)
            delete.append(child.copy())
    for p in reversed(delete):
        p.doDelete()
    c.selectPosition(views)
</t>
<t tx="ekr.20131230090121.16524">def is_at_auto_node(self,p):
    '''Return True if p is an @auto node.'''
    return g.match_word(p.h,0,'@auto') and not g.match(p.h,0,'@auto-')
        # Does not match @auto-rst, etc.

def is_at_file_node(self,p):
    '''Return True if p is an @file node.'''
    return g.match_word(p.h,0,'@file')
</t>
<t tx="ekr.20131230090121.16525">def is_organizer_node(self,p,root):
    '''
    Return True if p is an organizer node in the given @auto tree.
    '''
    vc = self
    return p.hasChildren() and vc.is_comment_node(p,root)

</t>
<t tx="ekr.20131230090121.16526">def comment_delims(self,p):
    '''Return the comment delimiter in effect at p, an @auto node.'''
    vc = self
    c = vc.c
    d = g.get_directives_dict(p)
    s = d.get('language') or c.target_language
    language,single,start,end = g.set_language(s,0)
    return single,start,end
</t>
<t tx="ekr.20131230090121.16529">def has_at_clones_node(self,root):
    '''
    Find the @clones node for an @auto node with the given unl.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@clones')
</t>
<t tx="ekr.20131230090121.16531">def has_at_organizers_node(self,root):
    '''
    Find the @organizers node for root, an @auto node.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@organizers')
</t>
<t tx="ekr.20131230090121.16532">def create_organizer_nodes(self,at_organizers,root):
    '''
    root is an @auto node. Create an organizer node in root's tree for each
    child @organizer: node of the given @organizers node.
    '''
    vc = self
    c = vc.c
    trace = False and not g.unitTesting
    t1 = time.clock()
    vc.pre_move_comments(root)
        # Merge comment nodes with the next node.
    t2 = time.clock()
    vc.precompute_all_data(at_organizers,root)
        # Init all data required for reading.
    t3 = time.clock()
    vc.demote(root)
        # Traverse root's tree, adding nodes to vc.work_list.
    t4 = time.clock()
    vc.move_nodes()
        # Move nodes on vc.work_list to their final locations.
    t5 = time.clock()
    vc.post_move_comments(root)
        # Move merged comments to parent organizer nodes.
    t6 = time.clock()
    if trace: g.trace(
        '\n  pre_move_comments:   %4.2f sec' % (t2-t1),
        '\n  precompute_all_data: %4.2f sec' % (t3-t2),
        '\n  demote:              %4.2f sec' % (t4-t3),
        '\n  move_nodes:          %4.2f sec' % (t5-t4),
        '\n  post_move_comments:  %4.2f sec' % (t6-t5))
</t>
<t tx="ekr.20131230090121.16533">def create_clone_links(self,at_clones,root):
    '''
    Recreate clone links from an @clones node.
    @clones nodes contain pairs of lines (gnx,unl)
    '''
    vc = self
    lines = g.splitLines(at_clones.b)
    gnxs = [s[4:].strip() for s in lines if s.startswith('gnx:')]
    unls = [s[4:].strip() for s in lines if s.startswith('unl:')]
    # g.trace('at_clones.b',at_clones.b)
    if len(gnxs) == len(unls):
        vc.headlines_dict = {} # May be out of date.
        ok = True
        for gnx,unl in zip(gnxs,unls):
            ok = ok and vc.create_clone_link(gnx,root,unl)
        return ok
    else:
        g.trace('bad @clones contents',gnxs,unls)
        return False
</t>
<t tx="ekr.20131230090121.16535">def has_at_views_node(self):
    '''Return the @views or None if it does not exist.'''
    vc = self
    return g.findNodeAnywhere(vc.c,'@views')
</t>
<t tx="ekr.20131230090121.16539">def find_position_for_relative_unl(self,parent,unl,priority_header=False):
    '''
    Return the node in parent's subtree matching the given unl.
    The unl is relative to the parent position.
    If priority_header == True and the node is not found, it will return the longest matching UNL starting from the tail
    '''
    # This is called from finish_create_organizers &amp; compute_all_organized_positions.
    trace = False # and not g.unitTesting
    trace_loop = True
    trace_success = False
    vc = self
    if not unl:
        if trace and trace_success:
            g.trace('return parent for empty unl:',parent.h)
        return parent
    # The new, simpler way: drop components of the unl automatically.
    drop,p = [],parent # for debugging.
    # if trace: g.trace('p:',p.h,'unl:',unl)
    import re
    pos_pattern = re.compile(r':(\d+),?(\d+)?$')
    for s in unl.split('--&gt;'):
        found = False # The last part must match.
        if 1:
            # Create the list of children on the fly.
            aList = vc.headlines_dict.get(p.v)
            if aList is None:
                aList = [z.h for z in p.children()]
                vc.headlines_dict[p.v] = aList
            try:
                pos = re.findall(pos_pattern,s)
                nth_sib,pos = pos[0] if pos else (0,0)
                pos = int(pos) if pos else 0
                nth_sib = int(nth_sib)
                s = re.sub(pos_pattern,"",s).replace('--%3E','--&gt;')
                indices = [i for i, x in enumerate(aList) if x == s]
                if len(indices)&gt;pos:
                    #First we try the nth node with same header
                    n = indices[pos]
                    p = p.nthChild(n)
                    found = True
                elif len(indices)&gt;0:
                    #Then we try any node with same header
                    n = indices[-1]
                    p = p.nthChild(n)
                    found = True
                elif not priority_header:
                    #Then we go for the child index if return_pos is true
                    if len(aList)&gt;nth_sib:
                        n = nth_sib
                    else:
                        n = len(aList)-1
                    if n&gt;-1:
                        p = p.nthChild(n)
                    else:
                        g.es('Partial UNL match: Referenced level is higher than '+str(p.level()))
                    found = True
                if trace and trace_loop: g.trace('match:',s)
            except ValueError: # s not in aList.
                if trace and trace_loop: g.trace('drop:',s)
                drop.append(s)
        else: # old code.
            for child in p.children():
                if child.h == s:
                    p = child
                    found = True
                    if trace and trace_loop: g.trace('match:',s)
                    break
                # elif trace and trace_loop: g.trace('no match:',child.h)
            else:
                if trace and trace_loop: g.trace('drop:',s)
                drop.append(s)
    if not found and priority_header:
        aList = []
        for p in vc.c.all_unique_positions():
            if p.h.replace('--%3E','--&gt;') in unl:
                aList.append((p.copy(),p.get_UNL(False,False,True)))
        unl_list = [re.sub(pos_pattern,"",x).replace('--%3E','--&gt;') for x in unl.split('--&gt;')]
        for iter_unl in aList:
            maxcount = 0
            count = 0
            compare_list = unl_list[:]
            for header in reversed(iter_unl[1].split('--&gt;')):
                if re.sub(pos_pattern,"",header).replace('--%3E','--&gt;') == compare_list[-1]:
                    count = count+1
                    compare_list.pop(-1)
                else:
                    break
            if count &gt; maxcount:
                p = iter_unl[0]
                found = True
    if found:
        if trace and trace_success:
            g.trace('found unl:',unl,'parent:',p.h,'drop',drop)
    else:
        if trace: g.trace('===== unl not found:',unl,'parent:',p.h,'drop',drop)
    return p if found else None
</t>
<t tx="ekr.20131230090121.16541">def relative_unl(self,p,root):
    '''Return the unl of p relative to the root position.'''
    vc = self
    result = []
    ivar = vc.headline_ivar
    for p in p.self_and_parents():
        if p == root:
            break
        else:
            h = getattr(p.v,ivar,p.h)
            result.append(h)
    return '--&gt;'.join(reversed(result))

def unl(self,p):
    '''Return the unl corresponding to the given position.'''
    vc = self
    return '--&gt;'.join(reversed([
        getattr(p.v,vc.headline_ivar,p.h)
            for p in p.self_and_parents()]))
    # return '--&gt;'.join(reversed([p.h for p in p.self_and_parents()]))
</t>
<t tx="ekr.20131230090121.16544">def find_representative_node (self,root,target):
    '''
    root is an @auto node. target is a clones node within root's tree.
    Return a node *outside* of root's tree that is cloned to target,
    preferring nodes outside any @&lt;file&gt; tree.
    Never return any node in any @views or @view tree.
    '''
    trace = False and not g.unitTesting
    assert target
    assert root
    vc = self
    # Pass 1: accept only nodes outside any @file tree.
    p = vc.c.rootPosition()
    while p:
        if p.h.startswith('@view'):
            p.moveToNodeAfterTree()
        elif p.isAnyAtFileNode():
            p.moveToNodeAfterTree()
        elif p.v == target.v:
            if trace: g.trace('success 1:',p,p.parent())
            return p
        else:
            p.moveToThreadNext()
    # Pass 2: accept any node outside the root tree.
    p = vc.c.rootPosition()
    while p:
        if p.h.startswith('@view'):
            p.moveToNodeAfterTree()
        elif p == root:
            p.moveToNodeAfterTree()
        elif p.v == target.v:
            if trace: g.trace('success 2:',p,p.parent())
            return p
        else:
            p.moveToThreadNext()
    g.trace('no representative node for:',target,'parent:',target.parent())
    return None
</t>
<t tx="ekr.20131230090121.16545">def create_clone_link(self,gnx,root,unl):
    '''
    Replace the node in the @auto tree with the given unl by a
    clone of the node outside the @auto tree with the given gnx.
    '''
    trace = False and not g.unitTesting
    vc = self
    p1 = vc.find_position_for_relative_unl(root,unl)
    p2 = vc.find_gnx_node(gnx)
    if p1 and p2:
        if trace: g.trace('relink',gnx,p2.h,'-&gt;',p1.h)
        if p1.b == p2.b:
            p2._relinkAsCloneOf(p1)
            return True
        else:
            g.es('body text mismatch in relinked node',p1.h)
            return False
    else:
        if trace: g.trace('relink failed',gnx,root.h,unl)
        return False
</t>
<t tx="ekr.20131230090121.16547">def find_gnx_node(self,gnx):
    '''Return the first position having the given gnx.'''
    # This is part of the read logic, so newly-imported
    # nodes will never have the given gnx.
    vc = self
    for p in vc.c.all_unique_positions():
        if p.v.gnx == gnx:
            return p
    return None
</t>
<t tx="ekr.20140102051335.16506">@g.command('view-pack')
def view_pack_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.pack()

@g.command('view-unpack')
def view_unpack_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.unpack()
        
@g.command('at-file-to-at-auto')
def at_file_to_at_auto_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.convert_at_file_to_at_auto(c.p)
</t>
<t tx="ekr.20140102052259.16394">def pack(self):
    '''
    Undoably convert c.p to a packed @view node, replacing all cloned
    children of c.p by unl lines in c.p.b.
    '''
    vc = self
    c,u = vc.c,vc.c.undoer
    vc.init()
    changed = False
    root = c.p
    # Create an undo group to handle changes to root and @views nodes.
    # Important: creating the @views node does *not* invalidate any positions.'''
    u.beforeChangeGroup(root,'view-pack')
    if not vc.has_at_views_node():
        changed = True
        bunch = u.beforeInsertNode(c.rootPosition())
        views = vc.find_at_views_node()
            # Creates the @views node as the *last* top-level node
            # so that no positions become invalid as a result.
        u.afterInsertNode(views,'create-views-node',bunch)
    # Prepend @view if need.
    if not root.h.strip().startswith('@'):
        changed = True
        bunch = u.beforeChangeNodeContents(root)
        root.h = '@view ' + root.h.strip()
        u.afterChangeNodeContents(root,'view-pack-update-headline',bunch)
    # Create an @view node as a clone of the @views node.
    bunch = u.beforeInsertNode(c.rootPosition())
    new_clone = vc.create_view_node(root)
    if new_clone:
        changed = True
        u.afterInsertNode(new_clone,'create-view-node',bunch)
    # Create a list of clones that have a representative node
    # outside of the root's tree.
    reps = [vc.find_representative_node(root,p)
        for p in root.children()
            if vc.is_cloned_outside_parent_tree(p)]
    reps = [z for z in reps if z is not None]
    if reps:
        changed = True
        bunch = u.beforeChangeTree(root)
        c.setChanged(True)
        # Prepend a unl: line for each cloned child.
        unls = ['unl: %s\n' % (vc.unl(p)) for p in reps]
        root.b = ''.join(unls) + root.b
        # Delete all child clones in the reps list.
        v_reps = set([p.v for p in reps])
        while True:
            for child in root.children():
                if child.v in v_reps:
                    child.doDelete()
                    break
            else: break
        u.afterChangeTree(root,'view-pack-tree',bunch)
    if changed:
        u.afterChangeGroup(root,'view-pack')
        c.selectPosition(root)
        c.redraw()
</t>
<t tx="ekr.20140102052259.16395">def unpack(self):
    '''
    Undoably unpack nodes corresponding to leading unl lines in c.p to child clones.
    Return True if the outline has, in fact, been changed.
    '''
    vc = self
    c,root,u = vc.c,vc.c.p,vc.c.undoer
    vc.init()
    # Find the leading unl: lines.
    i,lines,tag = 0,g.splitLines(root.b),'unl:'
    for s in lines:
        if s.startswith(tag): i += 1
        else: break
    changed = i &gt; 0
    if changed:
        bunch = u.beforeChangeTree(root)
        # Restore the body
        root.b = ''.join(lines[i:])
        # Create clones for each unique unl.
        unls = list(set([s[len(tag):].strip() for s in lines[:i]]))
        for unl in unls:
            p = vc.find_absolute_unl_node(unl)
            if p: p.clone().moveToLastChildOf(root)
            else: g.trace('not found: %s' % (unl))
        c.setChanged(True)
        c.undoer.afterChangeTree(root,'view-unpack',bunch)
        c.redraw()
    return changed
</t>
<t tx="ekr.20140102052259.16397">def create_view_node(self,root):
    '''
    Create a clone of root as a child of the @views node.
    Return the *newly* cloned node, or None if it already exists.
    '''
    vc = self
    c = vc.c
    # Create a cloned child of the @views node if it doesn't exist.
    views = vc.find_at_views_node()
    for p in views.children():
        if p.v == c.p.v:
            return None
    p = root.clone()
    p.moveToLastChildOf(views)
    return p
</t>
<t tx="ekr.20140102052259.16398">def is_cloned_outside_parent_tree(self,p):
    '''Return True if a clone of p exists outside the tree of p.parent().'''
    return len(list(set(p.v.parents))) &gt; 1
</t>
<t tx="ekr.20140102052259.16402">def find_absolute_unl_node(self,unl,priority_header=False):
    '''Return a node matching the given absolute unl.
    If priority_header == True and the node is not found, it will return the longest matching UNL starting from the tail
    '''
    import re
    pos_pattern = re.compile(r':(\d+),?(\d+)?$')
    vc = self
    aList = unl.split('--&gt;')
    if aList:
        first,rest = aList[0],'--&gt;'.join(aList[1:])
        count = 0
        pos = re.findall(pos_pattern,first)
        nth_sib,pos = pos[0] if pos else (0,0)
        pos = int(pos) if pos else 0
        nth_sib = int(nth_sib)
        first = re.sub(pos_pattern,"",first).replace('--%3E','--&gt;')
        for parent in vc.c.rootPosition().self_and_siblings():
            if parent.h.strip() == first.strip():
                if pos == count:
                    if rest:
                        return vc.find_position_for_relative_unl(parent,rest,priority_header=priority_header)
                    else:
                        return parent
                count = count+1
        #Here we could find and return the nth_sib if an exact header match was not found
    return None
</t>
<t tx="ekr.20140103062103.16442"># The find commands create the node if not found.
</t>
<t tx="ekr.20140103062103.16443"># The has commands return None if the node does not exist.
</t>
<t tx="ekr.20140103105930.16447">def has_at_auto_view_node(self,root):
    '''
    Return the @auto-view node corresponding to root, an @root node.
    Return None if no such node exists.
    '''
    vc = self
    c = vc.c
    assert vc.is_at_auto_node(root) or vc.is_at_file_node(root),root
    views = g.findNodeAnywhere(c,'@views')
    if views:
        # Find a direct child of views with matching headline and body.
        for p in views.children():
            if vc.match_at_auto_body(p,root):
                return p
    return None
</t>
<t tx="ekr.20140103105930.16448">def at_auto_view_body(self,p):
    '''Return the body text for the @auto-view node for p.'''
    # Note: the unl of p relative to p is simply p.h,
    # so it is pointless to add that to the @auto-view node.
    return 'gnx: %s\n' % p.v.gnx

def match_at_auto_body(self,p,auto_view):
    '''Return True if any line of auto_view.b matches the expected gnx line.'''
    if 0: g.trace(p.b == 'gnx: %s\n' % auto_view.v.gnx,
        g.shortFileName(p.h),auto_view.v.gnx,p.b.strip())
    return p.b == 'gnx: %s\n' % auto_view.v.gnx
</t>
<t tx="ekr.20140104063158.16448">reload-abbreviations and reload-key-bindings commands.
    Use regex replace to replace settings ivars with @property defs.

@language python
</t>
<t tx="ekr.20140104063158.17235"># About 65-70 matches.
</t>
<t tx="ekr.20140104112957.16587">def demote(self,root):
    '''
    The main line of the @auto-view algorithm. Traverse root's entire tree,
    placing items on the global work list.
    '''
    trace = False # and not g.unitTesting
    trace_loop = True
    vc = self
    active = None # The active od.
    vc.pending = [] # Lists of pending demotions.
    d = vc.anchor_offset_d # For traces.
    for p in root.subtree():
        parent = p.parent()
        if trace and trace_loop:
            if 1:
                g.trace('-----',p.childIndex(),p.h)
            else:
                g.trace(
                    '=====\np:',p.h,
                    'childIndex',p.childIndex(),
                    '\nparent:',parent.h,
                    'parent:offset',d.get(parent,0))
        vc.n_nodes_scanned += 1
        vc.terminate_organizers(active,parent)
        found = vc.find_organizer(parent,p)
        if found:
            pass ### vc.enter_organizers(found,p)
        else:
            pass ### vc.terminate_all_open_organizers()
        if trace and trace_loop:
            g.trace(
                'active:',active and active.h or 'None',
                'found:',found and found.h or 'None')
        # The main case statement...
        if found is None and active:
            vc.add_to_pending(active,p)
        elif found is None and not active:
            # Pending nodes will *not* be organized.
            vc.clear_pending(None,p)
        elif found and found == active:
            # Pending nodes *will* be organized.
            for z in vc.pending:
                active2,child2 = z
                vc.add(active2,child2,'found==active:pending')
            vc.pending = []
            vc.add(active,p,'found==active')
        elif found and found != active:
            # Pending nodes will *not* be organized.
            vc.clear_pending(found,p)
            active = found
            vc.enter_organizers(found,p)
            vc.add(active,p,'found!=active')
        else: assert False,'can not happen'
</t>
<t tx="ekr.20140105055318.16754">def is_comment_node(self,p,root,delims=None):
    '''Return True if p.b contains nothing but comments or blank lines.'''
    vc = self
    if not delims:
        delims = vc.comment_delims(root)
    # pylint: disable=unpacking-non-sequence
    single,start,end = delims
    assert single or start and end,'bad delims: %r %r %r' % (single,start,end)
    if single:
        for s in g.splitLines(p.b):
            s = s.strip()
            if s and not s.startswith(single) and not g.isDirective(s):
                return False
        return True
    else:
        def check_comment(s):
            done,in_comment = False,True
            i = s.find(end)
            if i &gt; -1:
                tail = s[i+len(end):].strip()
                if tail: done = True
                else: in_comment = False
            return done,in_comment
        
        done,in_comment = False,False
        for s in g.splitLines(p.b):
            s = s.strip()
            if not s:
                pass
            elif in_comment:
                done,in_comment = check_comment(s)
            elif g.isDirective(s):
                pass
            elif s.startswith(start):
                done,in_comment = check_comment(s[len(start):])
            else:
                # g.trace('fail 1: %r %r %r...\n%s' % (single,start,end,s)
                return False
            if done:
                return False
        # All lines pass.
        return True
</t>
<t tx="ekr.20140105055318.16755"></t>
<t tx="ekr.20140105055318.16760"></t>
<t tx="ekr.20140105055318.16761">def drop_unl_tail(self,unl):
    '''Drop the last part of the unl.'''
    return '--&gt;'.join(unl.split('--&gt;')[:-1])

def drop_unl_parent(self,unl):
    '''Drop the penultimate part of the unl.'''
    aList = unl.split('--&gt;')
    return '--&gt;'.join(aList[:-2] + aList[-1:])
</t>
<t tx="ekr.20140105055318.16762">def drop_all_organizers_in_unl(self,organizer_unls,unl):
    '''Drop all organizer unl's in unl, recreating the imported unl.'''
    vc = self
    def unl_sort_key(s):
        return s.count('--&gt;')
    for s in reversed(sorted(organizer_unls,key=unl_sort_key)):
        if unl.startswith(s):
            s2 = vc.drop_unl_tail(s)
            unl = s2 + unl[len(s):]
    return unl[3:] if unl.startswith('--&gt;') else unl
</t>
<t tx="ekr.20140106215321.16672">class OrganizerData:
    '''A class containing all data for a particular organizer node.'''
    def __init__ (self,h,unl,unls):
        self.anchor = None # The anchor position of this od node.
        self.children = [] # The direct child od nodes of this od node.
        self.closed = False # True: this od node no longer accepts new child od nodes.
        self.drop = True # Drop the unl for this od node when associating positions with unls.
        self.descendants = None # The descendant od nodes of this od node.
        self.exists = False # True: this od was created by @existing-organizer:
        self.h = h # The headline of this od node.
        self.moved = False # True: the od node has been moved to a global move list.
        self.opened = False # True: the od node has been opened.
        self.organized_nodes = [] # The list of positions organized by this od node.
        self.parent_od = None # The parent od node of this od node. (None is valid.)
        self.p = None # The position of this od node.
        self.parent = None # The original parent position of all nodes organized by this od node.
            # If parent_od is None, this will be the parent position of the od node.
        self.source_unl = None # The unl of self.parent.
        self.unl = unl # The unl of this od node.
        self.unls = unls # The unls contained in this od node.
        self.visited = False # True: demote_helper has already handled this od node.
    def __repr__(self):
        return 'OrganizerData: %s' % (self.h or '&lt;no headline&gt;')
    __str__ = __repr__
</t>
<t tx="ekr.20140106215321.16673">def get_at_organizer_unls(self,p):
    '''Return the unl: lines in an @organizer: node.'''
    return [s[len('unl:'):].strip()
        for s in g.splitLines(p.b)
            if s.startswith('unl:')]

</t>
<t tx="ekr.20140106215321.16674">def create_organizer_data(self,at_organizers,root):
    '''
    Create OrganizerData nodes for all @organizer: and @existing-organizer:
    nodes in the given @organizers node.
    '''
    vc = self
    vc.create_ods(at_organizers)
    vc.finish_create_organizers(root)
    vc.finish_create_existing_organizers(root)
    for od in vc.all_ods:
        assert od.parent,(od.exists,od.h)
</t>
<t tx="ekr.20140106215321.16675">def create_actual_organizer_nodes(self):
    '''
    Create all organizer nodes as children of holding cells. These holding
    cells ensure that moving an organizer node leaves all other positions
    unchanged.
    '''
    vc = self
    c = vc.c
    last = c.lastTopLevel()
    temp = vc.temp_node = last.insertAfter()
    temp.h = 'ViewController.temp_node'
    for od in vc.organizer_ods:
        holding_cell = temp.insertAsLastChild()
        holding_cell.h = 'holding cell for ' + od.h
        od.p = holding_cell.insertAsLastChild()
        od.p.h = od.h
</t>
<t tx="ekr.20140106215321.16678">def move_nodes(self):
    '''Move nodes to their final location and delete the temp node.'''
    trace = False # and not g.unitTesting
    vc = self
    vc.move_nodes_to_organizers(trace)
    vc.move_bare_organizers(trace)
    vc.temp_node.doDelete()
</t>
<t tx="ekr.20140106215321.16679">def pre_move_comments(self,root):
    '''
    Move comments from comment nodes to the next node.
    This must be done before any other processing.
    '''
    vc = self
    c = vc.c
    delims = vc.comment_delims(root)
    aList = []
    for p in root.subtree():
        if p.hasNext() and vc.is_comment_node(p,root,delims=delims):
            aList.append(p.copy())
            next = p.next()
            if p.b: next.b = p.b + next.b
    # g.trace([z.h for z in aList])
    c.deletePositionsInList(aList)
        # This sets c.changed.
</t>
<t tx="ekr.20140106215321.16680">def source_unl(self,organizer_unls,organizer_unl):
    '''Return the unl of the source node for the given organizer_unl.'''
    vc = self
    return vc.drop_all_organizers_in_unl(organizer_unls,organizer_unl)
</t>
<t tx="ekr.20140108081031.16612">def create_tree_structure(self,root):
    '''Set od.parent_od, od.children &amp; od.descendants for all ods.'''
    trace = False and not g.unitTesting
    vc = self
    # if trace: g.trace([z.h for z in data_list],g.callers())
    organizer_unls = [z.unl for z in vc.all_ods]
    for od in vc.all_ods:
        for unl in od.unls:
            if unl in organizer_unls:
                i = organizer_unls.index(unl)
                d2 = vc.all_ods[i]
                # if trace: g.trace('found organizer unl:',od.h,'==&gt;',d2.h)
                od.children.append(d2)
                d2.parent_od = od
    # create_organizer_data now ensures od.parent is set.
    for od in vc.all_ods:
        assert od.parent,od.h
    # Extend the descendant lists.
    for od in vc.all_ods:
        vc.compute_descendants(od)
        assert od.descendants is not None
    if trace:
        def tail(head,unl):
            return str(unl[len(head):]) if unl.startswith(head) else str(unl)
        for od in vc.all_ods:
            g.trace(
                '\n  od:',od.h,
                '\n  unl:',od.unl,
                '\n  unls:', [tail(od.unl,z) for z in od.unls],
                '\n  source (unl):',od.source_unl or repr(''),
                '\n  parent (pos):', od.parent.h,
                '\n  children:',[z.h for z in od.children],
                '\n  descendants:',[str(z.h) for z in od.descendants])
</t>
<t tx="ekr.20140109214515.16633">def compute_descendants(self,od,level=0,result=None):
    '''Compute the descendant od nodes of od.'''
    trace = False # and not g.unitTesting
    vc = self
    if level == 0:
        result = []
    if od.descendants is None:
        for child in od.children:
            result.append(child)
            result.extend(vc.compute_descendants(child,level+1,result))
            result = list(set(result))
        if level == 0:
            od.descendants = result
            if trace: g.trace(od.h,[z.h for z in result])
        return result
    else:
        if trace: g.trace('cached',od.h,[z.h for z in od.descendants])
        return od.descendants
</t>
<t tx="ekr.20140109214515.16636">def move_nodes_to_organizers(self,trace):
    '''Move all nodes in the work_list.'''
    trace = False # and not g.unitTesting
    trace_dict = False
    trace_moves = False
    trace_deletes = False
    vc = self
    if trace: # A highly useful trace!
        g.trace('\n\nunsorted_list...\n%s' % (
            '\n'.join(['%40s ==&gt; %s' % (parent.h,p.h)
                for parent,p in vc.work_list])))
    # Create a dictionary of each organizers children.
    d = {}
    for parent,p in vc.work_list:
        # This key must remain stable if parent moves.
        key = parent
        aList = d.get(key,[])
        aList.append(p)
        # g.trace(key,[z.h for z in aList])
        d[key] = aList
    if trace and trace_dict:
        # g.trace('d...',sorted([z.h for z in d.keys()]))
        g.trace('d{}...')
        for key in sorted(d.keys()):
            aList = [z.h for z in d.get(key)]
            g.trace('%s %-20s %s' % (id(key),key.h,vc.dump_list(aList,indent=29)))
    # Move *copies* of non-organizer nodes to each organizer.
    organizers = list(d.keys())
    existing_organizers = [z.p.copy() for z in vc.existing_ods]
    moved_existing_organizers = {} # Keys are vnodes, values are positions.
    for parent in organizers:
        aList = d.get(parent,[])
        if trace and trace_moves:
            g.trace('===== moving/copying:',parent.h,
                'with %s children:' % (len(aList)),
                '\n  '+'\n  '.join([z.h for z in aList]))
        for p in aList:
            if p in existing_organizers:
                if trace and trace_moves:
                    g.trace('copying existing organizer:',p.h)
                    g.trace('children:',
                    '\n  '+'\n  '.join([z.h for z in p.children()]))
                copy = vc.copy_tree_to_last_child_of(p,parent)
                old = moved_existing_organizers.get(p.v)
                if old and trace_moves:
                    g.trace('*********** overwrite',p.h)
                moved_existing_organizers[p.v] = copy
            elif p in organizers:
                if trace and trace_moves:
                    g.trace('moving organizer:',p.h)
                aList = d.get(p)
                if aList:
                    if trace and trace_moves: g.trace('**** relocating',
                        p.h,'children:',
                        '\n  '+'\n  '.join([z.h for z in p.children()]))
                    del d[p]
                p.moveToLastChildOf(parent)
                if aList:
                    d[p] = aList
            else:
                parent2 = moved_existing_organizers.get(parent.v)
                if parent2:
                    if trace and trace_moves:
                        g.trace('***** copying to relocated parent:',p.h)
                    vc.copy_tree_to_last_child_of(p,parent2)
                else:
                    if trace and trace_moves: g.trace('copying:',p.h)
                    vc.copy_tree_to_last_child_of(p,parent)
    # Finally, delete all the non-organizer nodes, in reverse outline order.
    def sort_key(od):
        parent,p = od
        return p.sort_key(p)
    sorted_list = sorted(vc.work_list,key=sort_key)
    if trace and trace_deletes:
        g.trace('===== deleting nodes in reverse outline order...')
    for parent,p in reversed(sorted_list):
        if p.v in moved_existing_organizers:
            if trace and trace_deletes:
                g.trace('deleting moved existing organizer:',p.h)
            p.doDelete()
        elif p not in organizers:
            if trace and trace_deletes:
                g.trace('deleting non-organizer:',p.h)
            p.doDelete()
</t>
<t tx="ekr.20140109214515.16637">def move_bare_organizers(self,trace):
    '''Move all nodes in global_bare_organizer_node_list.'''
    trace = False # and not g.unitTesting
    trace_data = True
    trace_move = True
    vc = self
    # For each parent, sort nodes on n.
    d = {} # Keys are vnodes, values are lists of tuples (n,parent,p)
    existing_organizers = [od.p for od in vc.existing_ods]
    if trace: g.trace('ignoring existing organizers:',
        [p.h for p in existing_organizers])
    for parent,p,n in vc.global_bare_organizer_node_list:
        if p not in existing_organizers:
            key = parent.v
            aList = d.get(key,[])
            if (parent,p,n) not in aList:
                aList.append((parent,p,n),)
                d[key] = aList
    # For each parent, add nodes in childIndex order.
    def key_func(obj):
        return obj[0]
    for key in d.keys():
        aList = d.get(key)
        for data in sorted(aList,key=key_func):
            parent,p,n = data
            n2 = parent.numberOfChildren()
            if trace and trace_data:
                g.trace(n,parent.h,'==&gt;',p.h)
            if trace and trace_move: g.trace(
                'move: %-20s:' % (p.h),
                'to child: %2s' % (n),
                'of: %-20s' % (parent.h),
                'with:',n2,'children')
            p.moveToNthChildOf(parent,n)
</t>
<t tx="ekr.20140109214515.16639">def post_move_comments(self,root):
    '''Move comments from the start of nodes to their parent organizer node.'''
    vc = self
    c = vc.c
    delims = vc.comment_delims(root)
    for p in root.subtree():
        if p.hasChildren() and not p.b:
            s = vc.delete_leading_comments(delims,p.firstChild())
            if s:
                p.b = s
                # g.trace(p.h)
</t>
<t tx="ekr.20140109214515.16640"></t>
<t tx="ekr.20140109214515.16641">def delete_leading_comments(self,delims,p):
    '''
    Scan for leading comments from p and return them.
    At present, this only works for single-line comments.
    '''
    single,start,end = delims
    if single:
        lines = g.splitLines(p.b)
        result = []
        for s in lines:
            if s.strip().startswith(single):
                result.append(s)
            else: break
        if result:
            p.b = ''.join(lines[len(result):])
            # g.trace('len(result)',len(result),p.h)
            return ''.join(result)
    return None
</t>
<t tx="ekr.20140109214515.16642"># def is_comment_organizer_node(self,p,root):
    # '''
    # Return True if p is an organizer node in the given @auto tree.
    # '''
    # return p.hasChildren() and vc.is_comment_node(p,root)
</t>
<t tx="ekr.20140109214515.16643">def check (self,root):
    '''
    Compare a trial write or root with the vc.trail_write_1.
    Unlike the perfect-import checks done by the importer,
    we expecct an *exact* match, regardless of language.
    '''
    trace = True # and not g.unitTesting
    vc = self
    trial1 = vc.trial_write_1
    trial2 = vc.trial_write(root)
    if trial1 != trial2:
        g.pr('') # Don't use print: it does not appear with the traces.
        g.es_print('perfect import check failed for:',color='red')
        g.es_print(root.h,color='red')
        if trace:
            vc.compare_trial_writes(trial1,trial2)
            g.pr('')
    return trial1 == trial2
</t>
<t tx="ekr.20140109214515.16644">def trial_write(self,root):
    '''
    Return a trial write of outline whose root is given.
    
    **Important**: the @auto import and write code end all nodes with
    newlines. Because no imported nodes are empty, the code below is
    *exactly* equivalent to the @auto write code as far as trailing
    newlines are concerned. Furthermore, we can treat Leo directives as
    ordinary text here.
    '''
    vc = self
    if 1:
        # Do a full trial write, exactly as will be done later.
        at = vc.c.atFileCommands
        ok = at.writeOneAtAutoNode(root,
            toString=True,force=True,trialWrite=True)
        if ok:
            return at.stringOutput
        else:
            g.trace('===== can not happen')
            return ''
    elif 1:
        # Concatenate all body text.  Close, but not exact.
        return ''.join([p.b for p in root.self_and_subtree()])
    else:
        # Compare headlines, ignoring nodes without body text and comment nodes.
        # This was handy during early development.
        return '\n'.join([p.h for p in root.self_and_subtree()
            if p.b and not p.h.startswith('#')])
</t>
<t tx="ekr.20140109214515.16646">def add_organizer_node (self,od,p):
    '''
    Add od to the appropriate move list.
    p is the existing node that caused od to be added.
    '''
    trace = True # and not g.unitTesting
    verbose = False
    vc = self
    # g.trace(od.h,'parent',od.parent_od and od.parent_od.h or 'None')
    if od.parent_od:
        # Not a bare organizer: a child of another organizer node.
        # If this is an existing organizer, it's *position* may have
        # been moved without active.moved being set.
        data = od.parent_od.p,od.p
        if data in vc.work_list:
            if trace and verbose: g.trace(
                '**** duplicate 1: setting moved bit.',od.h)
            od.moved = True
        elif od.parent_od.exists:    
            anchor = od.parent_od.p
            n = vc.anchor_incr(anchor,p) + p.childIndex()
            data = anchor,od.p,n
            # g.trace('anchor:',anchor.h,'p:',p.h,'childIndex',p.childIndex())
            vc.add_to_bare_list(data,'non-bare existing')
        else:
            vc.add_to_work_list(data,'non-bare')
    elif od.p == od.anchor:
        if trace and verbose: g.trace(
            '***** existing organizer: do not move:',od.h)
    else:
        ### This can be pre-computed?
        bare_list = [p for parent,p,n in vc.global_bare_organizer_node_list]
        if od.p in bare_list:
            if trace and verbose: g.trace(
                '**** duplicate 2: setting moved bit.',od.h)
            od.moved = True
        else:
            # A bare organizer node: a child of an *ordinary* node.
            anchor = p.parent()
            n = vc.anchor_incr(anchor,p) + p.childIndex()
            data = anchor,od.p,n
            vc.add_to_bare_list(data,'bare')
</t>
<t tx="ekr.20140109214515.16648">def compare_test_trees(self,root1,root2):
    '''
    Compare the subtrees whose roots are given.
    This is called only from unit tests.
    '''
    vc = self
    s1,s2 = vc.trial_write(root1),vc.trial_write(root2)
    if s1 == s2:
        return True
    g.trace('Compare:',root1.h,root2.h)
    p2 = root2.copy().moveToThreadNext()
    for p1 in root1.subtree():
        if p1.h == p2.h:
            g.trace('Match:',p1.h)
        else:
            g.trace('Fail: %s != %s' % (p1.h,p2.h))
            break
        p2.moveToThreadNext()
    return False
</t>
<t tx="ekr.20140112112622.16660"></t>
<t tx="ekr.20140112112622.16663">def copy_tree_to_last_child_of(self,p,parent):
    '''Copy p's tree to the last child of parent.'''
    vc = self
    assert p != parent,p
        # A failed assert leads to unbounded recursion.
    # print('copy_tree_to_last_child_of',p.h,parent.h)
    root = parent.insertAsLastChild()
    root.b,root.h = p.b,p.h
    root.v.u = copy.deepcopy(p.v.u)
    for child in p.children():
        vc.copy_tree_to_last_child_of(child,root)
    return root
</t>
<t tx="ekr.20140113181306.16690">def find_imported_organizer_nodes(self,root):
    '''
    Put the VNode of all imported nodes with children on
    vc.imported_organizers_list.
    '''
    trace = False # and not g.unitTesting
    vc = self
    aList = []
    for p in root.subtree():
        if p.hasChildren():
            aList.append(p.v)
    vc.imported_organizers_list = list(set(aList))
    if trace: g.trace([z.h for z in vc.imported_organizers_list])
</t>
<t tx="ekr.20140114145953.16696">def unl_tail(self,unl):
    '''Return the last part of a unl.'''
    return unl.split('--&gt;')[:-1][0]
</t>
<t tx="ekr.20140115052524.16699">​https://groups.google.com/d/msg/leo-editor/YjJdWjNSM9o/SDL7Nb__OUcJ

There is a way to allow clones *anywhere* in @file nodes and simplify Leo's
read code in the process! This might be one of the defining features of Leo
5.0.

The idea is for the read code to treat *all* nodes exactly the same
initially, regardless of whether they should actually be clones of each
other. A post-pass would then "unify" all vnodes having the same gnx.

Why, oh, why, did I never think of doing this? It will be *so* much simpler
than the present code!​ And it will be just as fast, maybe even faster.
Another example of generality arising from simplicity...

I can tell you why I *did* think of doing this now: the new @auto read
logic uses a new p._relinkAsCloneOf method, exactly what the @file read
post pass will use!
</t>
<t tx="ekr.20140115180051.16706">def compute_all_organized_positions(self,root):
    '''Compute the list of positions organized by every od.'''
    trace = False and not g.unitTesting
    vc = self
    for od in vc.all_ods:
        if od.unls:
            # Do a full search only for the first unl.
            ### parent = vc.find_position_for_relative_unl(root,od.unls[0])
            if True: ### parent:
                for unl in od.unls:
                    p = vc.find_position_for_relative_unl(root,unl)
                    ### p = vc.find_position_for_relative_unl(parent,vc.unl_tail(unl))
                    if p:
                        od.organized_nodes.append(p.copy())
                    if trace: g.trace('exists:',od.exists,
                        'od:',od.h,'unl:',unl,
                        'p:',p and p.h or '===== None')
            else:
                g.trace('fail',od.unls[0])
</t>
<t tx="ekr.20140115180051.16709">def precompute_all_data(self,at_organizers,root):
    '''Precompute all data needed to reorganize nodes.'''
    trace = False and not g.unitTesting
    vc = self
    t1 = time.clock() 
    vc.find_imported_organizer_nodes(root)
        # Put all nodes with children on vc.imported_organizer_node_list
    t2 = time.clock()
    vc.create_organizer_data(at_organizers,root)
        # Create OrganizerData objects for all @organizer:
        # and @existing-organizer: nodes.
    t3 = time.clock()
    vc.create_actual_organizer_nodes()
        # Create the organizer nodes in holding cells so positions remain valid.
    t4 = time.clock()
    vc.create_tree_structure(root)
        # Set od.parent_od, od.children &amp; od.descendants for all ods.
    t5 = time.clock()
    vc.compute_all_organized_positions(root)
        # Compute the positions organized by each organizer.
        # ** Most of the time is spent here **.
    t6 = time.clock()
    vc.create_anchors_d()
        # Create the dictionary that associates positions with ods.
    t7 = time.clock()
    if trace: g.trace(
        '\n  find_imported_organizer_nodes:   %4.2f sec' % (t2-t1),
        '\n  create_organizer_data:           %4.2f sec' % (t3-t2),
        '\n  create_actual_organizer_nodes:   %4.2f sec' % (t4-t3),
        '\n  create_tree_structure:           %4.2f sec' % (t5-t4),
        '\n  compute_all_organized_positions: %4.2f sec' % (t6-t5),
        '\n  create_anchors_d:                %4.2f sec' % (t7-t6))
</t>
<t tx="ekr.20140115215931.16707">def dump_list(self,aList,indent=4):
    '''Dump a list, one item per line.'''
    lead = '\n' + ' '*indent
    return lead+lead.join(sorted(aList))
</t>
<t tx="ekr.20140115215931.16710">def compare_trial_writes(self,s1,s2):
    '''
    Compare the two strings, the results of trial writes.
    Stop the comparison after the first mismatch.
    '''
    trace_matches = False
    full_compare = False
    lines1,lines2 = g.splitLines(s1),g.splitLines(s2)
    i,n1,n2 = 0,len(lines1),len(lines2)
    while i &lt; n1 and i &lt; n2:
        s1,s2 = lines1[i].rstrip(),lines2[i].rstrip()
        i += 1
        if s1 == s2:
            if trace_matches: g.trace('Match:',s1)
        else:
            g.trace('Fail:  %s != %s' % (s1,s2))
            if not full_compare: return
    if i &lt; n1:
        g.trace('Extra line 1:',lines1[i])
    if i &lt; n2:
        g.trace('Extra line 2:',lines2[i])
</t>
<t tx="ekr.20140117131738.16717">def add(self,active,p,tag):
    '''
    Add p, an existing (imported) node to the global work list.
    Subtract 1 from the vc.anchor_offset_d entry for p.parent().
    
    Exception: do *nothing* if p is a child of an existing organizer node.
    '''
    trace = False # and not g.unitTesting
    verbose = False
    vc = self
    # g.trace(active,g.callers())
    if active.p == p.parent() and active.exists:
        if trace and verbose: g.trace('===== do nothing',active.h,p.h)
    else:
        data = active.p,p.copy()
        vc.add_to_work_list(data,tag)
        vc.anchor_decr(anchor=p.parent(),p=p)
        
</t>
<t tx="ekr.20140117131738.16719">def add_to_pending(self,active,p):
    trace = False # and not g.unitTesting
    vc = self
    if trace: g.trace(active.p.h,'==&gt;',p.h)
    vc.pending.append((active,p.copy()),)
</t>
<t tx="ekr.20140117131738.16723">def enter_organizers(self,od,p):
    '''Enter all organizers whose anchors are p.'''
    vc = self
    ods = []
    while od:
        ods.append(od)
        od = od.parent_od
    if ods:
        for od in reversed(ods):
            vc.add_organizer_node(od,p)
</t>
<t tx="ekr.20140117131738.16724">def terminate_organizers(self,active,p):
    '''Terminate all organizers whose anchors are not ancestors of p.'''
    trace = False # and not g.unitTesting
    od = active
    while od and od.anchor != p and od.anchor.isAncestorOf(p):
        if not od.closed:
            if trace: g.trace('===== closing',od.h)
            od.closed = True
        od = od.parent_od
</t>
<t tx="ekr.20140117131738.16727">def create_anchors_d (self):
    '''
    Create vc.anchors_d.
    Keys are positions, values are lists of ods having that anchor.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = {}
    if trace: g.trace('all_ods',[z.h for z in vc.all_ods])
    for od in vc.all_ods:
        # Compute the anchor if it does not yet exists.
        # Valid now that p.__hash__ exists.
        key = od.anchor
        # key = '.'.join([str(z) for z in od.anchor.sort_key(od.anchor)])
        # key = '%s (%s)' % (key,od.anchor.h)
        aList = d.get(key,[])
        # g.trace(od.h,od.anchor.h,key,aList)
        aList.append(od)
        d[key] = aList
    if trace:
        for key in sorted(d.keys()):
            g.trace('od.anchor: %s ods: [%s]' % (key.h,','.join(z.h for z in d.get(key))))
    vc.anchors_d = d
</t>
<t tx="ekr.20140120105910.10488"></t>
<t tx="ekr.20140120105910.10490">def find_organizer(self,parent,p):
    '''Return the organizer that organizers p, if any.'''
    trace = False # and not g.unitTesting
    vc = self
    anchor = parent
    ods = vc.anchors_d.get(anchor,[])
    for od in ods:
        if p in od.organized_nodes:
            if trace: g.trace('found:',od.h,'for',p.h)
            return od
    return None
</t>
<t tx="ekr.20140123132424.10471">def create_at_headlines(self,root):
    '''Create the @headlines node for root, an @auto file.'''
    vc = self
    c = vc.c
    result = []
    ivar = vc.headline_ivar
    for p in root.subtree():
        h = getattr(p.v,ivar,None)
        if h is not None and p.h != h:
            # g.trace('custom:',p.h,'imported:',h)
            unl = vc.relative_unl(p,root)
            aList = unl.split('--&gt;')
            aList[-1] = h
            unl = '--&gt;'.join(aList)
            result.append('imported unl: %s\nhead: %s\n' % (
                unl,p.h))
            delattr(p.v,ivar)
    if result:
        p = vc.find_at_headlines_node(root)
        p.b = ''.join(result)
</t>
<t tx="ekr.20140123132424.10472">def find_special_nodes(self,root):
    '''
    Scan root's tree, looking for organizer and cloned nodes.
    Exclude organizers on imported organizers list.
    '''
    trace = False and not g.unitTesting
    verbose = False
    vc = self
    clones,existing_organizers,organizers = [],[],[]
    if trace: g.trace('imported existing',
        [v.h for v in vc.imported_organizers_list])
    for p in root.subtree():
        if p.isCloned():
            rep = vc.find_representative_node(root,p)
            if rep:
                unl = vc.relative_unl(p,root)
                gnx = rep.v.gnx
                clones.append((gnx,unl),)
        if p.v in vc.imported_organizers_list:
            # The node had children created by the importer.
            if trace and verbose: g.trace('ignore imported existing',p.h)
        elif vc.is_organizer_node(p,root):
            # p.hasChildren and p.b is empty, except for comments.
            if trace and verbose: g.trace('organizer',p.h)
            organizers.append(p.copy())
        elif p.hasChildren():
            if trace and verbose: g.trace('existing',p.h)
            existing_organizers.append(p.copy())
    return clones,existing_organizers,organizers
</t>
<t tx="ekr.20140123132424.10474">def find_at_headlines_node(self,root):
    '''
    Find the @headlines node for root, an @auto node.
    Create the @headlines node if it does not exist.
    '''
    vc = self
    c = vc.c
    h = '@headlines'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
</t>
<t tx="ekr.20140124111748.10635">def update_headlines_after_read(self,root):
    '''Handle custom headlines for all imported nodes.'''
    trace = False and not g.unitTesting
    vc = self
    # Remember the original imported headlines.
    ivar = vc.headline_ivar
    for p in root.subtree():
        if not hasattr(p.v,ivar):
            setattr(p.v,ivar,p.h)
    # Update headlines from @headlines nodes.
    at_headlines = vc.has_at_headlines_node(root)
    tag1,tag2 = 'imported unl: ','head: '
    n1,n2 = len(tag1),len(tag2)
    if at_headlines:
        lines = g.splitLines(at_headlines.b)
        unls  = [s[n1:].strip() for s in lines if s.startswith(tag1)]
        heads = [s[n2:].strip() for s in lines if s.startswith(tag2)]
    else:
        unls,heads = [],[]
    if len(unls) == len(heads):
        vc.headlines_dict = {} # May be out of date.
        for unl,head in zip(unls,heads):
            p = vc.find_position_for_relative_unl(root,unl)
            if p:
                if trace: g.trace('unl:',unl,p.h,'==&gt;',head)
                p.h = head
    else:
        g.trace('bad @headlines body',at_headlines.b)
</t>
<t tx="ekr.20140124111748.10637">def has_at_headlines_node(self,root):
    '''
    Find the @clones node for an @auto node with the given unl.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@headlines')
</t>
<t tx="ekr.20140125071842.10474">def convert_at_file_to_at_auto(self,root):
    # Define class ConvertController.
    @others
    vc = self
    c = vc.c
    if root.isAtFileNode():
        ConvertController(c,root).run()
    else:
        g.es_print('not an @file node:',root.h)
</t>
<t tx="ekr.20140125071842.10475">class ConvertController:
    def __init__ (self,c,p):
        self.c = c
        # self.ic = c.importCommands
        self.vc = c.viewController
        self.root = p.copy()
    @others
</t>
<t tx="ekr.20140125071842.10477">def import_from_string(self,s):
    '''Import from s into a temp outline.'''
    cc = self # (ConvertController)
    c = cc.c
    ic = c.importCommands
    root = cc.root
    language = g.scanForAtLanguage(c,root) 
    ext = '.'+g.app.language_extension_dict.get(language)
    scanner = ic.scanner_for_ext(ext)
    # g.trace(language,ext,scanner.__name__)
    p = root.insertAfter()
    ok = scanner(atAuto=True,parent=p,s=s)
    p.h = root.h.replace('@file','@auto' if ok else '@@auto')
    return ok,p
</t>
<t tx="ekr.20140125071842.10478">def run(self):
    '''Convert an @file tree to @auto tree.'''
    trace = True and not g.unitTesting
    trace_s = False
    cc = self
    c = cc.c
    root,vc = cc.root,c.viewController
    # set the headline_ivar for all vnodes.
    t1 = time.clock()
    cc.set_expected_imported_headlines(root)
    t2 = time.clock()
    # Delete all previous @auto-view nodes for this tree.
    cc.delete_at_auto_view_nodes(root)
    t3 = time.clock()
    # Ensure that all nodes of the tree are regularized.
    ok = vc.prepass(root)
    t4 = time.clock()
    if not ok:
        g.es_print('Can not convert',root.h,color='red')
        if trace: g.trace(
            '\n  set_expected_imported_headlines: %4.2f sec' % (t2-t1),
            # '\n  delete_at_auto_view_nodes:     %4.2f sec' % (t3-t2),
            '\n  prepass:                         %4.2f sec' % (t4-t3),
            '\n  total:                           %4.2f sec' % (t4-t1))
        return
    # Create the appropriate @auto-view node.
    at_auto_view = vc.update_before_write_at_auto_file(root)
    t5 = time.clock()
    # Write the @file node as if it were an @auto node.
    s = cc.strip_sentinels()
    t6 = time.clock()
    if trace and trace_s:
        g.trace('source file...\n',s)
    # Import the @auto string.
    ok,p = cc.import_from_string(s)
    t7 = time.clock()
    if ok:
        # Change at_auto_view.b so it matches p.gnx.
        at_auto_view.b = vc.at_auto_view_body(p)
        # Recreate the organizer nodes, headlines, etc.
        ok = vc.update_after_read_at_auto_file(p)
        t8 = time.clock()
        if not ok:
            p.h = '@@' + p.h
            g.trace('restoring original @auto file')
            ok,p = cc.import_from_string(s)
            if ok:
                p.h = '@@' + p.h + ' (restored)'
                if p.next():
                    p.moveAfter(p.next())
        t9 = time.clock()
    else:
        t8 = t9 = time.clock()
    if trace: g.trace(
        '\n  set_expected_imported_headlines: %4.2f sec' % (t2-t1),
        # '\n  delete_at_auto_view_nodes:     %4.2f sec' % (t3-t2),
        '\n  prepass:                         %4.2f sec' % (t4-t3),
        '\n  update_before_write_at_auto_file:%4.2f sec' % (t5-t4),
        '\n  strip_sentinels:                 %4.2f sec' % (t6-t5),
        '\n  import_from_string:              %4.2f sec' % (t7-t6),
        '\n  update_after_read_at_auto_file   %4.2f sec' % (t8-t7),
        '\n  import_from_string (restore)     %4.2f sec' % (t9-t8),
        '\n  total:                           %4.2f sec' % (t9-t1))
    if p:
        c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20140125071842.10479">def strip_sentinels(self):
    '''Write the file to a string without headlines or sentinels.'''
    trace = False and not g.unitTesting
    cc = self
    at = cc.c.atFileCommands
    # ok = at.writeOneAtAutoNode(cc.root,
        # toString=True,force=True,trialWrite=True)
    at.errors = 0
    at.write(cc.root,
        kind = '@file',
        nosentinels = True,
        perfectImportFlag = False,
        scriptWrite = False,
        thinFile = True,
        toString = True)
    ok = at.errors == 0
    s = at.stringOutput
    if trace: g.trace('ok:',ok,'s:...\n'+s)
    return s
</t>
<t tx="ekr.20140125141655.10476">def set_expected_imported_headlines(self,root):
    '''Set the headline_ivar for all vnodes.'''
    trace = False and not g.unitTesting
    cc = self
    c = cc.c
    ic = cc.c.importCommands
    language = g.scanForAtLanguage(c,root) 
    ext = '.'+g.app.language_extension_dict.get(language)
    aClass = ic.classDispatchDict.get(ext)
    scanner = aClass(importCommands=ic,atAuto=True)
    # Duplicate the fn logic from ic.createOutline.
    theDir = g.setDefaultDirectory(c,root,importing=True)
    fn = c.os_path_finalize_join(theDir,root.h)
    fn = root.h.replace('\\','/')
    junk,fn = g.os_path_split(fn)
    fn,junk = g.os_path_splitext(fn)
    if aClass and hasattr(scanner,'headlineForNode'):
        ivar = cc.vc.headline_ivar
        for p in root.subtree():
            if not hasattr(p.v,ivar):
                h = scanner.headlineForNode(fn,p)
                setattr(p.v,ivar,h)
                if trace and h != p.h:
                    g.trace('==&gt;',h) # p.h,'==&gt;',h
</t>
<t tx="ekr.20140126044100.15449">def create_ods(self,at_organizers):
    '''Create all organizer nodes and the associated lists.'''
    # Important: we must completely reinit all data here.
    vc = self
    tag1 = '@organizer:'
    tag2 = '@existing-organizer:'
    vc.all_ods,vc.existing_ods,vc.organizer_ods = [],[],[]
    for at_organizer in at_organizers.children():
        h = at_organizer.h
        for tag in (tag1,tag2):
            if h.startswith(tag):
                unls = vc.get_at_organizer_unls(at_organizer)
                if unls:
                    organizer_unl = vc.drop_unl_tail(unls[0])
                    h = h[len(tag):].strip()
                    od = OrganizerData(h,organizer_unl,unls)
                    vc.all_ods.append(od)
                    if tag == tag1:
                        vc.organizer_ods.append(od)
                        vc.organizer_unls.append(organizer_unl)
                    else:
                        vc.existing_ods.append(od)
                        # Do *not* append organizer_unl to the unl list.
                else:
                    g.trace('===== no unls:',at_organizer.h)
</t>
<t tx="ekr.20140126044100.15450">def finish_create_organizers(self,root):
    '''Finish creating all organizers.'''
    trace = False # and not g.unitTesting
    vc = self
    # Careful: we may delete items from this list.
    for od in vc.organizer_ods[:]: 
        od.source_unl = vc.source_unl(vc.organizer_unls,od.unl)
        od.parent = vc.find_position_for_relative_unl(root,od.source_unl)
        if od.parent:
            od.anchor = od.parent
            if trace: g.trace(od.h,
                # '\n  exists:',od.exists,
                # '\n  unl:',od.unl,
                # '\n  source (unl):',od.source_unl or repr(''),
                # '\n  anchor (pos):',od.anchor.h,
                # '\n  parent (pos):',od.parent.h,
            )
        else:
            # This is, most likely, a true error.
            g.trace('===== removing od:',od.h)
            vc.organizer_ods.remove(od)
            vc.all_ods.remove(od)
            assert od not in vc.existing_ods
            assert od not in vc.all_ods
</t>
<t tx="ekr.20140126044100.15451">def finish_create_existing_organizers(self,root):
    '''Finish creating existing organizer nodes.'''
    trace = False # and not g.unitTesting
    vc = self
    # Careful: we may delete items from this list.
    for od in vc.existing_ods[:]:
        od.exists = True
        assert od.unl not in vc.organizer_unls
        od.source_unl = vc.source_unl(vc.organizer_unls,od.unl)
        od.p = vc.find_position_for_relative_unl(root,od.source_unl)
        if od.p:
            od.anchor = od.p
            assert od.p.h == od.h,(od.p.h,od.h)  
            od.parent = od.p # Here, od.parent represents the "source" p.
            if trace: g.trace(od.h,
                # '\n  exists:',od.exists,
                # '\n  unl:',od.unl,
                # '\n  source (unl):',od.source_unl or repr(''),
                # '\n  anchor (pos):',od.anchor.h,
                # '\n  parent (pos):',od.parent.h,
            )
        else:
            # This arises when the imported node name doesn't match.
            g.trace('===== removing existing organizer:',od.h)
            vc.existing_ods.remove(od)
            vc.all_ods.remove(od)
            assert od not in vc.existing_ods
            assert od not in vc.all_ods

</t>
<t tx="ekr.20140127143108.15460">def anchor_decr(self,anchor,p): # p is only for traces.
    '''
    Decrement the anchor dict for the given anchor node.
    Return the *previous* value.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = vc.anchor_offset_d
    n = d.get(anchor,0)
    d[anchor] = n - 1
    if trace: g.trace(n-1,anchor.h,'==&gt;',p.h)
    return n
</t>
<t tx="ekr.20140127143108.15461">def anchor_incr(self,anchor,p): # p is only for traces.
    '''
    Increment the anchor dict for the given anchor node.
    Return the *previous* value.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = vc.anchor_offset_d
    n = d.get(anchor,0)
    d[anchor] = n + 1
    if trace: g.trace(n+1,anchor.h,'==&gt;',p.h)
    return n
</t>
<t tx="ekr.20140127143108.15462">def add_to_work_list(self,data,tag):
    '''Append the data to the work list, with tracing.'''
    trace = False # and not g.unitTesting
    vc = self
    vc.work_list.append(data)
    if trace:
        active,p = data
        g.trace('=====',tag,active.h,'==&gt;',p.h)
</t>
<t tx="ekr.20140127143108.15463">def add_to_bare_list(self,data,tag):
    '''Add data to the bare organizer list, with tracing.'''
    trace = False # and not g.unitTesting
    vc = self
    # Prevent duplicagtes.
    anchor,p,n = data
    for data2 in vc.global_bare_organizer_node_list:
        a2,p2,n2 = data2
        if p == p2:
            if trace: g.trace('ignore duplicate',
                'n:',n,anchor.h,'==&gt;',p.h)
            return
    vc.global_bare_organizer_node_list.append(data)
    if trace:
        anchor,p,n = data
        g.trace('=====',tag,'n:',n,anchor.h,'==&gt;',p.h)
            # '\n  anchor:',anchor.h,
            # '\n  p:',p.h)
</t>
<t tx="ekr.20140129164001.16251">def clear_pending(self,active,p):
    '''Clear the appropriate entries from the pending list.'''
    trace = False # and not g.unitTesting
    vc = self
    if trace: g.trace('===== clear pending',len(vc.pending))
    if False: # active and active.parent_od:
        for data in vc.pending:
            data = active.parent_od.p,data[1]
            vc.add_to_work_list(data,'clear-pending-to-active')
    vc.pending = []
</t>
<t tx="ekr.20140129164001.16252">def terminate_all_open_organizers(self):
    '''Terminate all open organizers.'''
    trace = True # and not g.unitTesting
    if 0: ###
        g.trace()
        for od in self.all_ods:
            if od.opened and not od.closed:
                if trace: g.trace('===== closing',od.h)
                od.closed = True
</t>
<t tx="ekr.20140202110830.17501">def delete_at_auto_view_nodes(self,root):
    '''Delete all @auto-view nodes pertaining to root.'''
    cc = self
    vc = cc.vc
    while True:
        p = vc.has_at_auto_view_node(root)
        if not p: break
        p.doDelete()
</t>
<t tx="ekr.20140212062130.16585">@language rest


</t>
<t tx="ekr.20140212062130.16586">Two major new Aha's have appeared. As often happens, they were the result
of a new distinction:

  **Nested** organizer nodes will become children of *other* organizer nodes.

  **Bare** organizer nodes will become children of *ordinary* nodes.
</t>
<t tx="ekr.20140212062130.16587">Aha 1: We don't have to compute child indices for nodes moved to children
of organizer nodes!

We simply put them on a list (in imported outline order) of tuples
(parent,moved_node). There will be only *one* such list, say
vc.global_moved_node_list.

When the time comes to do the actual moves, we do the following:

- Reverse the global list, thereby guaranteeing that positions that appear
   later in the reversed list remain valid.
- Insert each item on the list as the *last* child of the parent
   (organizer) node.
   
​There is a small, easily corrected, hole in this argument. It assumes that
positions appear in the list in outline order. That's usually so, but not
always. Indeed, @organizer: nodes *are* written in outline order, as are
their contents, but rearrangements in the imported outline could
conceivably mean that the nodes corresponding to @organizer nodes would not
be handled in the *new* outline order. This is easily remedied: just sort
the list in (imported) outline order before reversing it

That's all!

Using a global list was hard to see, because typically such schemes don't
work in recursive environments. But the @auto-view algorithms are *not*
recursive. Each @organizer: node is handled separately, in a completely
linear fashion, by vc.demote_helper, the true main line of the code.

Aha 2:  We can treat *nested* organizer nodes just as we treat ordinary nodes!

vc.switch_active_organizer (the code that handles the entry into an
organizer node) will simply add another entry (parent,organizer_node) to
the global move list.

Not having to track most child indices is a major collapse in complexity.
Indeed, the code that moves nodes to their final destinations will have no
"if" statements at all. It doesn't get any more solid than that.
</t>
<t tx="ekr.20140212062130.16588">===== Moving bare organizer nodes.

Now that moving most nodes has become trivial, the only remaining task is
to *safely* move bare organizers. This task has two parts:

1. Determine the proper child index of *bare* organizer nodes.

This will be done in the main line: vc.demote_helper will maintain a count
n of imported nodes that *haven't* been assigned to organizer nodes. This
count must also be incremented to include bare organizer nodes the will be
inserted later. It's just a bit tricky, but there are only a few cases to
get right. Once it works, it will work forever.

There will be another global list, say vc.global_bare_organizer_node_list,
containing tuples (parent,bare_organizer,n). vc.switch_active_organizer
will add entries to this list, but *only* for bare organizer nodes.

2. Actually move the bare organizer nodes.

The children of bare organizer nodes will appear vc.global_moved_node_list.
Each (ordinary) parent node may contain several bare organizer nodes. Here
is how to get the job done safely:

- For each parent, create a new per-parent list, containing all entries of
  the global list with that parent.
- Sort each per-parent list using n as the key.
- Move the nodes in each per-parent list to their destinations, in sorted
  order.

At first glace, this seems entirely bogus. How are we to ensure that
positions stay valid?

Unlike for ordinary nodes, we can't process bare organizer nodes in reverse
outline order: we have to handle them in the *new* sibling order, that is,
sorted by n. In other words, it won't work to move them to the last child
of their parent! Nor can we move nodes to any arbitrary sibling position:
we must move nodes with smaller child indices before moving nodes with
larger child indices.

To solve this problem, the setup code places each organizer node in a
separate **holding cell**. Moving the bare organizer out of a holding cell
to its final resting place affects no other holding cells, and no other
organizer node.


</t>
<t tx="ekr.20140212062130.16589">This post contains important insights for both users and developers.

The symptom of the bugs is that *non-bare* organizer nodes are not placed
in correct sibling order. As you recall, the value of n in the main line,
demote_helper, matters only for *bare* organizer nodes. So the proximate
cause of the problem is that pending nodes aren't entered on the global
node list before entering the organizers.

As we shall see below, the more fundamental problem is that the code does
not fully account for the outline relationships between organizer nodes. As
a result, the existing code does not always open and close organizer nodes
properly. (An organizer node is open when it may accumulated organized
nodes; an organizer node is closed when it can no longer accumulate
organized nodes without changing the order of the nodes in the @auto file.)

Two examples will illustrate the subtleties, and will lead naturally to a
new distinction, that of an **intermediate organizer** node.

Let's start with an easy case.  Suppose the organizer structure is:

  - @auto x.py
    - leading nodes
    - organizer A
       - node 1
       - organizer B
           - node 2
       - organizer C
       - node 3
    - organizer D

Clearly, the children of organizer A should be: node1, organizer B,
organizer C and node 3. That is, we must *not* close organizer A just
because we have entered organizer B or organizer C. Otoh, we *must* close
organizer A when we see organizer D.

The rule is clear: we must close an organizer whenever we see another
organizer that is not a descendant organizer.

The existing code creates parent/child data for OrganizerData instances. It
will be straightforward to add descendant relationships.

Let's consider another case:

- @auto x.py
    - leading nodes
    - organizer A
       - organizer B
         - organizer C
           - node 1
 
Here, organizer B is an **intermediate organizer** node. That is, it occurs
"between" organizers A and C.

Adding node 1 to the global node list should open organizer B, but the
present code does not. The present code opens an organizer node only when
adding a node to the organizer, but this example shows that organizer B
must be added to the global node list *before* any node is added to it.
Failure to do so results in organizer B being put in the wrong place.
</t>
<t tx="ekr.20140212062130.16590">As I was thinking about the outline relationships between organizer nodes,
I began to worry that minor changes to the imported @auto file might break
those relationships. In fact, the reverse is true: the relationships
between organizer nodes are *independent* of the @auto file!

The reason is simple: those relationships are created by the unl's in
@organizer: nodes in the .leo file. Furthermore, reorganizing the *outline*
will automatically update the unls in the @organizer nodes (in the @views
node) when the outline is saved. Thus, the *relationships* between
organizer nodes can never be broken by changes to the @auto node! This is
really important for users to know.

And there is more good news. Changing the contents of the @auto files can
indeed change the contents of organizer nodes, but the only way to totally
invalidate an organizer node is to change the *structural* relationships of
data in the @auto file. This almost never happens!

For example, if aClass is defined at the top level of the @auto file, then
the only way to invalidate the organizers that contain aClass or its
members is to move aClass so it is not a top-level node. But Leo's
importers will put aClass at the top level unless it becomes a nested class
in some other class! To repeat, this kind massive change to the context of
a class, function or method almost never happens.

In short, the links between unls (in @organizer: nodes) and imported
classes, methods and functions almost never break! This is truly great
news.
</t>
<t tx="ekr.20140212062130.16591">The following insights are important for users (and maintainers) to know:

- Changing an @auto file does not change the relationships between its
  organizer nodes in any way.
- Saving an outline automatically updates the relationships between
  organizer nodes.
- Unl's are much more stable than one might suppose: the *only* way to
  "break" organizer nodes is to change the fundamental relationships of
  classes, methods or functions in the imported @auto file. This almost
  *never* happens.
</t>
<t tx="ekr.20140212062130.16592">Headlines matter The unls will break if the headlines produced by *the
importer* don't match those unls. There are two cases to consider:

A. Section references. At present, Leo will abort the writing of an @auto
    tree that contains section references. Instead, Leo could write the
    expansion of the section reference. In practice, changing section
    definition nodes to ordinary nodes by hand isn't a big deal, but it
    would be nice for Leo to do that for the user.

B. Headlines for classes, methods and functions.

This is the important case. Most of my headlines look like x.y (z), where x
is some kind of indication of the class and y is the actual class, method
or function name and z is a optional comment. When converting from @file to
@auto *all* of the organizers will break unless the headline becomes just
"y".

Perhaps the best solution is to ask the importer what name it will give to
the node. Yes, this involves parsing the contents of the node. It will
likely require a new interface method of the baseScannerClass.
</t>
<t tx="ekr.20140212062130.16593">There are *two* kinds of organizer nodes:

- those that do *not* exist in the imported outline (these now work).
- those that *do* exist in the imported outline.

For example, I usually put the helpers of method X as children of X. There
is *no way* for the read logic to recreate such nodes at present, because
the parent/child relationships are do not exist in the @auto file. So X is
an organizer node!

Happily, it should be relatively straightforward to support **existing
organizers**:

1. The write code will represent existing organizers with
    @existing-organizer: nodes rather than @organizer: nodes. As with
    @organizer: nodes, the headline will contain the headline of the
    organizer node; the body will be a list of unls.

The write code can easily discover existing organizers: they are nodes with
children that contain something other than comments and blank lines.

2. The read code will create OrganizerData entries for @existing-organizer
   nodes just as with @organizer: nodes. A new ivar, data.existing, will
   distinguish between @organizer: and @existing-organizer nodes. These new
   entries will be members of a new global list of all organizer nodes.

The goal will be to confine tests of data.existing to the setup code. That
way, all the hard code will continue to work as is. We shall see whether
this is possible.

3. The code that munges unls will drop unls for a data object only if
   data.existing is False. This may be more tricky than it sounds. In any
   case, this is the fundamental reason why @existing-organizer: nodes
   *must* exist.
</t>
<t tx="ekr.20140212062130.16594">@language rest

After several hours staring at traces, I realized that *all* the problems
were in vc.move_nodes_to_organizers. That is, vc.global_moved_node_list,
the global move node list, was completely correct! This was not obvious,
because that trace in vc.move_nodes_to_organizers reported the *sorted*
version of the global move list. Bad idea: it was the sorting itself that
was causing all the problems!

Recall that I thought sorting the list was required to keep positions
unchanged until they are moved. But an hour or so of experimentation (at
3am) convinced me that there is *no way* to move items from sorted lists
into the correct positions.

After a few minutes of noodling, the solution finally appeared. Rather than
*moving* nodes by moving positions, the *only* way that leaves
to-be-considered positions intact is to *copy* all the nodes of a
position's tree to the correct place. Eureka! A new method,
vc.copy_tree_to_last_child_of does the actual copying. A final phase in
vc.move_nodes_to_organizers deletes all positions in reverse outline order.
So yes, sorting *is* essential, but only at the very end.

Note: these difficulties do not apply to bare organizer nodes, because each
is placed in its own holding cell. But it's not possible to create holding
cells for non-bare organizers.

</t>
<t tx="ekr.20140212062130.16595">Recall that *existing* organizer nodes are organizer nodes that the
importer will have created. Last night, after everything worked, I
reconsidered the design of existing organizer nodes in the light of the new
code. I wondered whether the existing code would correctly move such nodes
into their correct final positions.

The short answer is yes, because the importer will *not* have created any
children for existing organizer nodes. That being so, everything is
*exactly* as it is for organizer nodes, except that demote_helper and its
helpers never need to create the organizer. Some complications may arise,
but I expect them all to be minor.
</t>
<t tx="ekr.20140212062130.16596">In a previous post I wrote the new @auto write code could just warn if a
headline has changed since the @auto file was read. Wrong! It would be
*unbearable* to have to lose custom headlines. The new code must save and
restore headlines that don't match the **standard headlines**, the
headlines that the importer will give the node the *next* time the importer
reads the @auto file.

A new @headlines node (a child of the @auto-view node for the @auto file)
will contain the required data. It will contain pairs of lines, much like
@clones::

    unl: &lt;a unl&gt;
    head: &lt;the custom headline&gt;

The unls in the @headlines node must use standard headlines! The "links"
created by @headlines node will break if the body text of a node changes so
as to change its standard headline. That is, @headlines links will break
when class, method or function names change.

To combat such breakage, whenever the body text of a node changes the code
that writes the @headlines node should *recompute* the unl using a
to-be-written convenience method in leoImport.py. The convenience method
will return the new standard headline.
</t>
<t tx="ekr.20140212062130.16597">When converting an @file node to @auto *every* body text must be considered
changed. All unls in the @headlines node must be set using the headline
that the importer will create for the corresponding node.
</t>
<t tx="ekr.20140212062130.16598">​1. The hard part of the code involves moving nodes.

vc.global_moved_node_list is the backbone of the entire algorithm.
vc.demote_helper and its helpers add items to the list. vc.move_nodes and
its helpers remove items from the list. Very few significant "if"
statements exist:

Both vc.demote_helper and vc.move_nodes_to_organizers (the hard part of
vc.move_nodes) are straightforward. Very few if statements exist:

- The "main switch" in demote_helper is likely already correct and will
  have only localized consequences

- The single "if" statement in vc.move_nodes_to_organizers (the hard part
  of vc.move_nodes) reflects the fundamental distinction: nodes that must
  be copied vs. nodes that can be moved immediately.

2. Newly-installed traces make it clear what is happening.

This is surprisingly important. If bugs exist, it will be easy to recreate
them using unit tests that show, in compact, easy-to-understand dumps,
exactly what is happening.

3. Everything is easy after nodes have been moved.

Just for example, remembering nodes initial (standard) headlines is easy:
just create a dict whose keys are *vnodes* and whose values are the
standard headlines. A node's vnode does not change when the node moves, so
complications in the node-moving algorithm have *no* effect.

In short, only the node-moving algorithm (on both "sides" of the global
move list) has any potential for nasty bugs. The vast majority of those
bugs are gone, and will be easily fixed if any remain. Everything else is
completely routine bookkeeping.

4. Minimizing "if" statements.

I've worked hard to make all code as simple as possible.
</t>
<t tx="ekr.20140212062130.16599">@language rest

'''
The main line of the @auto-view algorithm. Traverse root's entire tree,
placing items on the global work list.

About the algorithm:

Moving *any* kind of node to an *ordinary* (non-existing) organizer is
easy: each node is moved to the last child of the organizer.

Moving nodes to *existing* organizers requires exact housekeeping. This
code must know at what child index to insert a node.

Terminology:
- p is the to-be-moved node.
- a(p) is p's **anchor**, an existing node.  a(p) == p.parent(). 
- o(p) be the *existing* organizer to which p will be moved as a child.  
- d is the global **offset dict**, vc.anchor_offset_d.

There are two cases to consider when moving a node p to an existing node:

Existing organizer case 1: p is *any kind* of existing node (organizer or not).

We insert p as the n'th child of o, where:

    n = p.childIndex() + d.get(p.parent(),0)

Existing organizer case 2: p is an non-existing node.

p must be an organizer node (because it doesn't exist) and it must be a
*bare* organizer node because o(p) is an existing organizer.

Let p2 be the (existing) node that causes p to be inserted.

We insert p as the n'th child of o(p), where:

    n = p2.childIndex() + d.get(p2.parent(),0)

The only remaining part of the puzzle is calculating the offsets, that is,
the entries in d. The simplifying insights:

Insight 1: We only calculate offsets for *existing* nodes.

Insight 2: Because the organizer exists in this case,
           the anchor is the existing organizer: a(p) == o(p)

Insight 3. Only inserting or deleting nodes from existing node can change offsets.

With these insights firmly in mind we can consider the following offset
cases:

Offset case 1: visiting existing children of existing organizers.

By definition, the importer will create children of existing organizers.
These nodes must *not* be moved: they are already in their correct spots!

Offset case 2: adding a non-existing organizer node p to any existing (organizer) node o:

This case adds one to d.get(o)

Offset case 3: moving an existing node p to *any* organizer node, existing or not.

This case subtracts one from d.get(p.parent())
'''

# Note: o may be:
# - a bare (ordinary) organizer node,
# - an ordinary organizer node,
# - a bare existing organizer node
# - an existing organizer node that is a child of another organizer node.
</t>
<t tx="ekr.20140216125129.16666"></t>
<t tx="ekr.20140306114536.16869">@language rest

How to select multiple nodes?  Did I disable multiple selections??

They work from the rclick menu, but not from the minibuffer.
- Should handle clone and delete and move, at least.
</t>
<t tx="ekr.20140312052111.16811">@language rest

https://groups.google.com/forum/#!topic/leo-editor/gEktoPf6aVc

    I've put adding new reload-abbreviations and reload-key-bindings
    commands on the list of things to do asap. These are non-trivial
    commands, but they should have been ​done ​ years ago. I'll see what I
    can do in the next day or so.


​Updating the configuration tables in leoConfig.py is straightforward, a​s
it turns out. Naturally, there are complications, all involved cached
settings, in one forma or another.

1. The easy cases: use properties.

There are about 60 or 70 places in the code where config settings are
stored in an ivar. Usually for readability, not for speed.

The solution (tested) is simple: rather than do:

    self.setting_ivar = c.config.getX('a-setting-name')

Leo could define a property:

    @property
    def setting_ivar(self):
        return c.config.getX('a-setting-name')

No other changes required. The existing code will test self.setting_ivar
exactly as before, but now any recent changes to the setting will have
effect.

I'll make these changes using a script.

2. The harder cases: use a reload_setting method in the affected classes.

Several subcommanders create tables on startup using config settings.
c.abbrevCommands is one such subcommander.

These classes should have a reload_settings method, called whenever
settings are dynamically reloaded.

Key bindings are the hardest case: the tables for key bindings are
mind-bogglingly complex. k.reload_settings would be a piece of work, but in
theory it should be possible.
</t>
<t tx="ekr.20140322090829.16832">@language rest

* Improve traces for __init__:

* Optionally print g.callers.

* Distinguish between calls &amp; returns.
    ? Just print return trace if it immediate follows the call trace.
    - Have a return-only trace list.

? Allow stops at each trace: drop into pdb??
</t>
<t tx="ekr.20140402091953.16863"># http://rope.sourceforge.net/library.html

import rope.base.project as project
print(project)

# myproject = project.Project('/path/to/myproject')
</t>
<t tx="ekr.20140424102007.16875">def linkCloneFindAllNode(self,p):
    '''Link p into the outline as the last top-level node.'''
    c = self.c
    top = c.rootPosition()
    while top.hasNext():
        top.moveToNext()
    p._linkAfter(top)
</t>
<t tx="ekr.20140426030229.16869"></t>
<t tx="ekr.20140521095206.16728"></t>
<t tx="ekr.20140526082700.17394">class TypeInferrer (AstFullTraverser):
    
    '''A class to infer the types of objects.'''
    
    def __init__ (self):
        AstFullTraverser.__init__(self)

    def __call__(self,node):
        return self.run(node)
    
    @others
</t>
<t tx="ekr.20140526082700.17395">def clean (self,aList):
    
    '''Return sorted(aList) with all duplicates removed.'''
    
    if 1:
        return aList or []
    else:
        ti = self
        if 1:
            # Good for debugging and traces.
            result = []
            for z in aList:
                if z not in result:
                    result.append(z)
            
            # An excellent check.
            assert len(result) == len(list(set(aList))),aList
        else:
            result = list(set(aList))
       
        # Strip out inference errors if there are real results.
        result2 = ti.ignore_failures(result)
        if result2:
            ti.stats.n_clean_success += 1
            return sorted(result2)
        else:
            ti.stats.n_clean_fail += 1
            return sorted(result)
</t>
<t tx="ekr.20140526082700.17396">def format(self,node):
    
    u = self.u
    return '%s%s' % (
        ' '*u.compute_node_level(node),
        u.first_line(u.format(node)))
</t>
<t tx="ekr.20140526082700.17397">def init(self):

    self.stats = Stats()
    self.u = Utils()
    
    # Local stats
    self.n_nodes = 0
    
    # Detecting circular inferences
    self.call_stack = [] # Detects recursive calls
    self.assign_stack = [] # Detects circular assignments.

    # Create singleton instances of simple types.
    self.bool_type = Bool_Type()
    self.builtin_type = Builtin_Type()
    self.bytes_type = Bytes_Type()
    self.float_type = Float_Type()
    self.int_type = Int_Type()
    self.none_type = None_Type()
    self.string_type = String_Type()

    # Create the builtin type dict.
    self.builtin_type_dict = {
        'eval': [self.none_type],
        'id':   [self.int_type],
        'len':  [self.int_type],
        'ord':  [self.int_type],
        # list,tuple...
        # close,open,sort,sorted,super...
    }
</t>
<t tx="ekr.20140526082700.17398">def run (self,root):
    
    self.init()
    self.visit(root)
</t>
<t tx="ekr.20140526082700.17399">def has_failed(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Inference_Failure) for z in t1+t2+t3])
    
def is_circular(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Circular_Assignment) for z in t1+t2+t3])
    
def is_recursive(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Recursive_Inference) for z in t1+t2+t3])
    
def ignore_failures(self,t1,t2=[],t3=[]):
    
    return [z for z in t1+t2+t3 if not isinstance(z,Inference_Failure)]
    
def ignore_unknowns(self,t1,t2=[],t3=[]):
    
    return [z for z in t1+t2+t3 if not isinstance(z,(Unknown_Type,Unknown_Arg_Type))]
    
def merge_failures(self,t1,t2=[],t3=[]):

    aList = [z for z in t1+t2+t3 if isinstance(z,Inference_Failure)]
    if len(aList) &gt; 1:
        # Prefer the most specific reason for failure.
        aList = [z for z in aList if not isinstance(z,Unknown_Type)]
    return aList
</t>
<t tx="ekr.20140526082700.17400">def visit(self,node):

    '''Visit a single node.  Callers are responsible for visiting children.'''

    # This assert is redundant.
    # assert isinstance(node,ast.AST),node.__class__.__name__
    method = getattr(self,'do_' + node.__class__.__name__)
    self.n_nodes += 1
    return method(node)
</t>
<t tx="ekr.20140526082700.17401"></t>
<t tx="ekr.20140526082700.17402"></t>
<t tx="ekr.20140526082700.17403"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute (self,node):

    ti = self
    trace = False and not g.app.runningAllUnitTests
    
    # g.trace(ti.format(node),node.value,node.attr)
    t = ti.visit(node.value) or [] ###
    t = ti.clean(t)
    t = ti.merge_failures(t)
    tag = '%s.%s' % (t,node.attr) # node.attr is always a string.
    if t:
        if len(t) == 1:
            ti.stats.n_not_fuzzy += 1
            t1 = t[0]
            if ti.kind(t1) == 'Class_Type':
                aList = t1.cx.ivars_dict.get(node.attr)
                aList = ti.clean(aList) if aList else []
                if aList:
                    t = []
                    for node2 in aList:
                        t.extend(ti.visit(node2))
                    t = ti.clean(t)
                    ti.set_cache(node,t,tag='ti.Attribute')
                    ti.stats.n_attr_success += 1
                    if trace and trace_found:
                        g.trace('ivar found: %s -&gt; %s' % (tag,t))
                elif t1.cx.bases:
                    if trace_errors: g.trace('bases',
                        ti.format(node),ti.format(t1.cx.bases))
                    ### Must check super classes.
                    t = [Unknown_Type(node)]
                else:
                    u.error('%20s has no %s member' % (ti.format(node),t1.cx.name))
                    t = [Unknown_Type(node)]
            else:
                ti.stats.n_attr_fail += 1
                if trace and trace_errors:
                    g.trace('fail',t,ti.format(node))
                t = [Unknown_Type(node)]
        else:
            ti.stats.n_fuzzy += 1
            if trace and trace_fuzzy: g.trace('fuzzy',t,ti.format(node))
    else:
        if trace and trace_errors: g.trace('fail',t,ti.format(node))
        t = [Unknown_Type(node)]
    # ti.check_attr(node) # Does nothing
    return t
</t>
<t tx="ekr.20140526082700.17404">def check_attr(self,node):
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    
    return ### Now done in ti.Attribute

    # assert ti.kind(node) == 'Attribute'
    # value = node.value
    # # node.attr is always a string.
    
    # if ti.kind(value) == 'Name':
        # # The ssa pass has computed the ivars dict.
        # # There is no need to examine value.ctx.
        # name = value.id
        # name_e = value.e
        # name_cx = name_e.cx
        # name_class_cx = name_cx.class_context
        # if name == 'self':
            # if name_class_cx:
                # if node.attr in name_class_cx.ivars_dict:
                    # if trace: g.trace('OK: %s.%s' % (
                        # name_class_cx.name,node.attr))
                # else:
                    # ti.error('%s has no %s member' % (
                        # name_class_cx.name,node.attr))
            # else:
                # ti.error('%s is not a method of any class' % (
                    # name)) ####
        # else:
            # ### To do: handle any id whose inferred type is a class or instance.
            # if trace:
                # g.trace('** not checked: %s' % (name))
                # g.trace(ti.u.dump_ast(value))
</t>
<t tx="ekr.20140526082700.17405">def do_BinOp (self,node):

    ti = self
    trace = True and not g.app.runningAllUnitTests
    trace_infer = False ; trace_fail = False
    lt = ti.visit(node.left) or []
    rt = ti.visit(node.right) or []
    lt = ti.clean(lt)
    rt = ti.clean(rt)
    op_kind = ti.kind(node.op)
    num_types = ([ti.float_type],[ti.int_type])
    list_type = [List_Type(None)]
    if rt in num_types and lt in num_types:
        if rt == [ti.float_type] or lt == [ti.float_type]:
            t = [ti.float_type]
        else:
            t = [ti.int_type]
    elif rt == list_type and lt == list_type and op_kind == 'Add':
        t = list_type
    elif op_kind == 'Add' and rt == [ti.string_type] and lt == [ti.string_type]:
        t = [ti.string_type]
    elif op_kind == 'Mult' and rt == [ti.string_type] and lt == [ti.string_type]:
        g.trace('*** User error: string mult')
        t = [Unknown_Type(node)]
    elif op_kind == 'Mult' and (
        (lt==[ti.string_type] and rt==[ti.int_type]) or
        (lt==[ti.int_type] and rt==[ti.string_type])
    ):
        t = [ti.string_type]
    elif op_kind == 'Mod' and lt == [ti.string_type]:
        t = [ti.string_type] # (string % anything) is a string.
    else:
        ti.stats.n_binop_fail += 1
        if trace and trace_fail:
            if 1:
                s = '%r %s %r' % (lt,op_kind,rt)
                g.trace('  fail: %30s %s' % (s,ti.format(node)))
            else:
                g.trace('  fail:',lt,op_kind,rt,ti.format(node))
        t = [Inference_Error(node)] ### Should merge types!
    if trace and trace_infer: g.trace(ti.format(node),'-&gt;',t)
    return t
</t>
<t tx="ekr.20140526082700.17406">def do_BoolOp(self,node):

    ti = self    
    return [ti.bool_type]
</t>
<t tx="ekr.20140526082700.17407"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   Note: node.starargs and node.kwargs are given only if assigned explicitly.

def do_Call (self,node):
    '''
    Infer the value of a function called with a particular set of arguments.
    '''
    ti = self
    trace = False and not g.app.runningAllUnitTests
    trace_builtins = True
    trace_errors = True ; trace_returns = False

    kind = ti.kind(node)
    func_name = ti.find_function_call(node)
    
    if trace: g.trace('1:entry:',func_name) # ,before='\n',
    
    # Special case builtins.
    t = ti.builtin_type_dict.get(func_name,[])
    if t:
        if trace and trace_builtins: g.trace(func_name,t)
        return t
        
    # Find the def or ctor to be evaluated.
    e = ti.find_call_e(node.func)
    if not (e and e.node):
        # find_call_e has given the warning.
        t = [Unknown_Type(node)]
        s = '%s(**no e**)' % (func_name)
        if trace and trace_errors: g.trace('%17s -&gt; %s' % (s,t))
        return t

    # Special case classes.  More work is needed.
    if ti.kind(e.node) == 'ClassDef':
        # Return a type representing an instance of the class
        # whose ctor is evaluated in the present context.
        args,t = ti.class_instance(e)
        if trace and trace_returns:
            s = '%s(%s)' % (func_name,args)
            g.trace('%17s -&gt; %s' % (s,t))
        return t

    # Infer the specific arguments and gather them in args list.
    # Each element of the args list may have multiple types.
    assert ti.kind(e.node) == 'FunctionDef'
    args = ti.infer_actual_args(e,node)
        
    # Infer the function for the cross-product the args list.
    # In the cross product, each argument has exactly one type.
    ti.stats.n_ti_calls += 1
    recursive_args,t = [],[]
    t2 = ti.infer_def(node,rescan_flag=False) ### specific_args,e,node,)
    if ti.is_recursive(t2):
        recursive_args.append(t2)
    t.extend(t2)

    if True and recursive_args:
        if trace: g.trace('===== rerunning inference =====',t)
        for t2 in recursive_args:
            t3 = ti.infer_def(node,rescan_flag=True) ### specific_args,e,node,rescan_flag=True)
            t.extend(t3)
        
    if ti.has_failed(t):
        t = ti.merge_failures(t)
        # t = ti.ignore_failures(t)
    else:
        t = ti.clean(t)
    if trace and trace_returns:
        s = '3:return %s(%s)' % (func_name,args)
        g.trace('%17s -&gt; %s' % (s,t))
    return t
</t>
<t tx="ekr.20140526082700.17408">def class_instance (self,e):
    
    '''
    Return a type representing an instance of the class
    whose ctor is evaluated in the present context.
    '''
    
    ti = self
    trace = True and not g.app.runningAllUnitTests
    cx = e.self_context
    
    # Step 1: find the ctor if it exists.
    d = cx.st.d
    ctor = d.get('__init__')

    # node2 = node.value
    # name = node2.id
    # attr = node.attr
    # e = getattr(node2,'e',None)
    # if trace: g.trace(kind,v_kind,name,attr)
    # # g.trace('e',e)
    # t = ti.get_cache(e)
    # # g.trace('cache',t)
    # if len(t) == 1:
        # t = t[0]
        # e_value = t.node.e
        # # g.trace('* e_value',e_value)
        # # g.trace('e_value.self_context',e_value.self_context)
        # e = e_value.self_context.st.d.get(node.attr)
        # if trace: g.trace('** e_value.self_context.st.d.get(%s)' % (attr),e)
        # # g.trace('e_value.self_context.st.d', e_value.self_context.st.d)
        # # g.trace('e.node',e.node)
        
    args = [] ### To do
    t = [Class_Type(cx)]
    # ti.set_cache(e,t,tag='class name')
    return args,t
</t>
<t tx="ekr.20140526082700.17409">def find_call_e (self,node):
    
    '''Find the symbol table entry for node, an ast.Call node.'''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    trace_errors = False; trace_fuzzy = True ; trace_return = False
    kind = ti.kind(node)
    e = None # Default.
    if kind == 'Name':
        # if trace: g.trace(kind,node.id)
        e = getattr(node,'e',None)
    else:
        t = ti.visit(node) or []
        if len(t) == 1:
            ti.stats.n_not_fuzzy += 1
            t = t[0]
            if ti.kind(t) == 'Class_Type':
                d = t.cx.st.d
                if ti.kind(node) == 'Attribute':
                    name = node.attr
                elif ti.kind(node) == 'Call':
                    name = node.func
                else:
                    name = None
                if name:
                    e = d.get(name)
                else:
                    e = None
            else:
                if trace and trace_errors:
                    g.trace('not a class type: %s %s' % (ti.kind(t),ti.format(node)))
        elif len(t) &gt; 1:
            if trace and trace_fuzzy: g.trace('fuzzy',t,ti.format(node))
            ti.stats.n_fuzzy += 1
            e = None
        
    # elif kind == 'Attribute':
        # v_kind = ti.kind(node.value)
        # if v_kind == 'Name':
            # node2 = node.value
            # name = node2.id
            # attr = node.attr
            # e = getattr(node2,'e',None)
            # # if trace: g.trace(kind,v_kind,name,attr)
            # t = ti.get_cache(e)
            # if len(t) == 1:
                # t = t[0]
                # if ti.kind(t) == 'Class_Type':
                    # d = t.cx.st.d
                    # e = d.get(node.attr)
                # else:
                    # pass ### To do
            # elif t:
                # pass
            # else:
                # t = [Unknown_Type(node)]
        # elif v_kind == 'Attribute':
            # node2 = node.value
            # g.trace('*****',kind,v_kind,ti.format(node.value))
            # e = ti.find_call_e(node2)
        # else:
            # g.trace('not ready yet',kind,v_kind)
            # e = None
    # elif kind in ('Call','Subscript'):
        # g.trace(kind)
        # e = None
    # else:
        # g.trace('===== oops:',kind)
        # e = None
        
    # if e:
        # assert isinstance(e,SymbolTableEntry),ti.kind(e)
        # ti.stats.n_find_call_e_success += 1
    # else:
        # # Can happen with methods,Lambda.
        # ti.stats.n_find_call_e_fail += 1
        # if trace and trace_errors: g.trace('**** no e!',kind,ti.format(node),
            # before='\n')

    # if e and not e.node:
        # if trace and trace_errors: g.trace(
            # 'undefined e: %s' % (e),before='\n')

    # if trace and trace_return: g.trace(
        # kind,'e:',e,ti.format(node))
    # return e
</t>
<t tx="ekr.20140526082700.17410"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   keyword = (identifier arg, expr value) # keyword arguments supplied to call

# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def infer_actual_args (self,e,node):
    
    '''Return a list of types for all actual args, in the order defined in
    by the entire formal argument list.'''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    trace_args = False
    assert ti.kind(node)=='Call'
    cx = e.self_context
    # Formals...
    formals  = cx.node.args or []
    defaults = cx.node.args.defaults or [] # A list of expressions
    vararg   = cx.node.args.vararg
    kwarg    = cx.node.args.kwarg
    # Actuals...
    actuals  = node.args or [] # A list of expressions.
    keywords = node.keywords or [] # A list of (identifier,expression) pairs.
    starargs = node.starargs
    kwargs   = node.kwargs
    assert ti.kind(formals)=='arguments'
    assert ti.kind(formals.args)=='list'
    
    formal_names = [z.id for z in formals.args]
        # The names of *all* the formal arguments, include those with defauls.
        # Doesw not include vararg and kwarg.
       
    # Append unnamed actual args.
    # These could be either non-keyword arguments or keyword arguments.
    args = [ti.visit(z) for z in actuals]
    bound_names = formal_names[:len(actuals)]
    
    if trace and trace_args:
        g.trace('formal names',formal_names)
        g.trace('   arg names',bound_names)
        g.trace('    starargs',starargs and ti.format(starargs))
        g.trace('    keywargs',kwargs   and ti.format(kwargs))
        # formal_defaults = [ti.visit(z) for z in defaults]
            # # The types of each default.
        # g.trace('formal default types',formal_defaults)
        # g.trace('unnamed actuals',ti.format(actuals))
    
    # Add keyword args in the call, in the order they appear in the formal list.
    # These could be either non-keyword arguments or keyword arguments.
    keywargs_d = {}
    keywords_d = {}
    for keyword in keywords:
        name = keyword.arg
        t = ti.visit(keyword.value)
        value = ti.format(keyword.value)
        keywords_d[name] = (value,t)

    for name in formal_names[len(actuals):]:
        data = keywords_d.get(name)
        if data:
            value,t = data
            if trace and trace_args: g.trace('set keyword',name,value,t)
            args.append(t)
            bound_names.append(name)
        # else: keywargs_d[name] = None ### ???

    # Finally, add any defaults from the formal args.
    n_plain = len(formal_names) - len(defaults)
    defaults_dict = {}
    for i,expr in enumerate(defaults):
        name = formal_names[n_plain+i]
        value = ti.format(expr)
        t = ti.visit(expr)
        defaults_dict[name] = (value,t)

    for name in formal_names:
        if name not in bound_names:
            data = defaults_dict.get(name)
            t = None # default
            if data:
                value,t = data
                if trace and trace_args: g.trace('set default',name,value,t)
            elif name == 'self':
                def_cx = e.self_context
                class_cx = def_cx and def_cx.class_context
                if class_cx:
                    t = [Class_Type(class_cx)]
            if t is None:
                t = [Unknown_Arg_Type(node)]
                ti.error('Unbound actual argument: %s' % (name))
            args.append(t)
            bound_names.append(name)
            
    ### Why should this be true???
    # assert sorted(formal_names) == sorted(bound_names)

    if None in args:
        g.trace('***** opps node.args: %s, args: %s' % (node.args,args))
        args = [z for z in args if z is not None]
        
    if trace: g.trace('result',args)
    return args
</t>
<t tx="ekr.20140526082700.17411">def infer_def(self,node,rescan_flag):
    
    '''Infer everything possible from a def D called with specific args:
    
    1. Bind the specific args to the formal parameters in D.
    2. Infer all assignments in D.
    3. Infer all outer expression in D.
    4. Infer all return statements in D.
    '''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    return ###

    # t0 = ti.get_call_cache(e,hash_) or []
    # if hash_ in ti.call_stack and not rescan_flag:
        # # A recursive call: always add an Recursive_Instance marker.
        # if trace:g.trace('A recursive','rescan',rescan_flag,hash_,'-&gt;',t0)
        # ti.stats.n_recursive_calls += 1
        # t = [Recursive_Inference(node)]
    # else:
        # if trace: g.trace('A',hash_,'-&gt;',t0)
        # ti.call_stack.append(hash_)
        # try:
            # cx = e.self_context
            # # data = ti.switch_context(e,hash_,node)
            # ti.bind_args(specific_args,cx,e,node)
            # ti.infer_assignments(cx,e)
            # ti.infer_outer_expressions(cx,node)
            # t = ti.infer_return_statements(cx,e)
            # ti.restore_context(data)
        # finally:
            # hash2 = ti.call_stack.pop()
            # assert hash2 == hash_
    # # Merge the result and reset the cache.
    # t.extend(t0)
    # t = ti.clean(t)
    # if trace: g.trace('B',hash_,'-&gt;',t)
    # return t
</t>
<t tx="ekr.20140526082700.17412"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   keyword = (identifier arg, expr value) # keyword arguments supplied to call

# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def bind_args (self,types,cx,e,node):
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    assert ti.kind(node)=='Call'
    assert isinstance(node.args,list),node
    formals = cx.node.args or []
    assert ti.kind(formals)=='arguments'
    assert ti.kind(formals.args)=='list'
    formal_names = [z.id for z in formals.args]
        # The names of *all* the formal arguments, include those with defauls.
        
    if len(formal_names) != len(types):
        # g.trace('**** oops: formal_names: %s types: %s' % (formal_names,types))
        return

    def_cx = e.self_context
    d = def_cx.st.d
    for i,name in enumerate(formal_names):
        pass ### 
        ### Handle self here.
        # t = types[i]
        # e2 = d.get(name)
        # if e2:
            # if trace: g.trace(e2,t) # g.trace(e2.name,t)
            # ti.set_cache(e2,[t],tag='bindargs:%s'%(name))
        # else:
            # g.trace('**** oops: no e2',name,d)
</t>
<t tx="ekr.20140526082700.17413">def infer_assignments(self,cx,e):
    
    '''Infer all the assignments in the function context.'''

    ti = self
    trace = False and not g.app.runningAllUnitTests
    for a in cx.assignments_list:
        if ti.kind(a) == 'Assign': # ignore AugAssign.
            pass ####

            # t2 = ti.get_cache(a)
            # if t2:
                # ti.stats.n_assign_hits += 1
                # if trace: g.trace('hit!',t2)
            # else:
                # t2 = ti.visit(a)
                # t3 = ti.ignore_failures(t2)
                # if t3:
                    # ti.stats.n_assign_misses += 1
                    # # g.trace('***** set cache',t2)
                    # ti.set_cache(a,t2,tag='infer_assns')
                    # if trace: g.trace('miss',t2)
                # else:
                    # ti.stats.n_assign_fails += 1
                    # if trace: g.trace('fail',t2)
               
                   
    return None # This value is never used.
</t>
<t tx="ekr.20140526082700.17414">def infer_outer_expressions(self,cx,node):
    
    '''Infer all outer expressions in the function context.'''

    ti = self
    trace = False and not g.app.runningAllUnitTests
    for exp in cx.expressions_list:
        if trace: g.trace(ti.format(exp))
        ti.stats.n_outer_expr_misses += 1
        t = ti.visit(exp)

    return None # This value is never used.
</t>
<t tx="ekr.20140526082700.17415">def infer_return_statements(self,cx,e):
    
    '''Infer all return_statements in the function context.'''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    t = []
    for r in cx.returns_list:
        t2 = ti.visit(r)
        if trace: g.trace('miss',t2)
        t.extend(t2)
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.17416"># Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self,node):
    
    ti = self
    ti.visit(node.left)
    for z in node.comparators:
        ti.visit(z)
    return [ti.bool_type]
</t>
<t tx="ekr.20140526082700.17417">def do_comprehension(self,node):

    ti = self
    ti.visit(node.target) # A name.
    ti.visit(node.iter) # An attribute.
    return [List_Type(node)]
</t>
<t tx="ekr.20140526082700.17418"># Expr(expr value)

def do_Expr(self,node):
    
    ti = self
    t = ti.visit(node.value)
    return t
</t>
<t tx="ekr.20140526082700.17419">def do_GeneratorExp (self,node):

    ti = self
    trace = False and not g.app.runningAllUnitTests
    junk = ti.visit(node.elt)
    t = []
    for node2 in node.generators:
        t2 = ti.visit(node2)
        t.extend(t2)
    if ti.has_failed(t):
        t = ti.merge_failures(t)
        if trace: g.trace('failed inference',ti.format(node),t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.17420"># The ternary operator
# IfExp(expr test, expr body, expr orelse)

def do_IfExp(self,node):
    
    ti = self    
    junk = ti.visit(node.test)
    t = ti.visit(node.body)
    t.extend(ti.visit(node.orelse))
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.17421">def do_Index(self,node):

    ti = self    
    return ti.visit(node.value)
</t>
<t tx="ekr.20140526082700.17422">def do_Lambda (self,node):
    
    ti = self
    return ti.visit(node.body)
</t>
<t tx="ekr.20140526082700.17423">def do_ListComp(self,node):
    
    ti = self
    # g.trace(node.elt,node.generators)
    junk = ti.visit(node.elt)
    t = []
    for node2 in node.generators:
        t.extend(ti.visit(node2))
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.17424">def do_Name(self,node):
    
    ti = self ; u = ti.u
    trace = True and not g.app.runningAllUnitTests
    trace_infer = False ; trace_fail = False
    trace_self = False
    ctx_kind = ti.kind(node.ctx)
    name = node.id
    trace = trace and name == 'i'
    
    # # Reaching sets are useful only for Load attributes.
    # if ctx_kind not in ('Load','Param'):
        # # if trace: g.trace('skipping %s' % ctx_kind)
        # return []

    # ### ast.Name nodes for class base names have no 'e' attr.
    # if not hasattr(node,'e'):
        # if trace: g.trace('no e',node)
        # return []

    if name == 'self':
        # reach = getattr(node,'reach',[])
        # if reach: g.trace('**** assignment to self')
        cx = node.stc_context ### should be class context.
        if cx:
            if trace and trace_self: g.trace('found self',cx)
            t = [Class_Type(cx)]
        else:
            g.trace('**** oops: no class context for self',ti.format(node))
            t = [Unknown_Type(node)]
    else:
        reach = getattr(node,'reach',[])
        t = []
        for node2 in reach:
            # The reaching sets are the RHS of assignments.
            t = [Unknown_Type(node)]
            t2 = ti.visit(node2)
            if isinstance(t2,(list,tuple)):
                t.extend(t2)
            else:
                g.trace('**oops:',t2,ti.format(node2))
        if ti.has_failed(t):
            t = ti.merge_failures(t)
        else:
            t = ti.clean(t)

    if trace and trace_infer and t:
        g.trace('infer',t,u.format(node))
    if trace and trace_fail and not t:
        g.trace('fail ',name,ctx_kind,'reach:',
            ['%s:%s' % (id(z),u.format(z)) for z in reach])
    return t
</t>
<t tx="ekr.20140526082700.17425">def do_Slice(self,node):
    
    ti = self
    if node.upper: junk = ti.visit(node.upper)
    if node.lower: junk = ti.visit(node.lower)
    if node.step:  junk = ti.visit(node.step)
    return [ti.int_type] ### ???
</t>
<t tx="ekr.20140526082700.17426">def do_Subscript(self,node):

    ti = self
    trace = False and not g.app.runningAllUnitTests
    t1 = ti.visit(node.value)
    t2 = ti.visit(node.slice)
    if t1 and trace: g.trace(t1,t2,ti.format(node))
    return t1 ### ?
</t>
<t tx="ekr.20140526082700.17427">def do_UnaryOp(self,node):
    
    ti = self
    trace = True and not g.app.runningAllUnitTests
    t = ti.visit(node.operand) or []
    t = ti.clean(t)
    op_kind = ti.kind(node.op)
    if op_kind == 'Not':
        t = [self.bool_type]
    elif t == [self.int_type] or t == [self.float_type]:
        pass # All operators are valid.
    else:
        ti.stats.n_unop_fail += 1
        if trace: g.trace(' fail:',op_kind,t,ti.format(node))
        t = [Unknown_Type(node)]
    return t
</t>
<t tx="ekr.20140526082700.17428"></t>
<t tx="ekr.20140526082700.17429">def do_Builtin(self,node):

    ti = self
    return [ti.builtin_type]
</t>
<t tx="ekr.20140526082700.17430">def do_Bytes(self,node):

    ti = self
    return [ti.bytes_type]
</t>
<t tx="ekr.20140526082700.17431"># Dict(expr* keys, expr* values)

def do_Dict(self,node):
    
    ti = self
    for z in node.keys:
        ti.visit(z)
    for z in node.values:
        ti.visit(z)
    return [Dict_Type(node)]
        ### More specific type.
</t>
<t tx="ekr.20140526082700.17432"># List(expr* elts, expr_context ctx) 

def do_List(self,node):
    
    ti = self
    for z in node.elts:
        ti.visit(z)
    # ti.visit(node.ctx)
    return [List_Type(node)]
</t>
<t tx="ekr.20140526082700.17433">def do_Num(self,node):
    
    ti = self
    t_num = Num_Type(node.n.__class__)
    # g.trace(ti.format(node),'-&gt;',t_num)
    return [t_num]
</t>
<t tx="ekr.20140526082700.17434">def do_Str(self,node):
    
    '''This represents a string constant.'''

    ti = self
    return [ti.string_type]
</t>
<t tx="ekr.20140526082700.17435"># Tuple(expr* elts, expr_context ctx)

def do_Tuple(self,node):
    
    ti = self
    for z in node.elts:
        ti.visit(z)
    # ti.visit(node.ctx)
    return [Tuple_Type(node)]
</t>
<t tx="ekr.20140526082700.17436"></t>
<t tx="ekr.20140526082700.17437"># arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments (self,node):
    
    '''Bind formal arguments to actual arguments.'''
    
    assert False # All the work is done in ti.Call and its helpers.
</t>
<t tx="ekr.20140526082700.17438">def do_Assign(self,node):

    ti = self
    trace = False and not g.app.runningAllUnitTests
    t_val = ti.visit(node.value)
    t = []
    for z in node.targets:
        t.append(ti.visit(z))
    t = ti.clean(t)
    return t

    # if data in ti.assign_stack:
        # t = [Circular_Assignment(node)]
        # ti.stats.n_circular_assignments += 1
    # else:
        # ti.assign_stack.append(data)
        # try:
            # t = ti.visit(node.value)
            # if trace: g.trace(t)
        # finally:
            # data2 = ti.assign_stack.pop()
            # assert data == data2
        
    # for target in node.targets:
        # kind = ti.kind(target)
        # if kind == 'Name':
            # t0 = ti.get_cache(target.e) or []
            # t.extend(t0)
            # ti.set_cache(target.e,t,tag='Name:target.e')
            # if trace: g.trace('infer: %10s -&gt; %s' % (
                # ti.format(target),t),before='\n')
        # else:
            # ### What to do about this?
            # if trace: g.trace('(ti) not a Name: %s' % (
                # ti.format(target)),before='\n')
                
    # # Update the cache immediately.
    # t0 = ti.get_cache(node) or []
    # t.extend(t0)
    # t = ti.clean(t)
    # ti.set_cache(node,t,tag='ti.Assign')
    # return t
</t>
<t tx="ekr.20140526082700.17439">def do_ClassDef(self,node):
    
    ti = self
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.17440"># For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For (self,tree):

    ti = self
    ### what if target conflicts with an assignment??
    ti.visit(tree.target)
    ti.visit(tree.iter)
    for z in tree.body:
        ti.visit(z)
    for z in tree.orelse:
        ti.visit(z)
</t>
<t tx="ekr.20140526082700.17441"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,node):
    
    '''Infer this function or method with 'unknown' as the value of all args.
    This gets inference going.
    '''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    ti.infer_outer_def(node)
    
    # # Set up function call, with 'unknown' for all args.
    # e = node.e
    # specific_args = [Unknown_Arg_Type(node)] * ti.count_full_args(node)
    # hash_ = ti.cache_hash(specific_args,e)
    # t = ti.get_call_cache(e,hash_)
    # if trace:
        # g.trace('%s %12s -&gt; %s' % ('miss' if t is None else 'hit!',
            # node.name,specific_args))
    # if t is None:
        # t = ti.infer_outer_def(specific_args,hash_,node)
    # return t
</t>
<t tx="ekr.20140526082700.17442"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def count_full_args (self,node):
    
    '''Return the number of arguments in a call to the function/def defined
    by node, an ast.FunctionDef node.'''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    assert ti.kind(node)=='FunctionDef'    
    args = node.args
    if trace: g.trace('args: %s vararg: %s kwarg: %s' % (
        [z.id for z in args.args],args.vararg,args.kwarg))
    n = len(args.args)
    if args.vararg: n += 1
    if args.kwarg:  n += 1
    return n
</t>
<t tx="ekr.20140526082700.17443">def infer_outer_def(self,node):
    
    '''Infer everything possible from a def D called with specific args:
    
    1. Bind the args to the formal parameters in D.
    2. Infer all assignments in D.
    3. Infer all outer expression in D.
    4. Infer all return statements in D.
    '''
    
    return []

    # ti = self
    # # trace = True and not g.app.runningAllUnitTests
    # assert ti.kind(node)=='FunctionDef',node
    # e = node.e
    # assert hasattr(e,'call_cache')
    # cx = e.self_context
    # ### data = ti.switch_context(e,hash_,node)
    # ti.bind_outer_args(node)
    # ti.infer_assignments(cx,e)
    # ti.infer_outer_expressions(cx,node)
    # t = ti.infer_return_statements(cx,e)
    # ### ti.set_call_cache(e,hash_,t,tag='infer_def')
    # ### ti.restore_context(data)
    # return t
</t>
<t tx="ekr.20140526082700.17444"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)
def bind_outer_args (self,node):
    
    '''Bind all all actual arguments except 'self' to "Unknown_Arg_Type".'''
    
    ti = self
    trace = False and not g.app.runningAllUnitTests
    assert ti.kind(node)=='FunctionDef'
    e = node.e
    def_cx = e.self_context
    args = node.args or []
    assert ti.kind(args)=='arguments',args
    assert ti.kind(args.args)=='list',args.args
    formal_names = [z.id if hasattr(z,'id') else '&lt;tuple arg&gt;' for z in args.args]
    if args.vararg: formal_names.append(args.vararg)
    if args.kwarg:  formal_names.append(args.kwarg)
    # if trace: g.trace(formal_names)
    d = def_cx.st.d
    for name in formal_names:
        if name == 'self':
            if def_cx:
                t = [Class_Type(def_cx)]
            else:
                t = [Unknown_Arg_Type(node)]
            e2 = e
        else:
            t = [Unknown_Arg_Type(node)]
            e2 = d.get(name)
        # if e2:
            # ti.set_cache(e2,t,tag='bind_outer_args:%s'%(name))
            # if trace: g.trace(name,t)
        # else:
            # if trace: g.trace('**** oops: no e2',name,d)
</t>
<t tx="ekr.20140526082700.17445"># def do_Import(self,node):
    
    # pass
</t>
<t tx="ekr.20140526082700.17446"># def do_ImportFrom(self,node):
    
    # pass
</t>
<t tx="ekr.20140526082700.17447">def do_Return(self,node):
    return self.return_helper(node)
    
def do_Yield(self,node):
    return self.return_helper(node)
</t>
<t tx="ekr.20140526082700.17448">def return_helper(self,node):

    ti = self
    trace = False and not g.app.runningAllUnitTests
    e = ti.call_e
    assert e
    if node.value:
        t = ti.visit(node.value)
        if ti.has_failed(t):
            ti.stats.n_return_fail += 1
            t = ti.ignore_unknowns(t)
        if t:
            ti.stats.n_return_success += 1
        else:
            ti.stats.n_return_fail += 1
            t = [] # Do **not** propagate a failure here!
    else:
        t = [ti.none_type]
    if trace: g.trace(t,ti.format(node))
    return t
</t>
<t tx="ekr.20140526082700.17449">def do_With (self,node):

    ti = self
    t = []
    for z in node.body:
        t.append(ti.visit(z))
    t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.18006"></t>
<t tx="ekr.20140526082700.18007">class AstTraverser:
    
    '''
    The base class for all traversers.
    
    See the documentation for *important* information about this class.
    '''

    @others
</t>
<t tx="ekr.20140526082700.18008">def __init__(self):

    self.context_stack = []
    self.level = 0 # The indentation level (not the context level).
        # The number of parents a node has.
    self.parents = [None]
</t>
<t tx="ekr.20140526082700.18009"></t>
<t tx="ekr.20140526082700.18010"># Used by leoInspect code.

def find_function_call (self,node):

    '''
    Return the static name of the function being called.
    
    tree is the tree.func part of the Call node.'''
    
    trace = True and self.enable_trace
    kind = self.kind(node)
    assert kind not in ('str','Builtin')
    if kind == 'Name':
        s = node.id
    elif kind == 'Attribute':
        s = node.attr # node.attr is always a string.
    elif kind == 'Call':
        s = self.find_function_call(node.func)
    elif kind == 'Subscript':
        s = None
    else:
        s = None
        if trace:
            # This is not an error.  Example:  (g())()
            s = '****unknown kind: %s****: %s' % (kind,Utils().format(node))
            g.trace(s)

    return s or '&lt;no function name&gt;'
</t>
<t tx="ekr.20140526082700.18011">def get_context (self):

    return self.context_stack[-1]

def push_context (self,context):

    assert context
    self.context_stack.append(context)

def pop_context (self):

    self.context_stack.pop()
</t>
<t tx="ekr.20140526082700.18012">def get_child_nodes(self,node):

    assert isinstance(node,ast.AST),node.__class__.__name__

    if node._fields is not None:
        for name in node._fields:
            child = getattr(node, name)
            if isinstance(child, list):
                for node2 in child:
                    if isinstance(node2, ast.AST):
                        yield node2    
            elif isinstance(child, ast.AST):
                yield child
</t>
<t tx="ekr.20140526082700.18013">def has_children(self,node):
    
    assert isinstance(node,ast.AST),node.__class__.__name__
    
    return any(self.get_child_nodes(node))
</t>
<t tx="ekr.20140526082700.18014">def run (self,s):

    t1 = time.time()
    node = ast.parse(s,filename=self.fn,mode='exec')
    self.visit(node)
    t2 = time.time()
    return t2-t1
</t>
<t tx="ekr.20140526082700.18015">def visit(self,node):
    
    """Walk a tree of AST nodes."""

    assert isinstance(node,ast.AST),node.__class__.__name__

    method_name = 'do_' + node.__class__.__name__
    method = getattr(self,method_name,None)
    if method:
        # method is responsible for traversing subtrees.
        return method(node)
    else:
        # Traverse subtrees automatically, without calling visit_children.
        for child in self.get_child_nodes(node):
            self.visit(child)
</t>
<t tx="ekr.20140526082700.18016"># def visit_children(self,node):
    
    # assert isinstance(node,ast.AST),node.__class__.__name__

    # for child in self.get_child_nodes(node):
        # self.visit(child)
</t>
<t tx="ekr.20140526082700.18017">def visit_list (self,aList):
    
    assert isinstance(aList,(list,tuple))
    
    for z in aList:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18018"></t>
<t tx="ekr.20140526082700.18019">def attribute_base(self,node):
    
    '''Return the node representing the base of the chain.
    Only 'Name' and 'Builtin' nodes represent names.
    All other chains have a base that is a constant or nameless dict, list, etc.
    '''

    trace = False
    kind = self.kind(node)
    if kind in ('Name','Builtin','Str'):
        result = node # We have found the base.
    elif kind in ('Attribute','Subscript'):
        if trace: g.trace('value: %s'% node.value)
        result = self.attribute_base(node.value)
    elif kind == 'Call':
        result = self.attribute_base(node.func)
    else:
        # The chain is rooted in a constant or nameless dict, list, etc.
        # This is not an error.
        # g.trace('*** kind: %s node: %s' % (kind,node))
        result = node
        
    if trace:
        u = Utils()
        g.trace(u.format(node),'-&gt;',u.format(result))
    return result
</t>
<t tx="ekr.20140526082700.18020">def attribute_target(self,node):
    
    '''Return the node representing the target of the chain.
    Only 'Name' and 'Builtin' Ops represent names.'''
    
    trace = True
    kind = self.kind(node)
    if kind in ('Name','Builtin','Str'):
        result = node # We have found the target.
    elif kind == 'Attribute':
        # result = self.attribute_target(node.attr) ### Always a string.
        result = node # node.attr is the target.
    elif kind == 'Call':
        result = self.attribute_target(node.func)
    elif kind == 'Subscript':
        result = self.attribute_target(node.value)
    else:
        g.trace('can not happen',node.__class__.__name__,repr(node))
        # Don't call u.format here.
        return None
    
    if trace:
        u = Utils()
        g.trace(u.format(node),'-&gt;',u.format(result))
    return result
</t>
<t tx="ekr.20140526082700.18021">def check_visitor_names(self):
    
    '''Check that there is an ast.AST node named x
    for all visitor methods do_x.'''
    
    &lt;&lt; ast abstract grammar &gt;&gt;
    &lt;&lt; define names &gt;&gt;

    # Inexpensive, because there are few entries in aList.
    aList = [z for z in dir(self) if z.startswith('do_')]
    for s in sorted(aList):
        name = s[3:]
        if name not in names:
            g.trace('***** oops',self.__class__.__name__,name)
            assert False,name
                # This is useful now that most errors have been caught.
</t>
<t tx="ekr.20140526082700.18022">@nocolor-node
@
Python 3 only:
    arguments = (arg* args, identifier? vararg, expr? varargannotation,
                     arg* kwonlyargs, identifier? kwarg,
                     expr? kwargannotation, expr* defaults,
                     expr* kw_defaults)
    arg = (identifier arg, expr? annotation)
mod:
    Expression(expr body)
    Interactive(stmt* body)
    Module(stmt* body)
    Suite(stmt* body) #  not an actual node,
stmt:
    Assert(expr test, expr? msg)
    Assign(expr* targets, expr value)
    AugAssign(expr target, operator op, expr value)
    Break
    ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
    Continue
    Delete(expr* targets)
    Exec(expr body, expr? globals, expr? locals)
    Expr(expr value)
    For(expr target, expr iter, stmt* body, stmt* orelse)
    FunctionDef(identifier name, arguments args,stmt* body, expr* decorator_list)
    Global(identifier* names)
    If(expr test, stmt* body, stmt* orelse)
    Import(alias* names)
    ImportFrom(identifier? module, alias* names, int? level)
    Pass
    Print(expr? dest, expr* values, bool nl)
    Raise(expr? type, expr? inst, expr? tback)
    Return(expr? value)
    TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)
    TryFinally(stmt* body, stmt* finalbody)
    While(expr test, stmt* body, stmt* orelse)
    With(expr context_expr, expr? optional_vars, stmt* body)
expr:
    Attribute(expr value, identifier attr, expr_context ctx)
    BinOp(expr left, operator op, expr right)
    BoolOp(boolop op, expr* values)
    Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
    Compare(expr left, cmpop* ops, expr* comparators)
    Dict(expr* keys, expr* values)
    DictComp(expr key, expr value, comprehension* generators)
    GeneratorExp(expr elt, comprehension* generators)
    IfExp(expr test, expr body, expr orelse)
    Lambda(arguments args, expr body)
    List(expr* elts, expr_context ctx) 
    ListComp(expr elt, comprehension* generators)
    Name(identifier id, expr_context ctx)
    Num(object n) -- a number as a PyObject.
    Repr(expr value)
    Set(expr* elts)
    SetComp(expr elt, comprehension* generators)
    Str(string s) -- need to specify raw, unicode, etc?
    Subscript(expr value, slice slice, expr_context ctx)
    Tuple(expr* elts, expr_context ctx)
    UnaryOp(unaryop op, expr operand)
    Yield(expr? value)
expr_context:
    AugLoad
    AugStore
    Del
    Load
    Param
    Store
slice:
    Ellipsis
    Slice(expr? lower, expr? upper, expr? step) 
    ExtSlice(slice* dims) 
    Index(expr value) 
boolop:
    And | Or 
operator:
    Add | Sub | Mult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv
unaryop:
    Invert | Not | UAdd | USub
cmpop:
    Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
excepthandler:
    ExceptHandler(expr? type, expr? name, stmt* body)
    
Lower case node names:
    alias (identifier name, identifier? asname)
    arguments (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)
    comprehension (expr target, expr iter, expr* ifs)
    keyword (identifier arg, expr value)
</t>
<t tx="ekr.20140526082700.18023">names = (
    'Add','And','Assert','Assign','Attribute','AugAssign','AugLoad','AugStore',
    'BinOp','BitAnd','BitOr','BitXor','BoolOp','Break',
    'Builtin', ### Python 3.x only???
    'Bytes', # Python 3.x only.
    'Call','ClassDef','Compare','Continue',
    'Del','Delete','Dict','DictComp','Div',
    'Ellipsis','Eq','ExceptHandler','Exec','Expr','Expression','ExtSlice',
    'FloorDiv','For','FunctionDef','GeneratorExp','Global','Gt','GtE',
    'If','IfExp','Import','ImportFrom','In','Index','Interactive',
    'Invert','Is','IsNot','LShift','Lambda',
    'List','ListComp','Load','Lt','LtE',
    'Mod','Module','Mult','Name','Not','NotEq','NotIn','Num',
    'Or','Param','Pass','Pow','Print',
    'RShift','Raise','Repr','Return',
    'Set','SetComp','Slice','Store','Str','Sub','Subscript','Suite',
    'TryExcept','TryFinally','Tuple','UAdd','USub','UnaryOp',
    'While','With','Yield',
    # Lower case names...
    'alias',         # A valid ast.AST node.
    'arguments',     # A valid ast.AST node.
    'comprehension', # A valid ast.AST node.
    'keyword',       # A valid ast.AST node(!)
        # 'keywords', # A valid field, but not a valid ast.AST node!
        # In ast.Call nodes, node.keywords points to a *list* of ast.keyword objects.
    # There is never any need to traverse these:
        # 'id','n','name','s','str'.
)
</t>
<t tx="ekr.20140526082700.18024">def info (self,node):
    
    return '%s: %9s' % (node.__class__.__name__,id(node))
</t>
<t tx="ekr.20140526082700.18025">def kind(self,node):
    
    return node.__class__.__name__
</t>
<t tx="ekr.20140526082700.18026">def op_name (self,node):
    
    '''Return the print name of an operator node.'''
    
    d = {
    # Binary operators. 
    'Add':       '+',
    'BitAnd':    '&amp;',
    'BitOr':     '|',
    'BitXor':    '^',
    'Div':       '/',
    'FloorDiv':  '//',
    'LShift':    '&lt;&lt;',
    'Mod':       '%',
    'Mult':      '*',
    'Pow':       '**',
    'RShift':    '&gt;&gt;',
    'Sub':       '-',
    # Boolean operators.
    'And':   ' and ',
    'Or':    ' or ',
    # Comparison operators
    'Eq':    '==',
    'Gt':    '&gt;',
    'GtE':   '&gt;=',
    'In':    ' in ',
    'Is':    ' is ',
    'IsNot': ' is not ',
    'Lt':    '&lt;',
    'LtE':   '&lt;=',
    'NotEq': '!=',
    'NotIn': ' not in ',
    # Context operators.
    'do_AugLoad':  '&lt;AugLoad&gt;',
    'do_AugStore': '&lt;AugStore&gt;',
    'do_Del':      '&lt;Del&gt;',
    'do_Load':     '&lt;Load&gt;',
    'do_Param':    '&lt;Param&gt;',
    'do_Store':    '&lt;Store&gt;',
    # Unary operators.
    'Invert':   '~',
    'Not':      ' not ',
    'UAdd':     '+',
    'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20140526082700.18027">class StatementTraverser(AstFullTraverser):
    
    def __init__ (self):

        AstFullTraverser.__init__(self)
            # Init the base class.
        self.root = None

    @others
</t>
<t tx="ekr.20140526082700.18028">def run (self,root):

    self.root = root
    self.visit(root)
</t>
<t tx="ekr.20140526082700.18029">def default_visitor(self,node):
    pass
   
def visit(self,node):
    
    '''Visit a *single* ast node.  Visitors are responsible for visiting children!'''
    assert isinstance(node,ast.AST),node.__class__.__name__
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self,method_name,self.default_visitor)
    return method(node)

def visit_children(self,node):
    assert False,'must visit children explicitly'
</t>
<t tx="ekr.20140526082700.18030">if 0:
    @others
</t>
<t tx="ekr.20140526082700.18031"># Assert(expr test, expr? msg)

def do_Assert(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18032"># Assign(expr* targets, expr value)

def do_Assign(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18033"># AugAssign(expr target, operator op, expr value)

def do_AugAssign(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18034">def do_Break(self,node):
    pass

</t>
<t tx="ekr.20140526082700.18035">def do_Continue(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18036"># Delete(expr* targets)

def do_Delete(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18037"># Python 2.x only
# Exec(expr body, expr? globals, expr? locals)

def do_Exec(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18038"># Expr(expr value)

def do_Expr(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18039"># Global(identifier* names)

def do_Global(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18040"># Import(alias* names)

def do_Import(self,node):
    pass

# ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18041">def do_Pass(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18042"># Python 2.x only
# Print(expr? dest, expr* values, bool nl)
def do_Print(self,node):
    pass
    
</t>
<t tx="ekr.20140526082700.18043"># Raise(expr? type, expr? inst, expr? tback)

def do_Raise(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18044"># Return(expr? value)

def do_Return(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18045">#  Yield(expr? value)

def do_Yield(self,node):
    pass
</t>
<t tx="ekr.20140526082700.18046">class CacheTraverser(AstTraverser):
    
    '''A class to report the contents of caches.'''
    
    def __init__(self):
    
        AstTraverser.__init__(self)
        self.level = 0
    
    @others
</t>
<t tx="ekr.20140526082700.18047">def show_cache(self,obj,cache,tag):
    
    d = cache
    pad = ' '*2*self.level
    result = []
    for key in sorted(d.keys()):
        aList = d.get(key)
        if len(aList) &gt; 1 or (aList and repr(aList[0]) != 'Unknown'):
            # result.append('  %s%20s =&gt; %s' % (pad,key,aList))
            result.append('  %s%s' % (pad,aList))
    if result:
        s = self.format(obj) if isinstance(obj,ast.AST) else repr(obj)
        s = s.replace('\n','')
        if len(s) &gt; 40: s = s[:37]+'...'
        if len(result) == 1:
            print('%s%s: %40s -&gt; %s' % (pad,tag,s,result[0].strip()))
        else:
            print('%s%s: %s' % (pad,tag,s))
            for s in result:
                print(s)
</t>
<t tx="ekr.20140526082700.18048">def run (self,node):

    self.check_visitor_names()
    fn = ' for %s' % (g.shortFileName(self.fn)) if self.fn else ''
    print('\nDump of caches%s...' % fn)
    self.visit(node)
</t>
<t tx="ekr.20140526082700.18049"></t>
<t tx="ekr.20140526082700.18050">def visit(self,node):
    
    """Walk a tree of AST nodes."""

    assert isinstance(node,ast.AST),node.__class__.__name__

    method_name = 'do_' + node.__class__.__name__
    method = getattr(self,method_name,None)
    if method:
        # method is responsible for traversing subtrees.
        return method(node)
    else:
        self.visit_cache(node)

        # Traverse subtrees automatically, without calling visit_children.
        for child in self.get_child_nodes(node):
            self.visit(child)
</t>
<t tx="ekr.20140526082700.18051">def visit_cache(self,node):
    
    if hasattr(node,'cache'):
        self.show_cache(node,node.cache,'cache')
        
    if hasattr(node,'e') and hasattr(node.e,'call_cache'):
        self.show_cache(node,node.e.call_cache,'call_cache')
</t>
<t tx="ekr.20140526082700.18052"></t>
<t tx="ekr.20140526082700.18053"># ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef(self,node):
    
    pad = ' '*2*self.level
    bases = ','.join([self.format(z) for z in node.bases])
    print('%sclass %s(%s)' % (pad,node.name,bases))
    
    self.level += 1
    try:
        self.visit_children(node)
    finally:
        self.level -= 1
</t>
<t tx="ekr.20140526082700.18054"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,node):
    
    pad = ' '*2*self.level
    print('%sdef %s(%s)' % (pad,node.name,self.format(node.args)))
    
    self.level += 1
    try:
        self.visit_children(node)
    finally:
        self.level -= 1
</t>
<t tx="ekr.20140526082700.18055">class ChainPrinter: ### (OpPatternFormatter):
    
    def __init__ (self,fn):
    
        self.d = {}
        self.top_attribute = True
    
        ### OpPatternFormatter.__init__ (self)
            # Init the base class.

    @others
</t>
<t tx="ekr.20140526082700.18056"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self,node):
    
    top = self.top_attribute
    try:
        self.top_attribute = False
        value = node.value
        attr  = node.attr
        s = '%s.%s' % (
            self.visit(value),
            self.visit(attr))
    finally:
        self.top_attribute = top
        
    if top:
        aList = s.split('.')
        if aList:
            name,rest = aList[0],aList[1:]
            if (
                name == 'self' and len(rest) &gt; 1 or
                name != 'self' and len(rest) &gt; 0
            ):
                aList2 = self.d.get(name,[])
                if rest not in aList2:
                    aList2.append(rest)
                    self.d[name] = aList2
                
    return s
</t>
<t tx="ekr.20140526082700.18057">def showChains(self):
    
    verbose = False
    result = []
    d,n1,n2 = self.d,0,0
    for key in sorted(d.keys()):
        aList = d.get(key)
        for chain in sorted(aList):
            s = '.'.join(chain)
            if s.find('(') &gt; -1 or s.find('[') &gt; -1 or s.find('{') &gt; -1:
                # print('%s.%s' % (key,s))
                result.append('%s.%s' % (key,s))
                n2 += 1
            else:
                if verbose:
                    result.append('%s.%s' % (key,s))
                n1 += 1

    return n1,n2,'\n'.join(result)

</t>
<t tx="ekr.20140526082700.18058">&lt;&lt; define class Context &gt;&gt;

@others
</t>
<t tx="ekr.20140526082700.18059">class Context:

    '''The base class of all Context objects.
    Contexts represent static scopes.'''

    @others
</t>
<t tx="ekr.20140526082700.18060">def __init__(self,parent_context):

    self.format = u.format
    self.kind = '&lt;Unknown context kind&gt;' # All subclasses set this.
    self.name = '&lt;Unknown context name&gt;' # All subclasses set this.
    self.parent_context = parent_context
    self.st = SymbolTable(cx=self)
    self.stats = Stats()
    self.stats.n_contexts += 1

    # Public semantic data: accessed via getters.
    self.assignments_list = [] # All assignment statements.
    self.calls_list = [] # All call statements defined in this context.
    self.classes_list = [] # Classes defined in this context.
    self.defs_list = [] # Functions defined in this context.
    self.expressions_list = [] # Expr nodes in this context.
    self.definitions_of = [] # Assignments, imports and arguments that define this symbol.
    self.imported_symbols_list = [] # All imported symbols.
    self.methods_list = [] # # All methods of a class context.  Elements are DefContexts.
    self.returns_list = [] # List of all return statements in the context.
    self.statements_list = [] # List of *all* statements in the context.
    self.yields_list = [] # List of all yield statements in the context.

    # Private semantic data: no getters.
    self.n_lambdas = 0
        # Number of lambdas in this context:
        # Used to synthesize names of the form 'Lambda@@n'
    self.defining_context = self
    # self.global_names = set()
        # Names that appear in a global statement in this context.
    self.node = None
        # The AST tree representing this context.
</t>
<t tx="ekr.20140526082700.18061">def __getstate__(self):
    
    '''Return the representation of the Context class for use by pickle.'''
    
    d = {
        'calls':        [repr(z) for z in self.calls_list],
        'classes':      [repr(z) for z in self.classes_list],
        'defs':         [repr(z) for z in self.defs_list],
        'statements':   [repr(z) for z in self.statements()],
    }

    return d
</t>
<t tx="ekr.20140526082700.18062"># Important: Define __hash__ only if __eq__ is also defined.

def __hash__ (self):
    return id(self)

# This is defined below...

# def __eq__ (self,other):
    # return id(self) == id(other)
</t>
<t tx="ekr.20140526082700.18063">def __repr__ (self):

    return 'Cx:id(%s)' % id(self)
    
__str__ = __repr__
</t>
<t tx="ekr.20140526082700.18064"># Py3k wants __lt__ etc, and Py2k needs all of them defined.

# Use identity only for contexts!
def __lt__(self, other): return NotImplemented 
def __le__(self, other): return NotImplemented 
def __eq__(self, other): return id(self) == id(other)
def __ne__(self, other): return id(self) != id(other)
def __gt__(self, other): return NotImplemented 
def __ge__(self, other): return NotImplemented 

# if 1:
    # # Ignore case in comparisons.
    # def __lt__(self, other): return self.name.lower() &lt;  other.name.lower()
    # def __le__(self, other): return self.name.lower() &lt;= other.name.lower()
    # def __eq__(self, other): return self.name.lower() == other.name.lower()
    # def __ne__(self, other): return self.name.lower() != other.name.lower()
    # def __gt__(self, other): return self.name.lower() &gt;  other.name.lower()
    # def __ge__(self, other): return self.name.lower() &gt;= other.name.lower()
# else:
    # def __lt__(self, other): return self.name &lt;  other.name
    # def __le__(self, other): return self.name &lt;= other.name
    # def __eq__(self, other): return self.name == other.name
    # def __ne__(self, other): return self.name != other.name
    # def __gt__(self, other): return self.name &gt;  other.name
    # def __ge__(self, other): return self.name &gt;= other.name
</t>
<t tx="ekr.20140526082700.18065">def description (self):
    
    '''Return a description of this context and all parent contexts.'''
    
    if self.parent_context:
        return  '%s:%s' % (
            self.parent_context.description(),repr(self))
    else:
        return repr(self)

def short_description(self):
    return repr(self)
</t>
<t tx="ekr.20140526082700.18066">def dump_statements(self,var_filter=None):
    
    cx = self
    # aList = [node.dump(0,var_filter=var_filter) for node in cx.local_statements()]
    aList = [self.u.dump_ast(node) for node in cx.local_statements()]
    return '\n'.join([z for z in aList if z.strip()])
</t>
<t tx="ekr.20140526082700.18067">def full_name (self):
    
    '''Return a context name for compatibility with HTMLReportTraverser.'''
    
    # A hack: must match the name generated in rt.report().
    
    return 'report_writer_test' if self.name == '&lt;string&gt;' else self.name
</t>
<t tx="ekr.20140526082700.18068"># Unlike in leoInspect, most of these getters return lists of Statement objects.
</t>
<t tx="ekr.20140526082700.18069"># This is really a helper for assignments_to/using.
def assignments(self):
    
    result = []
    for cx in self.contexts():
        result.extend(cx.assignments_list)
    return result
</t>
<t tx="ekr.20140526082700.18070">def assignments_to (self,s):
    
    cx = self
    result = []
    for node in cx.assignments():
        statement = cx.u.format(node)
        kind = cx.u.kind(node)
        if kind == 'Assign':
            #  Assign(expr* targets, expr value)
            for target in node.targets:
                kind2 = cx.u.kind(target)
                if kind2 == 'Name':
                    if s == target.id:
                        result.append(statement)
                elif kind2 == 'Tuple':
                    # Tuple(expr* elts, expr_context ctx)
                    for item2 in target.elts:
                        if cx.u.kind(item2) == 'Name' and s == item2.id:
                            result.append(statement)
        elif kind == 'AugAssign':
            kind2 = cx.u.kind(node.target)
            if kind2 == 'Name':
                if s == node.target.id:
                    result.append(statement)
        elif kind == 'For':
            s2 = statement
            i = s2.find(' in ')
            assert s2.startswith('for ')
            assert i &gt; -1
            s2 = s2[4:i].strip('()')
            aList = s2.split(',')
            if s in aList:
                i = statement.find(':\n')
                assert i &gt; -1
                result.append(statement[:i+1])
        elif kind == 'ListComp':
            # node.generators is a comprehension.
            for item in node.generators:
                target = item.target
                kind2 = cx.u.kind(target)
                if kind2 == 'Name':
                    if s == target.id:
                        result.append(statement)
                elif kind2 == 'Tuple':
                    for item2 in target.elts:
                        if cx.u.kind(item2) == 'Name' and s == item2.id:
                            result.append(statement)
                            break
                else:
                    assert False,kind2
        else:
            assert False,kind
    return list(set(result))
</t>
<t tx="ekr.20140526082700.18071">def assignments_using (self,s):
    
    result = []
    for node in self.assignments():
        assert node.kind in ('Assign','AugAssign'),node.kind
        val = node.value
        rhs = self.format(val)
        i = rhs.find(s,0)
        while -1 &lt; i &lt; len(rhs):
            if g.match_word(rhs,i,s):
                result.append(node)
                break
            else:
                i += len(s)

    return result
</t>
<t tx="ekr.20140526082700.18072">def call_args_of (self,s):
    
    result = []
    for node in self.calls():
        assert node.kind == 'Call'
        func = self.format(node.func)
        if s == func:
            result.append(node) ### Should return only args.

    return result
</t>
<t tx="ekr.20140526082700.18073"># This is really a helper for calls_to/call_args_of.
def calls(self):
    
    result = []
    for cx in self.contexts():
        result.extend(cx.calls_list)
    return result
</t>
<t tx="ekr.20140526082700.18074">def calls_to (self,s):

    result = []
    for node in self.calls():
        assert node.kind == 'Call'
        func = self.format(node.func)
        if s == func:
            result.append(node)

    return result
</t>
<t tx="ekr.20140526082700.18075">def classes (self):
    
    result = []
    for cx in self.contexts():
        result.extend(cx.classes_list)
    return result
</t>
<t tx="ekr.20140526082700.18076">def contexts (self,name=None):
        
    '''An iterator returning all contexts.
    
    If name is given, return only contexts with the given name.'''
    
    cx = self
    
    if name is None or cx.name == name:
        yield cx
       
    for cx2 in self.classes_list:
        for z in cx2.contexts(name=name):
            if z != self:
                yield z

    for cx2 in self.defs_list:
        for z in cx2.contexts(name=name):
            if z != self:
                yield z
</t>
<t tx="ekr.20140526082700.18077"># These getters are designed for unit testing.
def get_contexts(self,name):
    
    '''Return the list of symbol tables having the given name.
    If the list has exactly one element, return it.'''
    
    aList = list(self.contexts(name=name))
    return aList[0] if aList and len(aList) == 1 else aList
   
def get_unique_context (self,name):
    
    '''Return the unique symbol table having the given name.
    Raise AssertionError if the unexpected happens.'''
    
    aList = list(self.contexts(name=name))
    assert aList and len(aList) == 1,aList
    return aList[0]
</t>
<t tx="ekr.20140526082700.18078">def defs (self):
    
    result = []
    for cx in self.contexts():
        result.extend(cx.defs_list)
    return result
</t>
<t tx="ekr.20140526082700.18079">def parent_contexts (self):
    
    cx = self
    result = []

    while cx.parent_context:
        result.append(cx.parent_context)
        cx = cx.parent_context

    result.reverse()
    return result
</t>
<t tx="ekr.20140526082700.18080"># Using cx.returns_list will almost always be correct.

if 0:
    
    def returns (self):
        
        '''Return all return statements in the present context and all descendant contexts.'''
        
        result = []
        for cx in self.contexts():
            result.extend(cx.returns_list)
        return result
</t>
<t tx="ekr.20140526082700.18081">def statements (self):
    
    '''A generator yielding all statements in the receiver context, in the proper order.'''

    cx = self
    assert cx.kind in ('class','def','lambda','module')
    for node in cx.statements_list:
        yield node
</t>
<t tx="ekr.20140526082700.18082">def symbol_tables (self,name=None):
    
    '''Return all symbol tables for all contexts.
    If name is given, return only symbol tables for contexts with the given name.'''
    
    cx = self

    if name:
        for cx2 in self.contexts():
            if name == cx2.name:
                yield cx2.st
    else:
        for cx2 in self.contexts():
            yield cx2.st

</t>
<t tx="ekr.20140526082700.18083"># These getters are designed for unit testing.
def get_symbol_tables (self,name):
    
    '''Return the list of symbol tables having the given name.
    If the list has exactly one element, return it.'''
    
    aList = list(self.symbol_tables(name=name))
    return aList[0] if aList and len(aList) == 1 else aList
   
def get_unique_symbol_table (self,name):
    
    '''Return the unique symbol table having the given name.
    Raise AssertionError if the unexpected happens.'''
    
    aList = list(self.symbol_tables(name=name))
    assert aList and len(aList) == 1,aList
    return aList[0]
</t>
<t tx="ekr.20140526082700.18084">def symbol_table_entries (self,name):
    
    '''Return all STE's for the given name.'''
    
    cx = self

    for cx2 in cx.contexts():
        d = cx2.st.d
        e = d.get(name)
        if e:
            yield d.get(name)
</t>
<t tx="ekr.20140526082700.18085">def local_statements(self):
    
    '''Return the top-level statements of a context.'''
    
    cx = self

    assert cx.kind in ('class','def','lambda','module')

    return cx.node.body
</t>
<t tx="ekr.20140526082700.18086"># def line_number (self):
    
    # return self.tree_ptr.lineno
</t>
<t tx="ekr.20140526082700.18087"># def token_range (self):
    
    # tree = self.tree_ptr
    
    # # return (
        # # g.toUnicode(self.byte_array[:tree.col_offset]),
        # # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # # )
    
    # if getattr(tree,'col_offset',None):
        # return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    # else:
        # return -1,-1
</t>
<t tx="ekr.20140526082700.18088">class ClassContext (Context):

    '''A class to hold semantic data about a class.'''
    
    @others

</t>
<t tx="ekr.20140526082700.18089">def __init__(self,u,parent_context,name,node,bases):

    Context.__init__(self,u,parent_context)
        # Init the base class.

    self.ctor = None # Filled in when def __init__ seen.
    self.kind = 'class'
    self.bases = bases # A list of ast.Name nodes?
    self.name = name
    self.class_context  = self
    self.def_context = self.parent_context.def_context
    self.ivars_dict = {} # Keys are names, values are reaching sets.
    self.module_context = self.parent_context.module_context
    self.node = node
    u.stats.n_classes += 1
</t>
<t tx="ekr.20140526082700.18090">def __repr__ (self):

    if self.bases:
        bases = [self.format(z) for z in self.bases]
        return 'Cx:class %s(%s)' % (self.name,','.join(bases))
    else:
        return 'Cx:class %s' % (self.name)

__str__ = __repr__        
</t>
<t tx="ekr.20140526082700.18091">def short_description(self):
    
    if self.bases:
        bases = [self.format(z) for z in self.bases]
        return 'class %s(%s):' % (self.name,','.join(bases))
    else:
        return 'class %s:' % (self.name)
</t>
<t tx="ekr.20140526082700.18092">class DefContext (Context):

    '''A class to hold semantic data about a function/method.'''
        
    @others

    
</t>
<t tx="ekr.20140526082700.18093">def __init__(self,u,parent_context,name):
    
    Context.__init__(self,u,parent_context)
    self.kind = 'def'
    self.name = name
    self.args = None # Must be set later.
    self.class_context = self.parent_context.class_context
    self.def_context = self
    self.module_context = self.parent_context.module_context
    self.node = None
    u.stats.n_defs += 1
</t>
<t tx="ekr.20140526082700.18094">def __repr__ (self):
    
    args = self.format(self.args) if self.args else  '&lt;**no args yet**&gt;'

    return 'Cx:def %s(%s)' % (self.name,args)

__str__ = __repr__        
</t>
<t tx="ekr.20140526082700.18095">def short_description (self):
  
    args = self.format(self.args) if self.args else ''

    return 'def %s(%s):' % (self.name,args)
</t>
<t tx="ekr.20140526082700.18096">class LambdaContext (Context):

    '''A class to represent the range of a 'lambda' statement.'''

    def __init__(self,u,parent_context,name):
        Context.__init__(self,u,parent_context)
        self.kind = 'lambda'
        self.args = None # Patched in later.
        self.class_context  = self.parent_context.class_context
        self.def_context    = self.parent_context.def_context
        self.module_context = self.parent_context.module_context
        self.name = name # Set to 'Lambda@@n' by the caller.
        self.node = None
        u.stats.n_lambdas += 1

    def __repr__ (self):
        if self.args:
            args = ','.join([self.format(z) for z in self.args])
        else:
            args = 'None'
        return 'Cx:lambda %s:' % (args)

    __str__ = __repr__
</t>
<t tx="ekr.20140526082700.18097">class LibraryModuleContext (Context):

    '''A class to hold semantic data about a module.'''

    def __init__(self,u,fn):
        Context.__init__(self,u,parent_context=None)
        self.kind = 'module'
        self.class_context  = None
        self.def_context    = None
        self.fn = g.os_path_abspath(fn)
        self.module_context = self
        self.module_type = Module_Type(u,self,node=None)
            # The singleton *constant* type of this module.
        if fn.find('.') &gt; -1:
            self.name = g.shortFileName(self.fn)[:-3]
        else:
            self.name = fn
        self.node = None
        u.stats.n_library_modules += 1

    def __repr__ (self):
        return 'Cx:module(%s)' % self.name

    __str__ = __repr__        
</t>
<t tx="ekr.20140526082700.18098">class ModuleContext (Context):

    '''A class to hold semantic data about a module.'''

    def __init__(self,u,fn,node):
        Context.__init__(self,u,parent_context=None)
        self.kind = 'module'
        self.class_context  = None
        self.def_context    = None
        self.fn = g.os_path_abspath(fn)
        self.module_context = self
        self.module_type = Module_Type(u,self,node)
            # The singleton *constant* type of this module.
        if fn.find('.') &gt; -1:
            self.name = g.shortFileName(self.fn)[:-3]
        else:
            self.name = fn
        self.node = node
        u.stats.n_modules += 1

    def __repr__ (self):
        return 'Cx:module(%s)' % self.name

    __str__ = __repr__        
</t>
<t tx="ekr.20140526082700.18099">class GeneralTest: ### (StcTest):
    
    '''A general test class.'''
    
    @others
</t>
<t tx="ekr.20140526082700.18196">class HybridAstTraverser(AstTraverser):
    
    # def __init__(self):
        # AstTraverser.__init__(self)
        
    @others
</t>
<t tx="ekr.20140526082700.18197">def visit(self,node,data):
    
    '''Visit a tree using a combination of iteration and recursion.'''
    
    # pylint: disable=W0221
        # Arguments number differs from overridden method.
    
    assert isinstance(node,ast.AST),node.__class__.__name__
    method = getattr(self,'do_'+node.__class__.__name__,self.visit_children)
    return method(node,data)
</t>
<t tx="ekr.20140526082700.18198">def visit_children(self,node,data):
    
    # pylint: disable=W0221
        # Arguments number differs from overridden method.
    
    assert isinstance(node,ast.AST),node.__class__.__name__

    stack = list(self.get_child_nodes(node))
    while stack:
        node2 = stack.pop()
        kind = node2.__class__.__name__
        method = getattr(self,'do_'+kind,None)
        if method:
            # The method is responsible for visiting children.
            data = method(node2,data)
        else:
            # Just push the children.
            stack.extend(list(self.get_child_nodes(node2)))
    return data
</t>
<t tx="ekr.20140526082700.18199">class IterativeAstTraverser:
    
    # def __init__(self):
        # pass
        
    @others
</t>
<t tx="ekr.20140526082700.18200"></t>
<t tx="ekr.20140526082700.18201">def private_visit(self,node):
    
    '''Visit a node and all its descendants *without* using recursion.
    
    Visitor methods should *not* call visit, visit_children or visit_list:
    the visit method visits all nodes automatically.
    '''
    
    trace = False
    nodes=[]
    
    for node in self._iterative_postorder_nodes(node):
        kind = node.__class__.__name__
        if trace: nodes.append(kind)
        method = getattr(self,'do_'+kind,None)
        if method:
            if trace: g.trace(method,node)
            method(node)

    if trace: g.trace('\n'+' '.join(reversed(nodes)))
</t>
<t tx="ekr.20140526082700.18202">def _iterative_postorder_nodes(self,node):

    '''Iteratively yield a node and its descendants in post order:
    that is, this yields all descendants of a node before yielding the node.
    
    Adapted from the iterativePostorder algorithm at:
    http://en.wikipedia.org/wiki/Tree_traversal#Postorder
    '''

    marked_nodes = {} # Do *not* alter the AST nodes!
    stack = [node]
    while stack:
        all_visited = True
        for child in self._children(stack[-1]):
            if not marked_nodes.has_key(id(child)):
                stack.append(child)
                all_visited = False
        if all_visited:
            node2 = stack.pop()
            marked_nodes[id(node2)]=True
            yield node2
</t>
<t tx="ekr.20140526082700.18203">def _children(self,node):

    if isinstance(node, ast.Module):
        for node2 in node.body:
            yield node2

    elif isinstance(node,ast.AST) and node._fields is not None:
        for name in node._fields:
            child = getattr(node,name)
            if isinstance(child,list):
                for node2 in child:
                    if isinstance(node2, ast.AST):
                        yield node2
            elif isinstance(child, ast.AST):
                yield child
    else:
        raise StopIteration
</t>
<t tx="ekr.20140526082700.18204">class Pass1 (AstTraverser):
    
    ''' Pass1 traverses an entire AST tree, creating symbol
    tables and context objects, injecting pointers to them
    in the tree. This pass also resolves Python names to
    their proper context, following the rules of section
    4.1, Naming and binding, of the Python langauge
    reference.
    
    Pass1 uses the tree-traversal code from the AstTraverser
    base class. As a result, not all AST nodes need to be
    visited explicitly.
    
    Pass 1 injects the following fields into ast.AST nodes::

    for N in cx: refs_list: N.e = e
    for N in (ast.Class, ast.FunctionDef and ast.Lambda): N.new_cx = new_cx
    For ast.Name nodes N: N.e = e ; N.cx = cx
    For all operator nodes N: N.op_name = &lt;spelling of operator&gt;

    For every context C, Pass 1 sets the following ivars of C:
        C.node                  &lt;node defining C&gt;
        C.ivars_dict            Dictionary of ivars.
                                Keys are names, values are reaching sets (set by SSA pass)
        C.assignments_list      All assignment statements in C
        C.calls_list            All call statements defined in C.
        C.classes_list          All classes defined in C.
        C.defs_list             All functions defined in C.
        C.expressions_list      All Expr nodes in C.
        C.returns_list          All return statements in C.
        C.yields_list           All yield statements in C.
    '''

    @others
</t>
<t tx="ekr.20140526082700.18205">def __init__(self):
    
    # Init the base class.
    AstTraverser.__init__(self)
    
    # Abbreviations.
    self.stats = Stats()
    self.u = Utils()
    self.format = u.format
    
    # self.gen_flag = False
        # True: enable code generation (in part of an AST).
        # We generate code only for assignments,
        # returns, yields and function calls.

    self.in_attr = False
        # True: traversing inner parts of an AST.Attribute tree.
</t>
<t tx="ekr.20140526082700.18206">def run (self,root):

    self.visit(root)
</t>
<t tx="ekr.20140526082700.18207">def visit(self,node):
    
    """Walk a tree of AST nodes, injecting _parent entries into the tree."""
    
    assert isinstance(node,ast.AST),node.__class__.__name__
    node._parent = self.parents[-1]
    if self.context_stack:
        node.cx = self.context_stack[-1]

    self.level += 1
    self.parents.append(node)

    method_name = 'do_' + node.__class__.__name__
    # stat_name = 'n_' + node.__class__.__name__ + '_nodes'
    method = getattr(self,method_name,None)
    if method:
        # method is responsible for traversing subtrees.
        val = method(node)
    else:
        # Traverse subtrees automatically.
        val = None
        for child in self.get_child_nodes(node):
            val = self.visit(child)
            
    self.level -= 1
    self.parents.pop()
    return val
</t>
<t tx="ekr.20140526082700.18208"></t>
<t tx="ekr.20140526082700.18209">def bind_name(self,new_cx,old_cx,old_e,name):
    
    trace = False

    new_e = new_cx.st.d.get(name)
    if not new_e:
        # Not an error: name is not defined in new_cx.
        return

    assert old_e
    if old_e == new_e:
        return
        
    if trace and old_e.defs_list:
        g.trace('*****',old_e.defs_list)
        
    if trace:
        g.trace('%22s old_cx: %20s new_cx: %20s' % (name,old_cx,new_cx))

    assert old_cx.st.d.get(name) == old_e
    assert not old_e.defined
    self.stats.n_relinked_names += 1

    # Change all the references to old_e to references to new_e.
    for node in old_e.refs_list:
        kind = self.kind(node)
        assert kind in ('Builtin','Import','ImportFrom','Name'),kind
        setattr(node,'e',new_e)
        self.stats.n_relinked_pointers += 1

    # Merge the reference_lists.
    new_e.refs_list.extend(old_e.refs_list)

    # Relocate the old symbol table entry.
    old_cx.st.d[name] = new_e
</t>
<t tx="ekr.20140526082700.18210">def bind_unbound_name(self,name,cx):
    
    '''Name has just been bound in context cx.
    
    Bind all matching unbound names in descendant contexts.'''
    
    # Important: this method has little or no effect on overall speed.
    
    # g.trace('*** %10s %s' % (name,cx))
    for cx2 in cx.contexts():
        if cx2 != cx:
            e2 = cx2.st.d.get(name)
            if e2 and not e2.defined:
                self.bind_name(cx,cx2,e2,name)
</t>
<t tx="ekr.20140526082700.18211"># arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def def_args_helper (self,cx,def_e,node):
    
    assert self.kind(node) == 'arguments'
    self.visit_list(node.args)
    self.visit_list(node.defaults)
    for field in ('vararg','kwarg'): # node.field is a string.
        name = getattr(node,field,None)
        if name:
            e = cx.st.define_name(name)
            self.stats.n_param_names += 1
</t>
<t tx="ekr.20140526082700.18212">def get_import_names (self,node):

    '''Return a list of the the full file names in the import statement.'''

    result = []

    for ast2 in node.names:

        if self.kind(ast2) == 'alias':
            data = ast2.name,ast2.asname
            result.append(data)
        else:
            g.trace('unsupported kind in Import.names list',self.kind(ast2))

    # g.trace(result)
    return result
</t>
<t tx="ekr.20140526082700.18213">def resolve_import_name (self,spec):

    '''Return the full path name corresponding to the import spec.'''

    trace = False ; verbose = False

    if not spec:
        if trace: g.trace('no spec')
        return ''
    
    ### This may not work for leading dots.
    aList,path,paths = spec.split('.'),None,None

    for name in aList:
        try:
            f,path,description = imp.find_module(name,paths)
            if not path: break
            paths = [path]
            if f: f.close()
        except ImportError:
            # Important: imports can fail due to Python version.
            # Thus, such errors are not necessarily searious.
            if trace: g.trace('failed: %s paths: %s cx: %s' % (
                name,paths,self.get_context()))
            path = None
            break
            
    if trace and verbose: g.trace(name,path)
            
    if not path:
        if trace: g.trace('no path')
        return ''

    if path.endswith('.pyd'):
        if trace: g.trace('pyd: %s' % path)
        return ''
    else:
        if trace: g.trace('path: %s' % path)
        return path
</t>
<t tx="ekr.20140526082700.18214"></t>
<t tx="ekr.20140526082700.18215">def do_Assign(self,node):
    
    cx = self.get_context()
    self.stats.n_assignments += 1
    self.visit_children(node)
    cx.assignments_list.append(node)
    cx.statements_list.append(node)
</t>
<t tx="ekr.20140526082700.18216"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self,node):

    cx = self.get_context()
    self.stats.n_attributes += 1
    old_attr,self.in_attr = self.in_attr,True
    ctx = self.kind(node.ctx)
    self.visit_children(node)
    self.in_attr = old_attr
    if not self.in_attr:
        base_node = self.attribute_base(node)
        assert base_node
        kind = self.kind(base_node)
        if kind in ('Builtin','Name'):
            base_name = base_node.id
            assert base_node and base_name
            e = cx.st.add_name(base_name)
            e.refs_list.append(base_node)
            ### e.add_chain(base,node) ### ?
        elif kind in ('Dict','List','Num','Str','Tuple',):
            pass
        elif kind in ('BinOp','UnaryOp'):
            pass
        else:
            assert False,kind
</t>
<t tx="ekr.20140526082700.18217">def do_AugAssign(self,node):
    
    self.stats.n_assignments += 1
    cx = self.get_context()
    
    self.visit_children(node)
    cx.assignments_list.append(node)
    cx.statements_list.append(node)
        
</t>
<t tx="ekr.20140526082700.18218"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self,node):
    
    cx = self.get_context()
    self.stats.n_calls += 1
    cx.calls_list.append(node)

    n = len(node.args or []) + int(bool(node.starargs)) + int(bool(node.kwargs))
    d = self.stats.actual_args_dict
    d[n] = 1 + d.get(n,0)

    self.visit_children(node)
</t>
<t tx="ekr.20140526082700.18219"># ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef (self,node):

    '''Create a context for a class, and
    define the class name in the present context.'''
    
    old_cx = self.get_context()
    name = node.name
    
    # Generate code for the base classes.
    # g.trace([self.format(z) for z in node.bases]) # A list of ast.Name nodes.
    ### bases = self.visit_list(node.bases)
    new_cx = ClassContext(old_cx,name,node,node.bases)
    setattr(node,'new_cx',new_cx) # Bug fix: 2013/01/27

    # Generate code for the class members.
    self.push_context(new_cx)
    self.visit_list(node.body)
    self.pop_context()

    # Define the name in the old context.
    e = old_cx.st.define_name(name)
    e.node = node # 2012/12/25
    node.e = e # 2012/12/25
    # g.trace(e,node)
    e.self_context = new_cx
    old_cx.classes_list.append(new_cx)
    
    # Bind all unbound matching names in inner contexts.
    self.bind_unbound_name(name,new_cx)

</t>
<t tx="ekr.20140526082700.18220"># Expr(expr value)

def do_Expr(self,node):
    
    cx = self.get_context()
    self.visit_children(node)
    self.stats.n_expressions += 1
    cx.expressions_list.append(node)
    cx.statements_list.append(node)
</t>
<t tx="ekr.20140526082700.18221">def do_For(self,node):
    
    cx = self.get_context()
    self.stats.n_fors += 1
    self.visit_children(node)
    cx.statements_list.append(node)
    cx.assignments_list.append(node)
</t>
<t tx="ekr.20140526082700.18222"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,node):
    
    # Stats
    args = node.args.args
    n = len(args) if args else 0
    d = self.stats.formal_args_dict
    d[n] = 1 + d.get(n,0)

    # Switch to the new context.
    old_cx = self.get_context()
    
    # Define the function/method name in the old context.
    name = node.name
    e = old_cx.st.define_name(name)

    # Create the new context: args are known in the new context.
    new_cx = DefContext(old_cx,name)
    setattr(node,'new_cx',new_cx) # Bug fix.
    setattr(node,'e',e) # Bug fix: 2012/12/28.
    new_cx.node = node
    e.self_context = new_cx
    
    # If this is a method, remember it:
    if old_cx and old_cx.class_context:
        # If this is the ctor, remember it.
        if name == '__init__':
            old_cx.class_context.ctor = new_cx
        # 2013/01/28: Add the method to the ivars dict.
        d = old_cx.class_context.ivars_dict
        if name in d:
            # Not quite a correct error, but something unusual is happening.
            self.error('%20s method hides ivar' % name)
        else:
            aList = d.get(name,[])
            aList.append(node)
            d [name] = aList

    # Define the function arguments before visiting the body.
    # These arguments, including 'self', are known in the body.
    self.push_context(new_cx)
    self.def_args_helper(new_cx,e,node.args)
    self.pop_context()
    
    new_cx.args = node.args # was set by def_args_helper.
    old_cx.defs_list.append(new_cx)

    # Evaluate the body in the new context.
    self.push_context(new_cx)
    self.visit_list(node.body)
    new_cx.node = e.node = node
    self.pop_context()
    
    # Bind all unbound matching names in inner contexts.
    self.bind_unbound_name(name,new_cx)
</t>
<t tx="ekr.20140526082700.18223">def do_Global(self,node):

    '''Enter the names in a 'global' statement into the *module* symbol table.'''

    cx = self.get_context()
    cx.statements_list.append(node)
    self.stats.n_globals += 1

    for name in node.names:
        
        # Create a symbol table entry for the name in the *module* context.
        module_e = cx.module_context.st.add_name(name)
        
        # This does *not* define the symbol!
        module_e.defined = False
        
        # Both Python 2 and 3 generate SyntaxWarnings when a name
        # is used before the corresponding global declarations.
        # We can make the same assumpution here:
        # give an *error* if an STE appears in this context for the name.
        # The error indicates that scope resolution will give the wrong result.
        e = cx.st.d.get(name)
        if e:
            self.u.error('name \'%s\' used prior to global declaration' % (name))
            # Add the name to the global_names set in *this* context.
            # cx.global_names.add(name)
            
        # Regardless of error, bind the name in *this* context,
        # using the STE from the module context.
        cx.st.d[name] = module_e
</t>
<t tx="ekr.20140526082700.18224">@ From Guido:

import x            --&gt;  x = __import__('x')
import x as y       --&gt;  y = __import__('x')
import x.y.z        --&gt;  x = __import__('x.y.z')
import x.y.z as p   --&gt;  p = __import__('x.y.z').y.z
@c

def do_Import(self,node):

    '''Add the imported file to u.files_list if needed
    and create a context for the file.'''

    trace = False
    cx = self.get_context()
    cx.statements_list.append(node)
    e_list,names = [],[]
    for fn,asname in self.get_import_names(node):
        fn2 = self.resolve_import_name(fn)
        # Important: do *not* analyze modules not in the files list.
        if fn2:
            mname = self.u.module_name(fn2)
            if g.shortFileName(fn2) in self.u.files_list: 
                if mname not in self.u.module_names:
                    self.u.module_names.append(mname)
            # if trace: g.trace('%s as %s' % (mname,asname))
            def_name = asname or mname
            names.append(def_name)
            e = cx.st.define_name(def_name) # sets e.defined.
            cx.imported_symbols_list.append(def_name)
            if trace: g.trace('define: (Import) %10s in %s' % (def_name,cx))
            e_list.append(e)

            # Add the constant type to the list of types for the *variable*.
            mod_cx = self.u.modules_dict.get(fn2) or LibraryModuleContext(self.u,fn2)
            e.types_cache[''] = mod_cx.module_type
            self.u.stats.n_imports += 1
        else:
            if trace: g.trace('can not resolve %s in %s' % (fn,cx))

    for e in e_list:
        e.defs_list.append(node)
        e.refs_list.append(node)
</t>
<t tx="ekr.20140526082700.18225">@ From Guido:
    
from p.q import x       --&gt;  x = __import__('p.q', fromlist=['x']).x
from p.q import x as y  --&gt;  y = __import__('p.q', fromlist=['x']).x
from ..x.y import z     --&gt;  z = __import('x.y', level=2, fromlist=['z']).z

All these equivalences are still somewhat approximate; __import__
isn't looked up the way other variables are looked up (it is taken
from the current builtins), and if the getattr operation in the "from"
versions raises AttributeError that is translated into ImportError.

There's also a subtlety where "import x.y" implies that y must be a
submodule/subpackage of x, whereas in "from x import y" it may be
either a submodule/subpackage or a plain attribute (e.g. a class,
function or some other variable).
@c

def do_ImportFrom(self,node):

    '''Add the imported file to u.files_list if needed
    and add the imported symbols to the *present* context.'''

    trace = False ; dump = False
    if trace and dump:
        self.u.dump_ast(node)
        
    u = self.u
    cx = self.get_context()
    cx.statements_list.append(node)
    m = self.resolve_import_name(node.module)
    
    if m and m not in self.u.files_list:
        if trace: g.trace('adding module',m)
        self.u.files_list.append(m)

    e_list,names = [],[]
    for fn,asname in self.get_import_names(node):
        fn2 = asname or fn
        if fn2 == '*':
            if trace: g.trace('From x import * not ready yet')
            return
        names.append(fn2)
        e = cx.st.add_name(fn2)
        cx.imported_symbols_list.append(fn2)
        e_list.append(e)
        if trace: g.trace('define: (ImportFrom) %s' % (fn2))
        # Get the ModuleContext corresponding to fn2.
        mod_cx = self.u.modules_dict.get(fn2)
        ###
        ### if not mod_cx:
        ###    self.u.modules_dict[fn2] = mod_cx = ModuleContext(fn2)
        if mod_cx:
            # module_type is the singleton *constant* type of the module.
            module_type = mod_cx.module_type
            # Add the constant type to the list of types for the *variable*.
            e.defined = True # Indicate there is at least one definition.
            e.types_cache[''] = mod_cx.module_type
            mname = u.module_name(fn2)
            ### if mname not in self.u.module_names:
            ###    self.u.module_names.append(mname)
            u.stats.n_imports += 1

    for e in e_list:
        e.defs_list.append(node)
        e.refs_list.append(node)
</t>
<t tx="ekr.20140526082700.18226">def do_Interactive(self,node):
    
    assert False,'Interactive context not supported'
</t>
<t tx="ekr.20140526082700.18227">def do_Lambda (self,node):
    
    old_cx = self.get_context()

    # Synthesize a lambda name in the old context.
    # This name must not conflict with split names of the form name@n.
    old_cx.n_lambdas += 1
    name = 'Lambda@@%s' % old_cx.n_lambdas
    e = old_cx.st.define_name(name)

    # Define a namespace for the 'lambda' variables.
    new_cx = LambdaContext(self.u,old_cx,name)
    setattr(node,'new_cx',new_cx)
    setattr(node,'e',e) # Bug fix: 2012/12/28.
    new_cx.node = node
    
    self.push_context(new_cx)
    def_e = None
    args = self.def_args_helper(new_cx,def_e,node.args)
    body = self.visit(node.body)
    self.pop_context()
</t>
<t tx="ekr.20140526082700.18228">def do_ListComp(self,node):
    
    self.stats.n_list_comps += 1
    self.visit_children(node)

    cx = self.get_context()
    cx.assignments_list.append(node)
</t>
<t tx="ekr.20140526082700.18229">def do_Module (self,node):

    # Get the module context from the global dict if possible.
    
    # Bug fix: treat all &lt;string&gt; files as separate modules.
    new_cx = None if self.fn == '&lt;string&gt;' else self.u.modules_dict.get(self.fn)

    if not new_cx:
        new_cx = ModuleContext(self.u,self.fn,node)
        self.u.modules_dict[self.fn] = new_cx
        
    new_cx.node = node

    self.push_context(new_cx)
    self.visit_list(node.body)
    self.pop_context()
    
    # Bind all unbound matching names in inner contexts.
    for name in sorted(new_cx.st.d.keys()):
        self.bind_unbound_name(name,new_cx)
</t>
<t tx="ekr.20140526082700.18230">def do_Name(self,node):

    trace = False
    cx  = self.get_context()
    ctx = self.kind(node.ctx)
    name = node.id
    
    # Create the symbol table entry, even for builtins.
    e = cx.st.add_name(name)
    setattr(node,'e',e)
    setattr(node,'cx',cx)
    
    def_flag,ref_flag=False,False
    
    if ctx in ('AugLoad','AugStore','Load'):
        # Note: AugStore does *not* define the symbol.
        e.referenced = ref_flag = True
        self.stats.n_load_names += 1
    elif ctx == 'Store':
        # if name not in cx.global_names:
        e.defined = def_flag = True
        if trace: g.trace('Store: %s in %s' % (name,cx))
        self.stats.n_store_names += 1
    elif ctx == 'Param':
        if trace: g.trace('Param: %s in %s' % (name,cx))
        e.defined = def_flag = True
        self.stats.n_param_refs += 1
    else:
        assert ctx == 'Del',ctx
        e.referenced = ref_flag = True
        self.stats.n_del_names += 1

    if isPython3:
        if name in self.u.module_names:
            return None
    else:
        if name in dir(__builtin__) or name in self.u.module_names:
            return None

    if not self.in_attr:
        if def_flag: e.defs_list.append(node)
        if ref_flag: e.refs_list.append(node)
</t>
<t tx="ekr.20140526082700.18231">def do_Return(self,node):
    
    self.stats.n_returns += 1
    cx = self.get_context()
    if getattr(node,'value'):
        self.visit(node.value)
    cx.returns_list.append(node)
    cx.statements_list.append(node)
    # g.trace('%s %s' % (cx.name,self.format(node)))
</t>
<t tx="ekr.20140526082700.18232"># operator = Add | BitAnd | BitOr | BitXor | Div
# FloorDiv | LShift | Mod | Mult | Pow | RShift | Sub | 

def do_Add(self,node):       setattr(node,'op_name','+')
def do_BitAnd(self,node):    setattr(node,'op_name','&amp;')
def do_BitOr(self,node):     setattr(node,'op_name','|')
def do_BitXor(self,node):    setattr(node,'op_name','^')
def do_Div(self,node):       setattr(node,'op_name','/')
def do_FloorDiv(self,node):  setattr(node,'op_name','//')
def do_LShift(self,node):    setattr(node,'op_name','&lt;&lt;')
def do_Mod(self,node):       setattr(node,'op_name','%')
def do_Mult(self,node):      setattr(node,'op_name','*')
def do_Pow(self,node):       setattr(node,'op_name','**')
def do_RShift(self,node):    setattr(node,'op_name','&gt;&gt;')
def do_Sub(self,node):       setattr(node,'op_name','-')

# boolop = And | Or
def do_And(self,node):       setattr(node,'op_name',' and ')
def do_Or(self,node):        setattr(node,'op_name',' or ')

# cmpop = Eq | Gt | GtE | In |
# Is | IsNot | Lt | LtE | NotEq | NotIn
def do_Eq(self,node):        setattr(node,'op_name','==')
def do_Gt(self,node):        setattr(node,'op_name','&gt;')
def do_GtE(self,node):       setattr(node,'op_name','&gt;=')
def do_In(self,node):        setattr(node,'op_name',' in ')
def do_Is(self,node):        setattr(node,'op_name',' is ')
def do_IsNot(self,node):     setattr(node,'op_name',' is not ')
def do_Lt(self,node):        setattr(node,'op_name','&lt;')
def do_LtE(self,node):       setattr(node,'op_name','&lt;=')
def do_NotEq(self,node):     setattr(node,'op_name','!=')
def do_NotIn(self,node):     setattr(node,'op_name',' not in ')

# unaryop = Invert | Not | UAdd | USub
def do_Invert(self,node):   setattr(node,'op_name','~')
def do_Not(self,node):      setattr(node,'op_name',' not ')
def do_UAdd(self,node):     setattr(node,'op_name','+')
def do_USub(self,node):     setattr(node,'op_name','-')
</t>
<t tx="ekr.20140526082700.18233">def do_With(self,node):
    
    cx = self.get_context()
    self.stats.n_withs += 1
    self.visit_children(node)
    cx.statements_list.append(node)
</t>
<t tx="ekr.20140526082700.18234">class Resolver:
    
    '''A class controlling the resolution pattern matchers.'''

    @others
</t>
<t tx="ekr.20140526082700.18235">def __init__(self):
    
    self.app = app
    self.format = app.format
    self.sd = app.sd

    # g.trace('(Resolver)',g.callers())
    
    # Singleton type objects.
    # self.num_type = Num_Type()
    self.string_type = String_Type()

    # Data created in Pass 1...
    self.constants_list = []
        # List of all constant ops.
        
    # Data created just after scope resolution...
    self.self_list = []
        # List of all instances of self within methods.
    
    # The main lists for the main algorithm.
    self.known_symbols_list = []
        # The list of symbols whose types are definitely known.
        # The main algorithm pops symbols off this list.
    self.mushy_ops_list = []
        # Ops with mushy type sets. Debugging only?
    self.mushy_ste_list = []
        # The lists of symbols that would have mushy type sets.
        # The hard part of resolution deals with such symbols.
   
    self.calls_d = {}
        # Keys are contexts, values are list of calls in the context.
    self.defs_d = {} # The global defs dict.
        # Keys are names; values are sets of Contexts
    self.refs_d = {} # The global refs dict.
        # The global dictionary.
        # Keys are names.  Values are sets of contexts.

    # Class info dicts: keys and values are contexts.
    self.class_supers_d = {} # All superclasses.
    self.class_sub_d = {}  # All subclasses.
    self.class_relatives_d = {}
        # All super and subclasses, as well as other related classes.
        
    # Create the dispatch dict.
    self.dispatch_dict = self.make_dispatch_dict()
</t>
<t tx="ekr.20140526082700.18236"></t>
<t tx="ekr.20140526082700.18237">def classes (self):
    
    '''A generator yielding all class contexts in all modules.'''
    
    r = self
    for cx in r.contexts():
        if cx.kind == 'class':
            yield cx
</t>
<t tx="ekr.20140526082700.18238">def contexts (self):
    
    '''A generator yielding all contexts in all modules.'''
    
    r = self
    for m in r.modules():
        for cx in m.contexts():
            yield cx
</t>
<t tx="ekr.20140526082700.18239">def modules (self):
    
    d = self.sd.modules_dict
    for fn in sorted(d.keys()):
        m = d.get(fn)
        yield m
</t>
<t tx="ekr.20140526082700.18240">def statements(self):
    
    '''A generator yielding all statements in all modules, in the proper order.'''

    r = self
    
    for cx in r.modules():
        for op in cx.statements():
            yield op
</t>
<t tx="ekr.20140526082700.18241">def unresolved_names(self):
    
    r = self
    for cx in r.contexts():
        for e in cx.st.d.values():
            if not e.resolved:
                yield e
</t>
<t tx="ekr.20140526082700.18242">def resolve (self):
    
    trace_time = False
    r = self
    
    if trace_time: t1 = time.time()
    
    # Init &amp; do scope resolution.
    r.make_global_dicts()
    
    if trace_time:
        t2 = time.time()
        g.trace('make dicts &amp; resolve scopes: %2.2f sec' % (t2-t1))
    
    # Add 'self', module names and class names to list of known symbols.
    r.init_self()
    
    if trace_time:
        t3 = time.time()
        g.trace('init_self: %2.2f sec' % (t3-t2))
        
    r.init_module_names()
    
    if trace_time:
        t4 = time.time()
        g.trace('init_module_names: %2.2f sec' % (t4-t3))
        
    r.init_class_names()
    
    if trace_time:
        t5 = time.time()
        g.trace('init_class_names: %2.2f sec' % (t5-t4))
    
    r.known_symbols_list.extend(r.self_list)
    r.known_symbols_list.extend(r.constants_list)
    
    # Run the main algorithm.
    r.main_algorithm()
    
    r.resolve_aliases()
    r.resolve_class_relationships()
    r.analyze_classes()
    r.resolve_ivars()
    
    # The table of type-resolution methods.
    table = (
    )

    # Do the main, iterative, peepholes.
    progress = True
    while progress:
        progress = False
        for f in table:
            progress = progress or f()
            
    # Do the final peepholes.
    
    if trace_time:
        t6 = time.time()
        g.trace('main algorithm: %2.2f sec' % (t6-t5))
</t>
<t tx="ekr.20140526082700.18243">def init_class_names(self):
    
    '''Mark all refereces to class names as known.'''
    
    trace = False
    r = self
    format = self.format
    
    # Step 1: Create a dict whose keys are class names and whose values are lists of STE's.
    # Using a dict instead of a list speeds up the code by a factor of more than 300.
    # For all the files of Leo: 30 sec. for the old way and 0.08 sec. the new way.
    e_dict = {}
    for cx in r.classes():
        cx.class_type = Class_Type(cx) # Do this after scope resolution.
        parent = cx.parent_context
        if parent:
            d = parent.st.d
            e = d.get(cx.name)
            if e:
                key = e.name
                aList = e_dict.get(key,[])
                if e not in aList:
                    aList.append(e)
                        # Use a list to disambiguate classes with the same name.
                    e_dict[key] = aList

    # Step 2: Mark all Name ops refering to class names as knowns.
    for cx in r.contexts():
        d = cx.st.d
        for e in d.values():
            for op in e.refs_list:
                kind = op.__class__.__name__
                if kind == 'Builtin':
                    pass ### Not ready yet.
                elif kind == 'Name':
                    e = op.e
                    if e.name in e_dict:
                        aList = e_dict.get(e.name)
                        assert aList
                        if e in aList:
                            if trace: g.trace('known Name',e,op,op._parent,cx)
                            r.known_symbols_list.append(op)
                elif kind == 'Import':
                    aList = op.e_list
                    for e in aList:
                        if e.name in e_dict:
                            aList = e_dict.get(e.name)
                            assert aList
                            if e in aList:
                                if trace: g.trace('known Import',e,op,op._parent,cx)
                                r.known_symbols_list.append(op)
                elif kind == 'ImportFrom':
                    if trace: g.trace('ImportFrom not ready yet: %s' % (
                        format(op)))
                else:
                    assert False,'Unexpected Op: %s' % kind
</t>
<t tx="ekr.20140526082700.18244">def init_module_names(self):
    
    trace = False
    r,sd = self,self.sd
    format = self.format
    
    # Step 1: Create a dict whose keys are module names and whose values are lists of STE's.
    e_dict = {}
    for fn in sd.modules_dict:
        m = sd.modules_dict.get(fn)
        if trace: g.trace(m)
    # module_names = self.u.module_names
    # e_dict = {}
    # for cx in r.classes():
        # d = cx.st.d
        # e = d.get(cx.name)
        # if e:
            # key = e.name
            # aList = e_dict.get(key,[])
            # if e not in aList:
                # aList.append(e)
                    # # Use a list to disambiguate classes with the same name.
                # e_dict[key] = aList
                
    if trace: g.trace(e_dict)

    # Step 2: Mark all Name ops refering to class names as knowns.
    for cx in r.contexts():
        d = cx.st.d
        for e in d.values():
            for op in e.refs_list:
                kind = op.__class__.__name__
                if kind in ('Builtin','Name'):
                    e = op.e
                    if e and e.name in e_dict:
                        aList = e_dict.get(e.name)
                        assert aList
                        if e in aList:
                            if trace: g.trace('known',e,op,op._parent,cx)
                elif kind == 'Import':
                    aList = op.e_list
                    for e in aList:
                        if e.name in e_dict:
                            aList2 = e_dict.get(e.name)
                            assert aList2
                            if e in aList2:
                                if trace: g.trace('known',e,op,op._parent,cx)
                elif kind == 'ImportFrom':
                    if trace: g.trace('ImportFrom not ready yet: %s' % (
                        format(op)))
                else:
                    assert False,'Unexpected Op: %s' % kind
</t>
<t tx="ekr.20140526082700.18245">def init_self (self):
    
    '''Add all instances of "self" to r.self.list.'''

    r = self
    for class_ in r.classes():
        for def_ in class_.defs():
            e = def_.st.d.get('self')
            if e:
                if len(e.defs_list) &gt; 1:
                    g.trace('*** redefining self',e.defs_list)
                else:
                    r.self_list.extend(e.refs_list)
</t>
<t tx="ekr.20140526082700.18246">def main_algorithm(self):
    
    r = self
    
    # g.trace('known symbols: %s' % (len(r.known_symbols_list)))
    
    while r.known_symbols_list:
        op = r.known_symbols_list.pop()
        r.make_known(op)
</t>
<t tx="ekr.20140526082700.18247">def make_global_dicts (self):
    
    contexts = 0
    r = self
    r.refs_dict = {}
    for m in r.modules():
        for cx in m.contexts():
            contexts += 1
            d = cx.st.d # Keys are names, values are STEs.
            for e in d.values():
                aSet = r.refs_dict.get(e.name,set())
                if cx not in aSet:
                    aSet.add(cx)
                    r.refs_dict[e.name] = aSet
                    
    # r.defs_dict contains entries only for defined names.
    r.defs_dict = {}
    for name in r.refs_dict.keys():
        aSet = r.refs_dict.get(name)
        defs = [cx for cx in aSet if cx.st.d.get(name).defined]
        r.defs_dict[name] = defs

    # g.trace('contexts: %s' % (contexts))
</t>
<t tx="ekr.20140526082700.18248">def make_known(self,op):
    
    '''This is called from the main_algorithm.
    op is an Op representing a name or constant with a single, known type.
    '''

    r = self
    # g.trace('known: %s parent: %s' % (op,op._parent))
    
    if 0:
        g.trace('%10s %9s %-8s %8s %s' % (
            op,id(op),
            op.__class__.__name__,
            op._parent and op._parent.__class__.__name__,op._parent))

    return ###
    # if op._parent:
        # f = r.dispatch_dict.get(op.parent.kind)
        # if f:
            # f(op.parent)
        # else:
            # g.trace('bad op.parent.kind: %s' % op.parent.kind)
            # g.trace(op)
            # assert False
</t>
<t tx="ekr.20140526082700.18249">if 0:
    @others
</t>
<t tx="ekr.20140526082700.18250">def do_Arg (self,op):
    
    # arg = op.arg
    pass
</t>
<t tx="ekr.20140526082700.18251">def do_Arguments (self,op):
    
    # args     = [self.visit(z) for z in op.args]
    # defaults = [self.visit(z) for z in op.defaults]
    pass
</t>
<t tx="ekr.20140526082700.18252">def do_AugAssign(self,op):
    
    # This does not define any value!
    pass
</t>
<t tx="ekr.20140526082700.18253">def do_Keyword(self,op):
    
    # arg   = op.arg
    # value = op.value
    pass
</t>
<t tx="ekr.20140526082700.18254"></t>
<t tx="ekr.20140526082700.18255">def do_Bytes(self,op):

    value = op.value
    # g.trace(value)
</t>
<t tx="ekr.20140526082700.18256">def do_Dict(self,op):

    keys   = op.keys
    values = op.values
    # g.trace(keys,values)
</t>
<t tx="ekr.20140526082700.18257">def do_List(self,op):

    elts = op.elements
    # g.trace(elts)
</t>
<t tx="ekr.20140526082700.18258">def do_Num(self,op):
    
    n = op.n
    # g.trace(n)
</t>
<t tx="ekr.20140526082700.18259">def do_Str(self,op):
    
    '''This represents a string constant.'''

    s = op.s
    # g.trace(s)
    
</t>
<t tx="ekr.20140526082700.18260">def do_Tuple (self,op):
    
    elts = op.elements
    # g.trace(elts)
</t>
<t tx="ekr.20140526082700.18261"></t>
<t tx="ekr.20140526082700.18262">def do_Builtin(self,op):
    
    name = op.name
    # g.trace(name)
</t>
<t tx="ekr.20140526082700.18263">def do_Name(self,op):
    
    name = op.name
    # g.trace(name)
</t>
<t tx="ekr.20140526082700.18264"></t>
<t tx="ekr.20140526082700.18265">def do_Comprehension(self,op):

    result = []
    
    name  = op.name
    iter_ = op.it
    ifs   = op.ifs
    # g.trace(name,iter_,ifs)
</t>
<t tx="ekr.20140526082700.18266">def do_GenExp (self,op):
    
    elt  = op.elt
    gens = op.generators
    # g.trace(elt,gens)
</t>
<t tx="ekr.20140526082700.18267">def do_Index(self,op):
    
    index = op.index
    # g.trace(index)
</t>
<t tx="ekr.20140526082700.18268">def do_ListComp(self,op):

    elt  = op.elt
    gens = op.generators
    # g.trace(elt,gens)
</t>
<t tx="ekr.20140526082700.18269">def do_Slice(self,op):
    
    upper = op.upper
    lower = op.lower
    step  = op.step
    # g.trace(upper,lower,step)
</t>
<t tx="ekr.20140526082700.18270">def do_Subscript(self,op):

    value  = op.value
    slice_ = op.slice_
    # g.trace(value,slice_)
</t>
<t tx="ekr.20140526082700.18271"></t>
<t tx="ekr.20140526082700.18272">def do_Attribute (self,op):
    
    value = op.value
    attr  = op.attr
    # g.trace(attr,value)
</t>
<t tx="ekr.20140526082700.18273">def do_BinOp(self,op):
    
    trace = True
    r = self
    name = op.op_name
    lt   = op.lt
    rt   = op.rt
    assert lt.parent == op
    assert rt.parent == op
    assert op.n_unknowns &gt; 0
    op.n_unknowns -= 1
    if op.n_unknowns &gt; 0: return
    
    ### Testing only.
    if not lt.typ or not rt.typ:
        # if trace: g.trace('missing typ: %s' % op)
        return ###

    assert lt.typ,op
    assert rt.typ,op
    
    if len(lt.typ) == 1 and len(rt.typ):
        lt_type,rt_type = lt.typ[0],rt.typ[0]
        if lt_type == rt_type:
            op.typ = [lt_type]
        # elif lt_type == r.string_type and rt_type == r.num_type:
            # op.typ = [r.string_type]
        else:
            #### Unusual case.
            op.typ.extend(lt.typ)
            op.typ.extend(rt.typ)
    else:
        # Mushy cases.
        op.typ.extend(lt.typ)
        op.typ.extend(rt.typ)
        op.typ = list(set(op.typ))

    if trace and len(op.typ) &gt; 1:
        g.trace('ambiguous: %s%s%s %s' % (lt,name,rt,op.typ))
    
    assert op.typ,'empty op.typ'
    
    if len(op.typ) == 1:
        r.make_known(op)
    else:
        # if trace:
            # g.trace('lt',lt.typ)
            # g.trace('rt',rt.typ)
        r.mushy_ops_list.append(op)
</t>
<t tx="ekr.20140526082700.18274">def do_BoolOp(self,op):
    
    name   = op.op_name
    values = op.values
    # g.trace(name,values)
</t>
<t tx="ekr.20140526082700.18275">def do_Call (self,op):
    
    pass

    # args     = op.args    
    # func     = op.func
    # keyargs  = op.keywords
    # starargs = op.starargs
    # star2args = op.starstarargs
    
    ### We have to know the type of the return value to do anything useful.
    # g.trace(op)
    
    
    
   
</t>
<t tx="ekr.20140526082700.18276">def do_CompareOp(self,op):

    left  = op.left
    ops   = op.ops
    comps = op.comparators
    # g.trace(left,ops,comps)
</t>
<t tx="ekr.20140526082700.18277">def do_TernaryOp(self,op):

    test   = op.test
    body   = op.body
    orelse = op.orelse
    # g.trace(test,body,orelse)
</t>
<t tx="ekr.20140526082700.18278">def do_UnaryOp(self,op):
    
    name    = op.op_name
    operand = op.operand
    # g.trace(name,operand)
</t>
<t tx="ekr.20140526082700.18279">def do_Assign(self,op):
    
    trace = False
    r = self
    target = op.target
    value  = op.value
    assert target.parent == op
    assert value.parent == op
    assert repr(op) == '%s=%s' % (target,value)

    if target.kind == 'Name':
        e = target.e
        defs = e.defs_list
        e.defs_seen += 1

        # Append the new types to e.typ.
        changed = False
        for z in value.typ:
            if z not in e.typ:
                e.typ.append(z)
                changed = True
        if not changed:
            if trace: g.trace('unchanged: %s %s' % (e,e.typ))
            return
                
        # The symbol's type is unambiguously known if
        # a) all defs have been seen and 
        # b) e.type_list has exactly one symbol.
        val = value.typ[0]
        if e.defs_seen == len(defs) and len(value.typ) == 1:
            if trace:
                g.trace('known: %s=%s refs: %s' % (
                    target,val,[z.parent for z in e.refs_list]))
            assert target not in r.known_symbols_list
            # Push all the references to the newly-known symbol.
            r.known_symbols_list.extend(e.refs_list)
            # Add the new value to all Ops in e.refs_list.
            for op in e.refs_list:
                op.typ.append(val)
        else:
            if trace: g.trace('add: %s=%s' % (target,value.typ[0]))
            # Add the new value to all Ops in e.refs_list.
            for op in e.refs_list:
                op.typ.append(val)

        if len(e.typ) &gt; 1:
            if trace: g.trace('mushy: %s=%s' % (target,e.typ))
            if e not in r.mushy_ste_list:
                r.mushy_ste_list.append(e)
                    ### This could be expensive.
                    ### It would be better to make this a per-context list.
    else:
        # assert False,'Unexpected target kind: %s' % target.kind
        if trace: g.trace('unexpected target kind: %s %s' % (target.kind,target))
</t>
<t tx="ekr.20140526082700.18280">def do_nothing(self,op):
    pass
    
    # g.trace(op)
</t>
<t tx="ekr.20140526082700.18281"></t>
<t tx="ekr.20140526082700.18282">def analyze_assignments (self):
    
    r = self
    if 0: ### Old unit test...
        for m in r.modules():
            result = []
            for cx in m.contexts():
                n = len(cx.parent_contexts())
                pad,pad2 = ' '*n,' '*(n+1)
                result.append('%s%s' % (pad,cx))
                if 0:
                    result2 = []
                    for z in cx.assignments_list:
                        result2.append('%s%s' % (
                            pad2,
                            self.format(z.op).strip()))
                    result.extend(sorted(list(set(result2))))
                if 1:
                    result2 = []
                    for z in cx.returns_list:
                        result2.append('%s%s' % (
                            pad2,
                            self.format(z).strip()))
                    result.extend(sorted(list(set(result2))))
</t>
<t tx="ekr.20140526082700.18283">def analyze_calls (self):
    
    pass
</t>
<t tx="ekr.20140526082700.18284">def analyze_returns(self):
    
    r = self
    result = []
    # g.trace()
    for m in r.modules():
        for cx in m.defs():
            # print(cx.name)
            result.append(cx.name)
            for a in sorted(set(cx.assignments_list)):
                # print(' %s' % (a))
                result.append(' %s' % (a))
    # g.trace('end')
    
    return '\n'.join(result)
            
</t>
<t tx="ekr.20140526082700.18285">def resolve_class_relationships (self):
    
    r = self
    
    # Class info dicts: keys and values are contexts.
    r.class_supers_d = {} # All superclasses.
    r.class_sub_d = {}  # All sukbclasses.
    r.class_relatives_d = {}
        # All super and subclasses, as well as other related classes.

    excluded_names = ('object',)
    r_d = r.class_relatives_d
    
    return #### Rewrite

    # for m in r.modules():
        # for cx in m.contexts():
            # if cx.kind == 'class' and cx.name not in excluded_names:
                # hash1 = cx.name
                # aSet = r_d.get(hash1,set())
                # for cx2 in cx.bases:
                    # hash2 = repr(cx2)
                    # aSet2 = r_d.get(hash2,set())
                    # aSet2.add(cx)
                    # aSet.add(cx2)
                    # r_d[hash2] = aSet2
                # r_d[hash1] = aSet
</t>
<t tx="ekr.20140526082700.18286">def analyze_classes(self,aList=None):
    
    trace = False
    r = self

    if aList:
        # Convert names to classes.
        aList = sorted([z for z in r.classes() if z.name in aList])
    else:
        aList = sorted([z for z in r.classes()])

    for cx1 in aList:
        if trace:
            print('%20s %s' % (cx1.name,cx1.bases))
        # for cx2 in aList:
            # r.analyze_class_pair(aList,cx1,cx2)
    
    # for cx in sorted(aList):
        # g.trace(cx.name)

    # g.trace(len(aList))
    
    return aList
</t>
<t tx="ekr.20140526082700.18287">def analyze_class_pair(self,aLisst,cx1,cx2):
    
    r = self
    if cx1 == cx2:
        return
        
    print('  %s: %s' % (cx2.name,cx2.bases))
    # print('    subclass: %s' % (cx2.name in cx1.bases))
    
</t>
<t tx="ekr.20140526082700.18288">def resolve_ivars (self):
    
    r = self
    
    if 0: ###
    
        constants = ('Dict','Int','List','Num','Str','Tuple',)

        g.trace()
    
        trace = True
        
        for m in self.modules():
            g.trace(m)
            for class_ in m.classes():
                for def_ in class_.defs():
                    for op in def_.assignments_to('self'):
                        target = op.target
                        value  = op.value
                        kind = op.__class__.__name__
                        if trace:
                            g.trace(op)
                            g.trace(self.format(op))
                            
                        val = PatternFormatter().visit(value) ### g_pattern_formatter.visit(value)
                        if val in constants:
                            if trace: g.trace('found constant type: %s' % val)
                            if kind == 'Assign':
                                print('%s=%s\n' % (target,val))
                                    # To do: add constant type for the ste for target.
                            else:
                                assert kind=='AugAssign',kind
                                print('%s=%s\n' % (target,val))
</t>
<t tx="ekr.20140526082700.18289">def resolve_aliases (self):
    
    r = self
</t>
<t tx="ekr.20140526082700.18290"># Running ScopeBinder on all Leo files:
# 1.25sec when this class is a subclass of AstTraverser
# 0.75sec when this class is a subclass of AstFullTraverser.

class ScopeBinder(AstFullTraverser):
    
    '''Resolve all symbols to the scope in which they are defined.
    
    This pass is invoked by P1; it must run after P1 has injected
    all fields into the trees and discovered all definitions.
    '''
    
    def __init__(self):
        AstFullTraverser.__init__(self)
        self.init_dicts()
        self.u = Utils()

    @others
</t>
<t tx="ekr.20140526082700.18291">def check(self,fn,root):
    trace = True and not g.app.runningAllUnitTests
    u = self.u
    for cx in u.contexts(root):
        assert hasattr(cx,'stc_context'),cx
        result = []
        self.check_context(cx,result)
        if trace and result:
            result=sorted(set(result))
            pad = ' '*u.compute_node_level(cx)
            result.insert(0,'%s%s' % (pad,u.format(cx)))
            if fn:
                result.insert(0,fn)
            for s in result:
                print(s)
</t>
<t tx="ekr.20140526082700.18292">def check_context(self,cx,result):
    
    trace = False
    u = self.u
    for statement in u.local_statements(cx):
        if trace:
            pad = ' '*u.compute_node_level(statement)
            print(pad+u.format(statement))
        for node in u.local_nodes(statement):
            # if trace:print(' %s%s: %s' % (pad,node.__class__.__name__,u.format(node)))
            if isinstance(node,ast.Name):
                key = node.id
                def_cx = getattr(node,'stc_scope')
                if def_cx:
                    d = def_cx.stc_symbol_table
                    aSet = d.get('*defined*')
                    if key not in aSet:
                        # UnboundLocalError: no definition in scope.
                        pad = ' '*u.compute_node_level(statement)
                        result.append(' %s*%s %s: %s' % (
                            pad,u.format(node.ctx),key,u.format(statement)))
                else:
                    d = self.lookup(cx,key)
                    if d:
                        assert d.has_key(key),repr(key)
                    else:
                        # No scope.
                        pad = ' '*u.compute_node_level(statement)
                        result.append(' %s+%s %s: %s' % (
                            pad,u.format(node.ctx),key,u.format(statement)))
</t>
<t tx="ekr.20140526082700.18293">def dump_symbol_table(self,node):
    
    if getattr(node,'stc_symbol_table',None):
        d = node.stc_symbol_table
        for key in sorted(d.keys()):
            name = d.get(key)
            print('%s:%s' % (self.format(name.ctx),name.id))
</t>
<t tx="ekr.20140526082700.18294">def init_dicts(self):
    
    self.builtins_d = dict([(z,z) for z in __builtins__])

    table = (
        '__builtins__',
        '__file__',
        '__path__',
        '__repr__',
    )
    self.special_methods_d = dict([(z,z) for z in table])
</t>
<t tx="ekr.20140526082700.18295">def lookup(self,cx,key):
    
    '''Return the symbol table for key, starting the search at node cx.'''
    
    trace = False and not g.app.runningAllUnitTests
    assert isinstance(cx,(ast.Module,ast.ClassDef,ast.FunctionDef,ast.Lambda)),cx
    cx2 = cx
    while cx2:
        st = cx.stc_symbol_table
        if key in st.d.keys():
            return st.d
        else:
            cx2 = cx2.stc_context
            assert isinstance(cx,(ast.Module,ast.ClassDef,ast.FunctionDef,ast.Lambda)),cx
    for d in (self.builtins_d,self.special_methods_d):
        if key in d.keys():
            return d
    else:
        if trace:
            g.trace('** (ScopeBinder) no definition for %20s in %s' % (
                key,self.u.format(cx)))
        return None
</t>
<t tx="ekr.20140526082700.18296">def run (self,fn,root):

    self.fn = g.shortFileName(fn)
    self.n_resolved = 0
    self.n_visited = 0
    self.visit(root)
    if 0:
        self.check(fn,root)
        # g.trace('ScopeBinder visited %s nodes' % self.n_visited)
</t>
<t tx="ekr.20140526082700.18297">def visit(self,node):

    # assert isinstance(node,ast.AST),node.__class__.__name__
    method = getattr(self,'do_' + node.__class__.__name__)
    self.n_visited += 1
    return method(node)
</t>
<t tx="ekr.20140526082700.18298"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,node):
    
    self.visit(node.args)
    for z in node.body:
        self.visit(z)
    for z in node.decorator_list:
        self.visit(z)
  
</t>
<t tx="ekr.20140526082700.18299"># Name(identifier id, expr_context ctx)

def do_Name(self,node):
    
    '''Set node.stc_scope for all references to names.'''
    
    trace = False and not g.app.runningAllUnitTests

    # if isinstance(node.ctx.__class__,ast.Param):# 
        # assert node.stc_scope is not None,node
            # P1 has defined the scope.
    # elif isinstance(node.ctx,ast.Store):
        # assert node.stc_scope is not None,node
        
    if node.stc_scope is None:
        # Search for the defining context.
        self.n_resolved += 1
        cx = node.stc_context
            # cx will be None if cx is an ast.Module.
            # In that case, self.lookup will search the builtins.
        d = self.lookup(cx,node.id)
        if d is None:
            # g.trace('(ScopeBinder) undefined symbol: %s' % node.id)
            if trace: print('%s undefined name: %s' % (self.fn,node.id))
</t>
<t tx="ekr.20140526082700.18300">class StringReportTraverser (AstFormatter):
    
    '''Create string reports from an AST tree.'''

    @others
</t>
<t tx="ekr.20140526082700.18301">def __init__(self,fn):
    
    AstFormatter.__init__(self)
        # Init the base class.
    self.debug = True
    self.fn = fn
    self.visitor = self
</t>
<t tx="ekr.20140526082700.18302">def define_html_header(self):
    
    # Use string catenation to avoid using g.adjustTripleString.
    return (
        '&lt;?xml version="1.0" encoding="iso-8859-15"?&gt;\n'
        '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n'
        '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;\n'
        '&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;\n'
        '&lt;head&gt;\n'
        '  &lt;title&gt;%(title)s&lt;/title&gt;\n'
        '  &lt;link rel="stylesheet" type="text/css" href="%(css-fn)s" /&gt;\n'
        '&lt;/head&gt;\n&lt;body&gt;'
    )
</t>
<t tx="ekr.20140526082700.18303">def report(self,node):

    val = self.visit(node)
    s = val and val.strip()
    fn = ' for '+self.fn if self.fn else ''
    return '\nReport%s...\n\n' % (self.fn) + s
   
</t>
<t tx="ekr.20140526082700.18304">def show_all(self,node,tag):
    
    result = []
    s = self.show(node,tag)
    if s: result.append(s)
    for child in self.get_child_nodes(node):
        s = self.show_all(child,tag)
        if s: result.append(s)
    return '\n'.join(result)
</t>
<t tx="ekr.20140526082700.18305">def show(self,node,tag):
    
    e = getattr(node,'e',None)
    table = (
        (node,'cache',tag),
        (e,'call_cache','e(%s)' % (e and e.name or '')),
        (node,'failures',''),
    )
    result = []
    for obj,ivar,tag2 in table:
        if obj and hasattr(obj,ivar):
            list_or_dict = getattr(obj,ivar)
            pad = ' '*2*(self.level+2)
            if hasattr(list_or_dict,'keys'):
                result.append('%s%s:%s...' % (pad,tag2,ivar))
                for key in sorted(list_or_dict.keys()):
                    aList = list_or_dict.get(key)
                    result.append('   %s%s =&gt; %s' % (pad,key,aList))
            else:
                result.append('%sfailures: %s...' % (pad,self.format(obj)))
                result.append('   %s%s' % (pad,list_or_dict))
    # Must end with a newline so the source is shown correctly.
    return '%s\n' % '\n'.join(result) if result else ''
</t>
<t tx="ekr.20140526082700.18306">def visit(self,node):
    
    """Walk a tree of AST nodes."""

    assert isinstance(node,ast.AST),node.__class__.__name__
    kind = node.__class__.__name__
    method = getattr(self,'do_' + kind,None)
    if method:
        # method is responsible for traversing subtrees.
        return method(node)
    else:
        # Traverse subtrees automatically, without calling visit_children.
        return self.show_all(node,kind)
</t>
<t tx="ekr.20140526082700.18307"># Only these nodes may have caches.
</t>
<t tx="ekr.20140526082700.18308">def do_Assign(self,node):

    value = self.visit(node.value)
    assns = ['%s=%s\n' % (self.visit(z),value) for z in node.targets]
    s =  ''.join([self.indent(z) for z in assns])
    return s + self.show_all(node,'Assign')
</t>
<t tx="ekr.20140526082700.18309">def do_Expr(self,node):
    
    '''An outer expression: must be indented.'''
    
    s = self.indent('%s\n' % self.visit(node.value))
    return s + self.show_all(node,'Expr')
</t>
<t tx="ekr.20140526082700.18310">def do_Return(self,node):
     
    val = ' ' + self.visit(node.value) if node.value else ''
    s = self.indent('return%s\n' % val)
    return s + self.show_all(node,'Return')
</t>
<t tx="ekr.20140526082700.18311">def do_Str (self,node):
    
    '''This represents a string constant.'''
    s = repr(node.s)
    return s if len(s) &lt; 60 else s[:57]+'...%s' % (s[0])
</t>
<t tx="ekr.20140526082700.18325">class TypeInferer (AstTraverser):
    
    '''
    This class infers the types of objects.
    
    See the documentation for complete details.
    '''
    
    @others
</t>
<t tx="ekr.20140526082700.18326">def __init__ (self,enable_trace=True):
    
    AstTraverser.__init__(self)
    
    u = Utils()
    self.cache_traverser = CacheTraverser()
    self.dump_ast = u.dump_ast
    self.format = u.format
    self.kind = None
    self.stats = u.stats
    
    # Detecting circular inferences
    self.call_stack = [] # Detects recursive calls
    self.assign_stack = [] # Detects circular assignments.

    # Create singleton instances of simple types.
    self.bool_type = Bool_Type()
    self.builtin_type = Builtin_Type()
    self.bytes_type = Bytes_Type()
    self.float_type = Float_Type()
    self.int_type = Int_Type()
    self.none_type = None_Type()
    self.string_type = String_Type()
    
    # Create the builtin type dict.
    self.builtin_type_dict = {
        'eval': [self.none_type],
        'id':   [self.int_type],
        'len':  [self.int_type],
        'ord':  [self.int_type],
        # list,tuple...
        # close,open,sort,sorted,super...
    }
    
    # Context info.
    self.null_hash = 'hash:none'
    self.call_args = None # The list of argument types for the present call.
    self.call_e = None
    self.call_hash = self.null_hash
        # The hash associated with self.call_args.
        # All hashes must start with 'hash:'

    # Debugging.
    self.align = 15
    self.enable_trace = enable_trace and u.enable_trace
    self.level = 0 # Node nesting level.
    self.n_caches = 0
    self.trace_level = 0 # Trace nesting level.
    self.trace_context = False
    self.trace_context_level = 0
</t>
<t tx="ekr.20140526082700.18327">def run (self,node):
    
    # pylint: disable=W0221
        # Arguments number differs from overridden method.
    
    ti = self
    t1 = time.time()
    ti.check_visitor_names()
    ti.visit(node)
    ti.u.stats.n_caches += ti.n_caches
    t2 = time.time()
    return t2-t1
</t>
<t tx="ekr.20140526082700.18328"># Note: the hash_ argument to ti.get_call_cache can't easily be removed.
</t>
<t tx="ekr.20140526082700.18329">def cache_hash(self,args,e):
    
    ''' Return a hash for a list of type arg. This must be a perfect hash:
    collisions must not be possible.
    
    ti.set_cache asserts hash.startswith('hash:') This ensures that hashes
    can't be confused wiht tracing tags.'''

    return 'hash:%s([%s])' % (
        '%s@%s' % (e.name,id(e)),
        ','.join([repr(arg) for arg in args]))
</t>
<t tx="ekr.20140526082700.18330">def get_cache(self,obj):
    
    '''Return the value of object's cache for the present context, creating
    the cache as needed.'''
    
    ti = self
    if not hasattr(obj,'cache'):
        obj.cache = {}
        ti.n_caches += 1
    return obj.cache.get(ti.call_hash,None)
        # None is the signal for a cache miss.
</t>
<t tx="ekr.20140526082700.18331">def get_call_cache(self,obj,hash_):
    
    '''Return the value of object's cache for the present context, creating
    the cache as needed.'''
    
    ti = self
    if not hasattr(obj,'call_cache'):
        obj.call_cache = {}
        ti.n_caches += 1

    return obj.call_cache.get(hash_)
</t>
<t tx="ekr.20140526082700.18332">def method_hash(self,e,node):
    
    '''If this is a method call, return the hash for the inferred ctor's
    arguments. Otherwise, return the empty string.'''
    
    ti = self
    trace = False and ti.enable_trace
    
    if ti.kind(e.self_context) == 'ClassContext':
        class_cx = e.self_context
        class_name = class_cx.name
        ctor = e.self_context.ctor
        if ctor:
            args = [ti.visit(z) for z in ctor.node.args.args]
            for specific_args in ti.cross_product(args):
                hash_ = ti.cache_hash(specific_args,e)
            return 'hash:class:%s:%s' % (class_name,hash_)
        else:
            if trace: ti.trace(class_name,'no ctor')
    return ''
</t>
<t tx="ekr.20140526082700.18333">def set_cache(self,obj,t,tag=''):

    '''Set the object's cache for the present context to the given type
    list t, creating the cache as needed.'''

    ti = self
    trace = False and ti.enable_trace
    assert isinstance(t,list)
    hash_ = ti.call_hash
    assert hash_.startswith('hash:'),hash_
        # Don't confuse the hash_ and tag_ keywords!
    assert isinstance(t,list)
    if not hasattr(obj,'cache'):
        obj.cache = {}
        ti.n_caches += 1
    
    obj.cache [hash_] = t
    if trace: ti.trace('%s -&gt; %s' % (hash_,t))
        # ti.show_cache(obj,obj.cache,tag)
       
    # Old 
    # aList = obj.cache.get(hash_,[])
    # aList.extend(t)
    # aList = ti.clean(aList)
    #obj.cache [hash_] = aList
</t>
<t tx="ekr.20140526082700.18334">def set_call_cache(self,obj,hash_,t,tag=''):
    
    ti=self
    trace = False and ti.enable_trace
    if not hasattr(obj,'call_cache'):
        obj.call_cache = {}
        ti.n_caches += 1

    # Update e.call_cache, not e.cache!
    assert isinstance(t,list)
    obj.call_cache [hash_] = t
    
    if trace: ti.trace('%s:%s -&gt; %s' % (obj,hash_,t))
 
    ### Old
    # aList = obj.call_cache.get(hash_,[])
    # aList.extend(t)
    # aList = ti.clean(aList)
    # obj.call_cache [hash_] = aList
</t>
<t tx="ekr.20140526082700.18335">def show_cache(self,obj,cache,tag):
    
    ti = self
    d = cache
    # kind = ti.kind(obj)
    pad = ' '*2*ti.level
    s = ti.format(obj) if isinstance(obj,ast.AST) else repr(obj)
    if len(s) &gt; 40: s = s[:40]+'...'
    g.trace('%2s %s %s' % (ti.level,tag,s))
    # pad2 = pad + ' '*44
    for key in sorted(d.keys()):
        aList = d.get(key)
        for item in aList:
            print('   %s =&gt; %s' % (key,item))
    print('')
</t>
<t tx="ekr.20140526082700.18336"></t>
<t tx="ekr.20140526082700.18337">def clean (self,aList):
    
    '''Return sorted(aList) with all duplicates removed.'''
    
    ti = self
    if 1:
        # Good for debugging and traces.
        result = []
        for z in aList:
            if z not in result:
                result.append(z)
        
        # An excellent check.
        assert len(result) == len(list(set(aList))),aList
    else:
        result = list(set(aList))
   
    # Strip out inference errors if there are real results.
    result2 = ti.ignore_failures(result)
    if result2:
        ti.stats.n_clean_success += 1
        return sorted(result2)
    else:
        ti.stats.n_clean_fail += 1
        return sorted(result)
</t>
<t tx="ekr.20140526082700.18338">def cross_product(self,aList):
    
    '''Return generator yielding a list of lists representing the
    cross product of all elements in aList, a list of lists. Examples:
        
    cross_product([['a']])               -&gt; [['a']]
    cross_product([['a'],['b']])         -&gt; [['a'],['b']]
    cross_product([['a'],['b','c']])     -&gt; [['a','b'],['a','c']]
    cross_product([['a','b'],['c']])     -&gt; [['a','c'],['b','c']]
    cross_product([['a','b'],['c','d']]) -&gt; [['a','c'],['a','d'],['b','c'],['b','d']]
    '''
    
    ti = self
    trace = False and ti.enable_trace
    
    # Return a real list so we can do stats on it.
    result = [z for z in itertools.product(*aList)]
    
    if 0:
        g.trace(len(aList),aList)
        for z in result:
            print(z)
    
    if 1: # Stats and traces.
        ambig = len(result) &gt; 1
        if trace and ambig: g.trace('\n',aList,'-&gt;',result)
        ti.stats.n_cross_products += 1
        n = len(result)
        d = ti.stats.cross_product_dict
        d[n] = 1 + d.get(n,0)

    return result
</t>
<t tx="ekr.20140526082700.18339"># These are called *only* from ti.infer_def.
 
def switch_context(self,e,hash_,node):
    ti = self
    ti.trace_context = False and ti.enable_trace
    data = ti.call_args,ti.call_e,ti.call_hash
    ti.call_args = e.call_cache.get(hash_)
    ti.call_e = e
    ti.call_hash = hash_
    if ti.trace_context:
        ti.trace(ti.call_hash,before='\n'+' '*2*ti.trace_context_level)
    ti.trace_context_level += 1
    return data
    
def restore_context(self,data):
    ti = self
    ti.call_args,ti.call_e,ti.call_hash = data
    ti.trace_context_level -= 1
    if self.trace_context:
        ti.trace(ti.call_hash,before=' '*2*ti.trace_context_level)
</t>
<t tx="ekr.20140526082700.18340">def has_failed(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Inference_Failure) for z in t1+t2+t3])
    
def is_circular(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Circular_Assignment) for z in t1+t2+t3])
    
def is_recursive(self,t1,t2=[],t3=[]):
    
    return any([isinstance(z,Recursive_Inference) for z in t1+t2+t3])
    
def ignore_failures(self,t1,t2=[],t3=[]):
    
    return [z for z in t1+t2+t3 if not isinstance(z,Inference_Failure)]
    
def ignore_unknowns(self,t1,t2=[],t3=[]):
    
    return [z for z in t1+t2+t3 if not isinstance(z,(Unknown_Type,Unknown_Arg_Type))]
    
def merge_failures(self,t1,t2=[],t3=[]):

    aList = [z for z in t1+t2+t3 if isinstance(z,Inference_Failure)]
    if len(aList) &gt; 1:
        # Prefer the most specific reason for failure.
        aList = [z for z in aList if not isinstance(z,Unknown_Type)]
    return aList
</t>
<t tx="ekr.20140526082700.18341">def trace(self,*args,**keys):
    
    ti = self

    if 1: # No indentation at all.
        level = 0
    elif 1: # Show tree level.
        level = ti.level
    else: # Minimize trace level.
        if ti.trace_level &lt; ti.level:
            ti.trace_level += 1
        elif ti.trace_level &gt; ti.level:
            ti.trace_level -= 1
        level = ti.trace_level
        
    if keys.get('before') is None:
        before = '.'*level
    else:
        before = keys.get('before')
  
    keys['align'] = ti.align
    keys['before'] = before
    keys['caller_level'] = 2
    g.trace(*args,**keys)
</t>
<t tx="ekr.20140526082700.18342"></t>
<t tx="ekr.20140526082700.18343">def visit(self,node):
    
    '''Infer the types of all nodes in a tree of AST nodes.'''

    ti = self
    assert isinstance(node,ast.AST),node.__class__.__name__
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self,method_name,None)
    val = None
    try:
        ti.level += 1
        if method:
            # The method is responsible for traversing subtrees.
            # Furthermore, somebody uses the returned value.
            val = method(node)
        else:
            # Traverse subtrees automatically.
            # *Nobody* uses the returned value.
            for child in ti.get_child_nodes(node):
                ti.visit(child)
    
            # Returning None is a good test.
            val = None
    finally:
        ti.level -= 1
    return val
</t>
<t tx="ekr.20140526082700.18344">def visit_children(self,node):
    
    ti = self
    assert isinstance(node,ast.AST),node.__class__.__name__
    
    for child in ti.get_child_nodes(node):
        ti.visit(child)

    # Returning None is a good test.
    return None
</t>
<t tx="ekr.20140526082700.18345">def visit_list (self,aList):

    ti = self
    assert type(aList) in (list,tuple),aList
    
    for node in aList:
        ti.visit(node)
        
    # Returning None is a good test.
    return None
</t>
<t tx="ekr.20140526082700.18346"></t>
<t tx="ekr.20140526082700.18347"># arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments (self,node):
    
    '''Bind formal arguments to actual arguments.'''
    
    assert False # All the work is done in ti.Call and its helpers.
</t>
<t tx="ekr.20140526082700.18348">def do_Assign(self,node):

    ti = self
    trace = False and ti.enable_trace
    junk = ti.visit_list(node.targets)
    hash_ = ti.call_hash
    data = hash_,node
    if data in ti.assign_stack:
        t = [Circular_Assignment(hash_,node)]
        ti.stats.n_circular_assignments += 1
    else:
        ti.assign_stack.append(data)
        try:
            t = ti.visit(node.value)
            if trace: ti.trace(t)
        finally:
            data2 = ti.assign_stack.pop()
            assert data == data2
        
    for target in node.targets:
        kind = ti.kind(target)
        if kind == 'Name':
            t0 = ti.get_cache(target.e) or []
            t.extend(t0)
            ti.set_cache(target.e,t,tag='Name:target.e')
            if trace: ti.trace('infer: %10s -&gt; %s' % (
                ti.format(target),t),before='\n')
        else:
            ### What to do about this?
            if trace: ti.trace('(ti) not a Name: %s' % (
                ti.format(target)),before='\n')
                
    # Update the cache immediately.
    t0 = ti.get_cache(node) or []
    t.extend(t0)
    t = ti.clean(t)
    ti.set_cache(node,t,tag='ti.Assign')
    return t
</t>
<t tx="ekr.20140526082700.18349"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute (self,node):

    ti = self
    trace = False and ti.enable_trace
    trace_errors = True ; trace_found = False ; trace_fuzzy = True
    # print('do_Attribute',ti.format(node),node.value,node.attr)
    
    t = ti.get_cache(node)
    if t is not None:
        # g.trace('hit',t)
        return t

    #### ti.set_cache(node,[Unknown_Type(ti.call_hash,node)],tag='ti.Attribute')
    t = ti.visit(node.value)
    t = ti.clean(t) ###
    t = ti.merge_failures(t)
    tag = '%s.%s' % (t,node.attr) # node.attr is always a string.
    if t:
        if len(t) == 1:
            ti.stats.n_not_fuzzy += 1
            t1 = t[0]
            if ti.kind(t1) == 'Class_Type':
                aList = t1.cx.ivars_dict.get(node.attr)
                aList = ti.clean(aList) if aList else []
                if aList:
                    t = []
                    for node2 in aList:
                        t.extend(ti.visit(node2))
                    t = ti.clean(t)
                    ti.set_cache(node,t,tag='ti.Attribute')
                    ti.stats.n_attr_success += 1
                    if trace and trace_found:
                        g.trace('ivar found: %s -&gt; %s' % (tag,t))
                        # [ti.format(z) for z in aList],t))
                elif t1.cx.bases:
                    if trace_errors: g.trace('bases',
                        ti.format(node),[ti.format(z) for z in t1.cx.bases])
                    pass ### Must check super classes.
                    t = [Unknown_Type(ti.call_hash,node)] ###
                else:
                    ti.error('%20s has no %s member' % (ti.format(node),t1.cx.name))
                    t = [Unknown_Type(ti.call_hash,node)] ###
            else:
                ti.stats.n_attr_fail += 1
                if trace and trace_errors:
                    g.trace('fail',t,ti.format(node))
                t = [Unknown_Type(ti.call_hash,node)] ###
        else:
            ti.stats.n_fuzzy += 1
            if trace and trace_fuzzy: g.trace('fuzzy',t,ti.format(node))
    else:
        if trace and trace_errors: g.trace('fail',t,ti.format(node))
        t = [Unknown_Type(ti.call_hash,node)]

    # ti.check_attr(node) # Does nothing
    return t
</t>
<t tx="ekr.20140526082700.18350">def check_attr(self,node):
    
    ti = self
    trace = False and ti.enable_trace
    
    return ### Now done in ti.Attribute

    # assert ti.kind(node) == 'Attribute'
    # value = node.value
    # # node.attr is always a string.
    
    # if ti.kind(value) == 'Name':
        # # The ssa pass has computed the ivars dict.
        # # There is no need to examine value.ctx.
        # name = value.id
        # name_e = value.e
        # name_cx = name_e.cx
        # name_class_cx = name_cx.class_context
        # if name == 'self':
            # if name_class_cx:
                # if node.attr in name_class_cx.ivars_dict:
                    # if trace: g.trace('OK: %s.%s' % (
                        # name_class_cx.name,node.attr))
                # else:
                    # ti.error('%s has no %s member' % (
                        # name_class_cx.name,node.attr))
            # else:
                # ti.error('%s is not a method of any class' % (
                    # name)) ####
        # else:
            # ### To do: handle any id whose inferred type is a class or instance.
            # if trace:
                # g.trace('** not checked: %s' % (name))
                # g.trace(ti.dump_ast(value))
</t>
<t tx="ekr.20140526082700.18351">def do_Builtin(self,node):
    
    assert False,node
</t>
<t tx="ekr.20140526082700.18352"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   Note: node.starargs and node.kwargs are given only if assigned explicitly.

def do_Call (self,node):
    '''
    Infer the value of a function called with a particular set of arguments.
    '''
    ti = self
    trace = False and ti.enable_trace
    trace_builtins = True ; trace_hit = False
    trace_errors = True ; trace_returns = False

    kind = ti.kind(node)
    func_name = ti.find_function_call(node)
    
    if trace and trace_hit: ti.trace('1:entry:',func_name) # ,before='\n',
    
    # Special case builtins.
    t = ti.builtin_type_dict.get(func_name,[])
    if t:
        if trace and trace_builtins: ti.trace(func_name,t)
        return t
        
    # Find the def or ctor to be evaluated.
    e = ti.find_call_e(node.func)
    if not (e and e.node):
        # find_call_e has given the warning.
        t = [Unknown_Type(ti.call_hash,node)]
        s = '%s(**no e**)' % (func_name)
        if trace and trace_errors: ti.trace('%17s -&gt; %s' % (s,t))
        return t

    # Special case classes.  More work is needed.
    if ti.kind(e.node) == 'ClassDef':
        # Return a type representing an instance of the class
        # whose ctor is evaluated in the present context.
        args,t = ti.class_instance(e)
        if trace and trace_returns:
            s = '%s(%s)' % (func_name,args)
            ti.trace('%17s -&gt; %s' % (s,t))
        return t

    # Infer the specific arguments and gather them in args list.
    # Each element of the args list may have multiple types.
    assert ti.kind(e.node) == 'FunctionDef'
    args = ti.infer_actual_args(e,node)
        
    # Infer the function for the cross-product the args list.
    # In the cross product, each argument has exactly one type.
    ti.stats.n_ti_calls += 1
    recursive_args,t = [],[]
    for specific_args in ti.cross_product(args):
        # Add the specific arguments to the cache.
        hash_ = ti.cache_hash(specific_args,e)
        t2 = ti.get_call_cache(e,hash_)
        miss = t2 is None   
        # if trace and trace_hit:
            # ti.trace('%s %12s -&gt; %s' % ('miss' if miss else 'hit!',
                # func_name,specific_args))
        if miss:
            ti.stats.n_call_misses += 1
            if trace and trace_hit: ti.trace('2:miss',hash_)
            t2 = ti.infer_def(specific_args,e,hash_,node,rescan_flag=False)
            if ti.is_recursive(t2):
                data = hash_,specific_args,t2
                recursive_args.append(data)
            # if trace and trace_returns: ti.trace(hash_,'-&gt;',t2)
        else:
            if trace and trace_hit: ti.trace('2:hit!',hash_)
            ti.stats.n_call_hits += 1
        t.extend(t2)

    if True and recursive_args:
        if trace: ti.trace('===== rerunning inference =====',t)
        for data in recursive_args:
            # Merge the types into the cache.
            hash_,specific_args,t2 = data
            t3  = ti.get_call_cache(e,hash_) or []
            t4 = ti.ignore_failures(t,t2,t3)
            # g.trace('t3',t3)
            # g.trace('t4',t4)
            ti.set_call_cache(e,hash_,t4,tag='ti.call:recursive')
            t5 = ti.infer_def(specific_args,e,hash_,node,rescan_flag=True)
            if trace: g.trace('t5',t5)
            t.extend(t5)
        
    if ti.has_failed(t):
        t = ti.merge_failures(t)
        # t = ti.ignore_failures(t)
    else:
        t = ti.clean(t)
    if trace and trace_returns:
        s = '3:return %s(%s)' % (func_name,args)
        ti.trace('%17s -&gt; %s' % (s,t))
    return t
</t>
<t tx="ekr.20140526082700.18353">def class_instance (self,e):
    
    '''
    Return a type representing an instance of the class
    whose ctor is evaluated in the present context.
    '''
    
    ti = self
    trace = True and ti.enable_trace
    cx = e.self_context
    
    # Step 1: find the ctor if it exists.
    d = cx.st.d
    ctor = d.get('__init__')

    # node2 = node.value
    # name = node2.id
    # attr = node.attr
    # e = getattr(node2,'e',None)
    # if trace: ti.trace(kind,v_kind,name,attr)
    # # ti.trace('e',e)
    # t = ti.get_cache(e)
    # # ti.trace('cache',t)
    # if len(t) == 1:
        # t = t[0]
        # e_value = t.node.e
        # # ti.trace('* e_value',e_value)
        # # ti.trace('e_value.self_context',e_value.self_context)
        # e = e_value.self_context.st.d.get(node.attr)
        # if trace: ti.trace('** e_value.self_context.st.d.get(%s)' % (attr),e)
        # # ti.trace('e_value.self_context.st.d', e_value.self_context.st.d)
        # # ti.trace('e.node',e.node)
        
    args = [] ### To do
    t = [Class_Type(cx)]
    ti.set_cache(e,t,tag='class name')
    return args,t
</t>
<t tx="ekr.20140526082700.18354">def find_call_e (self,node):
    
    '''Find the symbol table entry for node, an ast.Call node.'''
    
    ti = self
    trace = False and ti.enable_trace
    trace_errors = False; trace_fuzzy = True ; trace_return = False
    kind = ti.kind(node)
    e = None # Default.
    if kind == 'Name':
        # if trace: ti.trace(kind,node.id)
        e = getattr(node,'e',None)
    else:
        t = ti.visit(node)
        if len(t) == 1:
            ti.stats.n_not_fuzzy += 1
            t = t[0]
            if ti.kind(t) == 'Class_Type':
                d = t.cx.st.d
                if ti.kind(node) == 'Attribute':
                    name = node.attr
                elif ti.kind(node) == 'Call':
                    name = node.func
                else:
                    name = None
                if name:
                    e = d.get(name)
                else:
                    e = None
            else:
                if trace and trace_errors:
                    ti.trace('not a class type: %s %s' % (ti.kind(t),ti.format(node)))
        elif len(t) &gt; 1:
            if trace and trace_fuzzy: ti.trace('fuzzy',t,ti.format(node))
            ti.stats.n_fuzzy += 1
            e = None
        
    # elif kind == 'Attribute':
        # v_kind = ti.kind(node.value)
        # if v_kind == 'Name':
            # node2 = node.value
            # name = node2.id
            # attr = node.attr
            # e = getattr(node2,'e',None)
            # # if trace: ti.trace(kind,v_kind,name,attr)
            # t = ti.get_cache(e)
            # if len(t) == 1:
                # t = t[0]
                # if ti.kind(t) == 'Class_Type':
                    # d = t.cx.st.d
                    # e = d.get(node.attr)
                # else:
                    # pass ### To do
            # elif t:
                # pass
            # else:
                # t = [Unknown_Type(ti.call_hash,node)]
        # elif v_kind == 'Attribute':
            # node2 = node.value
            # ti.trace('*****',kind,v_kind,ti.format(node.value))
            # e = ti.find_call_e(node2)
        # else:
            # ti.trace('not ready yet',kind,v_kind)
            # e = None
    # elif kind in ('Call','Subscript'):
        # ti.trace(kind)
        # e = None
    # else:
        # ti.trace('===== oops:',kind)
        # e = None
        
    if e:
        assert isinstance(e,SymbolTableEntry),ti.kind(e)
        ti.stats.n_find_call_e_success += 1
    else:
        # Can happen with methods,Lambda.
        ti.stats.n_find_call_e_fail += 1
        if trace and trace_errors: ti.trace('**** no e!',kind,ti.format(node),
            align=ti.align,before='\n')

    if e and not e.node:
        if trace and trace_errors: ti.trace(
            'undefined e: %s' % (e),before='\n')

    if trace and trace_return: ti.trace(
        kind,'e:',e,ti.format(node))
    return e
</t>
<t tx="ekr.20140526082700.18355"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   keyword = (identifier arg, expr value) # keyword arguments supplied to call

# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def infer_actual_args (self,e,node):
    
    '''Return a list of types for all actual args, in the order defined in
    by the entire formal argument list.'''
    
    ti = self
    trace = False and ti.enable_trace
    trace_args = False
    assert ti.kind(node)=='Call'
    cx = e.self_context
    # Formals...
    formals  = cx.node.args or []
    defaults = cx.node.args.defaults or [] # A list of expressions
    vararg   = cx.node.args.vararg
    kwarg    = cx.node.args.kwarg
    # Actuals...
    actuals  = node.args or [] # A list of expressions.
    keywords = node.keywords or [] # A list of (identifier,expression) pairs.
    starargs = node.starargs
    kwargs   = node.kwargs
    assert ti.kind(formals)=='arguments'
    assert ti.kind(formals.args)=='list'
    
    formal_names = [z.id for z in formals.args]
        # The names of *all* the formal arguments, include those with defauls.
        # Doesw not include vararg and kwarg.
       
    # Append unnamed actual args.
    # These could be either non-keyword arguments or keyword arguments.
    args = [ti.visit(z) for z in actuals]
    bound_names = formal_names[:len(actuals)]
    
    if trace and trace_args:
        ti.trace('formal names',formal_names)
        ti.trace('   arg names',bound_names)
        ti.trace('    starargs',starargs and ti.format(starargs))
        ti.trace('    keywargs',kwargs   and ti.format(kwargs))
        # formal_defaults = [ti.visit(z) for z in defaults]
            # # The types of each default.
        # ti.trace('formal default types',formal_defaults)
        # ti.trace('unnamed actuals',[ti.format(z) for z in actuals])
    
    # Add keyword args in the call, in the order they appear in the formal list.
    # These could be either non-keyword arguments or keyword arguments.
    keywargs_d = {}
    keywords_d = {}
    for keyword in keywords:
        name = keyword.arg
        t = ti.visit(keyword.value)
        value = ti.format(keyword.value)
        keywords_d[name] = (value,t)

    for name in formal_names[len(actuals):]:
        data = keywords_d.get(name)
        if data:
            value,t = data
            if trace and trace_args: ti.trace('set keyword',name,value,t)
            args.append(t)
            bound_names.append(name)
        # else: keywargs_d[name] = None ### ???

    # Finally, add any defaults from the formal args.
    n_plain = len(formal_names) - len(defaults)
    defaults_dict = {}
    for i,expr in enumerate(defaults):
        name = formal_names[n_plain+i]
        value = ti.format(expr)
        t = ti.visit(expr)
        defaults_dict[name] = (value,t)

    for name in formal_names:
        if name not in bound_names:
            data = defaults_dict.get(name)
            t = None # default
            if data:
                value,t = data
                if trace and trace_args: ti.trace('set default',name,value,t)
            elif name == 'self':
                def_cx = e.self_context
                class_cx = def_cx and def_cx.class_context
                if class_cx:
                    t = [Class_Type(class_cx)]
            if t is None:
                t = [Unknown_Arg_Type(ti.call_hash,node)]
                ti.error('Unbound actual argument: %s' % (name))
            args.append(t)
            bound_names.append(name)
            
    ### Why should this be true???
    # assert sorted(formal_names) == sorted(bound_names)

    if None in args:
        ti.trace('***** opps node.args: %s, args: %s' % (node.args,args))
        args = [z for z in args if z is not None]
        
    if trace: ti.trace('result',args)
    return args
</t>
<t tx="ekr.20140526082700.18356">def infer_def(self,specific_args,e,hash_,node,rescan_flag):
    
    '''Infer everything possible from a def D called with specific args:
    
    1. Bind the specific args to the formal parameters in D.
    2. Infer all assignments in D.
    3. Infer all outer expression in D.
    4. Infer all return statements in D.
    '''

    ti = self
    trace = False and ti.enable_trace
    t0 = ti.get_call_cache(e,hash_) or []
    if hash_ in ti.call_stack and not rescan_flag:
        # A recursive call: always add an Recursive_Instance marker.
        if trace:ti.trace('A recursive','rescan',rescan_flag,hash_,'-&gt;',t0)
        ti.stats.n_recursive_calls += 1
        t = [Recursive_Inference(hash_,node)]
    else:
        if trace: ti.trace('A',hash_,'-&gt;',t0)
        ti.call_stack.append(hash_)
        try:
            cx = e.self_context
            data = ti.switch_context(e,hash_,node)
            ti.bind_args(specific_args,cx,e,node)
            ti.infer_assignments(cx,e)
            ti.infer_outer_expressions(cx,node)
            t = ti.infer_return_statements(cx,e)
            ti.restore_context(data)
        finally:
            hash2 = ti.call_stack.pop()
            assert hash2 == hash_
    # Merge the result and reset the cache.
    t.extend(t0)
    t = ti.clean(t)
    ti.set_call_cache(e,hash_,t,tag='infer_def')
        # Important: does *not* use ti.call_hash.
    if trace: ti.trace('B',hash_,'-&gt;',t)
    return t
</t>
<t tx="ekr.20140526082700.18357"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
#   keyword = (identifier arg, expr value) # keyword arguments supplied to call

# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def bind_args (self,types,cx,e,node):
    
    ti = self
    trace = False and ti.enable_trace
    assert ti.kind(node)=='Call'
    assert isinstance(node.args,list),node
    formals = cx.node.args or []
    assert ti.kind(formals)=='arguments'
    assert ti.kind(formals.args)=='list'
    formal_names = [z.id for z in formals.args]
        # The names of *all* the formal arguments, include those with defauls.
        
    if len(formal_names) != len(types):
        # ti.trace('**** oops: formal_names: %s types: %s' % (formal_names,types))
        return

    def_cx = e.self_context
    d = def_cx.st.d
    for i,name in enumerate(formal_names):
        ### Handle self here.
        t = types[i]
        e2 = d.get(name)
        if e2:
            if trace: ti.trace(e2,t) # ti.trace(e2.name,t)
            ti.set_cache(e2,[t],tag='bindargs:%s'%(name))
        else:
            ti.trace('**** oops: no e2',name,d)
</t>
<t tx="ekr.20140526082700.18358">def infer_assignments(self,cx,e):
    
    '''Infer all the assignments in the function context.'''

    ti = self
    trace = False and ti.enable_trace
    for a in cx.assignments_list:
        if ti.kind(a) == 'Assign': # ignore AugAssign.
            t2 = ti.get_cache(a)
            if t2:
                ti.stats.n_assign_hits += 1
                if trace: ti.trace('hit!',t2)
            else:
                t2 = ti.visit(a)
                t3 = ti.ignore_failures(t2)
                if t3:
                    ti.stats.n_assign_misses += 1
                    # ti.trace('***** set cache',t2)
                    ti.set_cache(a,t2,tag='infer_assns')
                    if trace: ti.trace('miss',t2)
                else:
                    ti.stats.n_assign_fails += 1
                    if trace: ti.trace('fail',t2)
               
                   
    return None # This value is never used.
</t>
<t tx="ekr.20140526082700.18359">def infer_outer_expressions(self,cx,node):
    
    '''Infer all outer expressions in the function context.'''

    ti = self
    trace = False and ti.enable_trace
    for exp in cx.expressions_list:
        if trace: ti.trace(ti.call_hash,ti.format(exp))
        t2 = ti.get_cache(exp)
        if t2 is not None:
            ti.stats.n_outer_expr_hits += 1
            if trace: ti.trace('hit!',t2)
        else:
            ti.stats.n_outer_expr_misses += 1
            # ti.trace('miss',ti.call_hash)
            # Set the cache *before* calling ti.visit to terminate the recursion.
            t = [Unknown_Type(ti.call_hash,node)]
            ti.set_cache(exp,t,tag='ti.infer_outer_expressions')
            t = ti.visit(exp)
            ti.set_cache(exp,t,tag='ti.infer_outer_expressions')
            if trace: ti.trace('miss',t)

    return None # This value is never used.
</t>
<t tx="ekr.20140526082700.18360">def infer_return_statements(self,cx,e):
    
    '''Infer all return_statements in the function context.'''
    
    ti = self
    trace = True and ti.enable_trace
    trace_hit = False
    t = []
    for r in cx.returns_list:
        assert r
        t2 = ti.get_cache(r)
        if t2:
            if trace and trace_hit: ti.trace('hit!',t2)
        else:
            t2 = ti.visit(r)
            if trace and trace_hit: ti.trace('miss',t2)
            t.extend(t2)
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.18361">def do_ClassDef(self,node):
    
    '''
    For lint-like operation: infer all methods with 'unknown' as the value of all args.
    For jit-like operation: do nothing.
    '''
    
    ti = self
    if lint_like:
        return ti.visit_children(node)
    else:
        return [] # This value should not be used.
</t>
<t tx="ekr.20140526082700.18362"># Expr(expr value)

# This isn't really needed: the default visitor would work.

def do_Expr(self,node):
    
    ti = self
    t = ti.visit(node.value)
    return t
</t>
<t tx="ekr.20140526082700.18363"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,node):
    
    '''Infer this function or method with 'unknown' as the value of all args.
    This gets inference going.
    '''
    
    ti = self
    trace = False and not ti.enable_trace
    
    # Set up function call, with 'unknown' for all args.
    e = node.e
    specific_args = [Unknown_Arg_Type(ti.call_hash,node)] * ti.count_full_args(node)
    hash_ = ti.cache_hash(specific_args,e)
    t = ti.get_call_cache(e,hash_)
    if trace:
        ti.trace('%s %12s -&gt; %s' % ('miss' if t is None else 'hit!',
            node.name,specific_args))
    if t is None:
        t = ti.infer_outer_def(specific_args,hash_,node)
    return t

</t>
<t tx="ekr.20140526082700.18364"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def count_full_args (self,node):
    
    '''Return the number of arguments in a call to the function/def defined
    by node, an ast.FunctionDef node.'''
    
    ti = self
    trace = False and ti.enable_trace
    assert ti.kind(node)=='FunctionDef'    
    args = node.args
    if trace: ti.trace('args: %s vararg: %s kwarg: %s' % (
        [z.id for z in args.args],args.vararg,args.kwarg))
    n = len(args.args)
    if args.vararg: n += 1
    if args.kwarg:  n += 1
    return n
</t>
<t tx="ekr.20140526082700.18365">def infer_outer_def(self,specific_args,hash_,node):
    
    '''Infer everything possible from a def D called with specific args:
    
    1. Bind the args to the formal parameters in D.
    2. Infer all assignments in D.
    3. Infer all outer expression in D.
    4. Infer all return statements in D.
    '''

    ti = self
    # trace = True and ti.enable_trace
    assert ti.kind(node)=='FunctionDef',node
    e = node.e
    assert hasattr(e,'call_cache')
    cx = e.self_context
    data = ti.switch_context(e,hash_,node)
    ti.bind_outer_args(hash_,node)
    ti.infer_assignments(cx,e)
    ti.infer_outer_expressions(cx,node)
    t = ti.infer_return_statements(cx,e)
    ti.set_call_cache(e,hash_,t,tag='infer_def')
    ti.restore_context(data)
    return t
</t>
<t tx="ekr.20140526082700.18366"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
#   arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)
def bind_outer_args (self,hash_,node):
    
    '''Bind all all actual arguments except 'self' to "Unknown_Arg_Type".'''
    
    ti = self
    trace = False and ti.enable_trace
    assert ti.kind(node)=='FunctionDef'
    e = node.e
    def_cx = e.self_context
    args = node.args or []
    assert ti.kind(args)=='arguments',args
    assert ti.kind(args.args)=='list',args.args
    formal_names = [z.id if hasattr(z,'id') else '&lt;tuple arg&gt;' for z in args.args]
    if args.vararg: formal_names.append(args.vararg)
    if args.kwarg:  formal_names.append(args.kwarg)
    # if trace: ti.trace(formal_names)
    d = def_cx.st.d
    for name in formal_names:
        if name == 'self':
            if def_cx:
                t = [Class_Type(def_cx)]
            else:
                t = [Unknown_Arg_Type(ti.call_hash,node)]
            e2 = e
        else:
            t = [Unknown_Arg_Type(ti.call_hash,node)]
            e2 = d.get(name)
        if e2:
            ti.set_cache(e2,t,tag='bind_outer_args:%s'%(name))
            if trace: ti.trace(name,t)
        else:
            if trace: ti.trace('**** oops: no e2',name,d)
</t>
<t tx="ekr.20140526082700.18367">def do_Lambda (self,node):
    
    ti = self
    return ti.visit(node.body)
</t>
<t tx="ekr.20140526082700.18368"></t>
<t tx="ekr.20140526082700.18369">def do_BinOp (self,node):

    ti = self
    trace = True and ti.enable_trace
    trace_infer = False ; trace_fail = True
    lt = ti.visit(node.left)
    rt = ti.visit(node.right)
    lt = ti.clean(lt)
    rt = ti.clean(rt)
    op_kind = ti.kind(node.op)
    num_types = ([ti.float_type],[ti.int_type])
    list_type = [List_Type(None)]
    if rt in num_types and lt in num_types:
        if rt == [ti.float_type] or lt == [ti.float_type]:
            t = [ti.float_type]
        else:
            t = [ti.int_type]
    elif rt == list_type and lt == list_type and op_kind == 'Add':
        t = list_type
    elif op_kind == 'Add' and rt == [ti.string_type] and lt == [ti.string_type]:
        t = [ti.string_type]
    elif op_kind == 'Mult' and rt == [ti.string_type] and lt == [ti.string_type]:
        ti.trace('*** User error: string mult')
        t = [Unknown_Type(ti.call_hash,node)]
    elif op_kind == 'Mult' and (
        (lt==[ti.string_type] and rt==[ti.int_type]) or
        (lt==[ti.int_type] and rt==[ti.string_type])
    ):
        t = [ti.string_type]
    elif op_kind == 'Mod' and lt == [ti.string_type]:
        t = [ti.string_type] # (string % anything) is a string.
    else:
        ti.stats.n_binop_fail += 1
        if trace and trace_fail:
            if 1:
                s = '%r %s %r' % (lt,op_kind,rt)
                g.trace('  fail: %30s %s' % (s,ti.format(node)))
            else:
                g.trace('  fail:',lt,op_kind,rt,ti.format(node))
        t = [Inference_Error(ti.call_hash,node)] ### Should merge types!
    if trace and trace_infer: ti.trace(ti.format(node),'-&gt;',t)
    return t
</t>
<t tx="ekr.20140526082700.18370">def do_BoolOp(self,node):

    ti = self    
    junk = ti.visit_children(node)
    return [ti.bool_type]
</t>
<t tx="ekr.20140526082700.18371">def do_Compare(self,node):

    ti = self    
    junk = ti.visit_children(node)
    return [ti.bool_type]
</t>
<t tx="ekr.20140526082700.18372">def do_comprehension(self,node):

    ti = self    
    junk = ti.visit_children(node)

    # name = node.name
    # ti.visit(node.it)

    # for node2 in node.ifs:
        # ti.visit(node2)

    return [List_Type(node)]
</t>
<t tx="ekr.20140526082700.18373"># def do_Expr (self,node):

    # ti = self    
    # return ti.visit(node.value)
</t>
<t tx="ekr.20140526082700.18374">def do_GeneratorExp (self,node):

    ti = self
    trace = False and ti.enable_trace
    junk = ti.visit(node.elt)
    t = []
    for node2 in node.generators:
        t2 = ti.visit(node2)
        t.extend(t2)
    if ti.has_failed(t):
        t = ti.merge_failures(t)
        if trace: ti.trace('failed inference',ti.format(node),t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.18375"># IfExp(expr test, expr body, expr orelse)

def do_IfExp(self,node):
    
    ti = self    
    junk = ti.visit(node.test)
    t = ti.visit(node.body)
    t.extend(ti.visit(node.orelse))
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.18376">def do_Index(self,node):

    ti = self    
    return ti.visit(node.value)
</t>
<t tx="ekr.20140526082700.18377">def do_ListComp(self,node):
    
    ti = self
    # ti.trace(node.elt,node.generators)
    junk = ti.visit(node.elt)
    t = []
    for node2 in node.generators:
        t.extend(ti.visit(node2))
    if ti.has_failed(t):
        t = ti.merge_failures(t)
    else:
        t = ti.clean(t)
    return t
</t>
<t tx="ekr.20140526082700.18378">def do_Slice(self,node):
    
    ti = self
    if node.upper: junk = ti.visit(node.upper)
    if node.lower: junk = ti.visit(node.lower)
    if node.step:  junk = ti.visit(node.step)
    return [ti.int_type] ### ???
</t>
<t tx="ekr.20140526082700.18379">def do_Subscript(self,node):

    ti = self
    trace = False and not ti.enable_trace
    t1 = ti.visit(node.value)
    t2 = ti.visit(node.slice)
    if t1 and trace: g.trace(t1,t2,ti.format(node))
    return t1 ### ?
</t>
<t tx="ekr.20140526082700.18380">def do_UnaryOp(self,node):
    
    ti = self
    trace = True and ti.enable_trace
    t = ti.visit(node.operand)
    t = ti.clean(t)
    op_kind = ti.kind(node.op)
    if op_kind == 'Not':
        t == [self.bool_type]
    elif t == [self.int_type] or t == [self.float_type]:
        pass # All operators are valid.
    else:
        ti.stats.n_unop_fail += 1
        if trace: g.trace(' fail:',op_kind,t,ti.format(node))
        t = [Unknown_Type(ti.call_hash,node)]
    return t
</t>
<t tx="ekr.20140526082700.18381"></t>
<t tx="ekr.20140526082700.18382">def do_Builtin(self,node):

    ti = self
    assert not ti.has_children(node)
    return [ti.builtin_type]

</t>
<t tx="ekr.20140526082700.18383">def do_Bytes(self,node):

    ti = self
    assert not ti.has_children(node)    
    return [ti.bytes_type]
</t>
<t tx="ekr.20140526082700.18384">def do_Dict(self,node):

    ti = self
    junk = ti.visit_children(node)
    return [Dict_Type(node)]
        ### More specific type.
</t>
<t tx="ekr.20140526082700.18385">def do_List(self,node): 
            
    ti = self
    junk = ti.visit_children(node)
    return [List_Type(node)]
</t>
<t tx="ekr.20140526082700.18386">def do_Num(self,node):
    
    ti = self
    assert not ti.has_children(node)
    t_num = Num_Type(node.n.__class__)
    # ti.trace(ti.format(node),'-&gt;',t_num)
    return [t_num]
</t>
<t tx="ekr.20140526082700.18387">def do_Str(self,node):
    
    '''This represents a string constant.'''

    ti = self
    assert not ti.has_children(node)
    return [ti.string_type]
</t>
<t tx="ekr.20140526082700.18388">def do_Tuple (self,node):

    ti = self
    junk = ti.visit_children(node)
    return [Tuple_Type(node)]
</t>
<t tx="ekr.20140526082700.18389"></t>
<t tx="ekr.20140526082700.18390">def do_For(self,node):
    
    ### what if target conflicts with an assignment??
    
    ti = self
    # ti.visit(node.iter)
    # ti.visit_list(node.body)
    # if node.orelse:
        # ti.visit_list(node.orelse)
        
    return ti.visit_children(node)
</t>
<t tx="ekr.20140526082700.18391"># def do_Import(self,node):
    
    # pass
</t>
<t tx="ekr.20140526082700.18392"># def do_ImportFrom(self,node):
    
    # pass
</t>
<t tx="ekr.20140526082700.18393">def do_Return(self,node):
    ti = self
    return ti.return_helper(node)
    
def do_Yield(self,node):
    ti = self
    return ti.return_helper(node)
    
</t>
<t tx="ekr.20140526082700.18394">def return_helper(self,node):

    ti = self
    trace = False and ti.enable_trace
    trace_hash = False
    assert node
    e,hash_ = ti.call_e,ti.call_hash
    assert e
    assert hash_
    if node.value:
        t = ti.visit(node.value)
        if ti.has_failed(t):
            ti.stats.n_return_fail += 1
            t = ti.ignore_unknowns(t)
        if t:
            # Don't set the cache unless we succeed!
            ti.set_cache(node,t,tag=ti.format(node))
            ti.stats.n_return_success += 1
        else:
            ti.stats.n_return_fail += 1
            t = [] # Do **not** propagate a failure here!
    else:
        t = [ti.none_type]
    # Set the cache.
    t0 = ti.get_call_cache(e,hash_) or []
    t.extend(t0)
    ti.set_call_cache(e,hash_,t,tag='ti.return')
    if trace:
        if trace_hash: ti.trace(t,hash_,ti.format(node))
        else:          ti.trace(t,ti.format(node))
    return t
</t>
<t tx="ekr.20140526082700.18395">def do_With (self,node):

    ti = self
    t = ti.visit_list(node.body)
    # ti.trace(t)
    return t
</t>
<t tx="ekr.20140526082700.18396">def do_Name(self,node):
    
    ti = self
    trace = True and ti.enable_trace
    trace_hit = False ; trace_infer = False
    trace_fail = True ; trace_self = False
    ctx_kind = ti.kind(node.ctx)
    name = node.id
    trace = trace and name == 'i'
    hash_ = ti.call_hash
    
    # Reaching sets are useful only for Load attributes.
    if ctx_kind not in ('Load','Param'):
        # if trace: ti.trace('skipping %s' % ctx_kind)
        return []

    ### ast.Name nodes for class base names have no 'e' attr.
    if not hasattr(node,'e'):
        if trace: ti.trace('no e',node)
        return []

    t = ti.get_cache(node.e) or []
    t = ti.clean(t)
    t = ti.ignore_failures(t)
    if t:
        if trace and trace_hit: ti.trace('**hit!',t,name)
    elif name == 'self':
        e = node.e
        reach = getattr(e,'reach',[])
        if reach: ti.trace('**** assignment to self')
        cx = e.cx.class_context
        if cx:
            d = cx.ivars_dict
            if trace and trace_self: ti.trace('found self',e.name)
                # ti.u.dump_ivars_dict(d)) # Very expensive
            t = [Class_Type(cx)]
        else:
            ti.trace('**** oops: no class context for self',ti.format(node))
            t = [Unknown_Type(ti.call_hash,node)]
    else:
        reach = getattr(node.e,'reach',[])
        t = []
        for node2 in reach:
            # The reaching sets are the RHS of assignments.
            t2 = ti.get_cache(node2)
            if t2 is None:
                # Set the cache *before* calling ti.visit to terminate the recursion.
                t = [Unknown_Type(ti.call_hash,node)]
                ti.set_cache(node2,t,tag='ti.Name')
                t2 = ti.visit(node2)
                ti.set_cache(node2,t2,tag='ti.Name')
            if isinstance(t2,(list,tuple)):
                t.extend(t2)
            else:
                ti.trace('**oops:',t2,ti.format(node2))
        if ti.has_failed(t):
            t = ti.merge_failures(t)
        else:
            t = ti.clean(t)

    if trace and trace_infer and t:
        ti.trace('infer',t,ti.format(node))
    if trace and trace_fail and not t:
        ti.trace('fail ',name,ctx_kind,'reach:',
            ['%s:%s' % (id(z),ti.format(z)) for z in reach])
    return t
</t>
<t tx="ekr.20140526082700.18397"></t>
<t tx="ekr.20140526082700.18398">class DeductionTraverser (AstTraverser):

    '''A class to create all Deduction objects by traversing the AST.
    
    This second tree traversal happens after the scope-resolution pass
    has computed the ultimate Context for all names.
    '''

    @others
</t>
<t tx="ekr.20140526082700.18399">def __init__(self,fn):

    # Init the base class: calls create_dispatch_table()
    AstTraverser.__init__(self,fn)
    
    self.in_arg_list = False
    self.in_lhs = False
    self.in_rhs = False
</t>
<t tx="ekr.20140526082700.18400">def traverse (self,s):
    
    '''Perform all checks on the source in s.'''
    
    t1 = time.time()

    tree = ast.parse(s,filename=self.fn,mode='exec')

    t2 = time.time()
    self.u.stats.parse_time += t2-t1
    
    self.visit(tree)
    
    t3 = time.time()
    self.u.stats.pass1_time += t3-t2
</t>
<t tx="ekr.20140526082700.18401"></t>
<t tx="ekr.20140526082700.18402"># ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef (self,tree):

    self.visit(tree.name)
    
    for z in tree.body:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18403"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef (self,tree):
    
    self.visit(tree.name)
    
    # No deductions correspond to formal args.
        # assert self.kind(tree.args) == 'arguments'
        # for z in tree.args.args:
            # self.visit(z)
        # for z in tree.args.defaults:
            # self.visit(z)
    
    # Visit the body.
    for z in tree.body:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18404">def do_Module (self,tree):

    for z in tree.body:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18405"></t>
<t tx="ekr.20140526082700.18406">def do_Attribute(self,tree):
    
    name = tree.attr
    
    # Use the *formatter* to traverse tree.value.
    expr = g_format_tree(tree.value)
    s = '%s.%s' % (expr,name)
    
    chain = cx.st.add_chain(tree,s)
    
    if use_deductions and self.in_rhs:
        if trace: g.trace('Adding chain to dependencies',chain)
        self.dependencies.append((ast,chain),)
    
    self.u.stats.n_attributes += 1
    return s
        
    
</t>
<t tx="ekr.20140526082700.18407"># Python 2.x only.
def do_bool(self,tree):
    pass
    
</t>
<t tx="ekr.20140526082700.18408"># Python 3.x only.
def do_Bytes(self,tree):
    pass

</t>
<t tx="ekr.20140526082700.18409">def do_Call(self,tree):

    self.visit(tree.func)
    for z in tree.args:
        self.visit(z)
    for z in tree.keywords:
        self.visit(z)

    if hasattr(tree,'starargs') and tree.starargs:
        if self.isiterable(tree.starargs):
            for z in tree.starargs:
                self.visit(z)
        else:# Bug fix: 2012/10/22: always visit the tree.
            self.visit(tree.starargs)

    if hasattr(tree,'kwargs') and tree.kwargs:
        if self.isiterable(tree.kwargs):
            for z in tree.kwargs:
                self.visit(z)
        else:
            # Bug fix: 2012/10/22: always visit the tree.
            self.visit(tree.kwargs)
</t>
<t tx="ekr.20140526082700.18410">def do_comprehension(self,tree):

    self.visit(tree.target)
    self.visit(tree.iter)
    for z in tree.ifs:
        self.visit(z)

</t>
<t tx="ekr.20140526082700.18411">def do_Dict(self,tree):

    for z in tree.keys:
        self.visit(z)
    for z in tree.values:
        self.visit(z)

</t>
<t tx="ekr.20140526082700.18412">def do_Ellipsis(self,tree):
    pass

</t>
<t tx="ekr.20140526082700.18413">def do_ExtSlice (self,tree):

    for z in tree.dims:
        self.visit(z)

</t>
<t tx="ekr.20140526082700.18414">def do_Index (self,tree):

    self.visit(tree.value)

</t>
<t tx="ekr.20140526082700.18415">def do_int (self,s):
    pass

</t>
<t tx="ekr.20140526082700.18416">def do_Keyword (self,tree):

    self.visit(tree.arg)
    self.visit(tree.value)

</t>
<t tx="ekr.20140526082700.18417">def do_List(self,tree):

    for z in tree.elts:
        self.visit(z)
    self.visit(tree.ctx)

</t>
<t tx="ekr.20140526082700.18418">def do_ListComp(self,tree):

    self.visit(tree.elt)

    for z in tree.generators:
        self.visit(z)
        
</t>
<t tx="ekr.20140526082700.18419">def do_Name(self,tree):

    name = tree.id # a string.

    # if isPython3:
        # if name in self.u.module_names:
            # return
    # else:
        # if name in dir(__builtin__) or name in self.u.module_names:
            # return
            
    ctx = self.visit(tree.ctx)
            
    if ctx == 'Load': # Most common.
        pass
    elif ctx == 'Store': # Next most common.
        pass
    elif ctx == 'Param':
        pass
    else:
        assert ctx == 'Del',ctx
        cx.del_names.add(name)
        self.u.stats.n_del_names += 1
</t>
<t tx="ekr.20140526082700.18420">def do_Num(self,tree):
    pass

</t>
<t tx="ekr.20140526082700.18421">def do_Slice (self,tree):

    if hasattr(tree,'lower') and tree.lower is not None:
        self.visit(tree.lower)
    if hasattr(tree,'upper') and tree.upper is not None:
        self.visit(tree.upper)
    if hasattr(tree,'step') and tree.step is not None:
        self.visit(tree.step)

</t>
<t tx="ekr.20140526082700.18422">def do_Str (self,tree):
    '''This represents a string constant.'''
    pass
</t>
<t tx="ekr.20140526082700.18423">def do_Subscript(self,tree):

    self.visit(tree.slice)
    self.visit(tree.ctx)

</t>
<t tx="ekr.20140526082700.18424">def do_Tuple(self,tree):

    for z in tree.elts:
        self.visit(z)
    self.visit(tree.ctx)
</t>
<t tx="ekr.20140526082700.18425"></t>
<t tx="ekr.20140526082700.18426">def do_Assign(self,tree):
    
    val = self.visit(tree.value)
    
    for z in tree.targets:
        target = self.visit(z)
        Deduction(tree,self.assign_deducer,target,val)
</t>
<t tx="ekr.20140526082700.18427">def do_AugAssign(self,tree):

    Deduction(tree,
        self.visit(tree.op), # deducer method.
        self.visit(tree.target), # lhs
        self.visit(tree.value), # rhs
    )
</t>
<t tx="ekr.20140526082700.18428">def do_Call(self,tree):

    f        = self.visit(tree.func)
    args     = [self.visit(z) for z in tree.args]
    keywords = [self.visit(z) for z in tree.keywords]
    starargs = self.visit(tree.starargs) if  hasattr(tree,'starargs') and tree.starargs else []
    kwargs   = self.visit(tree.kwargs) if hasattr(tree,'kwargs') and tree.kwargs else []
        
    Deduction(tree,self.call_deducer,f,args,keywords,starags,kwargs)
</t>
<t tx="ekr.20140526082700.18429">def do_For (self,tree):
    
    self.visit(tree.target)

    self.visit(tree.iter)
    
    for z in tree.body:
        self.visit(z)

    for z in tree.orelse:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18430">def do_Global(self,tree):

    pass
</t>
<t tx="ekr.20140526082700.18431">def do_Import(self,tree):

    pass
</t>
<t tx="ekr.20140526082700.18432">def do_ImportFrom(self,tree):
    
    pass
</t>
<t tx="ekr.20140526082700.18433">def do_Lambda (self,tree):
    
    # Lambda args do not create deductions.
        # assert self.kind(tree) == 'arguments'
        # for z in tree.args.args:
            # self.visit(z)
        # for z in tree.args.defaults:
            # self.visit(z)
            
    self.visit(tree.body)
</t>
<t tx="ekr.20140526082700.18434">def do_Return(self,tree):
    
    if tree.value:
        val = self.visit(tree.value)
        Deduction(tree,self.return_deducer,val)
    else:
        Deduction(tree,self.return_deducerd)
</t>
<t tx="ekr.20140526082700.18435">def do_With (self,tree):
    
    if hasattr(tree,'context_expression'):
        self.visit(tree.context_expresssion)

    if hasattr(tree,'optional_vars'):
        try:
            for z in tree.optional_vars:
                self.visit(z)
        except TypeError: # Not iterable.
            self.visit(tree.optional_vars)
    
    for z in tree.body:
        self.visit(z)
</t>
<t tx="ekr.20140526082700.18436">def __init__ (sd,target,aList):
    
    if trace:
        name,obj = target
        deps = [b.short_description() for a,b in aList]
        g.trace('(Op) lhs: %s, aList: %s' % (name,deps))
    
    self.deps = aList
        # a list tuples (ast,s)
        # describing the symbols on which the target depends.
        # s is a string, either a plain id or an id chain.
        
    self.sd = sd

    self.target = target
        # A tuple (name,object) representing the target (LHS) of an assignment statement.
        # name is the spelling (a string) of the plain id or id chain.
        # object is a Chain for chains; a SymbolTableEntry for plain ids.
        # Note: chain.e is the SymbolTableEntry for chains.
        
    sd.n_dependencies += 1
    
    self.fold()
</t>
<t tx="ekr.20140526082700.18437">def remove_symbol (self,e):
    
    '''The type of this SymbolTableEntry has just become known.
    
    Remove e from this Dependency.
    
    If the Dependency becomes known, do the following:
        
    - Call eval_ast to evaluate the type.
    - Assign the type to the Dependency's symbol.
    - Add the symbol to sd.known_types.
    '''
  
    e = self
    
    for dep in e.dependencies:
        dep.remove(e) # May add entries to sd.known_types.
    e.dependencies = []

    g.trace(e)
</t>
<t tx="ekr.20140526082700.18438">def is_known (self):
    
    '''return True if this is a known symbol.'''
    
    return len(self.vals) == 1
</t>
<t tx="ekr.20140527123213.17048"></t>
<t tx="ekr.20140527123213.17049"></t>
<t tx="ekr.20140528102444.17989">def has_children(self,node):
    
    assert isinstance(node,ast.AST),node.__class__.__name__
    
    return any(self.get_child_nodes(node))
</t>
<t tx="ekr.20140528102444.17991">def has_children(self,node):
    
    assert isinstance(node,ast.AST),node.__class__.__name__
    
    return any(self.get_child_nodes(node))
</t>
<t tx="ekr.20140610063815.17693"></t>
<t tx="ekr.20140611055007.17696">https://groups.google.com/forum/#!topic/leo-editor/1uw1llvuYBQ

@language rest

For the last several days I have been thinking about the new-@auto project
that I worked on in February while in Florida.

As always, the real problems involve sentinels: It's essential that Leo's
sentinels not be visible in projects that do not use Leo.

The fundamental problem is that operating systems do not support additional
(hidden) data in text files. (Old versions of MacOS did support such data
in the so-called "resource fork").

A new set of thoughts has now appeared. These are quite different from the
thoughts I have explored for the past 20 years.

===== The idea

We want a way of Leo users to share outline structure in a way that is
completely invisible to non-Leo users. This is *not* the same thing as
doing without sentinels! It puts the focus on "back-channel" communication
of sentinels between Leo users as follows:

0. Let's use the same terminology as with @shadow: **private** files
   contain sentinels; **public** files do not.

1. Instead of writing sentinels *within* external files, Leo's file-write
   logic could easily create separate **sentinel files**. Sentinel files
   would contain:

- a header with data such as sha1-hash for the corresponding public file,
  and a gnx-like author/timestamp field.

- a list of sentinel lines themselves. Each sentinel line would be preceded
  by a relative offset of the sentinel within the corresponding public
  file. Using relative offsets means that most offsets would not change if
  a line were inserted/deleted from the public file.

2. Leo's file-read logic for public files would "shuffle" the sentinels
   into the public file (using the relative offset of each sentinel). After
   the sentinels have been restored, the read logic would be identical to
   the present @file read logic.

3. We want this scheme to be completely invisible to non-Leonine users, so
   sentinel files must be kept *away* from project files, say in the
   ~/.leo/sentinels directory. Call this the user's **sentinels
   directory**.

The obvious way to associate sentinel files with the corresponding public
file would be with the sha1 hash. The files in the sentinels directory
would have names that are the sha1 hash of the corresponding public file.

4. Leo users can *share outline structure* by sharing sentinels files.

At first, this sharing would have to be done "by hand" each time a public
file is committed. Later, perhaps more automatic ways of sharing sentinels
files could be created. Say by using git hooks, for example.

5. Because sharing sentinels files may not always be automatic (and might
   not ever be automatic), Leonine users will need ways of "recovering"
   when a public file changes without the corresponding sentinel files
   being available. This leads us to...

===== Doing without sentinels files

Suppose Alice has committed the new public file f.py, and suppose Alice has
*not* committed the corresponding sentinel file. Suppose Bob wants to use
the new version of f.py in Leo. Bob has two options:

1. Use @auto to create the outline for f.py.

2. Use the @shadow algorithm as follows. Using git (say) Bob recovers some
   previous version V of f.py (without sentinels) for which Bob *does* have
   a corresponding sentinel file. Bob (using Leo) recreates the *private*
   copy of version V of f.py by shuffling the sentinels into f.py. Bob then
   runs the @shadow algorithm on the old private copy to create the new
   version of f.py *with* sentinels.

**Important**: the choice between @auto and @shadow would be a personal
preference. I've gone into detail here to show how Leo could do the
recovery for Bob automatically using the @shadow idea.

===== Pros and cons

As with all ways of doing without sentinels, this scheme has plusses and
minuses.

On the plus side:

- It is completely invisible and imposes *zero* cost on non-Leonine users
  and projects. Costs accrue only to Leo users.

- When the proper sentinel file is available, Leo uses the simplest
  possible algorithm to reconstruct outlines, namely shuffling sentinels
  into the public file followed by running the @file read code. This
  requires neither parsing (as @auto does) nor any complicated diffing (as
  @shadow does). I think of the @file read code as a simple, deterministic
  finite automaton.

- When the proper sentinel file is available, Leo will provide all the
  advantages of @file nodes, including the conservation of gnx's and all
  that implies, especially rock-solid clone links.

- It will be easy to prototype. A simple script will test the **round trip** criterion.

  The script will create a sentinel file from a *private* file and verify
  that shuffling the sentinels from the sentinels file back into the
  corresponding *public* file results in the original *private* file.

On the minus side:

- Most importantly, no matter how good (or how automatic) the connection
  between public files and the corresponding sentinel files, that
  connection can *never* be as solid as embedding sentinels in external
  files. Thus, the opportunity for problems will always be greater when
  using this scheme compared to using files with embedded sentinels.

- Leo's users will be responsible for sharing sentinels files. This will be
  an extra step, even if it is eventually done automatically.

- When the proper sentinel file does not exist for a public file, Leo users
  will have to live with either @auto-based recovery or @shadow-based
  recovery.

- There is no advantage for a lone Leonine user within a project to use
  this scheme: she may as well use @shadow or @auto. Similarly, if *all*
  the users of the project use Leo, they may as well just use @file. So
  this scheme is only useful if a project contains two or more Leonine
  programmers and one or more non-Leonine programmers.

===== Summary

- This scheme puts more emphasis on sharing data *among Leo users* than on
  "magically" recreating sentinels.

- This scheme's implementation advantages (using the @file read logic) is
  offset (in part) by the inconvenience of having to share and synchronize
  sentinels files.

- This scheme is only useful when multiple Leonine programmers work in a
  non-Leonine project. Solo Leonine programmers in a non-Leonine project
  may as well use @shadow or @auto.
</t>
<t tx="ekr.20140630071432.16748">lm.doPrePluginsInit
lm.computeLocalSettings.
g.GeneralSetting
LM.Settings suboutline.
abbrevCommandsClass
    init_abbrev
</t>
<t tx="ekr.20140704052551.17950"></t>
<t tx="ekr.20140704052551.17951">All are minor.
</t>
<t tx="ekr.20140704052551.17954">p.isVisible: its algorithm is poor.

Where is this used?
</t>
<t tx="ekr.20140704052551.17955">Create myLeoSettings and workbook automatically if they do not exist.
</t>
<t tx="ekr.20140704052551.17957"></t>
<t tx="ekr.20140711111623.17859">if 0:
    ### No longer used
    # Replaced by pd.gnx_dict.
    def find_gnx_node(pd,gnx):
        '''Return the first position having the given gnx.'''
        # Newly-imported nodes never have the given gnx initially,
        # but their gnx's may be changed while reading.
        for p in pd.c.all_unique_positions():
            if p.v.gnx == gnx:
                return p
        return None
</t>
<t tx="ekr.20140716021139.17767">def recover_ua_for_gnx(pd,gnx,root,unl):
    '''
    No gnx was found for unl. If an @ua:&lt;gnx&gt; node exists,
    copy that node as a child of the @recovery node.
    '''
    trace = False and not g.unitTesting
    at_uas = pd.has_at_uas_node(root)
    if at_uas:
        # Find the @ua:&lt;gnx&gt; node in root's @uas node.
        h = '@ua:'+gnx
        for at_ua in at_uas.children():
            if at_ua.h == h:
                break
        else:
            if trace: g.trace('no @ua node for gnx:',gnx)
            return
        # Create the @recovery node if necessary.
        at_recovery = pd.find_at_recovery_node(root)
        # Create the @ua node if it does not exist as a child of the @recovery node.
        for child in at_recovery.children():
            if (child.h,child.b) == (at_ua.h,at_ua.b):
                if trace: g.trace('found recovered node',child.h)
                break
        else:
            p = at_recovery.insertAsLastChild()
            p.h = at_ua.h
            p.b = at_ua.b
            if not g.unitTesting:
                g.trace('created recovered node',p.h)
    elif trace:
        g.trace('no @uas node for:',root.h)
</t>
<t tx="ekr.20140716021139.17770">def has_at_recovery_node(pd,root):
    '''
    Find the @recovery node for an @data node with the given unl.
    Return None if it does not exist.
    '''
    p = pd.has_at_data_node(root)
    return p and g.findNodeInTree(pd.c,p,'@recovery')
</t>
<t tx="ekr.20140716021139.17772">def find_at_recovery_node(pd,root):
    '''
    Find the @recovery node for root, a foreign node.
    Create the @recovery node if it does not exist.
    '''
    h = '@recovery'
    at_data = pd.find_at_data_node(root)
    p = g.findNodeInTree(pd.c,at_data,h)
    if not p:
        p = at_data.insertAsLastChild()
        p.h = h
    return p
</t>
<t tx="ekr.20140720203932.17747">Leo can automatically import and export Emacs org-mode (.org) files. Nodes like::

    @auto-org-mode &lt;path to .org file&gt;

or equivalently::

    @auto-org &lt;path to .org file&gt;
    
import the org-mode file as a Leo outline. 

These nodes work like other @auto nodes: when Leo loads an outline, Leo
reads the .org file into the @auto-org-mode tree. When Leo writes an
outline, Leo writes any @auto-org-mode tree back to the org-mode file.

After creating an @auto-org-mode node by hand, be sure to use Leo's
refresh-from-disk command to populate the node. Do this *before* saving the
.leo file. If you try to save an empty @auto-org-mode node Leo will warn
you that you are about to overwrite the file.

The refresh-from-disck command creates an @auto-otl node whose **children**
represent the contents of the external .org file. Leo does *not* write the
\@auto-org-mode node itself. This allows you to put Leo directives in the
node.
</t>
<t tx="ekr.20140720203932.17748">Leo can automatically import and export vimoutline (.otl) files. Nodes like::

    @auto-otl &lt;path to .otl file&gt;

or equivalently::

    @auto-vimoutline &lt;path to .otl file&gt;
    
import the .otl as a Leo outline.

These nodes work like other @auto nodes: when Leo loads an outline, Leo
reads the .otl file into the @auto-otl tree. When Leo writes an outline,
Leo writes any @auto-otl tree back to the .otl file.

After creating an @auto-otl node by hand, be sure to use Leo's
refresh-from-disk command to populate the node. Do this *before* saving the
.leo file. If you try to save an empty @auto-otl node Leo will warn you
that you are about to overwrite the file.

The refresh-from-disck command creates an @auto-otl node whose **children**
represent the contents of the external .otl file. Leo does *not* write the
\@auto-otl node itself. This allows you to put Leo directives in the node.
</t>
<t tx="ekr.20140730175636.17982">@language rest

- N ; repeat the last t,T,f,F command.
  N , repeat the last t,T,f,F command in opposite direction.

- Support z commands:
    z-          or zb   redraw, current line at bottom of window
    z.          or zz   redraw, current line at center of window
    z&lt;Return&gt;   or zt   redraw, current line at top of window

- Finish g command
    ge should go to end of n'th word: at present it goes to end of line.
    gv start visual mode at previous visual area
    gV start visual-line mode at previous visual area.
    
- Possible extensions:
    gft  focus-to-tree
    gfb  focus-to-body
    gfl  focus-to-log
    gfs  focus-to-spell-tab
</t>
<t tx="ekr.20140808182202.18183">http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/

- ctrl-v : visual select column

- Write extend_vim_mode plugin

- Extend Leo's undo to show the vim characters for the commands.

- tab &amp; shift-tab in normal mode might indent text.
  They do nothing in the real vim.  Sheesh.

- Ctrl-C works like escape (Conflicts with copy-text)

:1,$ s/^/  /g

    From line 1 to EOF ($), replace the beginning of the line (^) with two
    spaces ( ), globally (keep applying as many times as possible)
    
    A quick vim-like way to do indents on a range of characters. I also use
    this one frequently...

EKR: Can't Leo's find command do this?
</t>
<t tx="ekr.20140810085801.18216"></t>
<t tx="ekr.20140810085801.18217">Leo's vim mode dispatches keystrokes sent to it from k.masterKeyHandler to
**key handlers**.

Each key handler handles the incoming key and then calls either
vc.accept(), vc.done(), vc.ignore() or vc.quit(). These methods tell
k.masterKeyHandler whether vim-mode has completely handled the key. If so,
k.masterKeyHandler simply returns. Otherwise, k.masterKeyHandler handles
the key as usual.
</t>
<t tx="ekr.20140810085801.18218">Key handlers handle a single key during the parsing of a vim command. Key
handlers can either complete a command, thereby actually doing something,
or change state so as to be able to parse (and possibly complete) the next
incoming keystroke.

For example, the key handler for the G command handles the command
completely. In contrast, two key handlers are needed to handle the gg
command. The first handler, vc.vim_g, simply calls
vc.accept(handler=vc.vim_g2). This call changes the vc.handler ivar to
point to the **follow-on handler**, vim_g2. vim_g2 handles all commands
after the user has typed 'g' in normal mode.

Each key handler must end with a call to an **acceptance method**.
vc.accept is one such method. Acceptance methods prepare for the next
keystroke by setting internal state ivars used by the various dispatchers.

Many key handlers simply call vc.done(). This method handles all the
details of completing a key handler: it hides the details of parsing vim
command.

**Important**: Any key handler that wants to change vc.state should
set vc.state *before* calling vc.done()

Key handlers can call either **direct acceptance methods**, vc.accept,
vc.delegate, vc.done, vc.ignore, vc.not_ready, vc.quit, and vc.reset, or
**indirect acceptance methods**: vc.begin_insert_mode, vc.begin_motion,
vc.end_insert_mode, and vc.vim_digits. Indirect acceptance methods must
eventually call direct acceptance methods.
</t>
<t tx="ekr.20140810085801.18219">Dispatchers set the following ivars for each key handler:

**vc.w** is the widget that has focus. Key handlers may use convenience
methods to determine the location and type of vc.w. The most important are:

- vc.is_text_widget(w): True if w is any text widget, including headlines,
  body text and log pane.
  
- vc.in_headline(w): True if w is a headline widget in edit mode.

**vc.stroke** is a standard Leo stroke representing the incoming key. Note
that the spelling of the stoke using the Tk spellings. Take a look at
entries in the dispatch dicts to see such spellings. When in doubt, enable
the trace in vc.do_key to see the incoming strokes.

**vc.n1** and **vc.n** are the repeat counts in effect for each key
handler. Dispatchers and their allies handle most details of setting these
repeat counts, so most key handlers can simply use vc.n1*vc.n as the
ultimate repeat count.

**vc.motion_i** is the insertion point *before* the motion has taken place.
</t>
<t tx="ekr.20140810085801.18220">The simplest way of moving the cursor or changing text is to use the vc.do
method, a thin wrapper for c.k.simulateCommand.  For example::

    if vc.state == 'visual':
        vc.do('end-of-buffer-extend-selection')
    else:
        vc.do('end-of-buffer')

Key handlers may also use the **high-level interface**. This is the API
used throughout Leo's core. For details, see the HighLevelInterface class
in leoFrame.py and various subclasses in qtGui.py.
</t>
<t tx="ekr.20140810085801.18221">The vc.vim_d method and its follow-on methods handle vim's d commands.

The vc.vis_d method handles the d keystroke that ends visual mode.

The following sections examine each piece of the code in detail. If you
understand how it works you should know everything you need to write any
other key handler.
</t>
<t tx="ekr.20140810085801.18222">@language python
::

    def vim_d(vc):
        '''
        N dd      delete N lines
        d{motion} delete the text that is moved over with {motion}
        '''
        if vc.is_text_widget(vc.w):
            vc.n = 1
            vc.accept(handler=vc.vim_d2)
        else:
            vc.quit()
@language rest

This is the key handler for the 'd' key in normal mode.

The entry in vc.normal_dispatch_d for 'd' is: 'd':vc.vim_d.

Because this command changes text, vc.is_text_widget(vc.w) must be True. If
so, this handler simply calls vc.accept(handler=vc.vim_d2) to queue up the
follow-on handler. Otherwise, the handler calls vc.quit() to end the
command.

</t>
<t tx="ekr.20140810085801.18223">@language python
::

    def vim_d2(vc):
        if vc.is_text_widget(vc.w):
            if vc.stroke == 'd':
                w = vc.w
                i = w.getInsertPoint()
                for z in range(vc.n1*vc.n):
                    # It's simplest just to get the text again.
                    s = w.getAllText()
                    i,j = g.getLine(s,i)
                    # Special case for end of buffer only for n == 1.
                    # This is exactly how vim works.
                    if vc.n1*vc.n == 1 and i == j == len(s):
                        i = max(0,i-1)
                    w.delete(i,j)
                vc.done()
            else:
                vc.d_stroke = vc.stroke # A scratch var.
                vc.begin_motion(vc.vim_d3)
        else:
            vc.quit()
@language rest

This is the follow-on handler for the 'd' command. It will be called when
the user types a *second* character following the 'd' command in normal
mode.

All forms of the 'd' command alter text, so this handler calls vc.quit if
vc.w is not a text widget.

If the second character is another 'd', we have the 'dd' command. The code
uses the high-level interface to delete a line, then calls vc.done() to end
the command.

If the second character is *not* a 'd', it should be a following motion,
such as "2j" in "d2j".

vc.vim_d2 remembers the character that started the motion in a **scratch
ivar**, vc.d_stroke. Such ivars are not inited or touched outside of vim_d
and its follow-on key handlers. This code must remember this character so
that the vim_d3 handler will know whether to expand the deleted text to a
line.

Finally, vc.vim_d2 calls vc.begin_motion, which does the following:

- Calls vc.ignore if the second character doesn't really start a motion.
- Sets vc.handler to vc.do_inner_motion.  This handles the motion.
- Sets the vc.after_motion to the next follow-on handler: vc.vim_d3.
  vc.vim_d3 will be called when the motion is complete. The details are
  complicated, but happily the key handlers don't have to know about them!
</t>
<t tx="ekr.20140810085801.18224">@language python
::

    def vim_d3(vc):
        '''Complete the d command after the cursor has moved.'''
        # d2w doesn't extend to line.  d2j does.
        trace = False and not g.unitTesting
        if vc.is_text_widget(vc.w):
            extend_to_line = vc.d_stroke in ('jk')
            w = vc.w
            s = w.getAllText()
            i1,i2 = vc.motion_i,w.getInsertPoint()
            if i1 == i2:
                if trace: g.trace('no change')
            elif i1 &lt; i2:
                for z in range(vc.n1*vc.n):
                    if extend_to_line:
                        i2 = vc.to_eol(s,i2)
                        if i2 &lt; len(s) and s[i2] == '\n':
                            i2 += 1
                        if trace: g.trace('extend i2 to eol',i1,i2)
                w.delete(i1,i2)
            else: # i1 &gt; i2
                i1,i2 = i2,i1
                for z in range(vc.n1*vc.n):
                    if extend_to_line:
                        i1 = vc.to_bol(s,i1)
                        if trace: g.trace('extend i1 to bol',i1,i2)
                w.delete(i1,i2)
            vc.done()
        else:
            vc.quit()
@language rest

This is the second and last follow-on handler for the d command. The
dispatcher that handles vim motions will call this handler after the
motions **have actually happened**.

First, the code double-checks that we are still in a text widget, calling
vc.quit() if not.

Next, the code compares the present insertion point, w,getInsertPoint(),
with the insertion point before the motion happened, vc.motion_i. It
extends the selection range if the scratch ivar, vc.d_stroke, is in ('jk').
The code then deletes the selected text.

Finally, this method calls vc.done().
</t>
<t tx="ekr.20140810085801.18225">@language python
::

    def vis_d(vc):
        '''Delete the highlighted text and terminate visual mode.'''
        w  = vc.vis_mode_w
        if vc.is_text_widget(w):
            i1 = vc.vis_mode_i
            i2 = w.getInsertPoint()
            w.delete(i1,i2)
            vc.state = 'normal'
            vc.done()
        else:
            vc.quit()
@language rest 

This is the key handler for the 'd' key in normal mode.

It is *not* a follow-on method of vim_d. The dispatcher calls this method
after visual mode has highlighted text. Here is the entry for 'd' in
vc.visual_dispatch_d: 'd':vc.vis_d.

Visual mode has already highlighted the text to be deleted, so this code
simply deletes the highlighted text and calls vc.done().

</t>
<t tx="ekr.20140810085801.18226">The VimCommands class in leoVim.py implements Leo's vim mode. Vim mode is
active only if @bool vim-mode = True.

The following sections will be of interest only to those seeking a deep
knowledge of how vim mode's dispatchers work. Such knowledge should rarely
be required because dispatchers and key handlers are completely unaware of
each other. Dispatch dicts and acceptance methods shield dispatchers and
key handlers of all knowledge of each other. In particular, acceptance
methods handle the sometimes tricky details of ending a key handler.

Leo's vim code is spectacularly different from the real vim's code.
Wherever possible, Leo uses methods to hide implementation details.

Ironically, now that everything is hard coded in tables, it would be easy
for plugins to customize the workings of vim-mode.
</t>
<t tx="ekr.20140810085801.18227">The init code for each Leo commander c assigns an instance of VimCommands
to c.vimCommands. This is done regardless of the @bool vim-mode setting.

Each ivar of the VimCommands class is inited by exactly one of the following::

    vc.init_constant_ivars()
    vc.init_dot_ivars()
    vc.init_persistent_ivars()
    vc.init_state_ivars()
    vc.create_dispatch_dicts()
    
In effect, this code partitions each ivar into disjoint sets. This
partitioning simplifies code that must re-init some ivars but not others.

The init code creates **dispatch dicts** used by dispatchers.  
</t>
<t tx="ekr.20140810085801.18228">Depending on various state date, dispatchers route incoming keys to the
proper **key handler**. Dispatchers use **dispatch dicts** to assign
handlers to incoming keys. These dicts eliminate almost all special case
code.
   
vc.do_key is the top-level dispatcher. k.masterKeyHandler calls it for all
keys *except* Ctrl-G. **Note**: k.masterKeyHandler calls vc.do_key only
when there no key state in effect, that is, when the minibuffer is not
active.

As discussed below, the value returned by vc.do_key tells k.masterKeyHandler
whether vim mode has completely handled the key.

Depending on the vc.handler ivar, vc.do_key can route the incoming key
either to an **inner dispatcher** or directly to a key handler.

Inner dispatchers handle keys for a particular vim mode using dispatch
dicts. Inner dispatchers the following ivars behind the scenes::

    vc.handler, vc.next_func, vc.return_value
    vc.in_motion and vc.motion_func
    
Handling these ivars can be tricky; hiding the details greatly simplifies all
key handlers.
</t>
<t tx="ekr.20140810085801.18229">vc.do_key returns the value of vc.return_value. Most the acceptance
functions set vc.return_value to True, indicating that vim mode has
completely handled the key and that k.masterKeyHandler should simply
return. k.masterKeyHandler handles the key as usual if vc.do_key returns
False.

Each key handler sets vc.return_value indirectly by calling an acceptance
method. A simple check in vc.do_key ensures that every key handler, has, in
fact, called an acceptance method. In practice, this check has been very
effective.
</t>
<t tx="ekr.20140810085801.18230">In general, vim-mode in Leo works much as in the real vim. There are three
modes, insert, normal and visual.


    
</t>
<t tx="ekr.20140810085801.18231"></t>
<t tx="ekr.20140810085801.18232">#############################
Vim Mode: Theory of Operation
#############################

.. |br| raw:: html

   &lt;br /&gt;
   
This is the theory of operation of Leo's vim mode, contained in
leo/core/leoVim.py. It discusses everything you need to understand the code
and to add new vim commands.

.. contents::
    :depth: 3
</t>
<t tx="ekr.20140810153947.6747">- Cursor motions: ^,$,0,b,e,f,F,gg,gG,j,h,k,l,t,T,w.
- The gb,ge,gh commands are synonyms for 0,$,^.
- The h,j,k,l commands work on outlines when entered in the outline pane.
- 0 in outline pane: goto-first-visible-node
- e in outline pane: goto-last-visible-node.
- Deleting text: d{motion},{motion}d,v{motion}d,diw,x.
- Insert commands: a,A,i,o,O and switch to insert mode if entered in the outline pane.
- Yank &amp; paste commands: y,p. These act on outlines if entered in the outline pane.
- Search commands: /,?,n,*,#.  These commands are node-only searches.
- The dot command '.' works for motions, but not yet for inserts or searches.
- v: start/end visual mode.

Notes:

- Except as noted above, all vim-mode commands must be entered in the body pane.
- &lt;Return&gt; in headlines switches to the outline pane.
- &lt;Return&gt; in the outline pane switches to the body pane.
</t>
<t tx="ekr.20140810153947.6749">- The ``jj`` abbreviation switches to normal mode, preserving the changed
  status of the .leo file.
- Return in visual/normal mode enters insert mode.

..  - ``,,`` in normal mode now moves to insert mode.
..  ``,,`` in insert mode does nothing, unless there is an abbreviation template available.
</t>
<t tx="ekr.20140810153947.6750">The ':' command enters Leo's minibuffer, with ':' pre-inserted. You may
backspace over the ':'. Here are the commands::
  
    :! Execute a shell command.
    :e! Revert all changes to a .leo file, prompting if there have been changes.
    :gt cycle-focus
    :q Quit, prompting for saves.
    :qa Quit only if there are no unsaved changes.
    :r Prompt for a file name.  Insert it at the cursor.
    :tabnew Prompt for a file name, and open a new tab.
    :w Save the .leo file.
    :wa Save all changed  .leo files.
    :wq Save all open files and exit.
    :xa ave all open files and exit.
    
The following colon commands are unique to Leo::

    :print-vim-dot
    :toggle-vim-mode
    :toggle-vim-trainer-mode
</t>
<t tx="ekr.20140810153947.6751">**@bool vim-mode = False**: Enables Leo's vim mode when True.

**@bool vim-crosses-lines = True**: When True the f,F,h,l,t,T,x
commands may cross line boundaries.
</t>
<t tx="ekr.20140810153947.6752">- The gb,ge,gh commands are synonyms for 0,$,^.
- The h,j,k,l commands work on outlines when entered in the outline pane.
- The a,A,i,o,O commands switch to insert mode if entered in the outline pane.
- The y,p commands act on outlines if entered in the outline pane.
- Ending visual mode with 'v' retains the selection range.
- Ctrl-H puts the headline in insert mode.
- Mouse clicks never change vim's state.

</t>
<t tx="ekr.20140811083910.18246">@language rest

The handler for the G command moves or extends the cursor depending on
vc.state.

@language python
::

    def vim_G(vc):
        '''Put the cursor on the last character of the body pane.'''
        if vc.is_text_widget(vc.w):
            if vc.state == 'visual':
                vc.do('end-of-buffer-extend-selection')
            else:
                vc.do('end-of-buffer')
            vc.done()
        else:
            vc.quit()
            
@language rest

On entry, the dispatcher has set vc.w to the widget with focus. First, the
code ensures that this widget is a text widget. If so, the code uses the
vc.do method, a thin wrapper for c.k.simulateCommand, to execute Leo
commands by name.
</t>
<t tx="ekr.20140822072856.18255">@language rest

The :substitute command searches for a text pattern, and replaces it with a text string. There are many options, but these are what you probably want:

:%s/foo/bar
:%s/foo/bar/
    Replace first occurrence of 'foo' with 'bar' in all lines.

:%s/foo/bar/g
     Replace all occurrences of 'foo' with 'bar' in all lines.
   
:s/foo/bar/
    Replace first occurrence of 'foo' (on the current line) with 'bar'

:s/foo/bar/g
    Replace all occurrence of 'foo' (on the current line ), with 'bar'.
    
Flags:
/gi case insensitive
/gI case sensitive
/gw word insensitive
/gW word sensitive
    
===== It's pointless to ask for confirmation: in that case, use Leo's search commands.

:%s/foo/bar/gc
    Change each 'foo' to 'bar', but ask for confirmation first. 

:%s/\&lt;foo\&gt;/bar/gc
    Change only whole words exactly matching 'foo' to 'bar'; ask for confirmation. 

:%s/foo/bar/gci
    Change each 'foo' (case insensitive) to 'bar'; ask for confirmation. 
    This may be wanted after using :set noignorecase to make searches case sensitive (the default). 

:%s/foo/bar/gcI
    Change each 'foo' (case sensitive) to 'bar'; ask for confirmation. 
    This may be wanted after using :set ignorecase to make searches case insensitive. 
</t>
<t tx="ekr.20140822160427.19046">N   CTRL-R          redo last N undone changes
    Ctrl-Shift-Z    redo last change
    
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
N   -               (motion) up N lines, on the first non-blank character
N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `&lt;              (motion) go to the start of the (previous) Visual area
    `&gt;              (motion) go to the end of the (previous) Visual area
    
N   [(              (motion) N times back to unclosed '('
N   [*              (motion) N times back to start of comment "/*"
N   [{              (motion) N times back to unclosed '{'
N   ])              (motion) N times forward to unclosed ')'
N   ]*              (motion) N times forward to end of comment "*/"
N   ]}              (motion) N times forward to unclosed '}'

N   C               change to end-of-line (and N-1 more lines)
N   D               delete to end-of-line (and N-1 more lines)
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   I               insert text before the first non-blank in the line (N times)
N   J               (motion?) join N-1 lines (delete newlines)
VIS J               (motion?) join the highlighted lines
N   N               (motion) repeat last search, in opposite direction
N   R               enter Replace mode (repeat the entered text N times)
N   S               change N lines
N   X               delete N characters before the cursor
N   Y               yank N lines
    ZQ              Same as ":q!".
    ZZ              Same as ":x".
    
N   cc              change N lines
N   c{motion}       change the text that is moved over with {motion}
VIS c               change the highlighted text
    m&lt;a-zA-Z&gt;       mark current position with mark &lt;a-zA-Z&gt;
N   p               put a register after the cursor position (N times)
    q               stop recording
    q&lt;A-Z&gt;          record typed characters, appended to register &lt;a-z&gt;
    q&lt;a-z&gt;          record typed characters into register &lt;a-z&gt;
N   r&lt;char&gt;         replace N characters with &lt;char&gt;
N   s               change N characters

Searches:

N   /&lt;CR&gt;                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]&lt;CR&gt;   (motion) search forward for the Nth occurrence of {pattern}
N   ?&lt;CR&gt;                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]&lt;CR&gt;   (motion) search backward for the Nth occurrence of {pattern}
</t>
<t tx="ekr.20140822160427.19047">Support the ';' key: repeat the last "To character" or "Find character" command.
</t>
<t tx="ekr.20140822160427.19049">Most, if not all of these things *can* be solved in Leo's new vim mode.
</t>
<t tx="ekr.20140824043305.18292"></t>
<t tx="ekr.20140824043305.18295">These items will not be done.  Most are bad ideas, imo.
</t>
<t tx="ekr.20140824043305.18296">These are known bugs that probably can't be fixed.
</t>
<t tx="ekr.20140824043305.18297"></t>
<t tx="ekr.20140824043305.18299"></t>
<t tx="ekr.20140824043305.18303"></t>
<t tx="ekr.20140824163757.20587">@language rest

https://bugs.launchpad.net/leo-editor/+bug/1022140
</t>
<t tx="ekr.20140829172618.18477">if 0:

    def remove_big_text_buttons(self,old_p):
        '''Remove the load and paste buttons created for large text.'''
        btc = self.c.bigTextController
        if btc and btc.active_flag:
            ###
            # # # s = btc.s
            # # # if old_p and old_p.b !=s:
                # # # if trace: g.trace('===== restoring s',len(s),old_p.h)
                # # # old_p.b = s
                # # # if hasattr(c.frame.tree,'updateIcon'):
                    # # # c.frame.tree.updateIcon(old_p,force=True)
            btc.go_away()
</t>
<t tx="ekr.20140829172618.20682">if 0:
    def is_big_text(self,p):
        '''True if p.b is large and the text widgets supports big text buttons.'''
        c = self.c
        if big_text_buttons and c.max_pre_loaded_body_chars &gt; 0:
            wrapper = c.frame.body.wrapper
            w = wrapper and wrapper.widget
            return (
                ### w and hasattr(w,'leo_load_button') and
                w and len(p.b) &gt; c.max_pre_loaded_body_chars)
        else:
            return False
</t>
<t tx="ekr.20140914042331.19494">/* Documentation of Qt stylesheets at http://qt-project.org/doc/qt-4.8/stylesheet.html */

/* 
   Buttons may be styled by name:
      QPushButton#&lt;button text&gt;-button { &lt;style&gt; }
   or by kind:
      QPushButton[button_kind="&lt;button kind&gt;"] { &lt;style&gt; }
   Button kinds are:
   'run-script' (the singleton run-script button),
   'debug-script',
   'script-button-button' (the singleton script-button button), 
   'script-button' (buttons created by the script-button button),
   'generic-button' (default), 
   'quick-move' from the quickMove plugin,
   'interact' from the interact plugin,
   'at-button' (created from @button nodes)
   Search 'button_kind' below for button styling examples.
   
*/

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/*
    Important: this stylesheets is responsible for most, but *not* all, of Leos appearance.
    See also settings in "Colorizer and colors" 
*/

QScrollArea {
    background-color: white;
}

/* Components of the Find Tab */

QWidget#findTab {
    background-color: white;
}

QLabel#findHeading {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel#findLabel {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel#changeLabel {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel#findHelp {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#findPattern {
    font-family: DejaVu Sans Mono;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#findChange {
    font-family: DejaVu Sans Mono;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    color: @text-foreground-tree;
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: @font-family;
    font-size: @font-size-tree;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
    show-decoration-selected: 1 /* 1: select entire row */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: @font-family;
    font-size: @font-size-tree;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: white; /* #f2fdff; */
    color: @text-foreground-log;
    selection-color: white;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family: @font-family;
    font-size: @font-size-log;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: white; /* #fdf5f5; A kind of pink. */
    color: @text-foreground-body;
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: @font-family;
    /* font-family: Courier New; */
    font-size: @font-size-body;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The text "Minibuffer" in the minibuffer area.

Do not overide QLabel directly.  It is used for dialog text.
*/

QLabel#minibufferLabel {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal;
    font-style: normal;
}

/* 
QLabel {
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal;
    font-style: normal;
    border: 2px;
    margin: 2px;
}
*/


/* The mini-buffer

**Important**: Because Leo changes the color of the minibuffer dynamically,
stylesheets can not be used. Instead, set the desired colors using one of the
following settings, with defaults as shown::

    @color minibuffer-background-color = lightblue
    @color minibuffer-error-color = red
    @color minibuffer-foreground-color = black
    @color minibuffer-warning-color = lightgrey
*/

QLineEdit#lineEdit {
    color: @minibuffer_foreground_color;
    background-color: @minibuffer_background_color;
}

QLineEdit#lineEdit[style_class ~= 'minibuffer_warning'] {
    background-color: @minibuffer_warning_color;
}

QLineEdit#lineEdit[style_class ~= 'minibuffer_error'] {
    color: @minibuffer_error_color;
    background-color: @minibuffer_warning_color;
}


QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: @font-family;
    font-size: 10pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
    font-size: 10pt;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
    font-size: 10pt;
}

/* button_kind based button coloring */
QPushButton[button_kind="run-script"] { 
    background-color: @run-script-btn-bg; }
QPushButton[button_kind="debug-script"] { 
    background-color: @debug-script-btn-bg; }
QPushButton[button_kind="generic-button"] { 
    background-color: @generic-button-btn-bg; }
QPushButton[button_kind="quick-move"] { 
    background-color: @quick-move-btn-bg; }
QPushButton[button_kind="interact"] { 
    background-color: @interact-btn-bg; }
QPushButton[button_kind="at-button"] { 
    background-color: @at-button-btn-bg; }
QPushButton[button_kind="script-button"] { 
    background-color: @script-button-btn-bg; }
/* example of name based button coloring.  Coincidentally, the
   name and button_kind of this button are the same */
QPushButton#script-button-button { 
    background-color: @script-button-button-btn-bg; }

QPlainTextEdit#screencastcaption {
    background-color: yellow;
    font-family: @font-family; /* Times New Roman; */
    font-size: 18pt;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* focused pane border highlight */
QTextEdit#log-widget, LeoQTreeWidget#treeWidget, QTextEdit#richTextEdit { 
  border-style: @focused-border-style;
  border-width: @focused-border-width; 
  border-color: @focused-border-unfocus-color; 
}
QTextEdit:focus#log-widget, LeoQTreeWidget:focus#treeWidget, QTextEdit:focus#richTextEdit { 
  border-style: @focused-border-style;
  border-width: @focused-border-width; 
  border-color: @focused-border-focus-color; 
}

/* bookmarks plugin styling */
#show_bookmarks QPushButton { 
    margin: 0; padding: 1; border: none;
    font-size: @bookmarks_base_size;
    color: @bookmarks_base_color;
    font-weight: @bookmarks_base_weight;
    text-decoration: @bookmarks_base_decoration;
}
#show_bookmarks QPushButton[style_class~='bookmark_children'] {
    font-size: @bookmarks_children_size;
    color: @bookmarks_children_color;
    font-weight: @bookmarks_children_weight;
    text-decoration: @bookmarks_children_decoration;
}
#show_bookmarks QPushButton[style_class~='bookmark_expanded'] {
    font-size: @bookmarks_expanded_size;
    color: @bookmarks_expanded_color;
    font-weight: @bookmarks_expanded_weight;
    text-decoration: @bookmarks_expanded_decoration;
}
#show_bookmarks QPushButton[style_class~='bookmark_current'] {
    font-size: @bookmarks_current_size;
    color: @bookmarks_current_color;
    font-weight: @bookmarks_current_weight;
    text-decoration: @bookmarks_current_decoration;
}

/* Borders for vim mode. */

QTextEdit#richTextEdit[vim_state~="vim_normal"] {
  border: 3px solid #FA8072; /* Salmon */
}
QTextEdit#richTextEdit[vim_state~="vim_insert"] {
  border: 3px solid blue;
}
QTextEdit#richTextEdit[vim_state~="vim_visual"] {
  border: 3px solid gray;
}

</t>
<t tx="ekr.20140918124632.19462"></t>
<t tx="ekr.20140919052413.17946">Do this after the new run-script commands
</t>
<t tx="ekr.20140921072018.17937">@language rest

run-script-from-bridge
run-script-externally
    * Specify which version of python to use.
    
*** The at_produce plugin now has technology for reporting progress using
the IdleTime class.

This technology should become part of g.execute_shell_commands. New
settings will control whether, and how often, to report progress.

*** There will soon be two new functions for running both Leo and non-Leo
scripts externally.

- g.run_python_script_externally would simply create an external file
  containing the script and then run python on that file.

- g.run_leo_script_externally would do something similar using the Leo
  bridge.

Both functions would be controlled by new settings, including (Kent will be
glad) what version of Python.

*** Revise http://leoeditor.com/leoBridge.html

There are several ways to run code externally:

- Using leo.core.leoBridgeTest.
- (When ready) using g.run_leo_script_externally.
- Using the full-blown method that Terry discusses in that chapter.
</t>
<t tx="ekr.20140921072018.17938">* Why not just improve g.execute_shell_commands ?
    - It could report too.
    - And it could use settings too.

- time-between-notifications: 0 means disable notifications.
- Decrease time between calls to idle-time handler.
</t>
<t tx="ekr.20140921072018.17943">'''A minimal Leo bridge application'''
# This can not be run locally!
import leo.core.leoBridge as leoBridge
b = leoBridge.controller(
    gui='nullGui',loadPlugins=True,
    silent=False,tracePlugins=True,verbose=False)
g = b.globals()
path = g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo')
assert g.os_path_exists(path)
c = b.openLeoFile(path)
assert c
assert c.rootPosition()
</t>
<t tx="ekr.20140922043414.17947"># http://leoeditor.com/leoBridge.html#running-leobridge-from-within-leo

import sys
import subprocess
path = r'c:\Users\edreamleo\test\leo_bridge_test.py'
    ### Create file containing script
assert g.os_path_exists(path)
proc = subprocess.Popen([sys.executable,path])
proc.communicate()
</t>
<t tx="ekr.20140922043414.17948"># From within the bridge, do:
import leo.core.leoTest as leoTest
helper = leoTest.RunTestExternallyHelperClass(c,all=True,marked=False)
helper.runUnitTestLeoFile(
    path='unitTest.leo',
        # The path, relative to leo/test.  The full path will be:
        # g.os_path_finalize_join(g.app.loadDir,'..','test',relative_path)
    gui=None, # Use a Null gui.
    loadPlugins=True,
    readSettings=True,
    silent=True,
    tracePlugins=True,
    verbose=True,
)
</t>
<t tx="ekr.20140922043414.17949">import leo.core.leoBridgeTest as leoBridgeTest

leoBridgeTest.main()
</t>
<t tx="ekr.20141014131442.18346">@language rest
</t>
<t tx="ekr.20141017110114.18265">https://groups.google.com/d/msg/leo-editor/p_b2LLBAqps/aTQoyGBec68J

This post discusses a new command line argument for Leo: --uuid

I have no plans to implement --uuid now, but it may have to be done in future.

===== Rationale

Terry has convinced me that collisions between both user ids and timestamps
will become more frequent as Leo becomes more popular. Such collisions are
not a serious problem at present: the odds of two different people with the
same user id sharing .leo files is small.

Nevertheless, a serious problem lurks, one that can not, even in principle,
be solved with Leo's present gnx's.

Suppose two people have the same id. Then Leo *must* assume that those
people are actually the same person! As I have explained in other post,
this can lead to data loss if the two people create two *distinct* nodes
with the same gnx, and then try to merge those nodes into the same .leo
file. The odds of this happening are small, but increasing.

A good way to solve this problem is to use uuids,
http://en.wikipedia.org/wiki/Universally_unique_identifier
and python's uuid module: https://docs.python.org/2/library/uuid.html

===== Operation

The --uuid should cause Leo to use uuid's for all *new* gnx's. The uuid
option should not convert *existing* gnx's to uuid-based gnx's.

A new Leo command would convert all existing gnx's to uuid-based gnxs. Such
mass conversions should *never* be done automatically.

===== Format of uuid-based gnxs

I would like the uuid-based gnx's to use uuid's in *addition* to the id and
timestamp fields. Something like::

    id.timestamp..uuid

Alas, that does not seem possible, unless this kind of gnx is written to
external files (in node sentinels). But many users would complain that such
very-long gnx's clutters external files too much.

So it seems that new-style gnxs would have something like this form::

    ..uuid

The leading dots allow Leo to distinguish this kind of gnx from the old
forms::

    id.timestamp.n
    id.timestamp

provided that dots are not allowed in ids.

===== Summary

Leo's uuid-based gnxs can contain neither user ids nor timestamps.

We must ensure we stick with whatever new-style gnx format we choose
initially: we don't want to burden Leo with distinguishing between several
different forms of uuid-based gnxs.
</t>
<t tx="ekr.20141017110114.18267">- @data qt-scintilla-styles *only* works in leoSetting.leo, not myLeoSettings.leo.
</t>
<t tx="ekr.20141017150357.18271">https://bugs.launchpad.net/leo-editor/+bug/1245111
Can't get the viewrendered pane back next to the editor

https://github.com/leo-editor/leo-editor/issues/57
Leo sets focus to body when main window gets focus

https://bugs.launchpad.net/leo-editor/+bug/1235619 BUG: Deleting multiple
selection in pyqt if a children of a to-delete node is also to be deleted
</t>
<t tx="ekr.20141021083702.18355">        # This looks dubious.
        for child in at_data.children():
            if g.match_word(child.h,0,'@recovery'):
                # Move the node to the parent.
                parent = at_data.parent()
                child.moveToLastChildOf(parent)
                # Delete all the children.
                at_data.deleteAllChildren()
                # Move the node back.
                p = parent.firstChild()
                while p.hasNext():
                    p.moveToNext()
                p.moveToLastChildOf(at_data)
                break
        else:
            at_data.deleteAllChildren()
</t>
<t tx="ekr.20141021083702.18356"></t>
<t tx="ekr.20141023110422.2"></t>
<t tx="ekr.20141024211256.7">Fix focus problem with F11 &amp; help-for-command

Add modules/plugins to help-for-command.
</t>
<t tx="ekr.20141026191037.6">@language rest

https://github.com/leo-editor/leo-editor/issues/83

This appears to be a Windows 8 issue.
</t>
<t tx="ekr.20141030042423.13">https://bugs.launchpad.net/leo-editor/+bug/1247140
Wishlist: Command History in minibuffer

https://bugs.launchpad.net/leo-editor/+bug/1259974
Leo should watch @ node contents for external updates

https://bugs.launchpad.net/leo-editor/+bug/1259755
Leo should keep the external editor's temp file up to date

https://bugs.launchpad.net/leo-editor/+bug/1159490
"Open with" fails to copy changes by external editor back to Leo-Editor node
</t>
<t tx="ekr.20141030042423.14">https://bugs.launchpad.net/leo-editor/+bug/1258512
_leo.c not working from IPython

https://bugs.launchpad.net/leo-editor/+bug/1228099
Cancelling save of dirty untitled commander doesn't work with --ipython

https://bugs.launchpad.net/leo-editor/+bug/1335310
Error: leo.plugins.at_folder.init did not return a bool

https://bugs.launchpad.net/leo-editor/+bug/1158269
viewrendered pane goes blank when url clicked.

https://bugs.launchpad.net/leo-editor/+bug/820019
Shift-Ctrl-F (quicksearch) Sometimes leaves focus in body

https://bugs.launchpad.net/leo-editor/+bug/823538
Plugin quicksearch.py command marked-list does nothing

https://bugs.launchpad.net/leo-editor/+bug/917805
Quicksearch, select string in header, Shift-Ctrl-F does NOT work

https://bugs.launchpad.net/leo-editor/+bug/1173798
Notebook plugin command nb-subtree does not start with the right leo file

https://bugs.launchpad.net/leo-editor/+bug/1199979
find-quick / Nav tab doesn't work with "first_date = events[0].date"

https://bugs.launchpad.net/leo-editor/+bug/1230273
Todo.py documentation - image link semi-broken in docstring

https://bugs.launchpad.net/leo-editor/+bug/1240688
Problems with the Help Menu
Apparently, this bug is related to the leo_dark theme 0 settings.

https://bugs.launchpad.net/leo-editor/+bug/323175
run_nodes plugins doesn't work
</t>
<t tx="ekr.20141030042423.9">Use the %~dp0 syntax.  Example::
  
  %~dp0\Python27\python.exe %~dp0\Leo-editor\launchLeo.py

http://ss64.com/nt/syntax-args.html
http://stackoverflow.com/questions/5034076/what-does-dp0-mean-and-how-does-it-work

FYI, this FAQ entry fixes the following bug:
https://bugs.launchpad.net/leo-editor/+bug/613153
unable to describe root directory on thumb drive
</t>
<t tx="ekr.20141103113220.10">From: Alexandre_Toledo &lt;jalexandretoledo@gmail.com&gt;

As I use Leo to write PL/SQL code, I need to write similar text several
times, changing only small parts of it. It would be great if I could create
a node with the "template" and then clone it everywhere it should be
written, and then providing the parameters to be used in this writing.

Let me try to clarify it. I'd like to create a tree like this:

    +- @file something.sql
       +- Section 1
          + &lt;&lt; Clone &gt;&gt; with Parameters A, B
       +- Section 2
          + &lt;&lt; Clone &gt;&gt; with Parameters C, D

In this tree, both "Clone" nodes would be generated from a template
specified somewhere in the tree, and would have parts of its text replaced
with values "A" and "B" in Section 1, and "C" and "D" in Section 2.

I've searched but couldn't find anything like this, then I've thought of
trying to write a hook to intercept the "save" command, but couldn't think
of a way to pass the parameters; I think the obvious way would be to put
the parameters after the "&lt;&lt; &gt;&gt;", but then all cloned nodes are changed, so
it wouldn't work.

Another alternative would be creating some kind of directive @something,
but I have no idea of how to do that.

Any ideas?
</t>
<t tx="ekr.20141103113220.11">I've tried it and it's great, I think it will be useful, but it's not what
I was thinking of...

Let me try to explain what I had thought about.  What I would like to do is:

 1. create a new .leo file
 2. add a "template" node (eventually with sub nodes) with some ${schema}
    and ${table} macro place holders in its contents
 3. add a @file node to the .leo file
 4. add to this @file node a new one with definitions such as
    schema=3DSCHEMA_NAME and table=3DTABLE_NAME
 5. add as a sub node to this last one a clone from the "template" node;
 6. then, when I save everything, the @file would have "SCHEMA_NAME" and
    "TABLE_NAME" everywhere a "${schema}" or a "${table}" were in the original
    template node.

It would be important that, when I reopen the .leo file later, the macros
in the @file node where shown as ${schema} and ${table}, and not as it's
substituted text.

Now that I've described it, I can't see how it would be done... The
${macro} place holders should be on the contents of the @file node, so
after substitution, how could we recover it?

That's also why the code from Jacob is not what I need (but I'm already
thinking of other uses for it :) ): it will create a text when the button
is pressed, but the generated nodes will be just static text.
</t>
<t tx="ekr.20141103113220.22"></t>
<t tx="ekr.20141105050314.23">@language rest

This post discusses discusses problems with the @g.command decorator. Later
sections discuss solutions. These later sections are ENB (Engineering Note
Book) discussions, which can safely be ignored by all except the usual
suspects...

Promises to do something "today" don't always get kept because a seemingly
simple task like adding an insert-file-name command becomes unbearable.
Creating a better way to define commands has become urgent.

===== Background

@g.command has its uses, especially in plugins. It allows any code to
 define a new Leo command without having any access to Leo's core code. For
 this reason alone, the @g.command decorator is here to stay.

However, using @g.command to add Leo commands is often *way* too clumsy.
There are several problems using @g.command. To see these problems clearly,
let's look at a typical example, from leoVim.py::

@language python


    @g.command(':gt')
    def vim_gt(event):
        '''cycle-focus'''
        c = event.get('c')
        if c and c.vimCommands:
            c.vimCommands.cycle_focus()
            
@language rest

This code sucks, for at least the following reasons:

1. It requires an outer-level function-name (vim_gt) that has no value
   except to the @g.command decorator itself. This is useless verbiage and
   just clutters the namespace. Worse, although the decorator doesn't
   require distinct names, disabling a pylint check for duplicate names
   would be way too dangerous.

2. It repeats the template code for each different command. This is pure
   cruft. Worse, the tests for c and c.vimCommands would not be necessary
   in a subcommander.

3. It is usually bad design to define the command at the top level.
   Commands should be defined in the classes that contain their code!

For all these reasons, vim-mode commands clearly should *not* be defined
using the @g.command decorator. The question is, how to define them
cleanly?

Everything from here on is an ENB entry. Feel free to ignore, unless you
are Terry ;-)

===== Motivation

It would be possible to define vc commands in vc.finishCreate as is done by
sub-commanders in leoEditCommands.py, but as I was thinking about this
problem I discovered how to simplify the definition of almost *all* of
Leo's commands. This is too good to ignore, for the following reasons:

1. The simplifications to be described reduce order constraints during
   startup. Any such reduction is, all by itself, extremely valuable,
   because such order constraints are the main complicating factor in the
   startup code.

2. As always, simplifications to complex code (and Leo's startup code is
   complex in hard-to-see ways) promise further simplifications. No further
   simplifications are apparent *now*, but it would be bad practice not to
   simplify the code when I can.

===== Details

At present, there are several ways (not sure how to count them ;-) to
define large numbers of commands. By defining a command I mean associating
a string (the command's name) with a method of some class.

Although details vary, the basic idea in each case is to define a
**commands dict**, a Python dict whose keys are command names (Python
strings) and whose values are methods.

In particular, each subcommander in leoEditCommands.py defines a
getPublicCommands method that returns a commands dict.

ECM.finishCreateEditCommanders then merges all the commands dicts, like
this::

@language python

    def finishCreateEditCommanders (self):
        '''Finish creating edit classes in the commander.
        Return the commands dictionary for all the classes.'''
        c,d = self.c,{}
        for name, theClass in self.classesList:
            theInstance = getattr(c,name)
            theInstance.finishCreate()
            theInstance.init()
            d2 = theInstance.getPublicCommands()
            if d2:
                d.update(d2)
        return d
        
@language rest


But none of this should be necessary. Or rather, it should happen in a
different place, and at no *particular* time.

===== A much better way to define commands.

The basic problem with the code above is that it must happen at the exact
instant that various finishCreate methods get called. Yes, the present code
works, but it depends *far* too much on code order during startup.

We can remove *all* these unnecessary ordering constraints as follows:

1.  Define init phase 0: create ivars.

This phase is trivial, for our present purposes. Commands.__init__ will
just define c.commandsDict and its inverse, as *empty* Python dictionaries.

At present, the inverse of c.commandsDict is c.k.inverseCommandsDict. How
stupid is that? It must be a c (Commands) ivar, not a c.k (KeyHandlerClass)
ivar! Doh. Using a c.k ivar means that c.k must be inited *before*
c.k.inverseCommandsDict is ever used. This is a completely unnecessary
constraint.

In short, the inverseCommandsDict must be a Commands ivar, not a
KeyHandlerClass ivar. This will ensure that c.inverseCommandsDict will
exist before any subcommander's *ctor* gets called.

2. Define c.registerCommands (plural). This will call a new method,
   c.registerCommand, for each item in a commands dict.

Important: c.k.registerCommand must remain for compatibility, but it will
probably just call c.registerCommand.

With just these simple changes, *any* class can call c.registerCommands at
*any* time. In particular, any class can call c.registerCommands in its
ctor, or its ctor's helpers. There is no need to wait until finishCreate
gets called!

Defining command names in the ctor logic may leave some finishCreate
methods empty. If so, we can rejoice--another ordering constraint has
disappeared forever!

===== Testing

I expect the changeover to the new scheme to be straightforward. It may
happen "today" (TM).

This new scheme should be safe, but just to make sure, I'll probably enable
the new code with g.NEW_COMMANDS.

It's not clear how well the present unit tests actually tests the
association between commands and their names. A separate unit test may be
advisable.
</t>
<t tx="ekr.20141105050314.24">In the end, I have opted for the bare minimum of changes. Given the
complexity of key handling, I think this is the only sane way. Here is a
slightly revised checkin log for rev 09ab839...:

QQQ

Cleaned up how command names get put into c.commandsDict and
c.inverseCommandsDict, but only a little bit ;-)

All tests pass, but use a bit more caution.

- Removed @g.command nodes from leoVim.py.
  vc.defineCommandNames now creates command names.
 - Called vc.defineCommandNames from the new c.createCommandNames, called from c.finishCreate.
- Changed k.inverseCommandsDict to c.inverseCommandsDict.
- Renamed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
QQQ

All this adds up to *slightly* better code.

In particular, the various o.defineCommandNames methods can be called any
time after o has been created. These methods depend on nothing else, so
they can be called "early" in c.finishCreate, by c.createCommandNames. This
is a real plus: there are now a few less order dependencies in the startup
code. Replacing rst.finishCreate with rst.createCommandNames is gratifying.

This is important! The various finishCreate methods must be called in
*exactly* the right order so that various widgets are created in one
finishCreate method before they are needed in another finishCreate method.
So anything that either eliminates finishCreate methods entirely or reduces
their complexity is a real improvement in Leo's startup code.

Otoh, I left the code that creates c.commandsDict and c.inverseCommandsDict
*strictly* alone, except that:

1. inverseCommandsDict is now a c ivar instead of a k ivar.

2. The new c.createCommandNames method encapsulates all aspects of the
   making of the command name dicts. This should make this difficult code
   slightly easier to understand.

On balance, this was a long day of coding for minor improvements to Leo's
startup logic. But these are steps in the right direction.

In any case, the VimCommands class now defines command names in
vc.defineCommandNames. There no need for vc.finishCreate and no need for
all those redundant @g.command code hunks.

Unless there are bugs reported, this ends this project for the foreseeable
future.
</t>
<t tx="ekr.20141105052052.4">Leo's minimal dependencies are:

* Python 2.6 or later, including all Python 3.x versions.
* PyQt4 or PyQt5.

The following packages are optional:

* Docutils
* Sphinx
* PyEnchant: http://pythonhosted.org/pyenchant/download.html

The viewrendered and viewrendered2 plugins use docutils.

PyEnchant is required to do spell checking.

Plugins may require other packages.  For example, viewrendered
requires 'markdown' if one wishes to use markdown rendering, but it is
optional. rss.py will not function without 'feedparser'. Etc.
</t>
<t tx="ekr.20141105055521.5">The livecode-show commands shows the live code evaluation pane. Hover on
the buttons for helpful tool-tips.

Depends on https://pypi.python.org/pypi/meta which you can install with::

    pip install meta

The dependency on `meta` is for recursively turning AST node trees back
into printable identifiers like "m[m[5]]".  For example::

   a = 7

is easy, but::

   m[m[5]] = 7

is not.

</t>
<t tx="ekr.20141105055521.6">Provides node tagging capabilities to Leo

By Jacob M. Peck

</t>
<t tx="ekr.20141105055521.7">https://groups.google.com/d/msg/leo-editor/3dH_NSQ4TsQ/ueVewAn50ZcJ

https://groups.google.com/d/msg/leo-editor/BDzmytlSegw/C0IbSz0US54J

As mentioned in my previous post I'll attempt to elaborate on the plugin
I've used to make Leo more useful to me, in case it is useful for others
also. Apologies for the very long post, but I wanted get get all its
features and warts exposed here to get some feedback on whether others see
this as useful or that this is only valuable to me. If it's useful to
others then it may be worth polishing up quite a bit.
</t>
<t tx="ekr.20141105055521.8">Creates a global search window

Use the global-search command to show this window.

To restore the original appearance of the window, type help.

Requires the whoosh library ('easy_install whoosh') to do full text searches.
</t>
<t tx="ekr.20141105085003.10">The API is unlimited in tagging abilities.  If you do not wish to use
the UI, then the API may be used to tag nodes with any arbitrary
strings.  The UI, however, due to searching capabilities, may *not* be
used to tag (or search for) nodes with tags containing the special
search characters, `&amp;|-^`.  The UI also cannot search for tags of
zero-length, and it automatically removes surrounding whitespace
(calling .strip()).
</t>
<t tx="ekr.20141105085003.12">I like to use reStructuredText (reST) for all of my note-taking, idea
development, project and task management and automation of desktop
activities (e.g. initiating a backup). You could say it is the control
centre of my daily activities, including calculating and showing dashboards
of where I am and where I'm going.

This means I need a tool which seamlessly shows me the full-fidelity
browser-rendered version of what I am writing and be able to print my notes
for meetings, cut and paste nicely formatted output to my office e-mails
and documents, as well as show some of the material as a slideshow.

The existing *viewrendered* plugin couldn't seem to do what I needed
(especially math) and I was almost ready to abandon Leo again. This time I
bit the bullet and created a more capable renderer in viewrendered2 (VR2).
Initially I made a plugin that rendered, on demand, to my normal web
browser. This worked well, but I really thought live rendering like
"viewrendered" would be better, and for that I needed close control over
scroll positions etc. that I couldn't get with an external browser. So the
plugin became much more complex as I merged it with the existing
viewrendered plugin, but was ultimately more powerful and useful to me.

</t>
<t tx="ekr.20141105085003.13">* Show a "full" html representation of any reST node or tree, without an
  @rst root node, including more features than the existing viewrendered
  plugin::

      proper html layout
      math (mathjax, etc.)
      clickable URLs
      clickable hyperlinks within the page (e.g. TOC)
      good quality zoom
      cut and paste html with ctl-C
      s5 slideshows
      javascript
      svg images
      configurable css

* Allow showing of node tree rather than just the current node. This can
  give a better overview perspective of the tree contents.

* Be able to lock the rendering on the root node of a tree, to view the
  effect editing a sub-node within the larger html document.

* Provide proper rendering of any combination of node types in a tree, so long as
  they have been properly designated by @language directives (i.e. reST, text,
  code, css, ...).

* Allow viewing (and printing) of an entire source file from an @file type
  root node.

* Be able to *export* any of these renderings to a full web-browser to take advantage
  of the large rendering window (especially for slideshows, as well as printing, saving output.
  
* Be able to integrate automatically executed code nodes intermingled with
  reST nodes to provide an automatic calculation-based "Notebook" or "Report"
  type output.

* Don't increase the dependencies of Leo.
</t>
<t tx="ekr.20141105085003.14">VR2 is implemented mostly as an ~600 line expansion of the update_rst
method in the viewrendered.py plugin. The text-oriented class used for
rendering in VR1 has been replaced by the QWebView class which provides the
full rendering functionality of a real web-browser. To make this flexible,
a toolbar has been attached to the top with a few controls.

Because I wanted to retain compatibility with VR1, I created the
viewrendered2.py plugin, but retained all the class naming which occurred
within VR1. This means that it remains compatible with the existing
mechanisms (like free_layout) of showing and creating panes for VR1. I
tried this with an expectation that it would fail, but it appears to work
without any unintended side-effects.

Tooltips have been added where Qt allows, with the philosophy that a user
shouldn't need a manual to use this pane.

VR2 has been used a lot under Windows 7 and a little under Ubuntu 13.10.

</t>
<t tx="ekr.20141105085003.15">I use VR2 every few minutes every working day. However, VR2 is likely to
still have a lot of rough edges and, in particular, bugs that show up with
different work flows or css folder layouts etc. In fact, VR2 is still a
work in progress and therefore still being fiddled with, so bugs creep in
regularly.

But overall, my perception of its deficiencies are:

* Does not handle reST headings within the node bodies well (sometimes very
  slow render, blocking Leo).

* VR2 attempts to reconcile reST headings that originate from explicit
  headings within the nodes against reST headings that are
  automatically generated by the node hierarchy. In many cases, this
  is impossible, resulting in many errors which drastically slows down
  rendering. - Recommend not using headings within the nodes
  themselves, leaving the node hierarchy to do this automatically.

* If the node triggers one of the special viewrendered node header types
  (@md, @image, @movie, @html) VR2 simply defaults to the old handlers for
  those types. This means it jumps back to whatever pane type VR1 uses, so
  the features of VR2 disappear. I suspect that VR2 could incorporate these
  types into the new version and retain these new features. I should look
  at that.
    
* Doesn't integrate with rst3 plugin, especially honouring @others etc.
  There are some conflicts in objectives, so this may never be fully
  resolved. It would probably make sense for rst3 settings to get used for
  VR2 as well, along with additional VR2 specific settings. Currently, VR2
  has its own @settings-style settings. The rst3 code is not used.
  
* For slideshow purposes, a patch to docutils s5_writer is required to be
  able to handle an arbitrary hierarchy of nodes (forces all headings to
  start a new slide). Otherwise, only the 2nd level nodes (from the root)
  force a new slide.
  
* The integration of VR2 code into the existing viewrendered plugin code is
  rudimentary. I took the shortcut of not trying to understand this code
  well and confining my integration to the rst rendering only. Better
  integration would be a good future step.

With the plugin being able to execute javascript etc. there may be some
form of security issue, but I can't see it myself (given that Leo can
execute arbitrary python code anyway).
</t>
<t tx="ekr.20141105085003.16">- Expand the export button if pandoc is installed, adding optional
  output formats such as docx, odt, plus additional slideshow formats.

- Use new reST functionality to replace other media viewrendered methods
  for images, svg, movies, etc. * Integrate better with rst3?
</t>
<t tx="ekr.20141105085003.7">This plugin registers a controller object to c.theTagController, which
provides the following API::

    tc = c.theTagController
    tc.get_all_tags()
        # return a list of all tags used in the current
        # outline, automatically updated to be consistent
    tc.get_tagged_nodes('foo')
        # return a list of positions tagged 'foo'
    tc.get_tags(p)
        # return a list of tags applied to the node at
        # position p; returns [] if node has no tags
    tc.add_tag(p, 'bar') # add the tag 'bar' to the node at position p
    tc.remove_tag(p, 'baz')
        # remove the tag 'baz' from p if it is in the tag list

Internally, tags are stored in `p.v.unknownAttributes['__node_tags']` as
a set.
</t>
<t tx="ekr.20141105085003.8">UI

The "Tags" tab in the Log pane is the UI for this plugin.  The bar at
the top is a search bar, editable to allow complex search queries.  It
is pre-populated with all existing tags in the outline, and remembers
your custom searches within the given session.  It also acts double duty
as an input box for the add (+) button, which adds the contents of the
search bar as a tag to the currently selected node.

The list box in the middle is a list of headlines of nodes which contain
the tag(s) defined by the current search string.  These are clickable,
and doing so will center the focus in the outline pane on the selected node.

Below the list box is a dynamic display of tags on the currently
selected node.  Left-clicking on any of these will populate the search
bar with that tag, allowing you to explore similarly tagged nodes.
Right-clicking on a tag will remove it from the currently selected node.

The status line at the bottom is purely informational.

The tag browser has set-algebra querying possible.  Users may search for
strings like 'foo&amp;bar', to get nodes with both tags foo and bar, or
'foo|bar' to get nodes with either or both.  Set difference (-) and
symmetric set difference (^) are supported as well.  These queries are
left-associative, meaning they are read from left to right, with no
other precedence.  Parentheses are not supported. See below for more
details.

</t>
<t tx="ekr.20141107085700.5">c:\python27\python.exe launchLeo.py --gui=qttabs --gui=qttabs leo\core\leoPy.leo leo\plugins\leoP
lugins.leo c:\Users\edreamleo\ekr-projects.leo leo\doc\LeoDocs.leo

c:\leo.repo\leo-editor\leo\core\leoGlobals.py:400:
    UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode -
    interpreting them as being unequal
  elif hasattr(other,'s'):    return self.s == other.s
</t>
<t tx="ekr.20141108064630.10">Leo makes it easy to create and run unit tests from individual outline
nodes or trees. A node whose headline starts with @test defines a unit
test. The body text of the @test node contains a **self-contained** unit
test. For example, this creates a complete unit test::

    @test fails  (headline)
    assert False (body text)

To run this test, select the @test node and do::

    &lt;alt-x&gt;run-selected-unit-tests-locally.

Leo will create and run the unit test automatically.

To see all of Leo's unit testing commands, do::

    &lt;alt-x&gt;run&lt;tab&gt;

Leo pre-defines 'c', 'g' and 'p' in unit tests just as in scripts.

For more details about unit testing, see: 
http://leoeditor.com/unitTesting.html

**Notes for Leo developers**

leo/test/unitTest.leo contains all of Leo's own unit tests.

Running all tests is not necessary.  Just select::

    Active Unit Tests

and then do Alt-4 (run-selected-unit-tests-locally).

**Note**: Some tests will likely fail on machines other than EKR's. You
only need to be concerned about unit tests that start failing after you
make your changes.
</t>
<t tx="ekr.20141108064630.12">@language rest

File under things-I-didn't-know-but-should-have:

Instead of creating batch files all over the place to fire up python
programs, and then having to cope with annoying "Terminate batch job
(Y/N)?" with Ctrl-C/Break you can ask python setuptools to create an .exe
in the Python\Scripts folder.

in same folder as foo.py create setup.py, populate like so::

@language python

    from setuptools import setup
    
    setup(
        name='Foo for you',
        version='0.3',
        py_modules=['foo'],
        entry_points='''
            [console_scripts]
            foo = foo
            '''
        )
    
@language rest

Then run "pip --editable install . " in the same folder. Foo.exe will be
created in C:\pythonxx\Scripts. As long as that folder is in path you can
use foo like any other command line program. Furthermore the "editable"
parameter means we can continue to edit and change foo.py and the changes
are always live.

Yeah! No more "pushd ..\path\to\data\folder &amp;&amp; python ..\path\to\code\foo.py
--do-stuff-here ..." for me. :)

Works for Leo too -- with the existing setup.py. It creates leo.exe and
leoc.exe for Windowed mode (no log messages to console) and console mode
respectively.
</t>
<t tx="ekr.20141108064630.13">I am going through something similar Matt Wilkie went through in this post
https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/leopyref/leo-editor/pWyd5ae952I/kvxf_H-QBq4J

Basically I can find interesting functions in LeoPyRef.leo but I don't know
how to access them from my new leo scripts.

I don't get the difference when I have to call them using g.Functionname(), 
c.functionname(), or when those wont do.

How can I call the function "insertIconFromFile"?
How can I know how to call functions found in LeoPyRef.leo?

-----

Ok, in order to print icons, the code is this:

c.editCommands.insertIconFromFile(path)

I'm quoting from this Leo manual
http://leoeditor.com/scripting.html#important-objects,
http://leoeditor.com/scripting.html#inserting-and-deleting-icons

Although I still have a mess on which functions can be called how, and
where to find the list of classes that can be called such as "editCommands"
and the rest that they might exist. Thanks!

I suppose you could say that there is no general solution, but the
situation isn't really all that difficult.

Start with c. We know what that is: it is a commander object representing
an open outline.

There are **official ivars** of c, all referring to wrapper classes defined
in leoFrame.py::

    c.frame         an instance of leoFrame.
    c.frame.tree    an instance of  leoTree.
    c.frame.body    an instance of leoBody.
    c.frame.log     an instance of leoLog.

The tree, body and log objects have a *wrapper* object

c.frame.tree.wrapper
c.frame.body.wrapper
c.frame.log.wrapper

See http://leoeditor.com/scripting.html#c-frame-body-bodyctrl for a
description of the high-level text interface supported by all high-level
text widgets, including the log and body classes.

These wrapper classes have a widget ivar, which is a reference to the
corresponding Qt widget object.  For example::

    import PyQt4.QtGui as QtGui
    w =3D c.frame.body.wrapper.widget
    g.es(w)
    g.es(isinstance(w,QtGui.QTextBrowser)

yields::

    (LeoQTextBrowser) 62418136
    True

As shown, the LeoQTextBrowser class is a real (subclass of) QTextBrowser.

==== Terry

I'm not aware of a general solution to the problem of finding the various
pieces of Leo's class structure. Basically there are all these classes
defined in the source, and instances of these are attached to each other in
a hierarchical network (with loops).

I've written an introspection function which lists the methods and instance
variables (and class variables) of an arbitrary object by name and by type.
I should release it. It builds its lists in a Leo outline, so you can
navigate around that outline and expand nodes by introspection as needed.

It occurs to me that the same code could be used to search Leo's runtime
object hierarchy for you, i.e. you enter 'insertIconFromFile' and it
recursively searches for it.

-----

I didn't really finish the above para. The problem is that it's hard to
guess what the names of the attachment points are, and the attaching is
done in a variety of places, sometimes by factory functions which further
obscure linkages. Not a fault with Leo, just the way programs work. So the
tool I've written may be the best approach to mapping Leo's runtime
structure. Another thing it could do, try and map 'major' classes, or at
least classes from leo.core.* - i.e. ignore the built in types.
</t>
<t tx="ekr.20141108064630.14">If I want to use leo to make mathematical notes, how can I type in some
special mathematical symbols? Or is there a good way to make mathematical
notes using leo?

===== Terry

I use itex2MML with reStructuredText.  So within Leo you're looking at
LaTeX math markup, and you get outputs in PDF and XHTML, with MathML in
the latter.

===== Jose

I've been doing this for about a year now.  I use the math docutils 
directive.  A custom .XCompose file (for example: 
https://github.com/kragen/xcompose)  also helps.

===== Terry

I think math was added to docutils after I started using itex2mml,
neater to use docutils built in math now I think.

Although having said that, playing with docutils math a bit suggests
itex2mml gives more complete support for both MathML and perhaps LaTeX
math (with the PDF target).

===== Jose

Terry, your setup is probably more flexible, but I haven't had any problems with 
docutils math. It seems to support all the syntax that I've found necessary.

I forgot to mention that the viewrendered plug-in doesn't display math 
correctly.  I'm not sure what the problem is, I remember trying to figure 
it out a while back, but I never got anywhere.  It's not really a big 
problem though, I have scripts to compile nodes to html/pdfs and open them 
in firefox/pdf reader; math works fine that way.

===== offray

Is not properly Leo, but is python related, tailored for math and with a
web interface and has leo bindings, check IPython:

http://ipython.org/

I'm using it for all my math related writing and I think that point the
future of interactive writing in Python. I dream of a body pane on leo
with the features of the python qt console.
</t>
<t tx="ekr.20141108064630.15">The code that handles the rclick menu is in the QtIconBarClass class in
qt_frame.py.

Show that the  top-level button contains structure, do this::

    @string mod_scripting_subtext = ▾

An alternative: ▼ U=25BC: Black Down-Pointing Triangle.

It's reasonable to have the top-level button just be a placeholder for
subsidiary @rclick nodes. To do that without getting a warning when
clicking the top-level button, set its script to "empty string".
</t>
<t tx="ekr.20141108064630.16">Put the following in the style-sheet:

    QTextEdit#richTextEdit { background-image: url('/home/tbrown/Desktop/cow2.jpg'); }

If you wanted node specific backgrounds Leo would have to start setting
an attribute on the body widget, probably the gnx, so you could do::

    QTextEdit#richTextEdit[leo_gnx='tbrown.20130430222443.19340'] { 
        background-image: url('/home/tbrown/Desktop/cow2.jpg'); 
    }
</t>
<t tx="ekr.20141108064630.18">@language rest

I'm trying to create a interactive chart in a embedded in a new leo pane
using matplotlib. However, I am not sure about the the best way to
implement this. I would appreciate some guidance on this please? The
questions I would like answered are:

1. How do I create a new blank pane for embedding a chart as well as other
   QtWidgets.

2. Can I do this in a script or do I need to work with leo source?

I want to create a data processing and visualization tool kit in leo. Like
Excel but using nodes instead of columns. Nodes will have data and I want
to create new data nodes by applying python functions to data in existing
nodes. The thing missing is the visualization within a leo pane (I can
easily launch a chart in it's own window).

----- Terry Brown

You can run this script from any body pane::

    '''
    A script that adds a MatPlotLib pane to Leo.
    
    After running this script, right click on one of the pane dividers and
    select Insert. A new pane with a button 'Action' appears. Click it, and
    select "Add matplot" from the context menu.
    '''
    
    from leo.core.leoQt import QtWidgets
    
    class MatplotPaneProvider:
        def __init__(self, c):
            self.c = c
            if hasattr(c, 'free_layout'):
                splitter = c.free_layout.get_top_splitter()
                if splitter:
                    splitter.register_provider(self)
        def ns_provides(self):
            return[('Add matplot', '_add_matplot_pane')]
        def ns_provide(self, id_):
            if id_ == '_add_matplot_pane':
                c = self.c
                w = QtWidgets.QSlider() ### w = myMatplotWidget()
                return w
        def ns_provider_id(self):
            # used by register_provider() to unregister previously registered
            # providers of the same service
            # provider ID is not the same as the service id_ above
            return "completely unique value here"
    
    MatplotPaneProvider(c)

----- OP

I have managed to get a matplotlib graph embedded within a pane in 
leo as a widget. I now need some help with how to interact with the 
widget using scripts in leo. I am unsure about the following:
 
*1/ How do I expose the widget within the leo environment?* 

If you were only going to have one and you weren't going to destroy it,
you could just do something simple like c._matplot = self in its
constrictor (assuming c was passed to the constructor).

If you're going to have more than one and they may be destroyed, it
might be simplest to let the free_layout / nested_splitter system manage
them::

    ts = c.free_layout.get_top_splitter()
    matplotters = ts.findChildren(myMatplotWidget)

should return a list of the widgets of your class in the layout, but only
if they're in the main window, widgets in extra windows opened from the
"Open window" context menu item would be missed, I can add a
find_children() method to complement the find_child() method the splitters
already have to account for this.

Detail: the above is just using Qt's QObject.findChildren(), the
nested_splitter find_child() and (not yet written) find_children()
versions search the extra windows as well.

Here I have created a self.mat in your MatplotPaneProvider class to make 
the windget accessible but it doesn't feel like the correct way to do this.

@language python

    mat = MatplotPaneProvider(c)
    mat.mat.someMethod()
    mat.mat.someOtherMethod()
    
@language rest
 
2. I would also like to make the widget accessible from any script within
   leo. What's the leo way of doing this?

See above
 
3. If I create more than 1 pane containing these widgets. How do I switch
   between them in scripts?*

See above

4. Running this script more than once creates multiple items for Add
   Matplot when pressing the Action button. How do I stop this from
   happening? I have already tried returning a unique integer in *
   ns_provider_id *but that did not work.*
 
The value returned by ns_provider_id should be unique for the provider
class, but constant. So it can just return something like "matplotlib provider ver 1"
</t>
<t tx="ekr.20141108064630.19">From: Joon Ro &lt;joonpyro@gmail.com&gt;

I think it would make more sense if leo checks the file modification time
when it makes decision which node is new, instead of just depending on the
order of files in the outline.
</t>
<t tx="ekr.20141108064630.8">.. https://groups.google.com/d/msg/leo-editor/4s44H9cUJGY/ewRBDBSw-A8J

For the last several weeks I've used clones in a new, more effective way,
inspired by git's stash/unstash commands. Here are the main ideas.

1. [Most important] I avoid putting clones in two different *external*
   files.

For any task, I create a task node that resides in @file leoToDo.txt. I
clone that node and put it in the outline, *never* in any other @file node.
This instantly eliminates clone wars.

2. I use top-level "stashed" nodes/trees in my local copy of leoPy.leo.

These clones are *not* written to any external file, so they would be lost
if I lost leoPy.leo. But the risks are negligible because all stashed nodes
are clones of nodes that *do* exist in external files.

3. I have two main stashed trees: recent files and recent code.

The "recent files" tree contains clones of all the @file nodes I have
worked on recently. This speeds up access to them. That happens
surprisingly often--often enough to be well worth maintaining the tree.
Furthermore, because Leo's new pylint command now works on trees, I can
check all recently-changed files simply by running pylint on the "recent
files" tree.

The "recent code" tree is even more valuable, for three reasons. The first
is obvious--it speeds access to recently-changed nodes.

Second, the "recent code" tree allows me to work on multiple tasks without
getting overwhelmed by details and loose nodes lying around. I add
organizer nodes as needed to make accessing the nodes faster, and also to
jog my memory about what I was doing when I changed those nodes ;-)

Third, the "recent code" tree allows me *not* to put clones in the @file
leoProjects.txt tree. This leads me to...

4. I use clones in a stylized way when fixing and committing bugs.

I always use clones when working on a project. A "task" node contains
clones of all nodes related to the task. The task node typically remains in
leoToDo.txt until the task is completely finished. While working on the
bug, I create a clone of the task node, and move that clone to the bottom
top-level node of the outline. Among other things, this makes it easy to
limit searches without actually choosing "suboutline only" in the Find
panel. This workflow is decades old.

The following is the heart of the new workflow. When a task is complete, I
do the following:

A. First, I create a **stashed-task** node, containing all the clones that
    were previously in the task node.

The *stashed-task* becomes pre-writing for the commit log. The *task* node
instantly becomes pre-writing for the release notes, so if it needs to
discuss any code in the clones that have just been moved to the
stashed-task node, I write those words immediately, while all details are
fresh in my mind.

B. Now I move the cloned task node that is in leoToDo.txt to the
   appropriate place in leoProjects.txt.

C. Next I do the commit.

The *other* clone of the task node, and the stashed task node are still
within easy reach, and I typically use both nodes to create the commit log.
The commit will typically consist of the changed leoToDo.txt and
leoProjects.txt and whatever .py files the task itself changed. Happily,
leoToDo.txt and leoProjects.txt are now up-to-date because of steps A and
B.

D. Finally, I clean up.

I delete the top-level clone of the task node, and move the stashed-task
node to the "recent code" tree.

E. Later, when it appears that activity has died down on various projects,
   I'll delete nodes from the "recent files" an "recent code" trees. This
   is a minor judgment call: I want to leave nodes in the trees while they
   are useful, but not significantly longer than that. I do *not* regard
   these trees as permanently useful. leoProjects.txt should contain *all*
   permanent notes about a project.

===== Conclusions

This work flow may seem complicated. Believe me, it is not. It's easier to
use than to describe.

This workflow has big advantages:

1. Clone wars are gone for good.
2. All recent data is easily available.
3. Task nodes and stashed-task nodes provide natural places for
   proto-documentation.
4. Banning clones from leoProjects.txt forces me to complete the first
   draft of the documentation before committing the fix.
</t>
<t tx="ekr.20141109053526.4"></t>
<t tx="ekr.20141109053526.7"></t>
<t tx="ekr.20141109053526.8">GTD (Getting Things Done)
http://www.amazon.com/Getting-Things-Done-Stress-Free-Productivity/dp/0142000280
is, by far, the best productivity book I have ever read. Many aspects of
Leo are idea for putting GTD into practice.

Here is a surprisingly useful workflow tip related to GTD.

Ideas often "intrude" when I am busy with something else. When that
happens, I create a top-level node of the form::

    ** description of idea

Now I can continue what I was doing! This is such a simple idea, but it's
really really important: it means I never have to put off getting my ideas
into Leo. The "**" draws my attention to the new to-do item. Later, when I
am not fully immersed in the previous task, I can put the "**" node
somewhere else.

It's super important to deal with new ideas *instantly* but *without*
greatly interrupting the task at hand. Creating "**" nodes does that. This
new workflow has been a big improvement to my GTD practice.
</t>
<t tx="ekr.20141109160640.8">@language rest

https://github.com/leo-editor/leo-editor/issues/99

https://bugs.launchpad.net/leo-editor/+bug/1249368
Leo 4.11 final custom hotkey can not work on 1st call

There are communications problems because the OP's native language is Chinese, not English.

===== My guess about what is meant:


With the custom setting: delete-node = Ctrl-.

We want to use clover-period instead of Ctrl-period.

But for each Leo file, nothing happens until you use the menu to select the command.

===== The original posting:

custom hotkey as:
myLeoSettings.leo#@settings--&gt;Keyboard shortcuts--&gt;@keys EKR bindings--&gt;@shortcuts Outline operations

delete-node = Ctrl-. #None

but as MAC OS X, usage Ctrl-. as Cmd-.
- For each opened Leo file:
- Nothing happens if use hotkey first
- need to use menu command before custom hotkey will work.

Leo 4.11 final, build 5020, 2012-02-26 13:18:08 -0600
Python 2.7.1, qt version 4.8.0
darwin
</t>
<t tx="ekr.20141110154742.6">https://github.com/leo-editor/leo-editor/issues/78

Add tracing/history to find this bug.
</t>
<t tx="ekr.20141110223158.9">https://github.com/leo-editor/leo-editor/issues/101

https://bugs.launchpad.net/leo-editor/+bug/1258512
_leo.c not working from IPython

https://bugs.launchpad.net/leo-editor/+bug/1228099
Cancelling save of dirty untitled commander doesn't work with --ipython
</t>
<t tx="ekr.20141112070001.4">@language rest
</t>
<t tx="ekr.20141112070001.6">@@@test markdown 1 (creates an unwanted @auto node)
</t>
<t tx="ekr.20141112094313.4">For me:

https://bugs.launchpad.net/leo-editor/+bug/1158269
viewrendered pane goes blank when url clicked.

https://bugs.launchpad.net/leo-editor/+bug/1240688
Problems with the Help Menu
Apparently, this bug is related to the leo_dark theme 0 settings.

For others:

https://bugs.launchpad.net/leo-editor/+bug/1173798
Notebook plugin command nb-subtree does not start with the right leo file 

https://bugs.launchpad.net/leo-editor/+bug/1230273
Todo.py documentation - image link semi-broken in docstring

</t>
<t tx="ekr.20141113102829.5"></t>
<t tx="ekr.20141113114751.1"></t>
<t tx="ekr.20141113123533.4">@language rest

https://github.com/leo-editor/leo-editor/issues/66

I get no errors here: @auto mkdocs/docs/index.md
rclick -&gt; refresh from disk

but from here:
@path mkdocs
descending to the file, I get an old perfect import error 
</t>
<t tx="ekr.20141114054312.6">@language rest

https://github.com/leo-editor/leo-editor/issues/102

The following node definition saves the file into /home/user/.leo
(on Linux, not tested on Win)::

    @file {{g.app.loadDir}}/testapp.txt

but when such leo file is loaded, it starts with error::

    can not open: '@file /home/user/.leo/{{g.app.loadDir}}/testapp.txt'

and files are not loaded. Tried 4.11, it behaves in the same way.
</t>
<t tx="ekr.20141114054312.7">https://github.com/leo-editor/leo-editor/issues/103
</t>
<t tx="peckj.20130813123907.6841" str_ctime="1376412039.0" str_mtime="1376412039.0" str_atime="1376414164.0">Documenting new plugins is important for users to be able understand
and use the features they add. To that effect, there are a few
documentation steps that should not be overlooked.

- Document the plugin thoroughly in the plugin's docstring. This
  allows the documentation to be accessed from the Plugins menu.
  
- Document any new commands with a proper docstring. This allows the
  minibuffer command `help-for-command` to provide help for the
  command.
  
- In `leo/doc/sphinx-docs/sphinxDocs.leo`, to the node `@file
  leo.plugins.rst`, add the following snippet (preferably in
  alphabetical order), with the name of the plugin modified to the
  name of your plugin (here `ipython`). This allows the API docs to be
  automatically updated::

    :mod:`ipython` Module
    ---------------------
    
    .. automodule:: leo.plugins.ipython
        :members:
        :undoc-members:
        :show-inheritance:
</t>
<t tx="shadow.20080825171547.9">**Question**: I must follow a coding standard when writing source code. It
includes a maximum line length restriction. How can I know the length of a
line when it gets written to the external file?

**Answer**: If a node belongs to a external file hierarchy, its body might get
indented when it is written to the external file. It happens when an
\@others directive or a section name appears indented in a higher-level
node body. While (**line**, **col**) in status area show the line and column
containing the body text's cursor, **fcol** shows the cursor coordinate
relative to the external file, not to the current node. The relation
**fcol &gt;= col** is always true.
</t>
<t tx="sps.20100710110337.12187"></t>
<t tx="sps.20100710110337.12188"></t>
<t tx="sps.20100710110337.12189"></t>
<t tx="tbrown.20140412113009.50227">As of 2014 .zip snapshots can be downloaded directly from github, no
account required.  The downloaded file will have a name like::

  leo-editor-50c070b715b9fec50c31be5853055a0ebc72cad5.zip

where the ``50c0...cad5`` part is the ID or fingerprint of the version
you've downloaded.  Except "Latest", which is just ``leo-editor-master.zip``.

Here are some direct download links:

  - `Latest &lt;https://github.com/leo-editor/leo-editor/archive/master.zip&gt;`_
  - `1 day ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{1%20day%20ago}.zip&gt;`_
  - `2 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{2%20days%20ago}.zip&gt;`_
  - `5 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{5%20days%20ago}.zip&gt;`_
  - `10 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{10%20days%20ago}.zip&gt;`_
  - `30 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{30%20days%20ago}.zip&gt;`_
  - `90 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{90%20days%20ago}.zip&gt;`_
</t>
<t tx="vivainio.20080302174639.1">Leo's --ipython command-line option enables two-way communication
(**ILeo**, the **IPython bridge**) between Leo and IPython: you can run Leo
scripts from IPython, and IPython scripts from Leo.

The level of integration is much deeper than conventional integration in
IDEs. Most notably, you are able to store and manipulate *data* in Leo
nodes, in addition to mere program code--essentially making ILeo a
hierarchical spreadsheet, albeit with non-grid view of the data. The
possibilities of this are endless, and the approach can be applied in wide
range of problem domains with very little actual coding.
</t>
<t tx="vivainio.20080302174639.2">To run Leo's IPython bridge:

1. Install IPython 0.8.3 or above.

2. `run Leo in a console window`_ with the --ipython command-line option
   enabled. This option starts an instance of the IPython shell in the
   console. Leo and IPython run simultaneously and independently. Their
   separate event loops do not interfere with each other.

   The ipython-new command launches new terminals connected to the same
   IPython kernel.</t>
</tnodes>
</leo_file>
